/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _jquery = __webpack_require__(1);

	var _jquery2 = _interopRequireDefault(_jquery);

	var _spinner = __webpack_require__(2);

	var _spinner2 = _interopRequireDefault(_spinner);

	var _selectmenu = __webpack_require__(14);

	var _selectmenu2 = _interopRequireDefault(_selectmenu);

	var _checkboxradio = __webpack_require__(7);

	var _checkboxradio2 = _interopRequireDefault(_checkboxradio);

	var _controlgroup = __webpack_require__(4);

	var _controlgroup2 = _interopRequireDefault(_controlgroup);

	var _tooltip = __webpack_require__(18);

	var _tooltip2 = _interopRequireDefault(_tooltip);

	var _colorPicker = __webpack_require__(19);

	var _colorPicker2 = _interopRequireDefault(_colorPicker);

	var _OpenLayers = __webpack_require__(20);

	var _OpenLayers2 = _interopRequireDefault(_OpenLayers);

	var _OpenLayersControl = __webpack_require__(21);

	var _OpenLayersControl2 = _interopRequireDefault(_OpenLayersControl);

	var _d3Scale = __webpack_require__(22);

	var _d3Geo = __webpack_require__(30);

	var _d3Selection = __webpack_require__(31);

	var _querystringutil = __webpack_require__(32);

	var _coordinateconversion = __webpack_require__(33);

	var _layerswitcher = __webpack_require__(34);

	var _layerswitcher2 = _interopRequireDefault(_layerswitcher);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	console.log('jquery', _jquery2.default);
	console.log('spinner', _spinner2.default);
	console.log('OpenLayers', _OpenLayers2.default);
	console.log('UndoRedo', _OpenLayersControl2.default);
	console.log('d3select', _d3Selection.select);

	var IMG_DIR = "images/",
	    map_data_path = "data.json",
	    map_tile_path = "/media/images/map/687/",
	    map_w = 16384,
	    map_h = 16384,
	    map_x_boundaries = [-8475.58617377, 9327.49124559],
	    map_y_boundaries = [9028.52473332, -8836.61406266],
	    scale = Math.abs(map_x_boundaries[1] - map_x_boundaries[0]) / map_w,
	    imageToDota = _coordinateconversion.latLonToWorld.bind(null, map_x_boundaries, map_y_boundaries, map_w, map_h),
	    dotaToImage = _coordinateconversion.worldToLatLon.bind(null, map_x_boundaries, map_y_boundaries, map_w, map_h),
	    map = new _OpenLayers2.default.Map("map", {
	    theme: null,
	    maxExtent: new _OpenLayers2.default.Bounds(0, 0, map_w, map_h),
	    numZoomLevels: 5,
	    maxResolution: Math.pow(2, 5 - 1),
	    units: "m",
	    controls: [new _OpenLayers2.default.Control.Navigation(), new _OpenLayers2.default.Control.Zoom({
	        zoomInId: "zoom-in",
	        zoomOutId: "zoom-out"
	    })]
	}),
	    baseLayers = [new _OpenLayers2.default.Layer.TMS("Default", map_tile_path, {
	    type: "jpg",
	    getURL: getMyURL('default')
	}), new _OpenLayers2.default.Layer.TMS("Desert", map_tile_path, {
	    type: "jpg",
	    getURL: getMyURL('desert')
	}), new _OpenLayers2.default.Layer.TMS("Immortal Gardens", map_tile_path, {
	    type: "jpg",
	    getURL: getMyURL('immortalgardens')
	})],
	    layerSwitcher = new _layerswitcher2.default({
	    ascending: false
	}),
	    defaultHandlerOptions = {
	    regularpolygon: {
	        snapAngle: 15,
	        sides: 4,
	        radius: 1000
	    }
	},
	    defaultStyles = {
	    brush: {
	        strokeWidth: 50,
	        strokeColor: '#ff0000',
	        strokeOpacity: 1,
	        pointRadius: 1,
	        fillColor: '#ff0000'
	    },
	    icon: {
	        externalGraphic: "",
	        graphicHeight: 512,
	        graphicOpacity: 1
	    },
	    line: {
	        strokeWidth: 25,
	        strokeColor: '#00ff00',
	        strokeOpacity: 1,
	        pointRadius: 1,
	        fillColor: '#00ff00'
	    },
	    polygon: {
	        strokeWidth: 10,
	        strokeColor: '#0000ff',
	        strokeOpacity: 1,
	        pointRadius: 1,
	        fillColor: '#ff00ff',
	        fillOpacity: 0.5
	    },
	    regularpolygon: {
	        strokeWidth: 20,
	        strokeColor: '#00ffff',
	        strokeOpacity: 1,
	        pointRadius: 1,
	        fillColor: '#aa00ff',
	        fillOpacity: 1
	    },
	    modify: {
	        strokeWidth: 2,
	        strokeColor: '#ff0000',
	        strokeOpacity: 1,
	        pointRadius: 50,
	        fillColor: '#ff0000',
	        graphicName: "cross"
	    },
	    selectfeature: {
	        strokeWidth: 2,
	        strokeColor: '#ff0000',
	        strokeOpacity: 1,
	        pointRadius: 50,
	        fillColor: '#ff0000',
	        graphicName: "cross"
	    },
	    measure: {
	        strokeWidth: 2,
	        strokeColor: '#ff0000',
	        strokeOpacity: 1,
	        pointRadius: 50,
	        fillColor: '#ff0000',
	        graphicName: "cross"
	    }
	},
	    strokeTools = ['brush', 'line', 'polygon', 'regularpolygon'],
	    activeTool,
	    renderer = _OpenLayers2.default.Util.getParameters(window.location.href).renderer;

	/**************
	 * UI WIDGETS *
	 **************/

	function formatDegree(value) {
	    return value + 'ï¿½';
	}

	console.log("DEGREESPINNER", _jquery2.default.widget("ui.degreespinner", _jquery2.default.ui.spinner, {
	    _format: formatDegree,
	    _parse: function _parse(value) {
	        return parseFloat(value);
	    }
	}));

	function formatPercent(value) {
	    return value + '%';
	}

	_jquery2.default.widget("ui.percentspinner", _jquery2.default.ui.spinner, {
	    _format: formatPercent,
	    _parse: function _parse(value) {
	        return parseFloat(value);
	    }
	});

	_jquery2.default.widget("custom.iconselectmenu", _jquery2.default.ui.selectmenu, {
	    _renderItem: function _renderItem(ul, item) {
	        var li = (0, _jquery2.default)("<li>"),
	            wrapper = (0, _jquery2.default)("<div>");

	        if (item.disabled) {
	            li.addClass("ui-state-disabled");
	        }

	        (0, _jquery2.default)("<div>", {
	            "class": 'selectmenu-label',
	            text: item.label
	        }).appendTo(wrapper);

	        (0, _jquery2.default)("<div>", {
	            style: item.element.attr("data-style"),
	            "class": "selectmenu-icon " + item.element.attr("data-class")
	        }).appendTo(wrapper);

	        return li.append(wrapper).appendTo(ul);
	    }
	});

	/********************
	 * CONTROL HANDLERS *
	 ********************/

	function toggleModifyControl() {
	    console.log(this.value);
	    drawControls.modify.mode = _OpenLayers2.default.Control.ModifyFeature.RESHAPE;
	    switch (this.value) {
	        case 'reshape':
	            drawControls.modify.mode = _OpenLayers2.default.Control.ModifyFeature.RESHAPE;
	            break;
	        case 'rotate':
	            drawControls.modify.mode = _OpenLayers2.default.Control.ModifyFeature.ROTATE;
	            break;
	        case 'scale':
	            drawControls.modify.mode |= _OpenLayers2.default.Control.ModifyFeature.RESIZE;
	            drawControls.modify.mode &= ~_OpenLayers2.default.Control.ModifyFeature.RESHAPE;
	            break;
	        case 'skew':
	            drawControls.modify.mode |= _OpenLayers2.default.Control.ModifyFeature.RESIZE;
	            break;
	        case 'drag':
	            drawControls.modify.mode = _OpenLayers2.default.Control.ModifyFeature.DRAG;
	            break;
	    }
	    console.log('drawControls.modify', drawControls.modify);
	    var feature = drawControls.modify.feature;
	    if (feature) {
	        drawControls.modify.unselectFeature(feature);
	        drawControls.modify.selectFeature(feature);
	    }
	}

	function toggleControl() {
	    var control;
	    var tools = Object.keys(defaultStyles);
	    (0, _jquery2.default)('#toolbar').hide();
	    for (var key in drawControls) {
	        control = drawControls[key];
	        console.log(this.value, key, this.checked);
	        if (this.value == key && this.checked) {
	            control.activate();
	            map.updateSize();
	            console.log(key);
	            if (tools.indexOf(key) != -1) {
	                (0, _jquery2.default)('#toolbar').show();
	                updateTools(key);
	                if (key == 'modify') {
	                    //vectors.events.register("beforefeaturemodified", drawControls[key], onFeatureModified);
	                    vectors.events.register("afterfeaturemodified", drawControls[key], onFeatureModified);
	                } else {
	                    vectors.events.register("sketchcomplete", drawControls[key], onSketchCompletedHandlers[key]);
	                }
	            }
	        } else {
	            control.deactivate();
	            if (tools.indexOf(key) != -1) {
	                if (key == 'modify') {
	                    //vectors.events.unregister("beforefeaturemodified", drawControls[key], onFeatureModified);
	                    vectors.events.unregister("afterfeaturemodified", drawControls[key], onFeatureModified);
	                } else {
	                    vectors.events.unregister("sketchcomplete", drawControls[key], onSketchCompletedHandlers[key]);
	                }
	            }
	        }
	    }
	    if (this.value === "draw") {
	        (0, _jquery2.default)('#toolbar').show();
	        var selectedTool = document.querySelector('input[name="tool-radio"]:checked');
	        if (!selectedTool) {
	            selectedTool = document.querySelector('input[name="tool-radio"]');
	            selectedTool.checked = true;
	            updateTools(selectedTool.value);
	        }
	        toggleControl.call(selectedTool);
	    }
	}

	function updateTools(value) {
	    console.log("updateTools", value);
	    activeTool = value;
	    (0, _jquery2.default)(".tool-radiobutton").checkboxradio("refresh");
	    (0, _jquery2.default)('.tool-setting').hide();
	    (0, _jquery2.default)('.' + value + '-tool-group').css('display', 'inline-block');
	}

	// creates url for tiles. OpenLayers TMS Layer getURL property is set to this
	function getMyURL(baseLayer) {
	    return function (bounds) {
	        //console.log('getMyURL', baseLayer);
	        var res = this.map.getResolution(),
	            x = Math.round((bounds.left - this.maxExtent.left) / (res * this.tileSize.w)),
	            y = Math.round((this.maxExtent.top - bounds.top) / (res * this.tileSize.h)),
	            z = map.getZoom(),
	            path = z + "/tile_" + x + "_" + y + "." + this.type,
	            url = this.url;

	        if (url instanceof Array) {
	            url = this.selectUrl(path, url);
	        }
	        return url + baseLayer + '/' + path;
	    };
	}

	// Initialize map settings based on query string values
	function parseQueryString() {
	    var id = (0, _querystringutil.getParameterByName)('id');
	    if (id) {
	        _jquery2.default.get('save/' + id + '.json', function (data) {
	            console.log(data);
	            var parser = new _OpenLayers2.default.Format.GeoJSON();
	            vectors.addFeatures(parser.read(data));
	        });
	        map.zoomTo(parseInt(zoom));
	    }

	    var zoom = (0, _querystringutil.getParameterByName)('zoom');
	    if (zoom) {
	        map.zoomTo(parseInt(zoom));
	    }
	    var worldX = (0, _querystringutil.getParameterByName)('x');
	    var worldY = (0, _querystringutil.getParameterByName)('y');
	    if (worldX && worldY) {
	        var lonlat = dotaToImage(worldX, worldY);
	        map.setCenter(new _OpenLayers2.default.LonLat(lonlat.x, lonlat.y), undefined, false, false);
	    }

	    var baseLayerName = (0, _querystringutil.getParameterByName)('BaseLayer');
	    if (baseLayerName) {
	        for (var i = 0; i < baseLayers.length; i++) {
	            var layer = baseLayers[i];
	            var layerName = layer.name.replace(/ /g, '');
	            if (baseLayerName === layerName) {
	                map.setBaseLayer(layer);
	                break;
	            }
	        }
	    }
	}

	/******************
	 * STROKE UI INIT *
	 ******************/

	strokeTools.forEach(function (key) {
	    initStrokeWidth(key);
	    initStrokeOpacity(key);
	    initStrokeColor(key);
	});
	initStrokeOpacity('polygon', true);
	initStrokeColor('polygon', true);
	initStrokeOpacity('regularpolygon', true);
	initStrokeColor('regularpolygon', true);
	initDegreeSpinner('regularpolygon', 'snap-angle', 'snapAngle');
	initSpinner('regularpolygon', 'side-count', 'sides', {
	    min: 3,
	    step: 1
	});
	initSpinner('regularpolygon', 'radius', 'radius', {
	    min: 1,
	    step: 1
	});

	(0, _jquery2.default)('#regularpolygon-snap').checkboxradio({ icon: false }).change(function () {
	    var key = 'regularpolygon';
	    var prop = 'snapAngle';
	    var v;
	    if (this.checked) {
	        v = (0, _jquery2.default)(this).data('snapAngle');
	        (0, _jquery2.default)('#regularpolygon-snap-angle').degreespinner("enable");
	    } else {
	        v = null;
	        (0, _jquery2.default)(this).data('snapAngle', defaultHandlerOptions[key][prop]);
	        defaultHandlerOptions[key][prop] = null;
	        (0, _jquery2.default)('#regularpolygon-snap-angle').degreespinner("disable");
	    }
	    defaultHandlerOptions[key][prop] = v;
	    updateHandlerOption(key, prop, v);
	}).data('snapAngle', defaultHandlerOptions.regularpolygon.snapAngle);

	(0, _jquery2.default)('#regularpolygon-fixed-radius').checkboxradio({ icon: false }).change(function () {
	    var key = 'regularpolygon';
	    var prop = 'radius';
	    var v;
	    if (this.checked) {
	        v = (0, _jquery2.default)(this).data('radius');
	        (0, _jquery2.default)('#regularpolygon-radius').spinner("enable");
	        (0, _jquery2.default)('#regularpolygon-irregular').prop('checked', false).checkboxradio("refresh");
	        updateHandlerOption('regularpolygon', 'irregular', false);
	    } else {
	        v = null;
	        (0, _jquery2.default)(this).data('radius', defaultHandlerOptions[key][prop]);
	        defaultHandlerOptions[key][prop] = null;
	        (0, _jquery2.default)('#regularpolygon-radius').spinner("disable");
	    }
	    defaultHandlerOptions[key][prop] = v;
	    updateHandlerOption(key, prop, v);
	}).data('radius', defaultHandlerOptions.regularpolygon.radius);

	(0, _jquery2.default)('#regularpolygon-irregular').checkboxradio({ icon: false }).change(function () {
	    var key = 'regularpolygon';
	    var prop = 'irregular';
	    var v = this.checked;
	    if (this.checked) {
	        (0, _jquery2.default)('#regularpolygon-fixed-radius').prop('checked', false).checkboxradio("refresh");
	        (0, _jquery2.default)('#regularpolygon-radius').spinner("disable");
	    } else {}
	    /*if (this.checked) {
	        v = $(this).data('snapAngle');
	        $('#regularpolygon-snap-angle').degreespinner( "enable" );
	    }
	    else {
	        v = null;
	        $(this).data('snapAngle', defaultHandlerOptions[key][prop])
	        defaultHandlerOptions[key][prop] = null;
	        $('#regularpolygon-snap-angle').degreespinner( "disable" );
	    }
	    defaultHandlerOptions[key][prop] = v;*/
	    updateHandlerOption(key, prop, v);
	});

	// stroke width spinner
	function initStrokeWidth(key) {
	    (0, _jquery2.default)('#' + key + '-stroke-width').spinner({
	        min: 1,
	        step: 1,
	        change: function change(event, ui) {
	            var v = parseInt(this.value);
	            if (isNaN(v)) {
	                v = parseInt(defaultStyles[key].strokeWidth);
	            } else {
	                defaultStyles[key].strokeWidth = v;
	            }
	            (0, _jquery2.default)(this).val(v);
	        },
	        stop: function stop(event, ui) {
	            var v = parseInt(this.value);
	            if (!isNaN(v)) {
	                defaultStyles[key].strokeWidth = v;
	            }
	        }
	    }).val(defaultStyles[key].strokeWidth);
	}

	// stroke opacity spinner
	function initStrokeOpacity(key, isFill) {
	    var target = isFill ? 'fill' : 'stroke';
	    var strokeOpacityPreview = document.querySelector('#' + key + '-' + target + '-opacity-icon .opacity-preview-icon');
	    (0, _jquery2.default)('#' + key + '-' + target + '-opacity').percentspinner({
	        min: 0,
	        max: 100,
	        step: 1,
	        change: function change(event, ui) {
	            var v = parseInt(this.value);
	            if (isNaN(v)) {
	                v = parseInt(defaultStyles[key][target + 'Opacity'] * 100);
	            } else {
	                defaultStyles[key][target + 'Opacity'] = v / 100;
	                strokeOpacityPreview.style.opacity = defaultStyles[key][target + 'Opacity'];
	            }
	            (0, _jquery2.default)(this).val(formatPercent(v));
	        },
	        spin: function spin(event, ui) {
	            strokeOpacityPreview.style.opacity = ui.value / 100;
	        },
	        stop: function stop(event, ui) {
	            var v = parseInt(this.value);
	            if (!isNaN(v)) {
	                defaultStyles[key][target + 'Opacity'] = v / 100;
	                strokeOpacityPreview.style.opacity = defaultStyles[key][target + 'Opacity'];
	            }
	        }
	    }).val(formatPercent(defaultStyles[key][target + 'Opacity'] * 100));
	}

	// stroke color picker
	function initStrokeColor(key, isFill) {
	    var target = isFill ? 'fill' : 'stroke';
	    var colorPreview = document.getElementById(key + '-' + target + '-color-preview');
	    var colorPicker = new _colorPicker2.default(document.getElementById(key + '-' + target + '-color-picker'));
	    colorPicker.set(defaultStyles[key][target + 'Color']);
	    colorPicker.on("enter", function () {
	        var color = '#' + this._HSV2HEX(this.set());
	        colorPreview.title = color;
	        colorPreview.style.backgroundColor = color;
	    });
	    colorPicker.on("change", function (color) {
	        this.target.value = '#' + color;
	        colorPreview.style.backgroundColor = '#' + color;
	        defaultStyles[key][target + 'Color'] = '#' + color;
	    });
	    colorPicker.on("exit", function () {
	        this.target.value = colorPreview.title;
	    });
	    (0, _jquery2.default)(colorPreview).click(function () {
	        if (!colorPicker.visible) {
	            colorPicker.enter();
	        }
	    });

	    var closeButton = document.createElement('button');
	    closeButton.innerHTML = 'Close';
	    closeButton.className = 'color-picker-close tool-button';
	    closeButton.addEventListener("click", function () {
	        colorPicker.exit();
	    }, false);
	    colorPicker.picker.appendChild(closeButton);
	}

	function initDegreeSpinner(key, name, prop) {
	    (0, _jquery2.default)('#' + key + '-' + name).degreespinner({
	        min: 0,
	        max: 360,
	        step: 1,
	        change: function change(event, ui) {
	            var v = parseInt(this.value);
	            if (isNaN(v)) {
	                v = parseInt(defaultHandlerOptions[key][prop]);
	            } else {
	                defaultHandlerOptions[key][prop] = v;
	                updateHandlerOption(key, prop, v);
	            }
	            (0, _jquery2.default)(this).val(formatDegree(v));
	        },
	        stop: function stop(event, ui) {
	            var v = parseInt(this.value);
	            if (!isNaN(v)) {
	                defaultHandlerOptions[key][prop] = v;
	                updateHandlerOption(key, prop, v);
	            }
	        }
	    }).val(formatDegree(defaultHandlerOptions[key][prop]));
	}

	function initSpinner(key, name, prop, options, spinnerType, formatFunction) {
	    var spinnerType = spinnerType || 'spinner';
	    var formatFunction = formatFunction || identity;
	    (0, _jquery2.default)('#' + key + '-' + name)[spinnerType](_OpenLayers2.default.Util.extend({
	        change: function change(event, ui) {
	            var v = parseInt(this.value);
	            if (isNaN(v)) {
	                v = parseInt(defaultHandlerOptions[key][prop]);
	            } else {
	                defaultHandlerOptions[key][prop] = v;
	                updateHandlerOption(key, prop, v);
	            }
	            (0, _jquery2.default)(this).val(formatFunction(v));
	        },
	        stop: function stop(event, ui) {
	            var v = parseInt(this.value);
	            if (!isNaN(v)) {
	                defaultHandlerOptions[key][prop] = v;
	                updateHandlerOption(key, prop, v);
	            }
	        }
	    }, options)).val(formatFunction(defaultHandlerOptions[key][prop]));
	}

	function identity(v) {
	    return v;
	};

	function updateHandlerOption(key, prop, value) {
	    var option = {};
	    option[prop] = value;
	    drawControls[key].handler.setOptions(option);
	}

	/****************
	 * ICON UI INIT *
	 ****************/

	// marker size spinner
	(0, _jquery2.default)('#marker-size').spinner({
	    min: 32,
	    step: 32,
	    change: function change(event, ui) {
	        var v = parseInt(this.value);
	        if (isNaN(v)) {
	            v = parseInt(defaultStyles.icon.graphicHeight);
	        } else {
	            defaultStyles.icon.graphicHeight = v;
	        }
	        (0, _jquery2.default)(this).val(v);
	    },
	    stop: function stop(event, ui) {
	        var v = parseInt(this.value);
	        if (!isNaN(v)) {
	            defaultStyles.icon.graphicHeight = v;
	        }
	    }
	}).val(defaultStyles.icon.graphicHeight);

	// marker opacity spinner
	var markerOpacityPreview = document.querySelector('#marker-opacity-icon .opacity-preview-icon');
	(0, _jquery2.default)('#marker-opacity').percentspinner({
	    min: 0,
	    max: 100,
	    step: 1,
	    change: function change(event, ui) {
	        var v = parseInt(this.value);
	        if (isNaN(v)) {
	            v = parseInt(defaultStyles.icon.graphicOpacity * 100);
	        } else {
	            defaultStyles.icon.graphicOpacity = v / 100;
	            markerOpacityPreview.style.opacity = defaultStyles.icon.graphicOpacity;
	        }
	        (0, _jquery2.default)(this).val(formatPercent(v));
	    },
	    spin: function spin(event, ui) {
	        markerOpacityPreview.style.opacity = ui.value / 100;
	    },
	    stop: function stop(event, ui) {
	        var v = parseInt(this.value);
	        if (!isNaN(v)) {
	            defaultStyles.icon.graphicOpacity = v / 100;
	            markerOpacityPreview.style.opacity = defaultStyles.icon.graphicOpacity;
	        }
	    }
	}).val(formatPercent(defaultStyles.icon.graphicOpacity * 100));

	// icon select dropdown
	_jquery2.default.getJSON("sprite_manifest.json", function (data) {
	    var img_root = '/media/images/miniheroes/';
	    for (var i = 0; i < data.heroes.length; i++) {
	        var $option = (0, _jquery2.default)('<option value="' + img_root + data.heroes[i].file + '">').text(data.heroes[i].name).attr("data-class", 'miniheroes-sprite-' + data.heroes[i].id);
	        (0, _jquery2.default)('#marker-image-dropdown').append($option);
	    }
	    for (var i = 0; i < data.other.length; i++) {
	        var $option = (0, _jquery2.default)('<option value="' + img_root + data.other[i].file + '">').text(data.other[i].name).attr("data-class", 'miniheroes-sprite' + data.other[i].id);
	        (0, _jquery2.default)('#marker-image-dropdown').append($option);
	    }

	    (0, _jquery2.default)("#marker-image-dropdown").iconselectmenu({
	        change: function change(event, ui) {
	            console.log('change', event, ui);
	            defaultStyles.icon.externalGraphic = ui.item.value;
	        }
	    });

	    defaultStyles.icon.externalGraphic = (0, _jquery2.default)('#marker-image-dropdown > option')[0].value;
	});

	/********************
	 * INITITIALIZATION *
	 ********************/

	// listen to key presses
	_OpenLayers2.default.Event.observe(document, "keydown", function (evt) {
	    var handled = false;
	    console.log(evt.keyCode);
	    switch (evt.keyCode) {
	        case 90:
	            // z
	            if (evt.metaKey || evt.ctrlKey) {
	                console.log(vectors.features);
	                drawUndo();
	                handled = true;
	            }
	            break;
	        case 89:
	            // y
	            if (evt.metaKey || evt.ctrlKey) {
	                drawRedo();
	                handled = true;
	            }
	            break;
	        case 27:
	            // esc
	            handled = true;
	            break;
	        case 46:
	            // esc
	            if (activeTool == 'modify') modifyDeleteFeature();
	            break;
	    }
	    if (handled) {
	        _OpenLayers2.default.Event.stop(evt);
	    }
	});

	_OpenLayers2.default.ImgPath = IMG_DIR;

	// Start setting up the map, adding controls and layers
	baseLayers.forEach(function (layer) {
	    map.addLayer(layer);
	});

	function getStyle(key) {
	    return _OpenLayers2.default.Util.applyDefaults({}, defaultStyles[key]);
	}

	function createStrokeStyleContext(key) {
	    return {
	        getPointRadius: function getPointRadius(feature) {
	            return (feature.attributes.style ? feature.attributes.style.pointRadius : getStyle(key).pointRadius) / map.getResolution();
	        },
	        getStrokeWidth: function getStrokeWidth(feature) {
	            return (feature.attributes.style ? feature.attributes.style.strokeWidth : getStyle(key).strokeWidth) / map.getResolution();
	        },
	        getStrokeColor: function getStrokeColor(feature) {
	            return feature.attributes.style ? feature.attributes.style.strokeColor : getStyle(key).strokeColor;
	        },
	        getStrokeOpacity: function getStrokeOpacity(feature) {
	            return feature.attributes.style ? feature.attributes.style.strokeOpacity : getStyle(key).strokeOpacity;
	        }
	    };
	}

	function createFillStyleContext(key) {
	    return {
	        getFillColor: function getFillColor(feature) {
	            return feature.attributes.style ? feature.attributes.style.fillColor : getStyle(key).fillColor;
	        },
	        getFillOpacity: function getFillOpacity(feature) {
	            return feature.attributes.style ? feature.attributes.style.fillOpacity : getStyle(key).fillOpacity;
	        }
	    };
	}

	// Returns style property stored in feature attribute or get current default style property
	var styleContexts = {
	    brush: createStrokeStyleContext('brush'),
	    line: createStrokeStyleContext('line'),
	    polygon: _OpenLayers2.default.Util.extend(createStrokeStyleContext('polygon'), createFillStyleContext('polygon')),
	    regularpolygon: _OpenLayers2.default.Util.extend(createStrokeStyleContext('regularpolygon'), createFillStyleContext('regularpolygon')),
	    icon: {
	        getGraphicHeight: function getGraphicHeight(feature) {
	            return (feature.attributes.style ? feature.attributes.style.graphicHeight : getStyle('icon').graphicHeight) / map.getResolution();
	        },
	        getGraphicOpacity: function getGraphicOpacity(feature) {
	            return feature.attributes.style ? feature.attributes.style.graphicOpacity : getStyle('icon').graphicOpacity;
	        },
	        getGraphicYOffset: function getGraphicYOffset(feature) {
	            var externalGraphic = getStyle('icon').externalGraphic;
	            if (externalGraphic.indexOf('ward_sentry') == -1 && externalGraphic.indexOf('ward_observer') == -1) {
	                return -getStyle('icon').graphicHeight / map.getResolution() / 2;
	            } else {
	                return -getStyle('icon').graphicHeight / map.getResolution();
	            }
	        },
	        getExternalGraphic: function getExternalGraphic(feature) {
	            return feature.attributes.style ? feature.attributes.style.externalGraphic : getStyle('icon').externalGraphic;
	        }
	    },
	    modify: _OpenLayers2.default.Util.extend(createStrokeStyleContext('modify'), {
	        getGraphicName: function getGraphicName(feature) {
	            console.log('getGraphicName modify', feature.attributes.style ? feature.attributes.style.graphicName : getStyle('modify').graphicName);
	            return feature.attributes.style ? feature.attributes.style.graphicName : getStyle('modify').graphicName;
	        },
	        getExternalGraphic: function getExternalGraphic(feature) {
	            return "";
	        }
	    })
	};

	var styleTemplates = {
	    brush: {
	        pointRadius: "${getPointRadius}",
	        strokeWidth: "${getStrokeWidth}",
	        strokeColor: "${getStrokeColor}",
	        strokeOpacity: "${getStrokeOpacity}"
	    },
	    line: {
	        pointRadius: "${getPointRadius}",
	        strokeWidth: "${getStrokeWidth}",
	        strokeColor: "${getStrokeColor}",
	        strokeOpacity: "${getStrokeOpacity}"
	    },
	    polygon: {
	        pointRadius: "${getPointRadius}",
	        strokeWidth: "${getStrokeWidth}",
	        strokeColor: "${getStrokeColor}",
	        strokeOpacity: "${getStrokeOpacity}",
	        fillColor: "${getFillColor}",
	        fillOpacity: "${getFillOpacity}"
	    },
	    regularpolygon: {
	        pointRadius: "${getPointRadius}",
	        strokeWidth: "${getStrokeWidth}",
	        strokeColor: "${getStrokeColor}",
	        strokeOpacity: "${getStrokeOpacity}",
	        fillColor: "${getFillColor}",
	        fillOpacity: "${getFillOpacity}"
	    },
	    icon: {
	        graphicOpacity: "${getGraphicOpacity}",
	        externalGraphic: "${getExternalGraphic}",
	        graphicYOffset: "${getGraphicYOffset}",
	        graphicHeight: "${getGraphicHeight}"
	    },
	    modify: {
	        pointRadius: "${getPointRadius}",
	        strokeWidth: "${getStrokeWidth}",
	        strokeColor: "${getStrokeColor}",
	        strokeOpacity: "${getStrokeOpacity}",
	        externalGraphic: "${getExternalGraphic}",
	        graphicName: "${getGraphicName}"
	    }
	};

	// Collection of all style objects
	var styles = {
	    select: _OpenLayers2.default.Feature.Vector.style.select,
	    virtual: {
	        strokeColor: "#ee9900",
	        fillColor: "#ee9900",
	        strokeOpacity: 0.3,
	        strokeWidth: 2,
	        pointRadius: 8,
	        fillOpacity: 0.3,
	        graphicName: "circle"
	    },
	    vertex: new _OpenLayers2.default.Style(_OpenLayers2.default.Util.applyDefaults({
	        strokeWidth: 2,
	        pointRadius: 8,
	        graphicName: "circle",
	        externalGraphic: ""
	    }, _OpenLayers2.default.Feature.Vector.style['default']), { extendDefault: false })
	};

	// Styles used by control temporary layers
	for (var k in defaultStyles) {
	    if (defaultStyles.hasOwnProperty(k)) {
	        styles[k] = new _OpenLayers2.default.Style(styleTemplates[k], { context: styleContexts[k] });
	    }
	}
	var zIndexCounter = 0;
	// Custom default style returns feature attribute style values first with fallback to active tool value
	styles['default'] = new _OpenLayers2.default.Style({
	    pointRadius: "${getPointRadius}",
	    strokeWidth: "${getStrokeWidth}",
	    strokeColor: "${getStrokeColor}",
	    strokeOpacity: "${getStrokeOpacity}",
	    fillColor: "${getFillColor}",
	    fillOpacity: "${getFillOpacity}",
	    graphicOpacity: "${getGraphicOpacity}",
	    externalGraphic: "${getExternalGraphic}",
	    graphicYOffset: "${getGraphicYOffset}",
	    graphicHeight: "${getGraphicHeight}",
	    graphicName: "${getGraphicName}",
	    graphicZIndex: "${getGraphicZIndex}"
	}, {
	    extendDefault: true,
	    context: {
	        getPointRadius: function getPointRadius(feature) {
	            return (feature.attributes.style ? feature.attributes.style.pointRadius : getStyle(activeTool).pointRadius) / map.getResolution();
	        },
	        getStrokeWidth: function getStrokeWidth(feature) {
	            return (feature.attributes.style ? feature.attributes.style.strokeWidth : getStyle(activeTool).strokeWidth) / map.getResolution();
	        },
	        getStrokeColor: function getStrokeColor(feature) {
	            return feature.attributes.style ? feature.attributes.style.strokeColor : getStyle(activeTool).strokeColor;
	        },
	        getStrokeOpacity: function getStrokeOpacity(feature) {
	            return feature.attributes.style ? feature.attributes.style.strokeOpacity : getStyle(activeTool).strokeOpacity;
	        },
	        getFillColor: function getFillColor(feature) {
	            return feature.attributes.style ? feature.attributes.style.fillColor : getStyle(activeTool).fillColor;
	        },
	        getFillOpacity: function getFillOpacity(feature) {
	            return feature.attributes.style ? feature.attributes.style.fillOpacity : getStyle(activeTool).fillOpacity;
	        },
	        getGraphicHeight: function getGraphicHeight(feature) {
	            if (feature.attributes.style) {
	                return feature.attributes.style.graphicHeight / map.getResolution();
	            } else if (getStyle(activeTool).graphicHeight) {
	                return getStyle(activeTool).graphicHeight / map.getResolution();
	            } else {
	                return _OpenLayers2.default.Feature.Vector.style['default'].graphicHeight;
	            }
	            return (feature.attributes.style ? feature.attributes.style.graphicHeight : getStyle(activeTool).graphicHeight) / map.getResolution();
	        },
	        getGraphicOpacity: function getGraphicOpacity(feature) {
	            return feature.attributes.style ? feature.attributes.style.graphicOpacity : getStyle(activeTool).graphicOpacity;
	        },
	        getGraphicYOffset: function getGraphicYOffset(feature) {
	            if (feature.attributes.style) {
	                var externalGraphic = feature.attributes.style.externalGraphic;
	                var graphicHeight = feature.attributes.style.graphicHeight;
	            } else if (getStyle(activeTool).getGraphicYOffset) {
	                var externalGraphic = getStyle(activeTool).externalGraphic;
	                var graphicHeight = getStyle(activeTool).graphicHeight;
	            } else {
	                return _OpenLayers2.default.Feature.Vector.style['default'].getGraphicYOffset;
	            }
	            if (!externalGraphic || !graphicHeight) return _OpenLayers2.default.Feature.Vector.style['default'].getGraphicYOffset;

	            if (externalGraphic.indexOf('ward_sentry') == -1 && externalGraphic.indexOf('ward_observer') == -1) {
	                return -graphicHeight / map.getResolution() / 2;
	            } else {
	                return -graphicHeight / map.getResolution();
	            }
	        },
	        getExternalGraphic: function getExternalGraphic(feature) {
	            if (feature.attributes.style) {
	                return feature.attributes.style.externalGraphic;
	            } else if (getStyle(activeTool).externalGraphic) {
	                return getStyle(activeTool).externalGraphic;
	            } else {
	                return _OpenLayers2.default.Feature.Vector.style['default'].externalGraphic;
	            }
	            return feature.attributes.style ? feature.attributes.style.externalGraphic : getStyle(activeTool).externalGraphic;
	        },
	        getGraphicName: function getGraphicName(feature) {
	            if (feature.attributes.style) {
	                return feature.attributes.style.graphicName;
	            } else if (getStyle(activeTool).graphicName) {
	                return getStyle(activeTool).graphicName;
	            } else {
	                return _OpenLayers2.default.Feature.Vector.style['default'].graphicName;
	            }
	            return feature.attributes.style ? feature.attributes.style.graphicName : getStyle(activeTool).graphicName;
	        },
	        getGraphicZIndex: function getGraphicZIndex(feature) {
	            console.log("graphicZIndex", feature);
	            if (feature.attributes.hasOwnProperty('zIndex')) {
	                console.log("graphicZIndex feature.attributes", feature.attributes.zIndex);
	                return feature.attributes.zIndex;
	            }
	            feature.attributes.zIndex = ++zIndexCounter;
	            console.log("graphicZIndex new feature.attributes", feature.attributes.zIndex);
	            return feature.attributes.zIndex;
	        }
	    }
	});
	renderer = renderer ? [renderer] : _OpenLayers2.default.Layer.Vector.prototype.renderers;
	var vectors = new _OpenLayers2.default.Layer.Vector("Canvas", {
	    styleMap: new _OpenLayers2.default.StyleMap({
	        'default': styles['default'],
	        select: styles.select,
	        vertex: styles.vertex
	    }),
	    rendererOptions: { zIndexing: true },
	    renderers: ["Canvas"] //renderer //["Canvas"]
	});
	map.addLayer(vectors);

	// X/Y coordinate update control
	var coordinateControl = new _OpenLayers2.default.Control.MousePosition();
	coordinateControl.formatOutput = function (lonlat) {
	    var worldXY = imageToDota(lonlat.lon, lonlat.lat);
	    return worldXY.x.toFixed(0) + ', ' + worldXY.y.toFixed(0);
	};
	map.addControl(coordinateControl);

	map.addControl(new _OpenLayers2.default.Control.TouchNavigation({
	    dragPanOptions: {
	        enableKinetic: true
	    }
	}));
	map.addControl(new _OpenLayers2.default.Control.KeyboardDefaults());

	/*layerSwitcher.onButtonClick = (function (fn) {
	    return function (evt) {
	        var button = evt.buttonElement;
	        if (button === this.maximizeDiv) {
	            $('.olControlLayerSwitcher').removeClass("minimized");
	            if (isSmallScreen()) {
	                minimizeControlList();
	            }
	        }
	        return fn.apply(this, arguments);
	    }
	})(layerSwitcher.onButtonClick);
	layerSwitcher.minimizeControl = function (e) {
	    $('.olControlLayerSwitcher').addClass("minimized");
	    this.showControls(true);
	     if (e != null) {
	        OpenLayers.Event.stop(e);
	    }
	}
	layerSwitcher.loadContents = function () {
	    // layers list div
	    this.layersDiv = document.createElement("div");
	    this.layersDiv.id = this.id + "_layersDiv";
	    OpenLayers.Element.addClass(this.layersDiv, "layersDiv");
	     this.baseLbl = document.createElement("div");
	    this.baseLbl.innerHTML = OpenLayers.i18n("Base Layer");
	    OpenLayers.Element.addClass(this.baseLbl, "baseLbl");
	     this.baseLayersDiv = document.createElement("div");
	    OpenLayers.Element.addClass(this.baseLayersDiv, "baseLayersDiv");
	     this.dataLbl = document.createElement("div");
	    this.dataLbl.innerHTML = OpenLayers.i18n("Overlays");
	    OpenLayers.Element.addClass(this.dataLbl, "dataLbl");
	     this.dataLayersDiv = document.createElement("div");
	    OpenLayers.Element.addClass(this.dataLayersDiv, "dataLayersDiv");
	     if (this.ascending) {
	        this.layersDiv.appendChild(this.baseLbl);
	        this.layersDiv.appendChild(this.baseLayersDiv);
	        this.layersDiv.appendChild(this.dataLbl);
	        this.layersDiv.appendChild(this.dataLayersDiv);
	    } else {
	        this.layersDiv.appendChild(this.dataLbl);
	        this.layersDiv.appendChild(this.dataLayersDiv);
	        this.layersDiv.appendChild(this.baseLbl);
	        this.layersDiv.appendChild(this.baseLayersDiv);
	    }
	     this.div.appendChild(this.layersDiv);
	     // maximize button div
	    this.maximizeDiv = OpenLayers.Util.createAlphaImageDiv(
	                                "OpenLayers_Control_MaximizeDiv",
	                                null,
	                                null,
	                                null,
	                                "initial");
	    OpenLayers.Element.addClass(this.maximizeDiv, "maximizeDiv olButton");
	    this.maximizeDiv.style.display = "none";
	     this.div.appendChild(this.maximizeDiv);
	     // minimize button div
	    this.minimizeDiv = OpenLayers.Util.createAlphaImageDiv(
	                                "OpenLayers_Control_MinimizeDiv",
	                                null,
	                                null,
	                                null,
	                                "initial");
	    OpenLayers.Element.addClass(this.minimizeDiv, "minimizeDiv olButton");
	    this.minimizeDiv.style.display = "none";
	     this.maximizeDiv.innerHTML;
	    this.minimizeDiv.innerHTML = '&times;';
	    $(this.maximizeDiv).empty().append($('<i class="fa fa-bars">'));
	    this.div.appendChild(this.minimizeDiv);
	}*/
	map.addControl(layerSwitcher);
	layerSwitcher.maximizeControl();
	if (!map.getCenter()) {
	    map.zoomToMaxExtent();
	}

	// Controls configuration
	var drawControls = {
	    brush: new _OpenLayers2.default.Control.DrawFeature(vectors, _OpenLayers2.default.Handler.Path, {
	        handlerOptions: {
	            freehand: true,
	            layerOptions: {
	                styleMap: new _OpenLayers2.default.StyleMap(styles.brush)
	            }
	        }
	    }),
	    icon: new _OpenLayers2.default.Control.DrawFeature(vectors, _OpenLayers2.default.Handler.Point, {
	        handlerOptions: {
	            layerOptions: {
	                styleMap: new _OpenLayers2.default.StyleMap(styles.icon)
	            }
	        }
	    }),
	    line: new _OpenLayers2.default.Control.DrawFeature(vectors, _OpenLayers2.default.Handler.Path, {
	        handlerOptions: {
	            freehand: false,
	            layerOptions: {
	                styleMap: new _OpenLayers2.default.StyleMap(styles.line)
	            }
	        }
	    }),
	    polygon: new _OpenLayers2.default.Control.DrawFeature(vectors, _OpenLayers2.default.Handler.Polygon, {
	        handlerOptions: {
	            layerOptions: {
	                styleMap: new _OpenLayers2.default.StyleMap(styles.polygon)
	            }
	        }
	    }),
	    regularpolygon: new _OpenLayers2.default.Control.DrawFeature(vectors, _OpenLayers2.default.Handler.RegularPolygon, {
	        handlerOptions: _OpenLayers2.default.Util.extend(defaultHandlerOptions.regularpolygon, {
	            layerOptions: {
	                styleMap: new _OpenLayers2.default.StyleMap(styles.regularpolygon)
	            }
	        })
	    }),
	    modify: new _OpenLayers2.default.Control.ModifyFeature(vectors, { vertexRenderIntent: "vertex", virtualStyle: styles.virtual }),
	    selectfeature: new _OpenLayers2.default.Control.SelectFeature(vectors),
	    measure: new _OpenLayers2.default.Control.Measure(_OpenLayers2.default.Handler.Path, { persist: true, immediate: true })
	};

	(0, _jquery2.default)('#measure-cancel').click(function () {
	    drawControls.measure.cancel();
	    (0, _jquery2.default)('#measure-distance').val("");
	});
	drawControls.measure.events.register("measurepartial", drawControls.measure, handleMeasurements);
	drawControls.measure.events.register("measure", drawControls.measure, handleMeasurements);

	function handleMeasurements(event) {
	    console.log('handleMeasurements', event);
	    var geometry = event.geometry;
	    var units = event.units;
	    var order = event.order;
	    var measure = event.measure;
	    var element = document.getElementById('output');
	    var out = "";
	    if (order == 1) {
	        out += measure.toFixed(3) + " " + units;
	    } else {
	        out += measure.toFixed(3) + " " + units + "<sup>2</" + "sup>";
	    }
	    (0, _jquery2.default)('#measure-distance').val(out);
	}

	function createSketchCompletedHandler(key) {
	    return function (event) {
	        console.log('createSketchCompletedHandler', key);
	        //event.feature.attributes.renderIntent = key;
	        //event.feature.renderIntent = key;
	        event.feature.attributes.style = getStyle(key);
	    };
	}

	var onSketchCompletedHandlers = {
	    brush: createSketchCompletedHandler('brush'),
	    icon: createSketchCompletedHandler('icon'),
	    line: createSketchCompletedHandler('line'),
	    polygon: createSketchCompletedHandler('polygon'),
	    regularpolygon: createSketchCompletedHandler('regularpolygon')
	};

	// Modifying feature resets renderIntent to 'default'. Reset it to stored renderIntent and redraw feature.
	function onFeatureModified(event) {
	    console.log('onFeatureModified', _OpenLayers2.default.Util.extend({}, event.feature), event.modified);
	    //event.feature.renderIntent = event.feature.attributes.renderIntent;
	    //event.feature.layer.drawFeature(event.feature);
	}

	// Add controls to map
	for (var key in drawControls) {
	    map.addControl(drawControls[key]);
	}

	var historyControl = new _OpenLayersControl2.default([vectors]);
	map.addControl(historyControl);

	var measureControl = new _OpenLayers2.default.Control.Measure(_OpenLayers2.default.Handler.Path);
	map.addControl(measureControl);
	vectors.events.register("featureselected", drawControls.selectfeature, function (event) {
	    console.log("featureselected", event);
	    if (event.feature.geometry.CLASS_NAME.indexOf('LineString') > -1) {
	        console.log('distance', measureControl.getBestLength(event.feature.geometry));
	    } else {
	        console.log('area', measureControl.getBestArea(event.feature.geometry));
	    }
	});

	// map position/zoom tracking querystring update
	map.events.register("zoomend", map, function () {
	    (0, _querystringutil.setQueryString)('zoom', map.zoom);
	});
	map.events.register("moveend", map, function () {
	    var worldXY = imageToDota(map.center.lon, map.center.lat);
	    (0, _querystringutil.setQueryString)('x', worldXY.x.toFixed(0));
	    (0, _querystringutil.setQueryString)('y', worldXY.y.toFixed(0));
	});

	// Show/hide controls panel
	document.getElementById("controls-max").addEventListener("click", function (e) {
	    (0, _jquery2.default)('#controls-container').removeClass('minimized');
	    if (isSmallScreen()) {
	        layerSwitcher.minimizeControl();
	    }
	    if (e) e.preventDefault();
	}, false);
	function minimizeControlList(e) {
	    (0, _jquery2.default)('#controls-container').addClass('minimized');
	    if (e) e.preventDefault();
	}
	document.getElementById("controls-min").addEventListener("click", minimizeControlList, false);

	// Check screen size
	function isSmallScreen() {
	    return (window.innerWidth > 0 ? window.innerWidth : screen.width) <= 768;
	}
	// Initially hide controls if screen is small
	if (isSmallScreen()) {
	    minimizeControlList.call(document.getElementById("controls-min"));
	    layerSwitcher.minimizeControl();
	}

	// Set up panel radio button toggle handlers
	//document.getElementById('noneToggle').addEventListener('click', toggleControl, false);
	//document.getElementById('drawToggle').addEventListener('click', toggleControl, false);

	// tool switcher ui initialize
	(0, _jquery2.default)(".tool-radiobutton").checkboxradio({
	    icon: false
	}).change(toggleControl);
	(0, _jquery2.default)("#map-tools").controlgroup({ direction: "vertical" });

	(0, _jquery2.default)(".modify-tool-radiobutton").checkboxradio({
	    icon: false
	}).change(toggleModifyControl);
	(0, _jquery2.default)(".tool-radiogroup").controlgroup();

	// undo/redo logic
	vectors.redoStack = [];
	function drawUndo() {
	    console.log('undo');
	    /*if (vectors.features.length) {
	        var feature = vectors.features.pop();
	        vectors.removeFeatures([feature]);
	        vectors.redoStack.push(feature);
	    }*/
	    historyControl.undo();
	}
	function drawRedo() {
	    /*if (vectors.redoStack.length) {
	        var feature = vectors.redoStack.pop();
	        vectors.addFeatures([feature]);
	    }*/
	    historyControl.redo();
	}

	// undo/redo ui listen
	(0, _jquery2.default)('#draw-undo').click(drawUndo);
	(0, _jquery2.default)('#draw-redo').click(drawRedo);

	(0, _jquery2.default)('#modify-delete').click(modifyDeleteFeature);

	function modifyDeleteFeature() {
	    var feature = drawControls.modify.feature;
	    if (feature) {
	        drawControls.modify.unselectFeature(feature);
	        vectors.removeFeatures([feature]);
	    }
	}

	// save drawing
	(0, _jquery2.default)('#save').click(function () {
	    var parser = new _OpenLayers2.default.Format.GeoJSON();
	    var serialized = parser.write(vectors.features);
	    _jquery2.default.ajax({
	        type: "POST",
	        url: "save.php",
	        data: { 'data': serialized },
	        dataType: "json",
	        success: function success(data) {
	            var saveLink = [location.protocol, '//', location.host, location.pathname].join('') + '?id=' + data.file;
	            console.log(saveLink);
	        },
	        failure: function failure(errMsg) {
	            alert("Save request failed.");
	        }
	    });
	});

	// start jquery ui tooltips
	(0, _jquery2.default)(document).tooltip();

	parseQueryString();

	(0, _jquery2.default)('.controls-container').show();

	var EXPORT = function () {
	    var width = 1024,
	        height = 1024;

	    var x = (0, _d3Scale.scaleLinear)().range([0, width]);

	    var y = (0, _d3Scale.scaleLinear)().range([0, height]);

	    var projection = (0, _d3Geo.geoTransform)({
	        point: function point(px, py) {
	            //console.log('px py', px, py, x(px), y(py));
	            this.stream.point(x(px), height - y(py));
	        }
	    });

	    var path = (0, _d3Geo.geoPath)().projection(projection);

	    var svg = (0, _d3Selection.select)("body").append("svg").attr("id", "export-svg").attr("width", width).attr("height", height);

	    var stylePropMap = {
	        fillColor: 'fill',
	        fillOpacity: 'fill-opacity',
	        strokeColor: 'stroke',
	        strokeWidth: 'stroke-width',
	        strokeOpacity: 'stroke-opacity',
	        graphicOpacity: 'opacity'
	    };

	    var imagesToLoad;

	    function setStyle(d) {
	        console.log(d.geometry.type);
	        for (var p in stylePropMap) {
	            if (d.properties.style[p]) {
	                console.log(p);
	                var val = d.properties.style[p];
	                if (p == 'strokeWidth') {
	                    val = x(val);
	                }
	                if (p == 'fillColor' && d.geometry.type == 'LineString') val = 'none';
	                (0, _d3Selection.select)(this).style(stylePropMap[p], val);
	            } else if (p == 'fillColor') {
	                console.log('fillColor none', d.geometry.type);
	                (0, _d3Selection.select)(this).style(stylePropMap[p], "none");
	            } else {
	                //console.log(p);
	            }
	        }
	        if (d.properties.style.externalGraphic) {
	            console.log('imagesToLoad', imagesToLoad);
	            var val = d.properties.style.externalGraphic;
	            console.log('externalGraphic', val);
	            var self = this;
	            (0, _d3Selection.select)(this).attr("xlink:href", val).attr('x', x(d.geometry.coordinates[0]) - x(d.properties.style.graphicHeight) / 2).attr('y', height - y(d.geometry.coordinates[1]) - x(d.properties.style.graphicHeight) / 2).attr('width', x(d.properties.style.graphicHeight)).attr('height', x(d.properties.style.graphicHeight));
	            imagesToLoad++;
	            getImageBase64(val, function (data) {
	                (0, _d3Selection.select)(self).attr("href", "data:image/png;base64," + data); // replace link by data URI
	                imagesToLoad--;
	                imageLoadFinished();
	            });
	        }
	    }

	    function imageLoadFinished(callback) {
	        if (imagesToLoad == 0) {
	            download_png();
	        }
	    }

	    function featureFilter(e) {
	        return function (d) {
	            console.log(d.geometry.type);
	            return d.geometry.type == e;
	        };
	    }

	    function createSVG(data) {
	        console.log(data);

	        // add index of element as zIndex so they can be ordered properly later
	        data.features.forEach(function (d, i) {
	            d.zIndex = i;
	            console.log(d);
	        });

	        var yExtent = [0, 16384],
	            xExtent = [0, 16384];
	        x.domain(xExtent);
	        y.domain(yExtent);

	        // background element
	        var baseLayerName = map.baseLayer.name.replace(/ /g, '').toLowerCase();
	        console.log(baseLayerName);
	        var background = map_tile_path + baseLayerName + "/dotamap" + (baseLayerName == 'default' ? '' : baseLayerName) + "5_25.jpg";
	        svg.append("image").attr("class", "background").attr("xlink:href", background).attr('width', width).attr('height', height);
	        imagesToLoad = 1;
	        getImageBase64(background, function (data) {
	            (0, _d3Selection.select)(".background").attr("href", "data:image/png;base64," + data); // replace link by data URI
	            imagesToLoad--;
	            imageLoadFinished();
	        });

	        svg.selectAll("g").data(data.features.filter(featureFilter('Polygon'))).enter().append("path").attr("class", "node").attr("d", path).each(setStyle);

	        svg.selectAll("g").data(data.features.filter(featureFilter('LineString'))).enter().append("path").attr("class", "node").attr("d", path).each(setStyle);

	        svg.selectAll("g").data(data.features.filter(featureFilter('Point'))).enter().append("image").attr("class", "node").attr("d", path).each(setStyle);

	        // sort by zIndex
	        svg.selectAll(".node").sort(function (a, b) {
	            console.log(a, b);
	            if (a.zIndex > b.zIndex) return 1;
	            if (a.zIndex < b.zIndex) return -1;
	            return 0;
	        });
	    }

	    function converterEngine(input) {
	        // fn BLOB => Binary => Base64 ?
	        var uInt8Array = new Uint8Array(input),
	            i = uInt8Array.length;
	        var biStr = []; //new Array(i);
	        while (i--) {
	            biStr[i] = String.fromCharCode(uInt8Array[i]);
	        }
	        var base64 = window.btoa(biStr.join(''));
	        //console.log("2. base64 produced >>> " + base64); // print-check conversion result
	        return base64;
	    }

	    function getImageBase64(url, callback) {
	        // 1. Loading file from url:
	        var xhr = new XMLHttpRequest(url);
	        xhr.open('GET', url, true); // url is the url of a PNG image.
	        xhr.responseType = 'arraybuffer';
	        xhr.callback = callback;
	        xhr.onload = function (e) {
	            if (this.status == 200) {
	                // 2. When loaded, do:
	                //console.log("1:Loaded response >>> " + this.response); // print-check xhr response 
	                var imgBase64 = converterEngine(this.response); // convert BLOB to base64
	                this.callback(imgBase64); //execute callback function with data
	            }
	        };
	        xhr.send();
	    }

	    function download_png() {
	        var contents = (0, _d3Selection.select)("svg").attr("version", 1.1).attr("xmlns", "http://www.w3.org/2000/svg").node().outerHTML;
	        var src = 'data:image/svg+xml;utf8,' + contents;

	        var canvas = document.createElement('canvas');
	        canvas.width = width;
	        canvas.height = height;
	        var context = canvas.getContext("2d");

	        var image = new Image();
	        image.src = src;
	        image.onload = function () {
	            context.drawImage(image, 0, 0, width, height);
	            downloadCanvas(canvas);
	        };
	    }

	    function dataURLtoBlob(dataurl) {
	        var arr = dataurl.split(','),
	            mime = arr[0].match(/:(.*?);/)[1],
	            bstr = atob(arr[1]),
	            n = bstr.length,
	            u8arr = new Uint8Array(n);
	        while (n--) {
	            u8arr[n] = bstr.charCodeAt(n);
	        }
	        return new Blob([u8arr], { type: mime });
	    }

	    function downloadCanvas(_canvasObject) {
	        var link = document.createElement("a");
	        var imgData = _canvasObject.toDataURL({ format: 'png', multiplier: 4 });
	        var strDataURI = imgData.substr(22, imgData.length);
	        var blob = dataURLtoBlob(imgData);
	        var objurl = URL.createObjectURL(blob);

	        link.download = "image.png";

	        link.href = objurl;

	        link.click();
	    }

	    function doExport() {
	        var parser = new _OpenLayers2.default.Format.GeoJSON();
	        var data = JSON.parse(parser.write(vectors.features));
	        console.log(data, vectors.features);
	        createSVG(data, download_png);
	    }

	    (0, _jquery2.default)("#export").click(doExport);
	}();

	/*** EXPORTS FROM exports-loader ***/

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*eslint-disable no-unused-vars*/
	/*!
	 * jQuery JavaScript Library v3.1.0
	 * https://jquery.com/
	 *
	 * Includes Sizzle.js
	 * https://sizzlejs.com/
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license
	 * https://jquery.org/license
	 *
	 * Date: 2016-07-07T21:44Z
	 */
	( function( global, factory ) {

		"use strict";

		if ( typeof module === "object" && typeof module.exports === "object" ) {

			// For CommonJS and CommonJS-like environments where a proper `window`
			// is present, execute the factory and get jQuery.
			// For environments that do not have a `window` with a `document`
			// (such as Node.js), expose a factory as module.exports.
			// This accentuates the need for the creation of a real `window`.
			// e.g. var jQuery = require("jquery")(window);
			// See ticket #14549 for more info.
			module.exports = global.document ?
				factory( global, true ) :
				function( w ) {
					if ( !w.document ) {
						throw new Error( "jQuery requires a window with a document" );
					}
					return factory( w );
				};
		} else {
			factory( global );
		}

	// Pass this if window is not defined yet
	} )( typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

	// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
	// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
	// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
	// enough that all such attempts are guarded in a try block.
	"use strict";

	var arr = [];

	var document = window.document;

	var getProto = Object.getPrototypeOf;

	var slice = arr.slice;

	var concat = arr.concat;

	var push = arr.push;

	var indexOf = arr.indexOf;

	var class2type = {};

	var toString = class2type.toString;

	var hasOwn = class2type.hasOwnProperty;

	var fnToString = hasOwn.toString;

	var ObjectFunctionString = fnToString.call( Object );

	var support = {};



		function DOMEval( code, doc ) {
			doc = doc || document;

			var script = doc.createElement( "script" );

			script.text = code;
			doc.head.appendChild( script ).parentNode.removeChild( script );
		}
	/* global Symbol */
	// Defining this global in .eslintrc would create a danger of using the global
	// unguarded in another place, it seems safer to define global only for this module



	var
		version = "3.1.0",

		// Define a local copy of jQuery
		jQuery = function( selector, context ) {

			// The jQuery object is actually just the init constructor 'enhanced'
			// Need init if jQuery is called (just allow error to be thrown if not included)
			return new jQuery.fn.init( selector, context );
		},

		// Support: Android <=4.0 only
		// Make sure we trim BOM and NBSP
		rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,

		// Matches dashed string for camelizing
		rmsPrefix = /^-ms-/,
		rdashAlpha = /-([a-z])/g,

		// Used by jQuery.camelCase as callback to replace()
		fcamelCase = function( all, letter ) {
			return letter.toUpperCase();
		};

	jQuery.fn = jQuery.prototype = {

		// The current version of jQuery being used
		jquery: version,

		constructor: jQuery,

		// The default length of a jQuery object is 0
		length: 0,

		toArray: function() {
			return slice.call( this );
		},

		// Get the Nth element in the matched element set OR
		// Get the whole matched element set as a clean array
		get: function( num ) {
			return num != null ?

				// Return just the one element from the set
				( num < 0 ? this[ num + this.length ] : this[ num ] ) :

				// Return all the elements in a clean array
				slice.call( this );
		},

		// Take an array of elements and push it onto the stack
		// (returning the new matched element set)
		pushStack: function( elems ) {

			// Build a new jQuery matched element set
			var ret = jQuery.merge( this.constructor(), elems );

			// Add the old object onto the stack (as a reference)
			ret.prevObject = this;

			// Return the newly-formed element set
			return ret;
		},

		// Execute a callback for every element in the matched set.
		each: function( callback ) {
			return jQuery.each( this, callback );
		},

		map: function( callback ) {
			return this.pushStack( jQuery.map( this, function( elem, i ) {
				return callback.call( elem, i, elem );
			} ) );
		},

		slice: function() {
			return this.pushStack( slice.apply( this, arguments ) );
		},

		first: function() {
			return this.eq( 0 );
		},

		last: function() {
			return this.eq( -1 );
		},

		eq: function( i ) {
			var len = this.length,
				j = +i + ( i < 0 ? len : 0 );
			return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
		},

		end: function() {
			return this.prevObject || this.constructor();
		},

		// For internal use only.
		// Behaves like an Array's method, not like a jQuery method.
		push: push,
		sort: arr.sort,
		splice: arr.splice
	};

	jQuery.extend = jQuery.fn.extend = function() {
		var options, name, src, copy, copyIsArray, clone,
			target = arguments[ 0 ] || {},
			i = 1,
			length = arguments.length,
			deep = false;

		// Handle a deep copy situation
		if ( typeof target === "boolean" ) {
			deep = target;

			// Skip the boolean and the target
			target = arguments[ i ] || {};
			i++;
		}

		// Handle case when target is a string or something (possible in deep copy)
		if ( typeof target !== "object" && !jQuery.isFunction( target ) ) {
			target = {};
		}

		// Extend jQuery itself if only one argument is passed
		if ( i === length ) {
			target = this;
			i--;
		}

		for ( ; i < length; i++ ) {

			// Only deal with non-null/undefined values
			if ( ( options = arguments[ i ] ) != null ) {

				// Extend the base object
				for ( name in options ) {
					src = target[ name ];
					copy = options[ name ];

					// Prevent never-ending loop
					if ( target === copy ) {
						continue;
					}

					// Recurse if we're merging plain objects or arrays
					if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
						( copyIsArray = jQuery.isArray( copy ) ) ) ) {

						if ( copyIsArray ) {
							copyIsArray = false;
							clone = src && jQuery.isArray( src ) ? src : [];

						} else {
							clone = src && jQuery.isPlainObject( src ) ? src : {};
						}

						// Never move original objects, clone them
						target[ name ] = jQuery.extend( deep, clone, copy );

					// Don't bring in undefined values
					} else if ( copy !== undefined ) {
						target[ name ] = copy;
					}
				}
			}
		}

		// Return the modified object
		return target;
	};

	jQuery.extend( {

		// Unique for each copy of jQuery on the page
		expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

		// Assume jQuery is ready without the ready module
		isReady: true,

		error: function( msg ) {
			throw new Error( msg );
		},

		noop: function() {},

		isFunction: function( obj ) {
			return jQuery.type( obj ) === "function";
		},

		isArray: Array.isArray,

		isWindow: function( obj ) {
			return obj != null && obj === obj.window;
		},

		isNumeric: function( obj ) {

			// As of jQuery 3.0, isNumeric is limited to
			// strings and numbers (primitives or objects)
			// that can be coerced to finite numbers (gh-2662)
			var type = jQuery.type( obj );
			return ( type === "number" || type === "string" ) &&

				// parseFloat NaNs numeric-cast false positives ("")
				// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
				// subtraction forces infinities to NaN
				!isNaN( obj - parseFloat( obj ) );
		},

		isPlainObject: function( obj ) {
			var proto, Ctor;

			// Detect obvious negatives
			// Use toString instead of jQuery.type to catch host objects
			if ( !obj || toString.call( obj ) !== "[object Object]" ) {
				return false;
			}

			proto = getProto( obj );

			// Objects with no prototype (e.g., `Object.create( null )`) are plain
			if ( !proto ) {
				return true;
			}

			// Objects with prototype are plain iff they were constructed by a global Object function
			Ctor = hasOwn.call( proto, "constructor" ) && proto.constructor;
			return typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;
		},

		isEmptyObject: function( obj ) {

			/* eslint-disable no-unused-vars */
			// See https://github.com/eslint/eslint/issues/6125
			var name;

			for ( name in obj ) {
				return false;
			}
			return true;
		},

		type: function( obj ) {
			if ( obj == null ) {
				return obj + "";
			}

			// Support: Android <=2.3 only (functionish RegExp)
			return typeof obj === "object" || typeof obj === "function" ?
				class2type[ toString.call( obj ) ] || "object" :
				typeof obj;
		},

		// Evaluates a script in a global context
		globalEval: function( code ) {
			DOMEval( code );
		},

		// Convert dashed to camelCase; used by the css and data modules
		// Support: IE <=9 - 11, Edge 12 - 13
		// Microsoft forgot to hump their vendor prefix (#9572)
		camelCase: function( string ) {
			return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
		},

		nodeName: function( elem, name ) {
			return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
		},

		each: function( obj, callback ) {
			var length, i = 0;

			if ( isArrayLike( obj ) ) {
				length = obj.length;
				for ( ; i < length; i++ ) {
					if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
						break;
					}
				}
			} else {
				for ( i in obj ) {
					if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
						break;
					}
				}
			}

			return obj;
		},

		// Support: Android <=4.0 only
		trim: function( text ) {
			return text == null ?
				"" :
				( text + "" ).replace( rtrim, "" );
		},

		// results is for internal usage only
		makeArray: function( arr, results ) {
			var ret = results || [];

			if ( arr != null ) {
				if ( isArrayLike( Object( arr ) ) ) {
					jQuery.merge( ret,
						typeof arr === "string" ?
						[ arr ] : arr
					);
				} else {
					push.call( ret, arr );
				}
			}

			return ret;
		},

		inArray: function( elem, arr, i ) {
			return arr == null ? -1 : indexOf.call( arr, elem, i );
		},

		// Support: Android <=4.0 only, PhantomJS 1 only
		// push.apply(_, arraylike) throws on ancient WebKit
		merge: function( first, second ) {
			var len = +second.length,
				j = 0,
				i = first.length;

			for ( ; j < len; j++ ) {
				first[ i++ ] = second[ j ];
			}

			first.length = i;

			return first;
		},

		grep: function( elems, callback, invert ) {
			var callbackInverse,
				matches = [],
				i = 0,
				length = elems.length,
				callbackExpect = !invert;

			// Go through the array, only saving the items
			// that pass the validator function
			for ( ; i < length; i++ ) {
				callbackInverse = !callback( elems[ i ], i );
				if ( callbackInverse !== callbackExpect ) {
					matches.push( elems[ i ] );
				}
			}

			return matches;
		},

		// arg is for internal usage only
		map: function( elems, callback, arg ) {
			var length, value,
				i = 0,
				ret = [];

			// Go through the array, translating each of the items to their new values
			if ( isArrayLike( elems ) ) {
				length = elems.length;
				for ( ; i < length; i++ ) {
					value = callback( elems[ i ], i, arg );

					if ( value != null ) {
						ret.push( value );
					}
				}

			// Go through every key on the object,
			} else {
				for ( i in elems ) {
					value = callback( elems[ i ], i, arg );

					if ( value != null ) {
						ret.push( value );
					}
				}
			}

			// Flatten any nested arrays
			return concat.apply( [], ret );
		},

		// A global GUID counter for objects
		guid: 1,

		// Bind a function to a context, optionally partially applying any
		// arguments.
		proxy: function( fn, context ) {
			var tmp, args, proxy;

			if ( typeof context === "string" ) {
				tmp = fn[ context ];
				context = fn;
				fn = tmp;
			}

			// Quick check to determine if target is callable, in the spec
			// this throws a TypeError, but we will just return undefined.
			if ( !jQuery.isFunction( fn ) ) {
				return undefined;
			}

			// Simulated bind
			args = slice.call( arguments, 2 );
			proxy = function() {
				return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
			};

			// Set the guid of unique handler to the same of original handler, so it can be removed
			proxy.guid = fn.guid = fn.guid || jQuery.guid++;

			return proxy;
		},

		now: Date.now,

		// jQuery.support is not used in Core but other projects attach their
		// properties to it so it needs to exist.
		support: support
	} );

	if ( typeof Symbol === "function" ) {
		jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
	}

	// Populate the class2type map
	jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
	function( i, name ) {
		class2type[ "[object " + name + "]" ] = name.toLowerCase();
	} );

	function isArrayLike( obj ) {

		// Support: real iOS 8.2 only (not reproducible in simulator)
		// `in` check used to prevent JIT error (gh-2145)
		// hasOwn isn't used here due to false negatives
		// regarding Nodelist length in IE
		var length = !!obj && "length" in obj && obj.length,
			type = jQuery.type( obj );

		if ( type === "function" || jQuery.isWindow( obj ) ) {
			return false;
		}

		return type === "array" || length === 0 ||
			typeof length === "number" && length > 0 && ( length - 1 ) in obj;
	}
	var Sizzle =
	/*!
	 * Sizzle CSS Selector Engine v2.3.0
	 * https://sizzlejs.com/
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license
	 * http://jquery.org/license
	 *
	 * Date: 2016-01-04
	 */
	(function( window ) {

	var i,
		support,
		Expr,
		getText,
		isXML,
		tokenize,
		compile,
		select,
		outermostContext,
		sortInput,
		hasDuplicate,

		// Local document vars
		setDocument,
		document,
		docElem,
		documentIsHTML,
		rbuggyQSA,
		rbuggyMatches,
		matches,
		contains,

		// Instance-specific data
		expando = "sizzle" + 1 * new Date(),
		preferredDoc = window.document,
		dirruns = 0,
		done = 0,
		classCache = createCache(),
		tokenCache = createCache(),
		compilerCache = createCache(),
		sortOrder = function( a, b ) {
			if ( a === b ) {
				hasDuplicate = true;
			}
			return 0;
		},

		// Instance methods
		hasOwn = ({}).hasOwnProperty,
		arr = [],
		pop = arr.pop,
		push_native = arr.push,
		push = arr.push,
		slice = arr.slice,
		// Use a stripped-down indexOf as it's faster than native
		// https://jsperf.com/thor-indexof-vs-for/5
		indexOf = function( list, elem ) {
			var i = 0,
				len = list.length;
			for ( ; i < len; i++ ) {
				if ( list[i] === elem ) {
					return i;
				}
			}
			return -1;
		},

		booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

		// Regular expressions

		// http://www.w3.org/TR/css3-selectors/#whitespace
		whitespace = "[\\x20\\t\\r\\n\\f]",

		// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
		identifier = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+",

		// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
		attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
			// Operator (capture 2)
			"*([*^$|!~]?=)" + whitespace +
			// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
			"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
			"*\\]",

		pseudos = ":(" + identifier + ")(?:\\((" +
			// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
			// 1. quoted (capture 3; capture 4 or capture 5)
			"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
			// 2. simple (capture 6)
			"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
			// 3. anything else (capture 2)
			".*" +
			")\\)|)",

		// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
		rwhitespace = new RegExp( whitespace + "+", "g" ),
		rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

		rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
		rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),

		rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),

		rpseudo = new RegExp( pseudos ),
		ridentifier = new RegExp( "^" + identifier + "$" ),

		matchExpr = {
			"ID": new RegExp( "^#(" + identifier + ")" ),
			"CLASS": new RegExp( "^\\.(" + identifier + ")" ),
			"TAG": new RegExp( "^(" + identifier + "|[*])" ),
			"ATTR": new RegExp( "^" + attributes ),
			"PSEUDO": new RegExp( "^" + pseudos ),
			"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
				"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
				"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
			"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
			// For use in libraries implementing .is()
			// We use this for POS matching in `select`
			"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
				whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
		},

		rinputs = /^(?:input|select|textarea|button)$/i,
		rheader = /^h\d$/i,

		rnative = /^[^{]+\{\s*\[native \w/,

		// Easily-parseable/retrievable ID or TAG or CLASS selectors
		rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

		rsibling = /[+~]/,

		// CSS escapes
		// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
		runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
		funescape = function( _, escaped, escapedWhitespace ) {
			var high = "0x" + escaped - 0x10000;
			// NaN means non-codepoint
			// Support: Firefox<24
			// Workaround erroneous numeric interpretation of +"0x"
			return high !== high || escapedWhitespace ?
				escaped :
				high < 0 ?
					// BMP codepoint
					String.fromCharCode( high + 0x10000 ) :
					// Supplemental Plane codepoint (surrogate pair)
					String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
		},

		// CSS string/identifier serialization
		// https://drafts.csswg.org/cssom/#common-serializing-idioms
		rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\x80-\uFFFF\w-]/g,
		fcssescape = function( ch, asCodePoint ) {
			if ( asCodePoint ) {

				// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
				if ( ch === "\0" ) {
					return "\uFFFD";
				}

				// Control characters and (dependent upon position) numbers get escaped as code points
				return ch.slice( 0, -1 ) + "\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";
			}

			// Other potentially-special ASCII characters get backslash-escaped
			return "\\" + ch;
		},

		// Used for iframes
		// See setDocument()
		// Removing the function wrapper causes a "Permission Denied"
		// error in IE
		unloadHandler = function() {
			setDocument();
		},

		disabledAncestor = addCombinator(
			function( elem ) {
				return elem.disabled === true;
			},
			{ dir: "parentNode", next: "legend" }
		);

	// Optimize for push.apply( _, NodeList )
	try {
		push.apply(
			(arr = slice.call( preferredDoc.childNodes )),
			preferredDoc.childNodes
		);
		// Support: Android<4.0
		// Detect silently failing push.apply
		arr[ preferredDoc.childNodes.length ].nodeType;
	} catch ( e ) {
		push = { apply: arr.length ?

			// Leverage slice if possible
			function( target, els ) {
				push_native.apply( target, slice.call(els) );
			} :

			// Support: IE<9
			// Otherwise append directly
			function( target, els ) {
				var j = target.length,
					i = 0;
				// Can't trust NodeList.length
				while ( (target[j++] = els[i++]) ) {}
				target.length = j - 1;
			}
		};
	}

	function Sizzle( selector, context, results, seed ) {
		var m, i, elem, nid, match, groups, newSelector,
			newContext = context && context.ownerDocument,

			// nodeType defaults to 9, since context defaults to document
			nodeType = context ? context.nodeType : 9;

		results = results || [];

		// Return early from calls with invalid selector or context
		if ( typeof selector !== "string" || !selector ||
			nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

			return results;
		}

		// Try to shortcut find operations (as opposed to filters) in HTML documents
		if ( !seed ) {

			if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
				setDocument( context );
			}
			context = context || document;

			if ( documentIsHTML ) {

				// If the selector is sufficiently simple, try using a "get*By*" DOM method
				// (excepting DocumentFragment context, where the methods don't exist)
				if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {

					// ID selector
					if ( (m = match[1]) ) {

						// Document context
						if ( nodeType === 9 ) {
							if ( (elem = context.getElementById( m )) ) {

								// Support: IE, Opera, Webkit
								// TODO: identify versions
								// getElementById can match elements by name instead of ID
								if ( elem.id === m ) {
									results.push( elem );
									return results;
								}
							} else {
								return results;
							}

						// Element context
						} else {

							// Support: IE, Opera, Webkit
							// TODO: identify versions
							// getElementById can match elements by name instead of ID
							if ( newContext && (elem = newContext.getElementById( m )) &&
								contains( context, elem ) &&
								elem.id === m ) {

								results.push( elem );
								return results;
							}
						}

					// Type selector
					} else if ( match[2] ) {
						push.apply( results, context.getElementsByTagName( selector ) );
						return results;

					// Class selector
					} else if ( (m = match[3]) && support.getElementsByClassName &&
						context.getElementsByClassName ) {

						push.apply( results, context.getElementsByClassName( m ) );
						return results;
					}
				}

				// Take advantage of querySelectorAll
				if ( support.qsa &&
					!compilerCache[ selector + " " ] &&
					(!rbuggyQSA || !rbuggyQSA.test( selector )) ) {

					if ( nodeType !== 1 ) {
						newContext = context;
						newSelector = selector;

					// qSA looks outside Element context, which is not what we want
					// Thanks to Andrew Dupont for this workaround technique
					// Support: IE <=8
					// Exclude object elements
					} else if ( context.nodeName.toLowerCase() !== "object" ) {

						// Capture the context ID, setting it first if necessary
						if ( (nid = context.getAttribute( "id" )) ) {
							nid = nid.replace( rcssescape, fcssescape );
						} else {
							context.setAttribute( "id", (nid = expando) );
						}

						// Prefix every selector in the list
						groups = tokenize( selector );
						i = groups.length;
						while ( i-- ) {
							groups[i] = "#" + nid + " " + toSelector( groups[i] );
						}
						newSelector = groups.join( "," );

						// Expand context for sibling selectors
						newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
							context;
					}

					if ( newSelector ) {
						try {
							push.apply( results,
								newContext.querySelectorAll( newSelector )
							);
							return results;
						} catch ( qsaError ) {
						} finally {
							if ( nid === expando ) {
								context.removeAttribute( "id" );
							}
						}
					}
				}
			}
		}

		// All others
		return select( selector.replace( rtrim, "$1" ), context, results, seed );
	}

	/**
	 * Create key-value caches of limited size
	 * @returns {function(string, object)} Returns the Object data after storing it on itself with
	 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
	 *	deleting the oldest entry
	 */
	function createCache() {
		var keys = [];

		function cache( key, value ) {
			// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
			if ( keys.push( key + " " ) > Expr.cacheLength ) {
				// Only keep the most recent entries
				delete cache[ keys.shift() ];
			}
			return (cache[ key + " " ] = value);
		}
		return cache;
	}

	/**
	 * Mark a function for special use by Sizzle
	 * @param {Function} fn The function to mark
	 */
	function markFunction( fn ) {
		fn[ expando ] = true;
		return fn;
	}

	/**
	 * Support testing using an element
	 * @param {Function} fn Passed the created element and returns a boolean result
	 */
	function assert( fn ) {
		var el = document.createElement("fieldset");

		try {
			return !!fn( el );
		} catch (e) {
			return false;
		} finally {
			// Remove from its parent by default
			if ( el.parentNode ) {
				el.parentNode.removeChild( el );
			}
			// release memory in IE
			el = null;
		}
	}

	/**
	 * Adds the same handler for all of the specified attrs
	 * @param {String} attrs Pipe-separated list of attributes
	 * @param {Function} handler The method that will be applied
	 */
	function addHandle( attrs, handler ) {
		var arr = attrs.split("|"),
			i = arr.length;

		while ( i-- ) {
			Expr.attrHandle[ arr[i] ] = handler;
		}
	}

	/**
	 * Checks document order of two siblings
	 * @param {Element} a
	 * @param {Element} b
	 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
	 */
	function siblingCheck( a, b ) {
		var cur = b && a,
			diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
				a.sourceIndex - b.sourceIndex;

		// Use IE sourceIndex if available on both nodes
		if ( diff ) {
			return diff;
		}

		// Check if b follows a
		if ( cur ) {
			while ( (cur = cur.nextSibling) ) {
				if ( cur === b ) {
					return -1;
				}
			}
		}

		return a ? 1 : -1;
	}

	/**
	 * Returns a function to use in pseudos for input types
	 * @param {String} type
	 */
	function createInputPseudo( type ) {
		return function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === type;
		};
	}

	/**
	 * Returns a function to use in pseudos for buttons
	 * @param {String} type
	 */
	function createButtonPseudo( type ) {
		return function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return (name === "input" || name === "button") && elem.type === type;
		};
	}

	/**
	 * Returns a function to use in pseudos for :enabled/:disabled
	 * @param {Boolean} disabled true for :disabled; false for :enabled
	 */
	function createDisabledPseudo( disabled ) {
		// Known :disabled false positives:
		// IE: *[disabled]:not(button, input, select, textarea, optgroup, option, menuitem, fieldset)
		// not IE: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
		return function( elem ) {

			// Check form elements and option elements for explicit disabling
			return "label" in elem && elem.disabled === disabled ||
				"form" in elem && elem.disabled === disabled ||

				// Check non-disabled form elements for fieldset[disabled] ancestors
				"form" in elem && elem.disabled === false && (
					// Support: IE6-11+
					// Ancestry is covered for us
					elem.isDisabled === disabled ||

					// Otherwise, assume any non-<option> under fieldset[disabled] is disabled
					/* jshint -W018 */
					elem.isDisabled !== !disabled &&
						("label" in elem || !disabledAncestor( elem )) !== disabled
				);
		};
	}

	/**
	 * Returns a function to use in pseudos for positionals
	 * @param {Function} fn
	 */
	function createPositionalPseudo( fn ) {
		return markFunction(function( argument ) {
			argument = +argument;
			return markFunction(function( seed, matches ) {
				var j,
					matchIndexes = fn( [], seed.length, argument ),
					i = matchIndexes.length;

				// Match elements found at the specified indexes
				while ( i-- ) {
					if ( seed[ (j = matchIndexes[i]) ] ) {
						seed[j] = !(matches[j] = seed[j]);
					}
				}
			});
		});
	}

	/**
	 * Checks a node for validity as a Sizzle context
	 * @param {Element|Object=} context
	 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
	 */
	function testContext( context ) {
		return context && typeof context.getElementsByTagName !== "undefined" && context;
	}

	// Expose support vars for convenience
	support = Sizzle.support = {};

	/**
	 * Detects XML nodes
	 * @param {Element|Object} elem An element or a document
	 * @returns {Boolean} True iff elem is a non-HTML XML node
	 */
	isXML = Sizzle.isXML = function( elem ) {
		// documentElement is verified for cases where it doesn't yet exist
		// (such as loading iframes in IE - #4833)
		var documentElement = elem && (elem.ownerDocument || elem).documentElement;
		return documentElement ? documentElement.nodeName !== "HTML" : false;
	};

	/**
	 * Sets document-related variables once based on the current document
	 * @param {Element|Object} [doc] An element or document object to use to set the document
	 * @returns {Object} Returns the current document
	 */
	setDocument = Sizzle.setDocument = function( node ) {
		var hasCompare, subWindow,
			doc = node ? node.ownerDocument || node : preferredDoc;

		// Return early if doc is invalid or already selected
		if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
			return document;
		}

		// Update global variables
		document = doc;
		docElem = document.documentElement;
		documentIsHTML = !isXML( document );

		// Support: IE 9-11, Edge
		// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
		if ( preferredDoc !== document &&
			(subWindow = document.defaultView) && subWindow.top !== subWindow ) {

			// Support: IE 11, Edge
			if ( subWindow.addEventListener ) {
				subWindow.addEventListener( "unload", unloadHandler, false );

			// Support: IE 9 - 10 only
			} else if ( subWindow.attachEvent ) {
				subWindow.attachEvent( "onunload", unloadHandler );
			}
		}

		/* Attributes
		---------------------------------------------------------------------- */

		// Support: IE<8
		// Verify that getAttribute really returns attributes and not properties
		// (excepting IE8 booleans)
		support.attributes = assert(function( el ) {
			el.className = "i";
			return !el.getAttribute("className");
		});

		/* getElement(s)By*
		---------------------------------------------------------------------- */

		// Check if getElementsByTagName("*") returns only elements
		support.getElementsByTagName = assert(function( el ) {
			el.appendChild( document.createComment("") );
			return !el.getElementsByTagName("*").length;
		});

		// Support: IE<9
		support.getElementsByClassName = rnative.test( document.getElementsByClassName );

		// Support: IE<10
		// Check if getElementById returns elements by name
		// The broken getElementById methods don't pick up programmatically-set names,
		// so use a roundabout getElementsByName test
		support.getById = assert(function( el ) {
			docElem.appendChild( el ).id = expando;
			return !document.getElementsByName || !document.getElementsByName( expando ).length;
		});

		// ID find and filter
		if ( support.getById ) {
			Expr.find["ID"] = function( id, context ) {
				if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
					var m = context.getElementById( id );
					return m ? [ m ] : [];
				}
			};
			Expr.filter["ID"] = function( id ) {
				var attrId = id.replace( runescape, funescape );
				return function( elem ) {
					return elem.getAttribute("id") === attrId;
				};
			};
		} else {
			// Support: IE6/7
			// getElementById is not reliable as a find shortcut
			delete Expr.find["ID"];

			Expr.filter["ID"] =  function( id ) {
				var attrId = id.replace( runescape, funescape );
				return function( elem ) {
					var node = typeof elem.getAttributeNode !== "undefined" &&
						elem.getAttributeNode("id");
					return node && node.value === attrId;
				};
			};
		}

		// Tag
		Expr.find["TAG"] = support.getElementsByTagName ?
			function( tag, context ) {
				if ( typeof context.getElementsByTagName !== "undefined" ) {
					return context.getElementsByTagName( tag );

				// DocumentFragment nodes don't have gEBTN
				} else if ( support.qsa ) {
					return context.querySelectorAll( tag );
				}
			} :

			function( tag, context ) {
				var elem,
					tmp = [],
					i = 0,
					// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
					results = context.getElementsByTagName( tag );

				// Filter out possible comments
				if ( tag === "*" ) {
					while ( (elem = results[i++]) ) {
						if ( elem.nodeType === 1 ) {
							tmp.push( elem );
						}
					}

					return tmp;
				}
				return results;
			};

		// Class
		Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
			if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
				return context.getElementsByClassName( className );
			}
		};

		/* QSA/matchesSelector
		---------------------------------------------------------------------- */

		// QSA and matchesSelector support

		// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
		rbuggyMatches = [];

		// qSa(:focus) reports false when true (Chrome 21)
		// We allow this because of a bug in IE8/9 that throws an error
		// whenever `document.activeElement` is accessed on an iframe
		// So, we allow :focus to pass through QSA all the time to avoid the IE error
		// See https://bugs.jquery.com/ticket/13378
		rbuggyQSA = [];

		if ( (support.qsa = rnative.test( document.querySelectorAll )) ) {
			// Build QSA regex
			// Regex strategy adopted from Diego Perini
			assert(function( el ) {
				// Select is set to empty string on purpose
				// This is to test IE's treatment of not explicitly
				// setting a boolean content attribute,
				// since its presence should be enough
				// https://bugs.jquery.com/ticket/12359
				docElem.appendChild( el ).innerHTML = "<a id='" + expando + "'></a>" +
					"<select id='" + expando + "-\r\\' msallowcapture=''>" +
					"<option selected=''></option></select>";

				// Support: IE8, Opera 11-12.16
				// Nothing should be selected when empty strings follow ^= or $= or *=
				// The test attribute must be unknown in Opera but "safe" for WinRT
				// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
				if ( el.querySelectorAll("[msallowcapture^='']").length ) {
					rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
				}

				// Support: IE8
				// Boolean attributes and "value" are not treated correctly
				if ( !el.querySelectorAll("[selected]").length ) {
					rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
				}

				// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
				if ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
					rbuggyQSA.push("~=");
				}

				// Webkit/Opera - :checked should return selected option elements
				// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
				// IE8 throws error here and will not see later tests
				if ( !el.querySelectorAll(":checked").length ) {
					rbuggyQSA.push(":checked");
				}

				// Support: Safari 8+, iOS 8+
				// https://bugs.webkit.org/show_bug.cgi?id=136851
				// In-page `selector#id sibling-combinator selector` fails
				if ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {
					rbuggyQSA.push(".#.+[+~]");
				}
			});

			assert(function( el ) {
				el.innerHTML = "<a href='' disabled='disabled'></a>" +
					"<select disabled='disabled'><option/></select>";

				// Support: Windows 8 Native Apps
				// The type and name attributes are restricted during .innerHTML assignment
				var input = document.createElement("input");
				input.setAttribute( "type", "hidden" );
				el.appendChild( input ).setAttribute( "name", "D" );

				// Support: IE8
				// Enforce case-sensitivity of name attribute
				if ( el.querySelectorAll("[name=d]").length ) {
					rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
				}

				// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
				// IE8 throws error here and will not see later tests
				if ( el.querySelectorAll(":enabled").length !== 2 ) {
					rbuggyQSA.push( ":enabled", ":disabled" );
				}

				// Support: IE9-11+
				// IE's :disabled selector does not pick up the children of disabled fieldsets
				docElem.appendChild( el ).disabled = true;
				if ( el.querySelectorAll(":disabled").length !== 2 ) {
					rbuggyQSA.push( ":enabled", ":disabled" );
				}

				// Opera 10-11 does not throw on post-comma invalid pseudos
				el.querySelectorAll("*,:x");
				rbuggyQSA.push(",.*:");
			});
		}

		if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
			docElem.webkitMatchesSelector ||
			docElem.mozMatchesSelector ||
			docElem.oMatchesSelector ||
			docElem.msMatchesSelector) )) ) {

			assert(function( el ) {
				// Check to see if it's possible to do matchesSelector
				// on a disconnected node (IE 9)
				support.disconnectedMatch = matches.call( el, "*" );

				// This should fail with an exception
				// Gecko does not error, returns false instead
				matches.call( el, "[s!='']:x" );
				rbuggyMatches.push( "!=", pseudos );
			});
		}

		rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
		rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

		/* Contains
		---------------------------------------------------------------------- */
		hasCompare = rnative.test( docElem.compareDocumentPosition );

		// Element contains another
		// Purposefully self-exclusive
		// As in, an element does not contain itself
		contains = hasCompare || rnative.test( docElem.contains ) ?
			function( a, b ) {
				var adown = a.nodeType === 9 ? a.documentElement : a,
					bup = b && b.parentNode;
				return a === bup || !!( bup && bup.nodeType === 1 && (
					adown.contains ?
						adown.contains( bup ) :
						a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
				));
			} :
			function( a, b ) {
				if ( b ) {
					while ( (b = b.parentNode) ) {
						if ( b === a ) {
							return true;
						}
					}
				}
				return false;
			};

		/* Sorting
		---------------------------------------------------------------------- */

		// Document order sorting
		sortOrder = hasCompare ?
		function( a, b ) {

			// Flag for duplicate removal
			if ( a === b ) {
				hasDuplicate = true;
				return 0;
			}

			// Sort on method existence if only one input has compareDocumentPosition
			var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
			if ( compare ) {
				return compare;
			}

			// Calculate position if both inputs belong to the same document
			compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
				a.compareDocumentPosition( b ) :

				// Otherwise we know they are disconnected
				1;

			// Disconnected nodes
			if ( compare & 1 ||
				(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

				// Choose the first element that is related to our preferred document
				if ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
					return -1;
				}
				if ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
					return 1;
				}

				// Maintain original order
				return sortInput ?
					( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
					0;
			}

			return compare & 4 ? -1 : 1;
		} :
		function( a, b ) {
			// Exit early if the nodes are identical
			if ( a === b ) {
				hasDuplicate = true;
				return 0;
			}

			var cur,
				i = 0,
				aup = a.parentNode,
				bup = b.parentNode,
				ap = [ a ],
				bp = [ b ];

			// Parentless nodes are either documents or disconnected
			if ( !aup || !bup ) {
				return a === document ? -1 :
					b === document ? 1 :
					aup ? -1 :
					bup ? 1 :
					sortInput ?
					( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
					0;

			// If the nodes are siblings, we can do a quick check
			} else if ( aup === bup ) {
				return siblingCheck( a, b );
			}

			// Otherwise we need full lists of their ancestors for comparison
			cur = a;
			while ( (cur = cur.parentNode) ) {
				ap.unshift( cur );
			}
			cur = b;
			while ( (cur = cur.parentNode) ) {
				bp.unshift( cur );
			}

			// Walk down the tree looking for a discrepancy
			while ( ap[i] === bp[i] ) {
				i++;
			}

			return i ?
				// Do a sibling check if the nodes have a common ancestor
				siblingCheck( ap[i], bp[i] ) :

				// Otherwise nodes in our document sort first
				ap[i] === preferredDoc ? -1 :
				bp[i] === preferredDoc ? 1 :
				0;
		};

		return document;
	};

	Sizzle.matches = function( expr, elements ) {
		return Sizzle( expr, null, null, elements );
	};

	Sizzle.matchesSelector = function( elem, expr ) {
		// Set document vars if needed
		if ( ( elem.ownerDocument || elem ) !== document ) {
			setDocument( elem );
		}

		// Make sure that attribute selectors are quoted
		expr = expr.replace( rattributeQuotes, "='$1']" );

		if ( support.matchesSelector && documentIsHTML &&
			!compilerCache[ expr + " " ] &&
			( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
			( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

			try {
				var ret = matches.call( elem, expr );

				// IE 9's matchesSelector returns false on disconnected nodes
				if ( ret || support.disconnectedMatch ||
						// As well, disconnected nodes are said to be in a document
						// fragment in IE 9
						elem.document && elem.document.nodeType !== 11 ) {
					return ret;
				}
			} catch (e) {}
		}

		return Sizzle( expr, document, null, [ elem ] ).length > 0;
	};

	Sizzle.contains = function( context, elem ) {
		// Set document vars if needed
		if ( ( context.ownerDocument || context ) !== document ) {
			setDocument( context );
		}
		return contains( context, elem );
	};

	Sizzle.attr = function( elem, name ) {
		// Set document vars if needed
		if ( ( elem.ownerDocument || elem ) !== document ) {
			setDocument( elem );
		}

		var fn = Expr.attrHandle[ name.toLowerCase() ],
			// Don't get fooled by Object.prototype properties (jQuery #13807)
			val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
				fn( elem, name, !documentIsHTML ) :
				undefined;

		return val !== undefined ?
			val :
			support.attributes || !documentIsHTML ?
				elem.getAttribute( name ) :
				(val = elem.getAttributeNode(name)) && val.specified ?
					val.value :
					null;
	};

	Sizzle.escape = function( sel ) {
		return (sel + "").replace( rcssescape, fcssescape );
	};

	Sizzle.error = function( msg ) {
		throw new Error( "Syntax error, unrecognized expression: " + msg );
	};

	/**
	 * Document sorting and removing duplicates
	 * @param {ArrayLike} results
	 */
	Sizzle.uniqueSort = function( results ) {
		var elem,
			duplicates = [],
			j = 0,
			i = 0;

		// Unless we *know* we can detect duplicates, assume their presence
		hasDuplicate = !support.detectDuplicates;
		sortInput = !support.sortStable && results.slice( 0 );
		results.sort( sortOrder );

		if ( hasDuplicate ) {
			while ( (elem = results[i++]) ) {
				if ( elem === results[ i ] ) {
					j = duplicates.push( i );
				}
			}
			while ( j-- ) {
				results.splice( duplicates[ j ], 1 );
			}
		}

		// Clear input after sorting to release objects
		// See https://github.com/jquery/sizzle/pull/225
		sortInput = null;

		return results;
	};

	/**
	 * Utility function for retrieving the text value of an array of DOM nodes
	 * @param {Array|Element} elem
	 */
	getText = Sizzle.getText = function( elem ) {
		var node,
			ret = "",
			i = 0,
			nodeType = elem.nodeType;

		if ( !nodeType ) {
			// If no nodeType, this is expected to be an array
			while ( (node = elem[i++]) ) {
				// Do not traverse comment nodes
				ret += getText( node );
			}
		} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
			// Use textContent for elements
			// innerText usage removed for consistency of new lines (jQuery #11153)
			if ( typeof elem.textContent === "string" ) {
				return elem.textContent;
			} else {
				// Traverse its children
				for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
					ret += getText( elem );
				}
			}
		} else if ( nodeType === 3 || nodeType === 4 ) {
			return elem.nodeValue;
		}
		// Do not include comment or processing instruction nodes

		return ret;
	};

	Expr = Sizzle.selectors = {

		// Can be adjusted by the user
		cacheLength: 50,

		createPseudo: markFunction,

		match: matchExpr,

		attrHandle: {},

		find: {},

		relative: {
			">": { dir: "parentNode", first: true },
			" ": { dir: "parentNode" },
			"+": { dir: "previousSibling", first: true },
			"~": { dir: "previousSibling" }
		},

		preFilter: {
			"ATTR": function( match ) {
				match[1] = match[1].replace( runescape, funescape );

				// Move the given value to match[3] whether quoted or unquoted
				match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );

				if ( match[2] === "~=" ) {
					match[3] = " " + match[3] + " ";
				}

				return match.slice( 0, 4 );
			},

			"CHILD": function( match ) {
				/* matches from matchExpr["CHILD"]
					1 type (only|nth|...)
					2 what (child|of-type)
					3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
					4 xn-component of xn+y argument ([+-]?\d*n|)
					5 sign of xn-component
					6 x of xn-component
					7 sign of y-component
					8 y of y-component
				*/
				match[1] = match[1].toLowerCase();

				if ( match[1].slice( 0, 3 ) === "nth" ) {
					// nth-* requires argument
					if ( !match[3] ) {
						Sizzle.error( match[0] );
					}

					// numeric x and y parameters for Expr.filter.CHILD
					// remember that false/true cast respectively to 0/1
					match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
					match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

				// other types prohibit arguments
				} else if ( match[3] ) {
					Sizzle.error( match[0] );
				}

				return match;
			},

			"PSEUDO": function( match ) {
				var excess,
					unquoted = !match[6] && match[2];

				if ( matchExpr["CHILD"].test( match[0] ) ) {
					return null;
				}

				// Accept quoted arguments as-is
				if ( match[3] ) {
					match[2] = match[4] || match[5] || "";

				// Strip excess characters from unquoted arguments
				} else if ( unquoted && rpseudo.test( unquoted ) &&
					// Get excess from tokenize (recursively)
					(excess = tokenize( unquoted, true )) &&
					// advance to the next closing parenthesis
					(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

					// excess is a negative index
					match[0] = match[0].slice( 0, excess );
					match[2] = unquoted.slice( 0, excess );
				}

				// Return only captures needed by the pseudo filter method (type and argument)
				return match.slice( 0, 3 );
			}
		},

		filter: {

			"TAG": function( nodeNameSelector ) {
				var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
				return nodeNameSelector === "*" ?
					function() { return true; } :
					function( elem ) {
						return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
					};
			},

			"CLASS": function( className ) {
				var pattern = classCache[ className + " " ];

				return pattern ||
					(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
					classCache( className, function( elem ) {
						return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
					});
			},

			"ATTR": function( name, operator, check ) {
				return function( elem ) {
					var result = Sizzle.attr( elem, name );

					if ( result == null ) {
						return operator === "!=";
					}
					if ( !operator ) {
						return true;
					}

					result += "";

					return operator === "=" ? result === check :
						operator === "!=" ? result !== check :
						operator === "^=" ? check && result.indexOf( check ) === 0 :
						operator === "*=" ? check && result.indexOf( check ) > -1 :
						operator === "$=" ? check && result.slice( -check.length ) === check :
						operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
						operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
						false;
				};
			},

			"CHILD": function( type, what, argument, first, last ) {
				var simple = type.slice( 0, 3 ) !== "nth",
					forward = type.slice( -4 ) !== "last",
					ofType = what === "of-type";

				return first === 1 && last === 0 ?

					// Shortcut for :nth-*(n)
					function( elem ) {
						return !!elem.parentNode;
					} :

					function( elem, context, xml ) {
						var cache, uniqueCache, outerCache, node, nodeIndex, start,
							dir = simple !== forward ? "nextSibling" : "previousSibling",
							parent = elem.parentNode,
							name = ofType && elem.nodeName.toLowerCase(),
							useCache = !xml && !ofType,
							diff = false;

						if ( parent ) {

							// :(first|last|only)-(child|of-type)
							if ( simple ) {
								while ( dir ) {
									node = elem;
									while ( (node = node[ dir ]) ) {
										if ( ofType ?
											node.nodeName.toLowerCase() === name :
											node.nodeType === 1 ) {

											return false;
										}
									}
									// Reverse direction for :only-* (if we haven't yet done so)
									start = dir = type === "only" && !start && "nextSibling";
								}
								return true;
							}

							start = [ forward ? parent.firstChild : parent.lastChild ];

							// non-xml :nth-child(...) stores cache data on `parent`
							if ( forward && useCache ) {

								// Seek `elem` from a previously-cached index

								// ...in a gzip-friendly way
								node = parent;
								outerCache = node[ expando ] || (node[ expando ] = {});

								// Support: IE <9 only
								// Defend against cloned attroperties (jQuery gh-1709)
								uniqueCache = outerCache[ node.uniqueID ] ||
									(outerCache[ node.uniqueID ] = {});

								cache = uniqueCache[ type ] || [];
								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
								diff = nodeIndex && cache[ 2 ];
								node = nodeIndex && parent.childNodes[ nodeIndex ];

								while ( (node = ++nodeIndex && node && node[ dir ] ||

									// Fallback to seeking `elem` from the start
									(diff = nodeIndex = 0) || start.pop()) ) {

									// When found, cache indexes on `parent` and break
									if ( node.nodeType === 1 && ++diff && node === elem ) {
										uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
										break;
									}
								}

							} else {
								// Use previously-cached element index if available
								if ( useCache ) {
									// ...in a gzip-friendly way
									node = elem;
									outerCache = node[ expando ] || (node[ expando ] = {});

									// Support: IE <9 only
									// Defend against cloned attroperties (jQuery gh-1709)
									uniqueCache = outerCache[ node.uniqueID ] ||
										(outerCache[ node.uniqueID ] = {});

									cache = uniqueCache[ type ] || [];
									nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
									diff = nodeIndex;
								}

								// xml :nth-child(...)
								// or :nth-last-child(...) or :nth(-last)?-of-type(...)
								if ( diff === false ) {
									// Use the same loop as above to seek `elem` from the start
									while ( (node = ++nodeIndex && node && node[ dir ] ||
										(diff = nodeIndex = 0) || start.pop()) ) {

										if ( ( ofType ?
											node.nodeName.toLowerCase() === name :
											node.nodeType === 1 ) &&
											++diff ) {

											// Cache the index of each encountered element
											if ( useCache ) {
												outerCache = node[ expando ] || (node[ expando ] = {});

												// Support: IE <9 only
												// Defend against cloned attroperties (jQuery gh-1709)
												uniqueCache = outerCache[ node.uniqueID ] ||
													(outerCache[ node.uniqueID ] = {});

												uniqueCache[ type ] = [ dirruns, diff ];
											}

											if ( node === elem ) {
												break;
											}
										}
									}
								}
							}

							// Incorporate the offset, then check against cycle size
							diff -= last;
							return diff === first || ( diff % first === 0 && diff / first >= 0 );
						}
					};
			},

			"PSEUDO": function( pseudo, argument ) {
				// pseudo-class names are case-insensitive
				// http://www.w3.org/TR/selectors/#pseudo-classes
				// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
				// Remember that setFilters inherits from pseudos
				var args,
					fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
						Sizzle.error( "unsupported pseudo: " + pseudo );

				// The user may use createPseudo to indicate that
				// arguments are needed to create the filter function
				// just as Sizzle does
				if ( fn[ expando ] ) {
					return fn( argument );
				}

				// But maintain support for old signatures
				if ( fn.length > 1 ) {
					args = [ pseudo, pseudo, "", argument ];
					return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
						markFunction(function( seed, matches ) {
							var idx,
								matched = fn( seed, argument ),
								i = matched.length;
							while ( i-- ) {
								idx = indexOf( seed, matched[i] );
								seed[ idx ] = !( matches[ idx ] = matched[i] );
							}
						}) :
						function( elem ) {
							return fn( elem, 0, args );
						};
				}

				return fn;
			}
		},

		pseudos: {
			// Potentially complex pseudos
			"not": markFunction(function( selector ) {
				// Trim the selector passed to compile
				// to avoid treating leading and trailing
				// spaces as combinators
				var input = [],
					results = [],
					matcher = compile( selector.replace( rtrim, "$1" ) );

				return matcher[ expando ] ?
					markFunction(function( seed, matches, context, xml ) {
						var elem,
							unmatched = matcher( seed, null, xml, [] ),
							i = seed.length;

						// Match elements unmatched by `matcher`
						while ( i-- ) {
							if ( (elem = unmatched[i]) ) {
								seed[i] = !(matches[i] = elem);
							}
						}
					}) :
					function( elem, context, xml ) {
						input[0] = elem;
						matcher( input, null, xml, results );
						// Don't keep the element (issue #299)
						input[0] = null;
						return !results.pop();
					};
			}),

			"has": markFunction(function( selector ) {
				return function( elem ) {
					return Sizzle( selector, elem ).length > 0;
				};
			}),

			"contains": markFunction(function( text ) {
				text = text.replace( runescape, funescape );
				return function( elem ) {
					return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
				};
			}),

			// "Whether an element is represented by a :lang() selector
			// is based solely on the element's language value
			// being equal to the identifier C,
			// or beginning with the identifier C immediately followed by "-".
			// The matching of C against the element's language value is performed case-insensitively.
			// The identifier C does not have to be a valid language name."
			// http://www.w3.org/TR/selectors/#lang-pseudo
			"lang": markFunction( function( lang ) {
				// lang value must be a valid identifier
				if ( !ridentifier.test(lang || "") ) {
					Sizzle.error( "unsupported lang: " + lang );
				}
				lang = lang.replace( runescape, funescape ).toLowerCase();
				return function( elem ) {
					var elemLang;
					do {
						if ( (elemLang = documentIsHTML ?
							elem.lang :
							elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

							elemLang = elemLang.toLowerCase();
							return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
						}
					} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
					return false;
				};
			}),

			// Miscellaneous
			"target": function( elem ) {
				var hash = window.location && window.location.hash;
				return hash && hash.slice( 1 ) === elem.id;
			},

			"root": function( elem ) {
				return elem === docElem;
			},

			"focus": function( elem ) {
				return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
			},

			// Boolean properties
			"enabled": createDisabledPseudo( false ),
			"disabled": createDisabledPseudo( true ),

			"checked": function( elem ) {
				// In CSS3, :checked should return both checked and selected elements
				// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
				var nodeName = elem.nodeName.toLowerCase();
				return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
			},

			"selected": function( elem ) {
				// Accessing this property makes selected-by-default
				// options in Safari work properly
				if ( elem.parentNode ) {
					elem.parentNode.selectedIndex;
				}

				return elem.selected === true;
			},

			// Contents
			"empty": function( elem ) {
				// http://www.w3.org/TR/selectors/#empty-pseudo
				// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
				//   but not by others (comment: 8; processing instruction: 7; etc.)
				// nodeType < 6 works because attributes (2) do not appear as children
				for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
					if ( elem.nodeType < 6 ) {
						return false;
					}
				}
				return true;
			},

			"parent": function( elem ) {
				return !Expr.pseudos["empty"]( elem );
			},

			// Element/input types
			"header": function( elem ) {
				return rheader.test( elem.nodeName );
			},

			"input": function( elem ) {
				return rinputs.test( elem.nodeName );
			},

			"button": function( elem ) {
				var name = elem.nodeName.toLowerCase();
				return name === "input" && elem.type === "button" || name === "button";
			},

			"text": function( elem ) {
				var attr;
				return elem.nodeName.toLowerCase() === "input" &&
					elem.type === "text" &&

					// Support: IE<8
					// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
					( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
			},

			// Position-in-collection
			"first": createPositionalPseudo(function() {
				return [ 0 ];
			}),

			"last": createPositionalPseudo(function( matchIndexes, length ) {
				return [ length - 1 ];
			}),

			"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
				return [ argument < 0 ? argument + length : argument ];
			}),

			"even": createPositionalPseudo(function( matchIndexes, length ) {
				var i = 0;
				for ( ; i < length; i += 2 ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),

			"odd": createPositionalPseudo(function( matchIndexes, length ) {
				var i = 1;
				for ( ; i < length; i += 2 ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),

			"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
				var i = argument < 0 ? argument + length : argument;
				for ( ; --i >= 0; ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),

			"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
				var i = argument < 0 ? argument + length : argument;
				for ( ; ++i < length; ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			})
		}
	};

	Expr.pseudos["nth"] = Expr.pseudos["eq"];

	// Add button/input type pseudos
	for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
		Expr.pseudos[ i ] = createInputPseudo( i );
	}
	for ( i in { submit: true, reset: true } ) {
		Expr.pseudos[ i ] = createButtonPseudo( i );
	}

	// Easy API for creating new setFilters
	function setFilters() {}
	setFilters.prototype = Expr.filters = Expr.pseudos;
	Expr.setFilters = new setFilters();

	tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
		var matched, match, tokens, type,
			soFar, groups, preFilters,
			cached = tokenCache[ selector + " " ];

		if ( cached ) {
			return parseOnly ? 0 : cached.slice( 0 );
		}

		soFar = selector;
		groups = [];
		preFilters = Expr.preFilter;

		while ( soFar ) {

			// Comma and first run
			if ( !matched || (match = rcomma.exec( soFar )) ) {
				if ( match ) {
					// Don't consume trailing commas as valid
					soFar = soFar.slice( match[0].length ) || soFar;
				}
				groups.push( (tokens = []) );
			}

			matched = false;

			// Combinators
			if ( (match = rcombinators.exec( soFar )) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					// Cast descendant combinators to space
					type: match[0].replace( rtrim, " " )
				});
				soFar = soFar.slice( matched.length );
			}

			// Filters
			for ( type in Expr.filter ) {
				if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
					(match = preFilters[ type ]( match ))) ) {
					matched = match.shift();
					tokens.push({
						value: matched,
						type: type,
						matches: match
					});
					soFar = soFar.slice( matched.length );
				}
			}

			if ( !matched ) {
				break;
			}
		}

		// Return the length of the invalid excess
		// if we're just parsing
		// Otherwise, throw an error or return tokens
		return parseOnly ?
			soFar.length :
			soFar ?
				Sizzle.error( selector ) :
				// Cache the tokens
				tokenCache( selector, groups ).slice( 0 );
	};

	function toSelector( tokens ) {
		var i = 0,
			len = tokens.length,
			selector = "";
		for ( ; i < len; i++ ) {
			selector += tokens[i].value;
		}
		return selector;
	}

	function addCombinator( matcher, combinator, base ) {
		var dir = combinator.dir,
			skip = combinator.next,
			key = skip || dir,
			checkNonElements = base && key === "parentNode",
			doneName = done++;

		return combinator.first ?
			// Check against closest ancestor/preceding element
			function( elem, context, xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						return matcher( elem, context, xml );
					}
				}
			} :

			// Check against all ancestor/preceding elements
			function( elem, context, xml ) {
				var oldCache, uniqueCache, outerCache,
					newCache = [ dirruns, doneName ];

				// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
				if ( xml ) {
					while ( (elem = elem[ dir ]) ) {
						if ( elem.nodeType === 1 || checkNonElements ) {
							if ( matcher( elem, context, xml ) ) {
								return true;
							}
						}
					}
				} else {
					while ( (elem = elem[ dir ]) ) {
						if ( elem.nodeType === 1 || checkNonElements ) {
							outerCache = elem[ expando ] || (elem[ expando ] = {});

							// Support: IE <9 only
							// Defend against cloned attroperties (jQuery gh-1709)
							uniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});

							if ( skip && skip === elem.nodeName.toLowerCase() ) {
								elem = elem[ dir ] || elem;
							} else if ( (oldCache = uniqueCache[ key ]) &&
								oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

								// Assign to newCache so results back-propagate to previous elements
								return (newCache[ 2 ] = oldCache[ 2 ]);
							} else {
								// Reuse newcache so results back-propagate to previous elements
								uniqueCache[ key ] = newCache;

								// A match means we're done; a fail means we have to keep checking
								if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
									return true;
								}
							}
						}
					}
				}
			};
	}

	function elementMatcher( matchers ) {
		return matchers.length > 1 ?
			function( elem, context, xml ) {
				var i = matchers.length;
				while ( i-- ) {
					if ( !matchers[i]( elem, context, xml ) ) {
						return false;
					}
				}
				return true;
			} :
			matchers[0];
	}

	function multipleContexts( selector, contexts, results ) {
		var i = 0,
			len = contexts.length;
		for ( ; i < len; i++ ) {
			Sizzle( selector, contexts[i], results );
		}
		return results;
	}

	function condense( unmatched, map, filter, context, xml ) {
		var elem,
			newUnmatched = [],
			i = 0,
			len = unmatched.length,
			mapped = map != null;

		for ( ; i < len; i++ ) {
			if ( (elem = unmatched[i]) ) {
				if ( !filter || filter( elem, context, xml ) ) {
					newUnmatched.push( elem );
					if ( mapped ) {
						map.push( i );
					}
				}
			}
		}

		return newUnmatched;
	}

	function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
		if ( postFilter && !postFilter[ expando ] ) {
			postFilter = setMatcher( postFilter );
		}
		if ( postFinder && !postFinder[ expando ] ) {
			postFinder = setMatcher( postFinder, postSelector );
		}
		return markFunction(function( seed, results, context, xml ) {
			var temp, i, elem,
				preMap = [],
				postMap = [],
				preexisting = results.length,

				// Get initial elements from seed or context
				elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

				// Prefilter to get matcher input, preserving a map for seed-results synchronization
				matcherIn = preFilter && ( seed || !selector ) ?
					condense( elems, preMap, preFilter, context, xml ) :
					elems,

				matcherOut = matcher ?
					// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
					postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

						// ...intermediate processing is necessary
						[] :

						// ...otherwise use results directly
						results :
					matcherIn;

			// Find primary matches
			if ( matcher ) {
				matcher( matcherIn, matcherOut, context, xml );
			}

			// Apply postFilter
			if ( postFilter ) {
				temp = condense( matcherOut, postMap );
				postFilter( temp, [], context, xml );

				// Un-match failing elements by moving them back to matcherIn
				i = temp.length;
				while ( i-- ) {
					if ( (elem = temp[i]) ) {
						matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
					}
				}
			}

			if ( seed ) {
				if ( postFinder || preFilter ) {
					if ( postFinder ) {
						// Get the final matcherOut by condensing this intermediate into postFinder contexts
						temp = [];
						i = matcherOut.length;
						while ( i-- ) {
							if ( (elem = matcherOut[i]) ) {
								// Restore matcherIn since elem is not yet a final match
								temp.push( (matcherIn[i] = elem) );
							}
						}
						postFinder( null, (matcherOut = []), temp, xml );
					}

					// Move matched elements from seed to results to keep them synchronized
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) &&
							(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {

							seed[temp] = !(results[temp] = elem);
						}
					}
				}

			// Add elements to results, through postFinder if defined
			} else {
				matcherOut = condense(
					matcherOut === results ?
						matcherOut.splice( preexisting, matcherOut.length ) :
						matcherOut
				);
				if ( postFinder ) {
					postFinder( null, results, matcherOut, xml );
				} else {
					push.apply( results, matcherOut );
				}
			}
		});
	}

	function matcherFromTokens( tokens ) {
		var checkContext, matcher, j,
			len = tokens.length,
			leadingRelative = Expr.relative[ tokens[0].type ],
			implicitRelative = leadingRelative || Expr.relative[" "],
			i = leadingRelative ? 1 : 0,

			// The foundational matcher ensures that elements are reachable from top-level context(s)
			matchContext = addCombinator( function( elem ) {
				return elem === checkContext;
			}, implicitRelative, true ),
			matchAnyContext = addCombinator( function( elem ) {
				return indexOf( checkContext, elem ) > -1;
			}, implicitRelative, true ),
			matchers = [ function( elem, context, xml ) {
				var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
					(checkContext = context).nodeType ?
						matchContext( elem, context, xml ) :
						matchAnyContext( elem, context, xml ) );
				// Avoid hanging onto element (issue #299)
				checkContext = null;
				return ret;
			} ];

		for ( ; i < len; i++ ) {
			if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
				matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
			} else {
				matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

				// Return special upon seeing a positional matcher
				if ( matcher[ expando ] ) {
					// Find the next relative operator (if any) for proper handling
					j = ++i;
					for ( ; j < len; j++ ) {
						if ( Expr.relative[ tokens[j].type ] ) {
							break;
						}
					}
					return setMatcher(
						i > 1 && elementMatcher( matchers ),
						i > 1 && toSelector(
							// If the preceding token was a descendant combinator, insert an implicit any-element `*`
							tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
						).replace( rtrim, "$1" ),
						matcher,
						i < j && matcherFromTokens( tokens.slice( i, j ) ),
						j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
						j < len && toSelector( tokens )
					);
				}
				matchers.push( matcher );
			}
		}

		return elementMatcher( matchers );
	}

	function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
		var bySet = setMatchers.length > 0,
			byElement = elementMatchers.length > 0,
			superMatcher = function( seed, context, xml, results, outermost ) {
				var elem, j, matcher,
					matchedCount = 0,
					i = "0",
					unmatched = seed && [],
					setMatched = [],
					contextBackup = outermostContext,
					// We must always have either seed elements or outermost context
					elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
					// Use integer dirruns iff this is the outermost matcher
					dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
					len = elems.length;

				if ( outermost ) {
					outermostContext = context === document || context || outermost;
				}

				// Add elements passing elementMatchers directly to results
				// Support: IE<9, Safari
				// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
				for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
					if ( byElement && elem ) {
						j = 0;
						if ( !context && elem.ownerDocument !== document ) {
							setDocument( elem );
							xml = !documentIsHTML;
						}
						while ( (matcher = elementMatchers[j++]) ) {
							if ( matcher( elem, context || document, xml) ) {
								results.push( elem );
								break;
							}
						}
						if ( outermost ) {
							dirruns = dirrunsUnique;
						}
					}

					// Track unmatched elements for set filters
					if ( bySet ) {
						// They will have gone through all possible matchers
						if ( (elem = !matcher && elem) ) {
							matchedCount--;
						}

						// Lengthen the array for every element, matched or not
						if ( seed ) {
							unmatched.push( elem );
						}
					}
				}

				// `i` is now the count of elements visited above, and adding it to `matchedCount`
				// makes the latter nonnegative.
				matchedCount += i;

				// Apply set filters to unmatched elements
				// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
				// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
				// no element matchers and no seed.
				// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
				// case, which will result in a "00" `matchedCount` that differs from `i` but is also
				// numerically zero.
				if ( bySet && i !== matchedCount ) {
					j = 0;
					while ( (matcher = setMatchers[j++]) ) {
						matcher( unmatched, setMatched, context, xml );
					}

					if ( seed ) {
						// Reintegrate element matches to eliminate the need for sorting
						if ( matchedCount > 0 ) {
							while ( i-- ) {
								if ( !(unmatched[i] || setMatched[i]) ) {
									setMatched[i] = pop.call( results );
								}
							}
						}

						// Discard index placeholder values to get only actual matches
						setMatched = condense( setMatched );
					}

					// Add matches to results
					push.apply( results, setMatched );

					// Seedless set matches succeeding multiple successful matchers stipulate sorting
					if ( outermost && !seed && setMatched.length > 0 &&
						( matchedCount + setMatchers.length ) > 1 ) {

						Sizzle.uniqueSort( results );
					}
				}

				// Override manipulation of globals by nested matchers
				if ( outermost ) {
					dirruns = dirrunsUnique;
					outermostContext = contextBackup;
				}

				return unmatched;
			};

		return bySet ?
			markFunction( superMatcher ) :
			superMatcher;
	}

	compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
		var i,
			setMatchers = [],
			elementMatchers = [],
			cached = compilerCache[ selector + " " ];

		if ( !cached ) {
			// Generate a function of recursive functions that can be used to check each element
			if ( !match ) {
				match = tokenize( selector );
			}
			i = match.length;
			while ( i-- ) {
				cached = matcherFromTokens( match[i] );
				if ( cached[ expando ] ) {
					setMatchers.push( cached );
				} else {
					elementMatchers.push( cached );
				}
			}

			// Cache the compiled function
			cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

			// Save selector and tokenization
			cached.selector = selector;
		}
		return cached;
	};

	/**
	 * A low-level selection function that works with Sizzle's compiled
	 *  selector functions
	 * @param {String|Function} selector A selector or a pre-compiled
	 *  selector function built with Sizzle.compile
	 * @param {Element} context
	 * @param {Array} [results]
	 * @param {Array} [seed] A set of elements to match against
	 */
	select = Sizzle.select = function( selector, context, results, seed ) {
		var i, tokens, token, type, find,
			compiled = typeof selector === "function" && selector,
			match = !seed && tokenize( (selector = compiled.selector || selector) );

		results = results || [];

		// Try to minimize operations if there is only one selector in the list and no seed
		// (the latter of which guarantees us context)
		if ( match.length === 1 ) {

			// Reduce context if the leading compound selector is an ID
			tokens = match[0] = match[0].slice( 0 );
			if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
					support.getById && context.nodeType === 9 && documentIsHTML &&
					Expr.relative[ tokens[1].type ] ) {

				context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
				if ( !context ) {
					return results;

				// Precompiled matchers will still verify ancestry, so step up a level
				} else if ( compiled ) {
					context = context.parentNode;
				}

				selector = selector.slice( tokens.shift().value.length );
			}

			// Fetch a seed set for right-to-left matching
			i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
			while ( i-- ) {
				token = tokens[i];

				// Abort if we hit a combinator
				if ( Expr.relative[ (type = token.type) ] ) {
					break;
				}
				if ( (find = Expr.find[ type ]) ) {
					// Search, expanding context for leading sibling combinators
					if ( (seed = find(
						token.matches[0].replace( runescape, funescape ),
						rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
					)) ) {

						// If seed is empty or no tokens remain, we can return early
						tokens.splice( i, 1 );
						selector = seed.length && toSelector( tokens );
						if ( !selector ) {
							push.apply( results, seed );
							return results;
						}

						break;
					}
				}
			}
		}

		// Compile and execute a filtering function if one is not provided
		// Provide `match` to avoid retokenization if we modified the selector above
		( compiled || compile( selector, match ) )(
			seed,
			context,
			!documentIsHTML,
			results,
			!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
		);
		return results;
	};

	// One-time assignments

	// Sort stability
	support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

	// Support: Chrome 14-35+
	// Always assume duplicates if they aren't passed to the comparison function
	support.detectDuplicates = !!hasDuplicate;

	// Initialize against the default document
	setDocument();

	// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
	// Detached nodes confoundingly follow *each other*
	support.sortDetached = assert(function( el ) {
		// Should return 1, but returns 4 (following)
		return el.compareDocumentPosition( document.createElement("fieldset") ) & 1;
	});

	// Support: IE<8
	// Prevent attribute/property "interpolation"
	// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
	if ( !assert(function( el ) {
		el.innerHTML = "<a href='#'></a>";
		return el.firstChild.getAttribute("href") === "#" ;
	}) ) {
		addHandle( "type|href|height|width", function( elem, name, isXML ) {
			if ( !isXML ) {
				return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
			}
		});
	}

	// Support: IE<9
	// Use defaultValue in place of getAttribute("value")
	if ( !support.attributes || !assert(function( el ) {
		el.innerHTML = "<input/>";
		el.firstChild.setAttribute( "value", "" );
		return el.firstChild.getAttribute( "value" ) === "";
	}) ) {
		addHandle( "value", function( elem, name, isXML ) {
			if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
				return elem.defaultValue;
			}
		});
	}

	// Support: IE<9
	// Use getAttributeNode to fetch booleans when getAttribute lies
	if ( !assert(function( el ) {
		return el.getAttribute("disabled") == null;
	}) ) {
		addHandle( booleans, function( elem, name, isXML ) {
			var val;
			if ( !isXML ) {
				return elem[ name ] === true ? name.toLowerCase() :
						(val = elem.getAttributeNode( name )) && val.specified ?
						val.value :
					null;
			}
		});
	}

	return Sizzle;

	})( window );



	jQuery.find = Sizzle;
	jQuery.expr = Sizzle.selectors;

	// Deprecated
	jQuery.expr[ ":" ] = jQuery.expr.pseudos;
	jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
	jQuery.text = Sizzle.getText;
	jQuery.isXMLDoc = Sizzle.isXML;
	jQuery.contains = Sizzle.contains;
	jQuery.escapeSelector = Sizzle.escape;




	var dir = function( elem, dir, until ) {
		var matched = [],
			truncate = until !== undefined;

		while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
			if ( elem.nodeType === 1 ) {
				if ( truncate && jQuery( elem ).is( until ) ) {
					break;
				}
				matched.push( elem );
			}
		}
		return matched;
	};


	var siblings = function( n, elem ) {
		var matched = [];

		for ( ; n; n = n.nextSibling ) {
			if ( n.nodeType === 1 && n !== elem ) {
				matched.push( n );
			}
		}

		return matched;
	};


	var rneedsContext = jQuery.expr.match.needsContext;

	var rsingleTag = ( /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i );



	var risSimple = /^.[^:#\[\.,]*$/;

	// Implement the identical functionality for filter and not
	function winnow( elements, qualifier, not ) {
		if ( jQuery.isFunction( qualifier ) ) {
			return jQuery.grep( elements, function( elem, i ) {
				return !!qualifier.call( elem, i, elem ) !== not;
			} );

		}

		if ( qualifier.nodeType ) {
			return jQuery.grep( elements, function( elem ) {
				return ( elem === qualifier ) !== not;
			} );

		}

		if ( typeof qualifier === "string" ) {
			if ( risSimple.test( qualifier ) ) {
				return jQuery.filter( qualifier, elements, not );
			}

			qualifier = jQuery.filter( qualifier, elements );
		}

		return jQuery.grep( elements, function( elem ) {
			return ( indexOf.call( qualifier, elem ) > -1 ) !== not && elem.nodeType === 1;
		} );
	}

	jQuery.filter = function( expr, elems, not ) {
		var elem = elems[ 0 ];

		if ( not ) {
			expr = ":not(" + expr + ")";
		}

		return elems.length === 1 && elem.nodeType === 1 ?
			jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [] :
			jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
				return elem.nodeType === 1;
			} ) );
	};

	jQuery.fn.extend( {
		find: function( selector ) {
			var i, ret,
				len = this.length,
				self = this;

			if ( typeof selector !== "string" ) {
				return this.pushStack( jQuery( selector ).filter( function() {
					for ( i = 0; i < len; i++ ) {
						if ( jQuery.contains( self[ i ], this ) ) {
							return true;
						}
					}
				} ) );
			}

			ret = this.pushStack( [] );

			for ( i = 0; i < len; i++ ) {
				jQuery.find( selector, self[ i ], ret );
			}

			return len > 1 ? jQuery.uniqueSort( ret ) : ret;
		},
		filter: function( selector ) {
			return this.pushStack( winnow( this, selector || [], false ) );
		},
		not: function( selector ) {
			return this.pushStack( winnow( this, selector || [], true ) );
		},
		is: function( selector ) {
			return !!winnow(
				this,

				// If this is a positional/relative selector, check membership in the returned set
				// so $("p:first").is("p:last") won't return true for a doc with two "p".
				typeof selector === "string" && rneedsContext.test( selector ) ?
					jQuery( selector ) :
					selector || [],
				false
			).length;
		}
	} );


	// Initialize a jQuery object


	// A central reference to the root jQuery(document)
	var rootjQuery,

		// A simple way to check for HTML strings
		// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
		// Strict HTML recognition (#11290: must start with <)
		// Shortcut simple #id case for speed
		rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,

		init = jQuery.fn.init = function( selector, context, root ) {
			var match, elem;

			// HANDLE: $(""), $(null), $(undefined), $(false)
			if ( !selector ) {
				return this;
			}

			// Method init() accepts an alternate rootjQuery
			// so migrate can support jQuery.sub (gh-2101)
			root = root || rootjQuery;

			// Handle HTML strings
			if ( typeof selector === "string" ) {
				if ( selector[ 0 ] === "<" &&
					selector[ selector.length - 1 ] === ">" &&
					selector.length >= 3 ) {

					// Assume that strings that start and end with <> are HTML and skip the regex check
					match = [ null, selector, null ];

				} else {
					match = rquickExpr.exec( selector );
				}

				// Match html or make sure no context is specified for #id
				if ( match && ( match[ 1 ] || !context ) ) {

					// HANDLE: $(html) -> $(array)
					if ( match[ 1 ] ) {
						context = context instanceof jQuery ? context[ 0 ] : context;

						// Option to run scripts is true for back-compat
						// Intentionally let the error be thrown if parseHTML is not present
						jQuery.merge( this, jQuery.parseHTML(
							match[ 1 ],
							context && context.nodeType ? context.ownerDocument || context : document,
							true
						) );

						// HANDLE: $(html, props)
						if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
							for ( match in context ) {

								// Properties of context are called as methods if possible
								if ( jQuery.isFunction( this[ match ] ) ) {
									this[ match ]( context[ match ] );

								// ...and otherwise set as attributes
								} else {
									this.attr( match, context[ match ] );
								}
							}
						}

						return this;

					// HANDLE: $(#id)
					} else {
						elem = document.getElementById( match[ 2 ] );

						if ( elem ) {

							// Inject the element directly into the jQuery object
							this[ 0 ] = elem;
							this.length = 1;
						}
						return this;
					}

				// HANDLE: $(expr, $(...))
				} else if ( !context || context.jquery ) {
					return ( context || root ).find( selector );

				// HANDLE: $(expr, context)
				// (which is just equivalent to: $(context).find(expr)
				} else {
					return this.constructor( context ).find( selector );
				}

			// HANDLE: $(DOMElement)
			} else if ( selector.nodeType ) {
				this[ 0 ] = selector;
				this.length = 1;
				return this;

			// HANDLE: $(function)
			// Shortcut for document ready
			} else if ( jQuery.isFunction( selector ) ) {
				return root.ready !== undefined ?
					root.ready( selector ) :

					// Execute immediately if ready is not present
					selector( jQuery );
			}

			return jQuery.makeArray( selector, this );
		};

	// Give the init function the jQuery prototype for later instantiation
	init.prototype = jQuery.fn;

	// Initialize central reference
	rootjQuery = jQuery( document );


	var rparentsprev = /^(?:parents|prev(?:Until|All))/,

		// Methods guaranteed to produce a unique set when starting from a unique set
		guaranteedUnique = {
			children: true,
			contents: true,
			next: true,
			prev: true
		};

	jQuery.fn.extend( {
		has: function( target ) {
			var targets = jQuery( target, this ),
				l = targets.length;

			return this.filter( function() {
				var i = 0;
				for ( ; i < l; i++ ) {
					if ( jQuery.contains( this, targets[ i ] ) ) {
						return true;
					}
				}
			} );
		},

		closest: function( selectors, context ) {
			var cur,
				i = 0,
				l = this.length,
				matched = [],
				targets = typeof selectors !== "string" && jQuery( selectors );

			// Positional selectors never match, since there's no _selection_ context
			if ( !rneedsContext.test( selectors ) ) {
				for ( ; i < l; i++ ) {
					for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

						// Always skip document fragments
						if ( cur.nodeType < 11 && ( targets ?
							targets.index( cur ) > -1 :

							// Don't pass non-elements to Sizzle
							cur.nodeType === 1 &&
								jQuery.find.matchesSelector( cur, selectors ) ) ) {

							matched.push( cur );
							break;
						}
					}
				}
			}

			return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
		},

		// Determine the position of an element within the set
		index: function( elem ) {

			// No argument, return index in parent
			if ( !elem ) {
				return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
			}

			// Index in selector
			if ( typeof elem === "string" ) {
				return indexOf.call( jQuery( elem ), this[ 0 ] );
			}

			// Locate the position of the desired element
			return indexOf.call( this,

				// If it receives a jQuery object, the first element is used
				elem.jquery ? elem[ 0 ] : elem
			);
		},

		add: function( selector, context ) {
			return this.pushStack(
				jQuery.uniqueSort(
					jQuery.merge( this.get(), jQuery( selector, context ) )
				)
			);
		},

		addBack: function( selector ) {
			return this.add( selector == null ?
				this.prevObject : this.prevObject.filter( selector )
			);
		}
	} );

	function sibling( cur, dir ) {
		while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
		return cur;
	}

	jQuery.each( {
		parent: function( elem ) {
			var parent = elem.parentNode;
			return parent && parent.nodeType !== 11 ? parent : null;
		},
		parents: function( elem ) {
			return dir( elem, "parentNode" );
		},
		parentsUntil: function( elem, i, until ) {
			return dir( elem, "parentNode", until );
		},
		next: function( elem ) {
			return sibling( elem, "nextSibling" );
		},
		prev: function( elem ) {
			return sibling( elem, "previousSibling" );
		},
		nextAll: function( elem ) {
			return dir( elem, "nextSibling" );
		},
		prevAll: function( elem ) {
			return dir( elem, "previousSibling" );
		},
		nextUntil: function( elem, i, until ) {
			return dir( elem, "nextSibling", until );
		},
		prevUntil: function( elem, i, until ) {
			return dir( elem, "previousSibling", until );
		},
		siblings: function( elem ) {
			return siblings( ( elem.parentNode || {} ).firstChild, elem );
		},
		children: function( elem ) {
			return siblings( elem.firstChild );
		},
		contents: function( elem ) {
			return elem.contentDocument || jQuery.merge( [], elem.childNodes );
		}
	}, function( name, fn ) {
		jQuery.fn[ name ] = function( until, selector ) {
			var matched = jQuery.map( this, fn, until );

			if ( name.slice( -5 ) !== "Until" ) {
				selector = until;
			}

			if ( selector && typeof selector === "string" ) {
				matched = jQuery.filter( selector, matched );
			}

			if ( this.length > 1 ) {

				// Remove duplicates
				if ( !guaranteedUnique[ name ] ) {
					jQuery.uniqueSort( matched );
				}

				// Reverse order for parents* and prev-derivatives
				if ( rparentsprev.test( name ) ) {
					matched.reverse();
				}
			}

			return this.pushStack( matched );
		};
	} );
	var rnotwhite = ( /\S+/g );



	// Convert String-formatted options into Object-formatted ones
	function createOptions( options ) {
		var object = {};
		jQuery.each( options.match( rnotwhite ) || [], function( _, flag ) {
			object[ flag ] = true;
		} );
		return object;
	}

	/*
	 * Create a callback list using the following parameters:
	 *
	 *	options: an optional list of space-separated options that will change how
	 *			the callback list behaves or a more traditional option object
	 *
	 * By default a callback list will act like an event callback list and can be
	 * "fired" multiple times.
	 *
	 * Possible options:
	 *
	 *	once:			will ensure the callback list can only be fired once (like a Deferred)
	 *
	 *	memory:			will keep track of previous values and will call any callback added
	 *					after the list has been fired right away with the latest "memorized"
	 *					values (like a Deferred)
	 *
	 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
	 *
	 *	stopOnFalse:	interrupt callings when a callback returns false
	 *
	 */
	jQuery.Callbacks = function( options ) {

		// Convert options from String-formatted to Object-formatted if needed
		// (we check in cache first)
		options = typeof options === "string" ?
			createOptions( options ) :
			jQuery.extend( {}, options );

		var // Flag to know if list is currently firing
			firing,

			// Last fire value for non-forgettable lists
			memory,

			// Flag to know if list was already fired
			fired,

			// Flag to prevent firing
			locked,

			// Actual callback list
			list = [],

			// Queue of execution data for repeatable lists
			queue = [],

			// Index of currently firing callback (modified by add/remove as needed)
			firingIndex = -1,

			// Fire callbacks
			fire = function() {

				// Enforce single-firing
				locked = options.once;

				// Execute callbacks for all pending executions,
				// respecting firingIndex overrides and runtime changes
				fired = firing = true;
				for ( ; queue.length; firingIndex = -1 ) {
					memory = queue.shift();
					while ( ++firingIndex < list.length ) {

						// Run callback and check for early termination
						if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
							options.stopOnFalse ) {

							// Jump to end and forget the data so .add doesn't re-fire
							firingIndex = list.length;
							memory = false;
						}
					}
				}

				// Forget the data if we're done with it
				if ( !options.memory ) {
					memory = false;
				}

				firing = false;

				// Clean up if we're done firing for good
				if ( locked ) {

					// Keep an empty list if we have data for future add calls
					if ( memory ) {
						list = [];

					// Otherwise, this object is spent
					} else {
						list = "";
					}
				}
			},

			// Actual Callbacks object
			self = {

				// Add a callback or a collection of callbacks to the list
				add: function() {
					if ( list ) {

						// If we have memory from a past run, we should fire after adding
						if ( memory && !firing ) {
							firingIndex = list.length - 1;
							queue.push( memory );
						}

						( function add( args ) {
							jQuery.each( args, function( _, arg ) {
								if ( jQuery.isFunction( arg ) ) {
									if ( !options.unique || !self.has( arg ) ) {
										list.push( arg );
									}
								} else if ( arg && arg.length && jQuery.type( arg ) !== "string" ) {

									// Inspect recursively
									add( arg );
								}
							} );
						} )( arguments );

						if ( memory && !firing ) {
							fire();
						}
					}
					return this;
				},

				// Remove a callback from the list
				remove: function() {
					jQuery.each( arguments, function( _, arg ) {
						var index;
						while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
							list.splice( index, 1 );

							// Handle firing indexes
							if ( index <= firingIndex ) {
								firingIndex--;
							}
						}
					} );
					return this;
				},

				// Check if a given callback is in the list.
				// If no argument is given, return whether or not list has callbacks attached.
				has: function( fn ) {
					return fn ?
						jQuery.inArray( fn, list ) > -1 :
						list.length > 0;
				},

				// Remove all callbacks from the list
				empty: function() {
					if ( list ) {
						list = [];
					}
					return this;
				},

				// Disable .fire and .add
				// Abort any current/pending executions
				// Clear all callbacks and values
				disable: function() {
					locked = queue = [];
					list = memory = "";
					return this;
				},
				disabled: function() {
					return !list;
				},

				// Disable .fire
				// Also disable .add unless we have memory (since it would have no effect)
				// Abort any pending executions
				lock: function() {
					locked = queue = [];
					if ( !memory && !firing ) {
						list = memory = "";
					}
					return this;
				},
				locked: function() {
					return !!locked;
				},

				// Call all callbacks with the given context and arguments
				fireWith: function( context, args ) {
					if ( !locked ) {
						args = args || [];
						args = [ context, args.slice ? args.slice() : args ];
						queue.push( args );
						if ( !firing ) {
							fire();
						}
					}
					return this;
				},

				// Call all the callbacks with the given arguments
				fire: function() {
					self.fireWith( this, arguments );
					return this;
				},

				// To know if the callbacks have already been called at least once
				fired: function() {
					return !!fired;
				}
			};

		return self;
	};


	function Identity( v ) {
		return v;
	}
	function Thrower( ex ) {
		throw ex;
	}

	function adoptValue( value, resolve, reject ) {
		var method;

		try {

			// Check for promise aspect first to privilege synchronous behavior
			if ( value && jQuery.isFunction( ( method = value.promise ) ) ) {
				method.call( value ).done( resolve ).fail( reject );

			// Other thenables
			} else if ( value && jQuery.isFunction( ( method = value.then ) ) ) {
				method.call( value, resolve, reject );

			// Other non-thenables
			} else {

				// Support: Android 4.0 only
				// Strict mode functions invoked without .call/.apply get global-object context
				resolve.call( undefined, value );
			}

		// For Promises/A+, convert exceptions into rejections
		// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
		// Deferred#then to conditionally suppress rejection.
		} catch ( value ) {

			// Support: Android 4.0 only
			// Strict mode functions invoked without .call/.apply get global-object context
			reject.call( undefined, value );
		}
	}

	jQuery.extend( {

		Deferred: function( func ) {
			var tuples = [

					// action, add listener, callbacks,
					// ... .then handlers, argument index, [final state]
					[ "notify", "progress", jQuery.Callbacks( "memory" ),
						jQuery.Callbacks( "memory" ), 2 ],
					[ "resolve", "done", jQuery.Callbacks( "once memory" ),
						jQuery.Callbacks( "once memory" ), 0, "resolved" ],
					[ "reject", "fail", jQuery.Callbacks( "once memory" ),
						jQuery.Callbacks( "once memory" ), 1, "rejected" ]
				],
				state = "pending",
				promise = {
					state: function() {
						return state;
					},
					always: function() {
						deferred.done( arguments ).fail( arguments );
						return this;
					},
					"catch": function( fn ) {
						return promise.then( null, fn );
					},

					// Keep pipe for back-compat
					pipe: function( /* fnDone, fnFail, fnProgress */ ) {
						var fns = arguments;

						return jQuery.Deferred( function( newDefer ) {
							jQuery.each( tuples, function( i, tuple ) {

								// Map tuples (progress, done, fail) to arguments (done, fail, progress)
								var fn = jQuery.isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];

								// deferred.progress(function() { bind to newDefer or newDefer.notify })
								// deferred.done(function() { bind to newDefer or newDefer.resolve })
								// deferred.fail(function() { bind to newDefer or newDefer.reject })
								deferred[ tuple[ 1 ] ]( function() {
									var returned = fn && fn.apply( this, arguments );
									if ( returned && jQuery.isFunction( returned.promise ) ) {
										returned.promise()
											.progress( newDefer.notify )
											.done( newDefer.resolve )
											.fail( newDefer.reject );
									} else {
										newDefer[ tuple[ 0 ] + "With" ](
											this,
											fn ? [ returned ] : arguments
										);
									}
								} );
							} );
							fns = null;
						} ).promise();
					},
					then: function( onFulfilled, onRejected, onProgress ) {
						var maxDepth = 0;
						function resolve( depth, deferred, handler, special ) {
							return function() {
								var that = this,
									args = arguments,
									mightThrow = function() {
										var returned, then;

										// Support: Promises/A+ section 2.3.3.3.3
										// https://promisesaplus.com/#point-59
										// Ignore double-resolution attempts
										if ( depth < maxDepth ) {
											return;
										}

										returned = handler.apply( that, args );

										// Support: Promises/A+ section 2.3.1
										// https://promisesaplus.com/#point-48
										if ( returned === deferred.promise() ) {
											throw new TypeError( "Thenable self-resolution" );
										}

										// Support: Promises/A+ sections 2.3.3.1, 3.5
										// https://promisesaplus.com/#point-54
										// https://promisesaplus.com/#point-75
										// Retrieve `then` only once
										then = returned &&

											// Support: Promises/A+ section 2.3.4
											// https://promisesaplus.com/#point-64
											// Only check objects and functions for thenability
											( typeof returned === "object" ||
												typeof returned === "function" ) &&
											returned.then;

										// Handle a returned thenable
										if ( jQuery.isFunction( then ) ) {

											// Special processors (notify) just wait for resolution
											if ( special ) {
												then.call(
													returned,
													resolve( maxDepth, deferred, Identity, special ),
													resolve( maxDepth, deferred, Thrower, special )
												);

											// Normal processors (resolve) also hook into progress
											} else {

												// ...and disregard older resolution values
												maxDepth++;

												then.call(
													returned,
													resolve( maxDepth, deferred, Identity, special ),
													resolve( maxDepth, deferred, Thrower, special ),
													resolve( maxDepth, deferred, Identity,
														deferred.notifyWith )
												);
											}

										// Handle all other returned values
										} else {

											// Only substitute handlers pass on context
											// and multiple values (non-spec behavior)
											if ( handler !== Identity ) {
												that = undefined;
												args = [ returned ];
											}

											// Process the value(s)
											// Default process is resolve
											( special || deferred.resolveWith )( that, args );
										}
									},

									// Only normal processors (resolve) catch and reject exceptions
									process = special ?
										mightThrow :
										function() {
											try {
												mightThrow();
											} catch ( e ) {

												if ( jQuery.Deferred.exceptionHook ) {
													jQuery.Deferred.exceptionHook( e,
														process.stackTrace );
												}

												// Support: Promises/A+ section 2.3.3.3.4.1
												// https://promisesaplus.com/#point-61
												// Ignore post-resolution exceptions
												if ( depth + 1 >= maxDepth ) {

													// Only substitute handlers pass on context
													// and multiple values (non-spec behavior)
													if ( handler !== Thrower ) {
														that = undefined;
														args = [ e ];
													}

													deferred.rejectWith( that, args );
												}
											}
										};

								// Support: Promises/A+ section 2.3.3.3.1
								// https://promisesaplus.com/#point-57
								// Re-resolve promises immediately to dodge false rejection from
								// subsequent errors
								if ( depth ) {
									process();
								} else {

									// Call an optional hook to record the stack, in case of exception
									// since it's otherwise lost when execution goes async
									if ( jQuery.Deferred.getStackHook ) {
										process.stackTrace = jQuery.Deferred.getStackHook();
									}
									window.setTimeout( process );
								}
							};
						}

						return jQuery.Deferred( function( newDefer ) {

							// progress_handlers.add( ... )
							tuples[ 0 ][ 3 ].add(
								resolve(
									0,
									newDefer,
									jQuery.isFunction( onProgress ) ?
										onProgress :
										Identity,
									newDefer.notifyWith
								)
							);

							// fulfilled_handlers.add( ... )
							tuples[ 1 ][ 3 ].add(
								resolve(
									0,
									newDefer,
									jQuery.isFunction( onFulfilled ) ?
										onFulfilled :
										Identity
								)
							);

							// rejected_handlers.add( ... )
							tuples[ 2 ][ 3 ].add(
								resolve(
									0,
									newDefer,
									jQuery.isFunction( onRejected ) ?
										onRejected :
										Thrower
								)
							);
						} ).promise();
					},

					// Get a promise for this deferred
					// If obj is provided, the promise aspect is added to the object
					promise: function( obj ) {
						return obj != null ? jQuery.extend( obj, promise ) : promise;
					}
				},
				deferred = {};

			// Add list-specific methods
			jQuery.each( tuples, function( i, tuple ) {
				var list = tuple[ 2 ],
					stateString = tuple[ 5 ];

				// promise.progress = list.add
				// promise.done = list.add
				// promise.fail = list.add
				promise[ tuple[ 1 ] ] = list.add;

				// Handle state
				if ( stateString ) {
					list.add(
						function() {

							// state = "resolved" (i.e., fulfilled)
							// state = "rejected"
							state = stateString;
						},

						// rejected_callbacks.disable
						// fulfilled_callbacks.disable
						tuples[ 3 - i ][ 2 ].disable,

						// progress_callbacks.lock
						tuples[ 0 ][ 2 ].lock
					);
				}

				// progress_handlers.fire
				// fulfilled_handlers.fire
				// rejected_handlers.fire
				list.add( tuple[ 3 ].fire );

				// deferred.notify = function() { deferred.notifyWith(...) }
				// deferred.resolve = function() { deferred.resolveWith(...) }
				// deferred.reject = function() { deferred.rejectWith(...) }
				deferred[ tuple[ 0 ] ] = function() {
					deferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );
					return this;
				};

				// deferred.notifyWith = list.fireWith
				// deferred.resolveWith = list.fireWith
				// deferred.rejectWith = list.fireWith
				deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
			} );

			// Make the deferred a promise
			promise.promise( deferred );

			// Call given func if any
			if ( func ) {
				func.call( deferred, deferred );
			}

			// All done!
			return deferred;
		},

		// Deferred helper
		when: function( singleValue ) {
			var

				// count of uncompleted subordinates
				remaining = arguments.length,

				// count of unprocessed arguments
				i = remaining,

				// subordinate fulfillment data
				resolveContexts = Array( i ),
				resolveValues = slice.call( arguments ),

				// the master Deferred
				master = jQuery.Deferred(),

				// subordinate callback factory
				updateFunc = function( i ) {
					return function( value ) {
						resolveContexts[ i ] = this;
						resolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
						if ( !( --remaining ) ) {
							master.resolveWith( resolveContexts, resolveValues );
						}
					};
				};

			// Single- and empty arguments are adopted like Promise.resolve
			if ( remaining <= 1 ) {
				adoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject );

				// Use .then() to unwrap secondary thenables (cf. gh-3000)
				if ( master.state() === "pending" ||
					jQuery.isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {

					return master.then();
				}
			}

			// Multiple arguments are aggregated like Promise.all array elements
			while ( i-- ) {
				adoptValue( resolveValues[ i ], updateFunc( i ), master.reject );
			}

			return master.promise();
		}
	} );


	// These usually indicate a programmer mistake during development,
	// warn about them ASAP rather than swallowing them by default.
	var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

	jQuery.Deferred.exceptionHook = function( error, stack ) {

		// Support: IE 8 - 9 only
		// Console exists when dev tools are open, which can happen at any time
		if ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {
			window.console.warn( "jQuery.Deferred exception: " + error.message, error.stack, stack );
		}
	};




	jQuery.readyException = function( error ) {
		window.setTimeout( function() {
			throw error;
		} );
	};




	// The deferred used on DOM ready
	var readyList = jQuery.Deferred();

	jQuery.fn.ready = function( fn ) {

		readyList
			.then( fn )

			// Wrap jQuery.readyException in a function so that the lookup
			// happens at the time of error handling instead of callback
			// registration.
			.catch( function( error ) {
				jQuery.readyException( error );
			} );

		return this;
	};

	jQuery.extend( {

		// Is the DOM ready to be used? Set to true once it occurs.
		isReady: false,

		// A counter to track how many items to wait for before
		// the ready event fires. See #6781
		readyWait: 1,

		// Hold (or release) the ready event
		holdReady: function( hold ) {
			if ( hold ) {
				jQuery.readyWait++;
			} else {
				jQuery.ready( true );
			}
		},

		// Handle when the DOM is ready
		ready: function( wait ) {

			// Abort if there are pending holds or we're already ready
			if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
				return;
			}

			// Remember that the DOM is ready
			jQuery.isReady = true;

			// If a normal DOM Ready event fired, decrement, and wait if need be
			if ( wait !== true && --jQuery.readyWait > 0 ) {
				return;
			}

			// If there are functions bound, to execute
			readyList.resolveWith( document, [ jQuery ] );
		}
	} );

	jQuery.ready.then = readyList.then;

	// The ready event handler and self cleanup method
	function completed() {
		document.removeEventListener( "DOMContentLoaded", completed );
		window.removeEventListener( "load", completed );
		jQuery.ready();
	}

	// Catch cases where $(document).ready() is called
	// after the browser event has already occurred.
	// Support: IE <=9 - 10 only
	// Older IE sometimes signals "interactive" too soon
	if ( document.readyState === "complete" ||
		( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

		// Handle it asynchronously to allow scripts the opportunity to delay ready
		window.setTimeout( jQuery.ready );

	} else {

		// Use the handy event callback
		document.addEventListener( "DOMContentLoaded", completed );

		// A fallback to window.onload, that will always work
		window.addEventListener( "load", completed );
	}




	// Multifunctional method to get and set values of a collection
	// The value/s can optionally be executed if it's a function
	var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
		var i = 0,
			len = elems.length,
			bulk = key == null;

		// Sets many values
		if ( jQuery.type( key ) === "object" ) {
			chainable = true;
			for ( i in key ) {
				access( elems, fn, i, key[ i ], true, emptyGet, raw );
			}

		// Sets one value
		} else if ( value !== undefined ) {
			chainable = true;

			if ( !jQuery.isFunction( value ) ) {
				raw = true;
			}

			if ( bulk ) {

				// Bulk operations run against the entire set
				if ( raw ) {
					fn.call( elems, value );
					fn = null;

				// ...except when executing function values
				} else {
					bulk = fn;
					fn = function( elem, key, value ) {
						return bulk.call( jQuery( elem ), value );
					};
				}
			}

			if ( fn ) {
				for ( ; i < len; i++ ) {
					fn(
						elems[ i ], key, raw ?
						value :
						value.call( elems[ i ], i, fn( elems[ i ], key ) )
					);
				}
			}
		}

		return chainable ?
			elems :

			// Gets
			bulk ?
				fn.call( elems ) :
				len ? fn( elems[ 0 ], key ) : emptyGet;
	};
	var acceptData = function( owner ) {

		// Accepts only:
		//  - Node
		//    - Node.ELEMENT_NODE
		//    - Node.DOCUMENT_NODE
		//  - Object
		//    - Any
		return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
	};




	function Data() {
		this.expando = jQuery.expando + Data.uid++;
	}

	Data.uid = 1;

	Data.prototype = {

		cache: function( owner ) {

			// Check if the owner object already has a cache
			var value = owner[ this.expando ];

			// If not, create one
			if ( !value ) {
				value = {};

				// We can accept data for non-element nodes in modern browsers,
				// but we should not, see #8335.
				// Always return an empty object.
				if ( acceptData( owner ) ) {

					// If it is a node unlikely to be stringify-ed or looped over
					// use plain assignment
					if ( owner.nodeType ) {
						owner[ this.expando ] = value;

					// Otherwise secure it in a non-enumerable property
					// configurable must be true to allow the property to be
					// deleted when data is removed
					} else {
						Object.defineProperty( owner, this.expando, {
							value: value,
							configurable: true
						} );
					}
				}
			}

			return value;
		},
		set: function( owner, data, value ) {
			var prop,
				cache = this.cache( owner );

			// Handle: [ owner, key, value ] args
			// Always use camelCase key (gh-2257)
			if ( typeof data === "string" ) {
				cache[ jQuery.camelCase( data ) ] = value;

			// Handle: [ owner, { properties } ] args
			} else {

				// Copy the properties one-by-one to the cache object
				for ( prop in data ) {
					cache[ jQuery.camelCase( prop ) ] = data[ prop ];
				}
			}
			return cache;
		},
		get: function( owner, key ) {
			return key === undefined ?
				this.cache( owner ) :

				// Always use camelCase key (gh-2257)
				owner[ this.expando ] && owner[ this.expando ][ jQuery.camelCase( key ) ];
		},
		access: function( owner, key, value ) {

			// In cases where either:
			//
			//   1. No key was specified
			//   2. A string key was specified, but no value provided
			//
			// Take the "read" path and allow the get method to determine
			// which value to return, respectively either:
			//
			//   1. The entire cache object
			//   2. The data stored at the key
			//
			if ( key === undefined ||
					( ( key && typeof key === "string" ) && value === undefined ) ) {

				return this.get( owner, key );
			}

			// When the key is not a string, or both a key and value
			// are specified, set or extend (existing objects) with either:
			//
			//   1. An object of properties
			//   2. A key and value
			//
			this.set( owner, key, value );

			// Since the "set" path can have two possible entry points
			// return the expected data based on which path was taken[*]
			return value !== undefined ? value : key;
		},
		remove: function( owner, key ) {
			var i,
				cache = owner[ this.expando ];

			if ( cache === undefined ) {
				return;
			}

			if ( key !== undefined ) {

				// Support array or space separated string of keys
				if ( jQuery.isArray( key ) ) {

					// If key is an array of keys...
					// We always set camelCase keys, so remove that.
					key = key.map( jQuery.camelCase );
				} else {
					key = jQuery.camelCase( key );

					// If a key with the spaces exists, use it.
					// Otherwise, create an array by matching non-whitespace
					key = key in cache ?
						[ key ] :
						( key.match( rnotwhite ) || [] );
				}

				i = key.length;

				while ( i-- ) {
					delete cache[ key[ i ] ];
				}
			}

			// Remove the expando if there's no more data
			if ( key === undefined || jQuery.isEmptyObject( cache ) ) {

				// Support: Chrome <=35 - 45
				// Webkit & Blink performance suffers when deleting properties
				// from DOM nodes, so set to undefined instead
				// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
				if ( owner.nodeType ) {
					owner[ this.expando ] = undefined;
				} else {
					delete owner[ this.expando ];
				}
			}
		},
		hasData: function( owner ) {
			var cache = owner[ this.expando ];
			return cache !== undefined && !jQuery.isEmptyObject( cache );
		}
	};
	var dataPriv = new Data();

	var dataUser = new Data();



	//	Implementation Summary
	//
	//	1. Enforce API surface and semantic compatibility with 1.9.x branch
	//	2. Improve the module's maintainability by reducing the storage
	//		paths to a single mechanism.
	//	3. Use the same single mechanism to support "private" and "user" data.
	//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
	//	5. Avoid exposing implementation details on user objects (eg. expando properties)
	//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

	var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
		rmultiDash = /[A-Z]/g;

	function dataAttr( elem, key, data ) {
		var name;

		// If nothing was found internally, try to fetch any
		// data from the HTML5 data-* attribute
		if ( data === undefined && elem.nodeType === 1 ) {
			name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
			data = elem.getAttribute( name );

			if ( typeof data === "string" ) {
				try {
					data = data === "true" ? true :
						data === "false" ? false :
						data === "null" ? null :

						// Only convert to a number if it doesn't change the string
						+data + "" === data ? +data :
						rbrace.test( data ) ? JSON.parse( data ) :
						data;
				} catch ( e ) {}

				// Make sure we set the data so it isn't changed later
				dataUser.set( elem, key, data );
			} else {
				data = undefined;
			}
		}
		return data;
	}

	jQuery.extend( {
		hasData: function( elem ) {
			return dataUser.hasData( elem ) || dataPriv.hasData( elem );
		},

		data: function( elem, name, data ) {
			return dataUser.access( elem, name, data );
		},

		removeData: function( elem, name ) {
			dataUser.remove( elem, name );
		},

		// TODO: Now that all calls to _data and _removeData have been replaced
		// with direct calls to dataPriv methods, these can be deprecated.
		_data: function( elem, name, data ) {
			return dataPriv.access( elem, name, data );
		},

		_removeData: function( elem, name ) {
			dataPriv.remove( elem, name );
		}
	} );

	jQuery.fn.extend( {
		data: function( key, value ) {
			var i, name, data,
				elem = this[ 0 ],
				attrs = elem && elem.attributes;

			// Gets all values
			if ( key === undefined ) {
				if ( this.length ) {
					data = dataUser.get( elem );

					if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
						i = attrs.length;
						while ( i-- ) {

							// Support: IE 11 only
							// The attrs elements can be null (#14894)
							if ( attrs[ i ] ) {
								name = attrs[ i ].name;
								if ( name.indexOf( "data-" ) === 0 ) {
									name = jQuery.camelCase( name.slice( 5 ) );
									dataAttr( elem, name, data[ name ] );
								}
							}
						}
						dataPriv.set( elem, "hasDataAttrs", true );
					}
				}

				return data;
			}

			// Sets multiple values
			if ( typeof key === "object" ) {
				return this.each( function() {
					dataUser.set( this, key );
				} );
			}

			return access( this, function( value ) {
				var data;

				// The calling jQuery object (element matches) is not empty
				// (and therefore has an element appears at this[ 0 ]) and the
				// `value` parameter was not undefined. An empty jQuery object
				// will result in `undefined` for elem = this[ 0 ] which will
				// throw an exception if an attempt to read a data cache is made.
				if ( elem && value === undefined ) {

					// Attempt to get data from the cache
					// The key will always be camelCased in Data
					data = dataUser.get( elem, key );
					if ( data !== undefined ) {
						return data;
					}

					// Attempt to "discover" the data in
					// HTML5 custom data-* attrs
					data = dataAttr( elem, key );
					if ( data !== undefined ) {
						return data;
					}

					// We tried really hard, but the data doesn't exist.
					return;
				}

				// Set the data...
				this.each( function() {

					// We always store the camelCased key
					dataUser.set( this, key, value );
				} );
			}, null, value, arguments.length > 1, null, true );
		},

		removeData: function( key ) {
			return this.each( function() {
				dataUser.remove( this, key );
			} );
		}
	} );


	jQuery.extend( {
		queue: function( elem, type, data ) {
			var queue;

			if ( elem ) {
				type = ( type || "fx" ) + "queue";
				queue = dataPriv.get( elem, type );

				// Speed up dequeue by getting out quickly if this is just a lookup
				if ( data ) {
					if ( !queue || jQuery.isArray( data ) ) {
						queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
					} else {
						queue.push( data );
					}
				}
				return queue || [];
			}
		},

		dequeue: function( elem, type ) {
			type = type || "fx";

			var queue = jQuery.queue( elem, type ),
				startLength = queue.length,
				fn = queue.shift(),
				hooks = jQuery._queueHooks( elem, type ),
				next = function() {
					jQuery.dequeue( elem, type );
				};

			// If the fx queue is dequeued, always remove the progress sentinel
			if ( fn === "inprogress" ) {
				fn = queue.shift();
				startLength--;
			}

			if ( fn ) {

				// Add a progress sentinel to prevent the fx queue from being
				// automatically dequeued
				if ( type === "fx" ) {
					queue.unshift( "inprogress" );
				}

				// Clear up the last queue stop function
				delete hooks.stop;
				fn.call( elem, next, hooks );
			}

			if ( !startLength && hooks ) {
				hooks.empty.fire();
			}
		},

		// Not public - generate a queueHooks object, or return the current one
		_queueHooks: function( elem, type ) {
			var key = type + "queueHooks";
			return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
				empty: jQuery.Callbacks( "once memory" ).add( function() {
					dataPriv.remove( elem, [ type + "queue", key ] );
				} )
			} );
		}
	} );

	jQuery.fn.extend( {
		queue: function( type, data ) {
			var setter = 2;

			if ( typeof type !== "string" ) {
				data = type;
				type = "fx";
				setter--;
			}

			if ( arguments.length < setter ) {
				return jQuery.queue( this[ 0 ], type );
			}

			return data === undefined ?
				this :
				this.each( function() {
					var queue = jQuery.queue( this, type, data );

					// Ensure a hooks for this queue
					jQuery._queueHooks( this, type );

					if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
						jQuery.dequeue( this, type );
					}
				} );
		},
		dequeue: function( type ) {
			return this.each( function() {
				jQuery.dequeue( this, type );
			} );
		},
		clearQueue: function( type ) {
			return this.queue( type || "fx", [] );
		},

		// Get a promise resolved when queues of a certain type
		// are emptied (fx is the type by default)
		promise: function( type, obj ) {
			var tmp,
				count = 1,
				defer = jQuery.Deferred(),
				elements = this,
				i = this.length,
				resolve = function() {
					if ( !( --count ) ) {
						defer.resolveWith( elements, [ elements ] );
					}
				};

			if ( typeof type !== "string" ) {
				obj = type;
				type = undefined;
			}
			type = type || "fx";

			while ( i-- ) {
				tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
				if ( tmp && tmp.empty ) {
					count++;
					tmp.empty.add( resolve );
				}
			}
			resolve();
			return defer.promise( obj );
		}
	} );
	var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

	var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );


	var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

	var isHiddenWithinTree = function( elem, el ) {

			// isHiddenWithinTree might be called from jQuery#filter function;
			// in that case, element will be second argument
			elem = el || elem;

			// Inline style trumps all
			return elem.style.display === "none" ||
				elem.style.display === "" &&

				// Otherwise, check computed style
				// Support: Firefox <=43 - 45
				// Disconnected elements can have computed display: none, so first confirm that elem is
				// in the document.
				jQuery.contains( elem.ownerDocument, elem ) &&

				jQuery.css( elem, "display" ) === "none";
		};

	var swap = function( elem, options, callback, args ) {
		var ret, name,
			old = {};

		// Remember the old values, and insert the new ones
		for ( name in options ) {
			old[ name ] = elem.style[ name ];
			elem.style[ name ] = options[ name ];
		}

		ret = callback.apply( elem, args || [] );

		// Revert the old values
		for ( name in options ) {
			elem.style[ name ] = old[ name ];
		}

		return ret;
	};




	function adjustCSS( elem, prop, valueParts, tween ) {
		var adjusted,
			scale = 1,
			maxIterations = 20,
			currentValue = tween ?
				function() {
					return tween.cur();
				} :
				function() {
					return jQuery.css( elem, prop, "" );
				},
			initial = currentValue(),
			unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

			// Starting value computation is required for potential unit mismatches
			initialInUnit = ( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
				rcssNum.exec( jQuery.css( elem, prop ) );

		if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

			// Trust units reported by jQuery.css
			unit = unit || initialInUnit[ 3 ];

			// Make sure we update the tween properties later on
			valueParts = valueParts || [];

			// Iteratively approximate from a nonzero starting point
			initialInUnit = +initial || 1;

			do {

				// If previous iteration zeroed out, double until we get *something*.
				// Use string for doubling so we don't accidentally see scale as unchanged below
				scale = scale || ".5";

				// Adjust and apply
				initialInUnit = initialInUnit / scale;
				jQuery.style( elem, prop, initialInUnit + unit );

			// Update scale, tolerating zero or NaN from tween.cur()
			// Break the loop if scale is unchanged or perfect, or if we've just had enough.
			} while (
				scale !== ( scale = currentValue() / initial ) && scale !== 1 && --maxIterations
			);
		}

		if ( valueParts ) {
			initialInUnit = +initialInUnit || +initial || 0;

			// Apply relative offset (+=/-=) if specified
			adjusted = valueParts[ 1 ] ?
				initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
				+valueParts[ 2 ];
			if ( tween ) {
				tween.unit = unit;
				tween.start = initialInUnit;
				tween.end = adjusted;
			}
		}
		return adjusted;
	}


	var defaultDisplayMap = {};

	function getDefaultDisplay( elem ) {
		var temp,
			doc = elem.ownerDocument,
			nodeName = elem.nodeName,
			display = defaultDisplayMap[ nodeName ];

		if ( display ) {
			return display;
		}

		temp = doc.body.appendChild( doc.createElement( nodeName ) ),
		display = jQuery.css( temp, "display" );

		temp.parentNode.removeChild( temp );

		if ( display === "none" ) {
			display = "block";
		}
		defaultDisplayMap[ nodeName ] = display;

		return display;
	}

	function showHide( elements, show ) {
		var display, elem,
			values = [],
			index = 0,
			length = elements.length;

		// Determine new display value for elements that need to change
		for ( ; index < length; index++ ) {
			elem = elements[ index ];
			if ( !elem.style ) {
				continue;
			}

			display = elem.style.display;
			if ( show ) {

				// Since we force visibility upon cascade-hidden elements, an immediate (and slow)
				// check is required in this first loop unless we have a nonempty display value (either
				// inline or about-to-be-restored)
				if ( display === "none" ) {
					values[ index ] = dataPriv.get( elem, "display" ) || null;
					if ( !values[ index ] ) {
						elem.style.display = "";
					}
				}
				if ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {
					values[ index ] = getDefaultDisplay( elem );
				}
			} else {
				if ( display !== "none" ) {
					values[ index ] = "none";

					// Remember what we're overwriting
					dataPriv.set( elem, "display", display );
				}
			}
		}

		// Set the display of the elements in a second loop to avoid constant reflow
		for ( index = 0; index < length; index++ ) {
			if ( values[ index ] != null ) {
				elements[ index ].style.display = values[ index ];
			}
		}

		return elements;
	}

	jQuery.fn.extend( {
		show: function() {
			return showHide( this, true );
		},
		hide: function() {
			return showHide( this );
		},
		toggle: function( state ) {
			if ( typeof state === "boolean" ) {
				return state ? this.show() : this.hide();
			}

			return this.each( function() {
				if ( isHiddenWithinTree( this ) ) {
					jQuery( this ).show();
				} else {
					jQuery( this ).hide();
				}
			} );
		}
	} );
	var rcheckableType = ( /^(?:checkbox|radio)$/i );

	var rtagName = ( /<([a-z][^\/\0>\x20\t\r\n\f]+)/i );

	var rscriptType = ( /^$|\/(?:java|ecma)script/i );



	// We have to close these tags to support XHTML (#13200)
	var wrapMap = {

		// Support: IE <=9 only
		option: [ 1, "<select multiple='multiple'>", "</select>" ],

		// XHTML parsers do not magically insert elements in the
		// same way that tag soup parsers do. So we cannot shorten
		// this by omitting <tbody> or other required elements.
		thead: [ 1, "<table>", "</table>" ],
		col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
		tr: [ 2, "<table><tbody>", "</tbody></table>" ],
		td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

		_default: [ 0, "", "" ]
	};

	// Support: IE <=9 only
	wrapMap.optgroup = wrapMap.option;

	wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
	wrapMap.th = wrapMap.td;


	function getAll( context, tag ) {

		// Support: IE <=9 - 11 only
		// Use typeof to avoid zero-argument method invocation on host objects (#15151)
		var ret = typeof context.getElementsByTagName !== "undefined" ?
				context.getElementsByTagName( tag || "*" ) :
				typeof context.querySelectorAll !== "undefined" ?
					context.querySelectorAll( tag || "*" ) :
				[];

		return tag === undefined || tag && jQuery.nodeName( context, tag ) ?
			jQuery.merge( [ context ], ret ) :
			ret;
	}


	// Mark scripts as having already been evaluated
	function setGlobalEval( elems, refElements ) {
		var i = 0,
			l = elems.length;

		for ( ; i < l; i++ ) {
			dataPriv.set(
				elems[ i ],
				"globalEval",
				!refElements || dataPriv.get( refElements[ i ], "globalEval" )
			);
		}
	}


	var rhtml = /<|&#?\w+;/;

	function buildFragment( elems, context, scripts, selection, ignored ) {
		var elem, tmp, tag, wrap, contains, j,
			fragment = context.createDocumentFragment(),
			nodes = [],
			i = 0,
			l = elems.length;

		for ( ; i < l; i++ ) {
			elem = elems[ i ];

			if ( elem || elem === 0 ) {

				// Add nodes directly
				if ( jQuery.type( elem ) === "object" ) {

					// Support: Android <=4.0 only, PhantomJS 1 only
					// push.apply(_, arraylike) throws on ancient WebKit
					jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

				// Convert non-html into a text node
				} else if ( !rhtml.test( elem ) ) {
					nodes.push( context.createTextNode( elem ) );

				// Convert html into DOM nodes
				} else {
					tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

					// Deserialize a standard representation
					tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
					wrap = wrapMap[ tag ] || wrapMap._default;
					tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

					// Descend through wrappers to the right content
					j = wrap[ 0 ];
					while ( j-- ) {
						tmp = tmp.lastChild;
					}

					// Support: Android <=4.0 only, PhantomJS 1 only
					// push.apply(_, arraylike) throws on ancient WebKit
					jQuery.merge( nodes, tmp.childNodes );

					// Remember the top-level container
					tmp = fragment.firstChild;

					// Ensure the created nodes are orphaned (#12392)
					tmp.textContent = "";
				}
			}
		}

		// Remove wrapper from fragment
		fragment.textContent = "";

		i = 0;
		while ( ( elem = nodes[ i++ ] ) ) {

			// Skip elements already in the context collection (trac-4087)
			if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
				if ( ignored ) {
					ignored.push( elem );
				}
				continue;
			}

			contains = jQuery.contains( elem.ownerDocument, elem );

			// Append to fragment
			tmp = getAll( fragment.appendChild( elem ), "script" );

			// Preserve script evaluation history
			if ( contains ) {
				setGlobalEval( tmp );
			}

			// Capture executables
			if ( scripts ) {
				j = 0;
				while ( ( elem = tmp[ j++ ] ) ) {
					if ( rscriptType.test( elem.type || "" ) ) {
						scripts.push( elem );
					}
				}
			}
		}

		return fragment;
	}


	( function() {
		var fragment = document.createDocumentFragment(),
			div = fragment.appendChild( document.createElement( "div" ) ),
			input = document.createElement( "input" );

		// Support: Android 4.0 - 4.3 only
		// Check state lost if the name is set (#11217)
		// Support: Windows Web Apps (WWA)
		// `name` and `type` must use .setAttribute for WWA (#14901)
		input.setAttribute( "type", "radio" );
		input.setAttribute( "checked", "checked" );
		input.setAttribute( "name", "t" );

		div.appendChild( input );

		// Support: Android <=4.1 only
		// Older WebKit doesn't clone checked state correctly in fragments
		support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

		// Support: IE <=11 only
		// Make sure textarea (and checkbox) defaultValue is properly cloned
		div.innerHTML = "<textarea>x</textarea>";
		support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
	} )();
	var documentElement = document.documentElement;



	var
		rkeyEvent = /^key/,
		rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
		rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

	function returnTrue() {
		return true;
	}

	function returnFalse() {
		return false;
	}

	// Support: IE <=9 only
	// See #13393 for more info
	function safeActiveElement() {
		try {
			return document.activeElement;
		} catch ( err ) { }
	}

	function on( elem, types, selector, data, fn, one ) {
		var origFn, type;

		// Types can be a map of types/handlers
		if ( typeof types === "object" ) {

			// ( types-Object, selector, data )
			if ( typeof selector !== "string" ) {

				// ( types-Object, data )
				data = data || selector;
				selector = undefined;
			}
			for ( type in types ) {
				on( elem, type, selector, data, types[ type ], one );
			}
			return elem;
		}

		if ( data == null && fn == null ) {

			// ( types, fn )
			fn = selector;
			data = selector = undefined;
		} else if ( fn == null ) {
			if ( typeof selector === "string" ) {

				// ( types, selector, fn )
				fn = data;
				data = undefined;
			} else {

				// ( types, data, fn )
				fn = data;
				data = selector;
				selector = undefined;
			}
		}
		if ( fn === false ) {
			fn = returnFalse;
		} else if ( !fn ) {
			return elem;
		}

		if ( one === 1 ) {
			origFn = fn;
			fn = function( event ) {

				// Can use an empty set, since event contains the info
				jQuery().off( event );
				return origFn.apply( this, arguments );
			};

			// Use same guid so caller can remove using origFn
			fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
		}
		return elem.each( function() {
			jQuery.event.add( this, types, fn, data, selector );
		} );
	}

	/*
	 * Helper functions for managing events -- not part of the public interface.
	 * Props to Dean Edwards' addEvent library for many of the ideas.
	 */
	jQuery.event = {

		global: {},

		add: function( elem, types, handler, data, selector ) {

			var handleObjIn, eventHandle, tmp,
				events, t, handleObj,
				special, handlers, type, namespaces, origType,
				elemData = dataPriv.get( elem );

			// Don't attach events to noData or text/comment nodes (but allow plain objects)
			if ( !elemData ) {
				return;
			}

			// Caller can pass in an object of custom data in lieu of the handler
			if ( handler.handler ) {
				handleObjIn = handler;
				handler = handleObjIn.handler;
				selector = handleObjIn.selector;
			}

			// Ensure that invalid selectors throw exceptions at attach time
			// Evaluate against documentElement in case elem is a non-element node (e.g., document)
			if ( selector ) {
				jQuery.find.matchesSelector( documentElement, selector );
			}

			// Make sure that the handler has a unique ID, used to find/remove it later
			if ( !handler.guid ) {
				handler.guid = jQuery.guid++;
			}

			// Init the element's event structure and main handler, if this is the first
			if ( !( events = elemData.events ) ) {
				events = elemData.events = {};
			}
			if ( !( eventHandle = elemData.handle ) ) {
				eventHandle = elemData.handle = function( e ) {

					// Discard the second event of a jQuery.event.trigger() and
					// when an event is called after a page has unloaded
					return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
						jQuery.event.dispatch.apply( elem, arguments ) : undefined;
				};
			}

			// Handle multiple events separated by a space
			types = ( types || "" ).match( rnotwhite ) || [ "" ];
			t = types.length;
			while ( t-- ) {
				tmp = rtypenamespace.exec( types[ t ] ) || [];
				type = origType = tmp[ 1 ];
				namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

				// There *must* be a type, no attaching namespace-only handlers
				if ( !type ) {
					continue;
				}

				// If event changes its type, use the special event handlers for the changed type
				special = jQuery.event.special[ type ] || {};

				// If selector defined, determine special event api type, otherwise given type
				type = ( selector ? special.delegateType : special.bindType ) || type;

				// Update special based on newly reset type
				special = jQuery.event.special[ type ] || {};

				// handleObj is passed to all event handlers
				handleObj = jQuery.extend( {
					type: type,
					origType: origType,
					data: data,
					handler: handler,
					guid: handler.guid,
					selector: selector,
					needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
					namespace: namespaces.join( "." )
				}, handleObjIn );

				// Init the event handler queue if we're the first
				if ( !( handlers = events[ type ] ) ) {
					handlers = events[ type ] = [];
					handlers.delegateCount = 0;

					// Only use addEventListener if the special events handler returns false
					if ( !special.setup ||
						special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

						if ( elem.addEventListener ) {
							elem.addEventListener( type, eventHandle );
						}
					}
				}

				if ( special.add ) {
					special.add.call( elem, handleObj );

					if ( !handleObj.handler.guid ) {
						handleObj.handler.guid = handler.guid;
					}
				}

				// Add to the element's handler list, delegates in front
				if ( selector ) {
					handlers.splice( handlers.delegateCount++, 0, handleObj );
				} else {
					handlers.push( handleObj );
				}

				// Keep track of which events have ever been used, for event optimization
				jQuery.event.global[ type ] = true;
			}

		},

		// Detach an event or set of events from an element
		remove: function( elem, types, handler, selector, mappedTypes ) {

			var j, origCount, tmp,
				events, t, handleObj,
				special, handlers, type, namespaces, origType,
				elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );

			if ( !elemData || !( events = elemData.events ) ) {
				return;
			}

			// Once for each type.namespace in types; type may be omitted
			types = ( types || "" ).match( rnotwhite ) || [ "" ];
			t = types.length;
			while ( t-- ) {
				tmp = rtypenamespace.exec( types[ t ] ) || [];
				type = origType = tmp[ 1 ];
				namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

				// Unbind all events (on this namespace, if provided) for the element
				if ( !type ) {
					for ( type in events ) {
						jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
					}
					continue;
				}

				special = jQuery.event.special[ type ] || {};
				type = ( selector ? special.delegateType : special.bindType ) || type;
				handlers = events[ type ] || [];
				tmp = tmp[ 2 ] &&
					new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

				// Remove matching events
				origCount = j = handlers.length;
				while ( j-- ) {
					handleObj = handlers[ j ];

					if ( ( mappedTypes || origType === handleObj.origType ) &&
						( !handler || handler.guid === handleObj.guid ) &&
						( !tmp || tmp.test( handleObj.namespace ) ) &&
						( !selector || selector === handleObj.selector ||
							selector === "**" && handleObj.selector ) ) {
						handlers.splice( j, 1 );

						if ( handleObj.selector ) {
							handlers.delegateCount--;
						}
						if ( special.remove ) {
							special.remove.call( elem, handleObj );
						}
					}
				}

				// Remove generic event handler if we removed something and no more handlers exist
				// (avoids potential for endless recursion during removal of special event handlers)
				if ( origCount && !handlers.length ) {
					if ( !special.teardown ||
						special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

						jQuery.removeEvent( elem, type, elemData.handle );
					}

					delete events[ type ];
				}
			}

			// Remove data and the expando if it's no longer used
			if ( jQuery.isEmptyObject( events ) ) {
				dataPriv.remove( elem, "handle events" );
			}
		},

		dispatch: function( nativeEvent ) {

			// Make a writable jQuery.Event from the native event object
			var event = jQuery.event.fix( nativeEvent );

			var i, j, ret, matched, handleObj, handlerQueue,
				args = new Array( arguments.length ),
				handlers = ( dataPriv.get( this, "events" ) || {} )[ event.type ] || [],
				special = jQuery.event.special[ event.type ] || {};

			// Use the fix-ed jQuery.Event rather than the (read-only) native event
			args[ 0 ] = event;

			for ( i = 1; i < arguments.length; i++ ) {
				args[ i ] = arguments[ i ];
			}

			event.delegateTarget = this;

			// Call the preDispatch hook for the mapped type, and let it bail if desired
			if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
				return;
			}

			// Determine handlers
			handlerQueue = jQuery.event.handlers.call( this, event, handlers );

			// Run delegates first; they may want to stop propagation beneath us
			i = 0;
			while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
				event.currentTarget = matched.elem;

				j = 0;
				while ( ( handleObj = matched.handlers[ j++ ] ) &&
					!event.isImmediatePropagationStopped() ) {

					// Triggered event must either 1) have no namespace, or 2) have namespace(s)
					// a subset or equal to those in the bound event (both can have no namespace).
					if ( !event.rnamespace || event.rnamespace.test( handleObj.namespace ) ) {

						event.handleObj = handleObj;
						event.data = handleObj.data;

						ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
							handleObj.handler ).apply( matched.elem, args );

						if ( ret !== undefined ) {
							if ( ( event.result = ret ) === false ) {
								event.preventDefault();
								event.stopPropagation();
							}
						}
					}
				}
			}

			// Call the postDispatch hook for the mapped type
			if ( special.postDispatch ) {
				special.postDispatch.call( this, event );
			}

			return event.result;
		},

		handlers: function( event, handlers ) {
			var i, matches, sel, handleObj,
				handlerQueue = [],
				delegateCount = handlers.delegateCount,
				cur = event.target;

			// Support: IE <=9
			// Find delegate handlers
			// Black-hole SVG <use> instance trees (#13180)
			//
			// Support: Firefox <=42
			// Avoid non-left-click in FF but don't block IE radio events (#3861, gh-2343)
			if ( delegateCount && cur.nodeType &&
				( event.type !== "click" || isNaN( event.button ) || event.button < 1 ) ) {

				for ( ; cur !== this; cur = cur.parentNode || this ) {

					// Don't check non-elements (#13208)
					// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
					if ( cur.nodeType === 1 && ( cur.disabled !== true || event.type !== "click" ) ) {
						matches = [];
						for ( i = 0; i < delegateCount; i++ ) {
							handleObj = handlers[ i ];

							// Don't conflict with Object.prototype properties (#13203)
							sel = handleObj.selector + " ";

							if ( matches[ sel ] === undefined ) {
								matches[ sel ] = handleObj.needsContext ?
									jQuery( sel, this ).index( cur ) > -1 :
									jQuery.find( sel, this, null, [ cur ] ).length;
							}
							if ( matches[ sel ] ) {
								matches.push( handleObj );
							}
						}
						if ( matches.length ) {
							handlerQueue.push( { elem: cur, handlers: matches } );
						}
					}
				}
			}

			// Add the remaining (directly-bound) handlers
			if ( delegateCount < handlers.length ) {
				handlerQueue.push( { elem: this, handlers: handlers.slice( delegateCount ) } );
			}

			return handlerQueue;
		},

		addProp: function( name, hook ) {
			Object.defineProperty( jQuery.Event.prototype, name, {
				enumerable: true,
				configurable: true,

				get: jQuery.isFunction( hook ) ?
					function() {
						if ( this.originalEvent ) {
								return hook( this.originalEvent );
						}
					} :
					function() {
						if ( this.originalEvent ) {
								return this.originalEvent[ name ];
						}
					},

				set: function( value ) {
					Object.defineProperty( this, name, {
						enumerable: true,
						configurable: true,
						writable: true,
						value: value
					} );
				}
			} );
		},

		fix: function( originalEvent ) {
			return originalEvent[ jQuery.expando ] ?
				originalEvent :
				new jQuery.Event( originalEvent );
		},

		special: {
			load: {

				// Prevent triggered image.load events from bubbling to window.load
				noBubble: true
			},
			focus: {

				// Fire native event if possible so blur/focus sequence is correct
				trigger: function() {
					if ( this !== safeActiveElement() && this.focus ) {
						this.focus();
						return false;
					}
				},
				delegateType: "focusin"
			},
			blur: {
				trigger: function() {
					if ( this === safeActiveElement() && this.blur ) {
						this.blur();
						return false;
					}
				},
				delegateType: "focusout"
			},
			click: {

				// For checkbox, fire native event so checked state will be right
				trigger: function() {
					if ( this.type === "checkbox" && this.click && jQuery.nodeName( this, "input" ) ) {
						this.click();
						return false;
					}
				},

				// For cross-browser consistency, don't fire native .click() on links
				_default: function( event ) {
					return jQuery.nodeName( event.target, "a" );
				}
			},

			beforeunload: {
				postDispatch: function( event ) {

					// Support: Firefox 20+
					// Firefox doesn't alert if the returnValue field is not set.
					if ( event.result !== undefined && event.originalEvent ) {
						event.originalEvent.returnValue = event.result;
					}
				}
			}
		}
	};

	jQuery.removeEvent = function( elem, type, handle ) {

		// This "if" is needed for plain objects
		if ( elem.removeEventListener ) {
			elem.removeEventListener( type, handle );
		}
	};

	jQuery.Event = function( src, props ) {

		// Allow instantiation without the 'new' keyword
		if ( !( this instanceof jQuery.Event ) ) {
			return new jQuery.Event( src, props );
		}

		// Event object
		if ( src && src.type ) {
			this.originalEvent = src;
			this.type = src.type;

			// Events bubbling up the document may have been marked as prevented
			// by a handler lower down the tree; reflect the correct value.
			this.isDefaultPrevented = src.defaultPrevented ||
					src.defaultPrevented === undefined &&

					// Support: Android <=2.3 only
					src.returnValue === false ?
				returnTrue :
				returnFalse;

			// Create target properties
			// Support: Safari <=6 - 7 only
			// Target should not be a text node (#504, #13143)
			this.target = ( src.target && src.target.nodeType === 3 ) ?
				src.target.parentNode :
				src.target;

			this.currentTarget = src.currentTarget;
			this.relatedTarget = src.relatedTarget;

		// Event type
		} else {
			this.type = src;
		}

		// Put explicitly provided properties onto the event object
		if ( props ) {
			jQuery.extend( this, props );
		}

		// Create a timestamp if incoming event doesn't have one
		this.timeStamp = src && src.timeStamp || jQuery.now();

		// Mark it as fixed
		this[ jQuery.expando ] = true;
	};

	// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
	// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
	jQuery.Event.prototype = {
		constructor: jQuery.Event,
		isDefaultPrevented: returnFalse,
		isPropagationStopped: returnFalse,
		isImmediatePropagationStopped: returnFalse,
		isSimulated: false,

		preventDefault: function() {
			var e = this.originalEvent;

			this.isDefaultPrevented = returnTrue;

			if ( e && !this.isSimulated ) {
				e.preventDefault();
			}
		},
		stopPropagation: function() {
			var e = this.originalEvent;

			this.isPropagationStopped = returnTrue;

			if ( e && !this.isSimulated ) {
				e.stopPropagation();
			}
		},
		stopImmediatePropagation: function() {
			var e = this.originalEvent;

			this.isImmediatePropagationStopped = returnTrue;

			if ( e && !this.isSimulated ) {
				e.stopImmediatePropagation();
			}

			this.stopPropagation();
		}
	};

	// Includes all common event props including KeyEvent and MouseEvent specific props
	jQuery.each( {
		altKey: true,
		bubbles: true,
		cancelable: true,
		changedTouches: true,
		ctrlKey: true,
		detail: true,
		eventPhase: true,
		metaKey: true,
		pageX: true,
		pageY: true,
		shiftKey: true,
		view: true,
		"char": true,
		charCode: true,
		key: true,
		keyCode: true,
		button: true,
		buttons: true,
		clientX: true,
		clientY: true,
		offsetX: true,
		offsetY: true,
		pointerId: true,
		pointerType: true,
		screenX: true,
		screenY: true,
		targetTouches: true,
		toElement: true,
		touches: true,

		which: function( event ) {
			var button = event.button;

			// Add which for key events
			if ( event.which == null && rkeyEvent.test( event.type ) ) {
				return event.charCode != null ? event.charCode : event.keyCode;
			}

			// Add which for click: 1 === left; 2 === middle; 3 === right
			if ( !event.which && button !== undefined && rmouseEvent.test( event.type ) ) {
				return ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
			}

			return event.which;
		}
	}, jQuery.event.addProp );

	// Create mouseenter/leave events using mouseover/out and event-time checks
	// so that event delegation works in jQuery.
	// Do the same for pointerenter/pointerleave and pointerover/pointerout
	//
	// Support: Safari 7 only
	// Safari sends mouseenter too often; see:
	// https://bugs.chromium.org/p/chromium/issues/detail?id=470258
	// for the description of the bug (it existed in older Chrome versions as well).
	jQuery.each( {
		mouseenter: "mouseover",
		mouseleave: "mouseout",
		pointerenter: "pointerover",
		pointerleave: "pointerout"
	}, function( orig, fix ) {
		jQuery.event.special[ orig ] = {
			delegateType: fix,
			bindType: fix,

			handle: function( event ) {
				var ret,
					target = this,
					related = event.relatedTarget,
					handleObj = event.handleObj;

				// For mouseenter/leave call the handler if related is outside the target.
				// NB: No relatedTarget if the mouse left/entered the browser window
				if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
					event.type = handleObj.origType;
					ret = handleObj.handler.apply( this, arguments );
					event.type = fix;
				}
				return ret;
			}
		};
	} );

	jQuery.fn.extend( {

		on: function( types, selector, data, fn ) {
			return on( this, types, selector, data, fn );
		},
		one: function( types, selector, data, fn ) {
			return on( this, types, selector, data, fn, 1 );
		},
		off: function( types, selector, fn ) {
			var handleObj, type;
			if ( types && types.preventDefault && types.handleObj ) {

				// ( event )  dispatched jQuery.Event
				handleObj = types.handleObj;
				jQuery( types.delegateTarget ).off(
					handleObj.namespace ?
						handleObj.origType + "." + handleObj.namespace :
						handleObj.origType,
					handleObj.selector,
					handleObj.handler
				);
				return this;
			}
			if ( typeof types === "object" ) {

				// ( types-object [, selector] )
				for ( type in types ) {
					this.off( type, selector, types[ type ] );
				}
				return this;
			}
			if ( selector === false || typeof selector === "function" ) {

				// ( types [, fn] )
				fn = selector;
				selector = undefined;
			}
			if ( fn === false ) {
				fn = returnFalse;
			}
			return this.each( function() {
				jQuery.event.remove( this, types, fn, selector );
			} );
		}
	} );


	var

		/* eslint-disable max-len */

		// See https://github.com/eslint/eslint/issues/3229
		rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,

		/* eslint-enable */

		// Support: IE <=10 - 11, Edge 12 - 13
		// In IE/Edge using regex groups here causes severe slowdowns.
		// See https://connect.microsoft.com/IE/feedback/details/1736512/
		rnoInnerhtml = /<script|<style|<link/i,

		// checked="checked" or checked
		rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
		rscriptTypeMasked = /^true\/(.*)/,
		rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

	function manipulationTarget( elem, content ) {
		if ( jQuery.nodeName( elem, "table" ) &&
			jQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {

			return elem.getElementsByTagName( "tbody" )[ 0 ] || elem;
		}

		return elem;
	}

	// Replace/restore the type attribute of script elements for safe DOM manipulation
	function disableScript( elem ) {
		elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
		return elem;
	}
	function restoreScript( elem ) {
		var match = rscriptTypeMasked.exec( elem.type );

		if ( match ) {
			elem.type = match[ 1 ];
		} else {
			elem.removeAttribute( "type" );
		}

		return elem;
	}

	function cloneCopyEvent( src, dest ) {
		var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

		if ( dest.nodeType !== 1 ) {
			return;
		}

		// 1. Copy private data: events, handlers, etc.
		if ( dataPriv.hasData( src ) ) {
			pdataOld = dataPriv.access( src );
			pdataCur = dataPriv.set( dest, pdataOld );
			events = pdataOld.events;

			if ( events ) {
				delete pdataCur.handle;
				pdataCur.events = {};

				for ( type in events ) {
					for ( i = 0, l = events[ type ].length; i < l; i++ ) {
						jQuery.event.add( dest, type, events[ type ][ i ] );
					}
				}
			}
		}

		// 2. Copy user data
		if ( dataUser.hasData( src ) ) {
			udataOld = dataUser.access( src );
			udataCur = jQuery.extend( {}, udataOld );

			dataUser.set( dest, udataCur );
		}
	}

	// Fix IE bugs, see support tests
	function fixInput( src, dest ) {
		var nodeName = dest.nodeName.toLowerCase();

		// Fails to persist the checked state of a cloned checkbox or radio button.
		if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
			dest.checked = src.checked;

		// Fails to return the selected option to the default selected state when cloning options
		} else if ( nodeName === "input" || nodeName === "textarea" ) {
			dest.defaultValue = src.defaultValue;
		}
	}

	function domManip( collection, args, callback, ignored ) {

		// Flatten any nested arrays
		args = concat.apply( [], args );

		var fragment, first, scripts, hasScripts, node, doc,
			i = 0,
			l = collection.length,
			iNoClone = l - 1,
			value = args[ 0 ],
			isFunction = jQuery.isFunction( value );

		// We can't cloneNode fragments that contain checked, in WebKit
		if ( isFunction ||
				( l > 1 && typeof value === "string" &&
					!support.checkClone && rchecked.test( value ) ) ) {
			return collection.each( function( index ) {
				var self = collection.eq( index );
				if ( isFunction ) {
					args[ 0 ] = value.call( this, index, self.html() );
				}
				domManip( self, args, callback, ignored );
			} );
		}

		if ( l ) {
			fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
			first = fragment.firstChild;

			if ( fragment.childNodes.length === 1 ) {
				fragment = first;
			}

			// Require either new content or an interest in ignored elements to invoke the callback
			if ( first || ignored ) {
				scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
				hasScripts = scripts.length;

				// Use the original fragment for the last item
				// instead of the first because it can end up
				// being emptied incorrectly in certain situations (#8070).
				for ( ; i < l; i++ ) {
					node = fragment;

					if ( i !== iNoClone ) {
						node = jQuery.clone( node, true, true );

						// Keep references to cloned scripts for later restoration
						if ( hasScripts ) {

							// Support: Android <=4.0 only, PhantomJS 1 only
							// push.apply(_, arraylike) throws on ancient WebKit
							jQuery.merge( scripts, getAll( node, "script" ) );
						}
					}

					callback.call( collection[ i ], node, i );
				}

				if ( hasScripts ) {
					doc = scripts[ scripts.length - 1 ].ownerDocument;

					// Reenable scripts
					jQuery.map( scripts, restoreScript );

					// Evaluate executable scripts on first document insertion
					for ( i = 0; i < hasScripts; i++ ) {
						node = scripts[ i ];
						if ( rscriptType.test( node.type || "" ) &&
							!dataPriv.access( node, "globalEval" ) &&
							jQuery.contains( doc, node ) ) {

							if ( node.src ) {

								// Optional AJAX dependency, but won't run scripts if not present
								if ( jQuery._evalUrl ) {
									jQuery._evalUrl( node.src );
								}
							} else {
								DOMEval( node.textContent.replace( rcleanScript, "" ), doc );
							}
						}
					}
				}
			}
		}

		return collection;
	}

	function remove( elem, selector, keepData ) {
		var node,
			nodes = selector ? jQuery.filter( selector, elem ) : elem,
			i = 0;

		for ( ; ( node = nodes[ i ] ) != null; i++ ) {
			if ( !keepData && node.nodeType === 1 ) {
				jQuery.cleanData( getAll( node ) );
			}

			if ( node.parentNode ) {
				if ( keepData && jQuery.contains( node.ownerDocument, node ) ) {
					setGlobalEval( getAll( node, "script" ) );
				}
				node.parentNode.removeChild( node );
			}
		}

		return elem;
	}

	jQuery.extend( {
		htmlPrefilter: function( html ) {
			return html.replace( rxhtmlTag, "<$1></$2>" );
		},

		clone: function( elem, dataAndEvents, deepDataAndEvents ) {
			var i, l, srcElements, destElements,
				clone = elem.cloneNode( true ),
				inPage = jQuery.contains( elem.ownerDocument, elem );

			// Fix IE cloning issues
			if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
					!jQuery.isXMLDoc( elem ) ) {

				// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
				destElements = getAll( clone );
				srcElements = getAll( elem );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					fixInput( srcElements[ i ], destElements[ i ] );
				}
			}

			// Copy the events from the original to the clone
			if ( dataAndEvents ) {
				if ( deepDataAndEvents ) {
					srcElements = srcElements || getAll( elem );
					destElements = destElements || getAll( clone );

					for ( i = 0, l = srcElements.length; i < l; i++ ) {
						cloneCopyEvent( srcElements[ i ], destElements[ i ] );
					}
				} else {
					cloneCopyEvent( elem, clone );
				}
			}

			// Preserve script evaluation history
			destElements = getAll( clone, "script" );
			if ( destElements.length > 0 ) {
				setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
			}

			// Return the cloned set
			return clone;
		},

		cleanData: function( elems ) {
			var data, elem, type,
				special = jQuery.event.special,
				i = 0;

			for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
				if ( acceptData( elem ) ) {
					if ( ( data = elem[ dataPriv.expando ] ) ) {
						if ( data.events ) {
							for ( type in data.events ) {
								if ( special[ type ] ) {
									jQuery.event.remove( elem, type );

								// This is a shortcut to avoid jQuery.event.remove's overhead
								} else {
									jQuery.removeEvent( elem, type, data.handle );
								}
							}
						}

						// Support: Chrome <=35 - 45+
						// Assign undefined instead of using delete, see Data#remove
						elem[ dataPriv.expando ] = undefined;
					}
					if ( elem[ dataUser.expando ] ) {

						// Support: Chrome <=35 - 45+
						// Assign undefined instead of using delete, see Data#remove
						elem[ dataUser.expando ] = undefined;
					}
				}
			}
		}
	} );

	jQuery.fn.extend( {
		detach: function( selector ) {
			return remove( this, selector, true );
		},

		remove: function( selector ) {
			return remove( this, selector );
		},

		text: function( value ) {
			return access( this, function( value ) {
				return value === undefined ?
					jQuery.text( this ) :
					this.empty().each( function() {
						if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
							this.textContent = value;
						}
					} );
			}, null, value, arguments.length );
		},

		append: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
					var target = manipulationTarget( this, elem );
					target.appendChild( elem );
				}
			} );
		},

		prepend: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
					var target = manipulationTarget( this, elem );
					target.insertBefore( elem, target.firstChild );
				}
			} );
		},

		before: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.parentNode ) {
					this.parentNode.insertBefore( elem, this );
				}
			} );
		},

		after: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.parentNode ) {
					this.parentNode.insertBefore( elem, this.nextSibling );
				}
			} );
		},

		empty: function() {
			var elem,
				i = 0;

			for ( ; ( elem = this[ i ] ) != null; i++ ) {
				if ( elem.nodeType === 1 ) {

					// Prevent memory leaks
					jQuery.cleanData( getAll( elem, false ) );

					// Remove any remaining nodes
					elem.textContent = "";
				}
			}

			return this;
		},

		clone: function( dataAndEvents, deepDataAndEvents ) {
			dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
			deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

			return this.map( function() {
				return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
			} );
		},

		html: function( value ) {
			return access( this, function( value ) {
				var elem = this[ 0 ] || {},
					i = 0,
					l = this.length;

				if ( value === undefined && elem.nodeType === 1 ) {
					return elem.innerHTML;
				}

				// See if we can take a shortcut and just use innerHTML
				if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
					!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

					value = jQuery.htmlPrefilter( value );

					try {
						for ( ; i < l; i++ ) {
							elem = this[ i ] || {};

							// Remove element nodes and prevent memory leaks
							if ( elem.nodeType === 1 ) {
								jQuery.cleanData( getAll( elem, false ) );
								elem.innerHTML = value;
							}
						}

						elem = 0;

					// If using innerHTML throws an exception, use the fallback method
					} catch ( e ) {}
				}

				if ( elem ) {
					this.empty().append( value );
				}
			}, null, value, arguments.length );
		},

		replaceWith: function() {
			var ignored = [];

			// Make the changes, replacing each non-ignored context element with the new content
			return domManip( this, arguments, function( elem ) {
				var parent = this.parentNode;

				if ( jQuery.inArray( this, ignored ) < 0 ) {
					jQuery.cleanData( getAll( this ) );
					if ( parent ) {
						parent.replaceChild( elem, this );
					}
				}

			// Force callback invocation
			}, ignored );
		}
	} );

	jQuery.each( {
		appendTo: "append",
		prependTo: "prepend",
		insertBefore: "before",
		insertAfter: "after",
		replaceAll: "replaceWith"
	}, function( name, original ) {
		jQuery.fn[ name ] = function( selector ) {
			var elems,
				ret = [],
				insert = jQuery( selector ),
				last = insert.length - 1,
				i = 0;

			for ( ; i <= last; i++ ) {
				elems = i === last ? this : this.clone( true );
				jQuery( insert[ i ] )[ original ]( elems );

				// Support: Android <=4.0 only, PhantomJS 1 only
				// .get() because push.apply(_, arraylike) throws on ancient WebKit
				push.apply( ret, elems.get() );
			}

			return this.pushStack( ret );
		};
	} );
	var rmargin = ( /^margin/ );

	var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

	var getStyles = function( elem ) {

			// Support: IE <=11 only, Firefox <=30 (#15098, #14150)
			// IE throws on elements created in popups
			// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
			var view = elem.ownerDocument.defaultView;

			if ( !view || !view.opener ) {
				view = window;
			}

			return view.getComputedStyle( elem );
		};



	( function() {

		// Executing both pixelPosition & boxSizingReliable tests require only one layout
		// so they're executed at the same time to save the second computation.
		function computeStyleTests() {

			// This is a singleton, we need to execute it only once
			if ( !div ) {
				return;
			}

			div.style.cssText =
				"box-sizing:border-box;" +
				"position:relative;display:block;" +
				"margin:auto;border:1px;padding:1px;" +
				"top:1%;width:50%";
			div.innerHTML = "";
			documentElement.appendChild( container );

			var divStyle = window.getComputedStyle( div );
			pixelPositionVal = divStyle.top !== "1%";

			// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
			reliableMarginLeftVal = divStyle.marginLeft === "2px";
			boxSizingReliableVal = divStyle.width === "4px";

			// Support: Android 4.0 - 4.3 only
			// Some styles come back with percentage values, even though they shouldn't
			div.style.marginRight = "50%";
			pixelMarginRightVal = divStyle.marginRight === "4px";

			documentElement.removeChild( container );

			// Nullify the div so it wouldn't be stored in the memory and
			// it will also be a sign that checks already performed
			div = null;
		}

		var pixelPositionVal, boxSizingReliableVal, pixelMarginRightVal, reliableMarginLeftVal,
			container = document.createElement( "div" ),
			div = document.createElement( "div" );

		// Finish early in limited (non-browser) environments
		if ( !div.style ) {
			return;
		}

		// Support: IE <=9 - 11 only
		// Style of cloned element affects source element cloned (#8908)
		div.style.backgroundClip = "content-box";
		div.cloneNode( true ).style.backgroundClip = "";
		support.clearCloneStyle = div.style.backgroundClip === "content-box";

		container.style.cssText = "border:0;width:8px;height:0;top:0;left:-9999px;" +
			"padding:0;margin-top:1px;position:absolute";
		container.appendChild( div );

		jQuery.extend( support, {
			pixelPosition: function() {
				computeStyleTests();
				return pixelPositionVal;
			},
			boxSizingReliable: function() {
				computeStyleTests();
				return boxSizingReliableVal;
			},
			pixelMarginRight: function() {
				computeStyleTests();
				return pixelMarginRightVal;
			},
			reliableMarginLeft: function() {
				computeStyleTests();
				return reliableMarginLeftVal;
			}
		} );
	} )();


	function curCSS( elem, name, computed ) {
		var width, minWidth, maxWidth, ret,
			style = elem.style;

		computed = computed || getStyles( elem );

		// Support: IE <=9 only
		// getPropertyValue is only needed for .css('filter') (#12537)
		if ( computed ) {
			ret = computed.getPropertyValue( name ) || computed[ name ];

			if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
				ret = jQuery.style( elem, name );
			}

			// A tribute to the "awesome hack by Dean Edwards"
			// Android Browser returns percentage for some values,
			// but width seems to be reliably pixels.
			// This is against the CSSOM draft spec:
			// https://drafts.csswg.org/cssom/#resolved-values
			if ( !support.pixelMarginRight() && rnumnonpx.test( ret ) && rmargin.test( name ) ) {

				// Remember the original values
				width = style.width;
				minWidth = style.minWidth;
				maxWidth = style.maxWidth;

				// Put in the new values to get a computed value out
				style.minWidth = style.maxWidth = style.width = ret;
				ret = computed.width;

				// Revert the changed values
				style.width = width;
				style.minWidth = minWidth;
				style.maxWidth = maxWidth;
			}
		}

		return ret !== undefined ?

			// Support: IE <=9 - 11 only
			// IE returns zIndex value as an integer.
			ret + "" :
			ret;
	}


	function addGetHookIf( conditionFn, hookFn ) {

		// Define the hook, we'll check on the first run if it's really needed.
		return {
			get: function() {
				if ( conditionFn() ) {

					// Hook not needed (or it's not possible to use it due
					// to missing dependency), remove it.
					delete this.get;
					return;
				}

				// Hook needed; redefine it so that the support test is not executed again.
				return ( this.get = hookFn ).apply( this, arguments );
			}
		};
	}


	var

		// Swappable if display is none or starts with table
		// except "table", "table-cell", or "table-caption"
		// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
		rdisplayswap = /^(none|table(?!-c[ea]).+)/,
		cssShow = { position: "absolute", visibility: "hidden", display: "block" },
		cssNormalTransform = {
			letterSpacing: "0",
			fontWeight: "400"
		},

		cssPrefixes = [ "Webkit", "Moz", "ms" ],
		emptyStyle = document.createElement( "div" ).style;

	// Return a css property mapped to a potentially vendor prefixed property
	function vendorPropName( name ) {

		// Shortcut for names that are not vendor prefixed
		if ( name in emptyStyle ) {
			return name;
		}

		// Check for vendor prefixed names
		var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
			i = cssPrefixes.length;

		while ( i-- ) {
			name = cssPrefixes[ i ] + capName;
			if ( name in emptyStyle ) {
				return name;
			}
		}
	}

	function setPositiveNumber( elem, value, subtract ) {

		// Any relative (+/-) values have already been
		// normalized at this point
		var matches = rcssNum.exec( value );
		return matches ?

			// Guard against undefined "subtract", e.g., when used as in cssHooks
			Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
			value;
	}

	function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {
		var i = extra === ( isBorderBox ? "border" : "content" ) ?

			// If we already have the right measurement, avoid augmentation
			4 :

			// Otherwise initialize for horizontal or vertical properties
			name === "width" ? 1 : 0,

			val = 0;

		for ( ; i < 4; i += 2 ) {

			// Both box models exclude margin, so add it if we want it
			if ( extra === "margin" ) {
				val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );
			}

			if ( isBorderBox ) {

				// border-box includes padding, so remove it if we want content
				if ( extra === "content" ) {
					val -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
				}

				// At this point, extra isn't border nor margin, so remove border
				if ( extra !== "margin" ) {
					val -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
				}
			} else {

				// At this point, extra isn't content, so add padding
				val += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

				// At this point, extra isn't content nor padding, so add border
				if ( extra !== "padding" ) {
					val += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
				}
			}
		}

		return val;
	}

	function getWidthOrHeight( elem, name, extra ) {

		// Start with offset property, which is equivalent to the border-box value
		var val,
			valueIsBorderBox = true,
			styles = getStyles( elem ),
			isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

		// Support: IE <=11 only
		// Running getBoundingClientRect on a disconnected node
		// in IE throws an error.
		if ( elem.getClientRects().length ) {
			val = elem.getBoundingClientRect()[ name ];
		}

		// Some non-html elements return undefined for offsetWidth, so check for null/undefined
		// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
		// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
		if ( val <= 0 || val == null ) {

			// Fall back to computed then uncomputed css if necessary
			val = curCSS( elem, name, styles );
			if ( val < 0 || val == null ) {
				val = elem.style[ name ];
			}

			// Computed unit is not pixels. Stop here and return.
			if ( rnumnonpx.test( val ) ) {
				return val;
			}

			// Check for style in case a browser which returns unreliable values
			// for getComputedStyle silently falls back to the reliable elem.style
			valueIsBorderBox = isBorderBox &&
				( support.boxSizingReliable() || val === elem.style[ name ] );

			// Normalize "", auto, and prepare for extra
			val = parseFloat( val ) || 0;
		}

		// Use the active box-sizing model to add/subtract irrelevant styles
		return ( val +
			augmentWidthOrHeight(
				elem,
				name,
				extra || ( isBorderBox ? "border" : "content" ),
				valueIsBorderBox,
				styles
			)
		) + "px";
	}

	jQuery.extend( {

		// Add in style property hooks for overriding the default
		// behavior of getting and setting a style property
		cssHooks: {
			opacity: {
				get: function( elem, computed ) {
					if ( computed ) {

						// We should always get a number back from opacity
						var ret = curCSS( elem, "opacity" );
						return ret === "" ? "1" : ret;
					}
				}
			}
		},

		// Don't automatically add "px" to these possibly-unitless properties
		cssNumber: {
			"animationIterationCount": true,
			"columnCount": true,
			"fillOpacity": true,
			"flexGrow": true,
			"flexShrink": true,
			"fontWeight": true,
			"lineHeight": true,
			"opacity": true,
			"order": true,
			"orphans": true,
			"widows": true,
			"zIndex": true,
			"zoom": true
		},

		// Add in properties whose names you wish to fix before
		// setting or getting the value
		cssProps: {
			"float": "cssFloat"
		},

		// Get and set the style property on a DOM Node
		style: function( elem, name, value, extra ) {

			// Don't set styles on text and comment nodes
			if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
				return;
			}

			// Make sure that we're working with the right name
			var ret, type, hooks,
				origName = jQuery.camelCase( name ),
				style = elem.style;

			name = jQuery.cssProps[ origName ] ||
				( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );

			// Gets hook for the prefixed version, then unprefixed version
			hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

			// Check if we're setting a value
			if ( value !== undefined ) {
				type = typeof value;

				// Convert "+=" or "-=" to relative numbers (#7345)
				if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
					value = adjustCSS( elem, name, ret );

					// Fixes bug #9237
					type = "number";
				}

				// Make sure that null and NaN values aren't set (#7116)
				if ( value == null || value !== value ) {
					return;
				}

				// If a number was passed in, add the unit (except for certain CSS properties)
				if ( type === "number" ) {
					value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
				}

				// background-* props affect original clone's values
				if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
					style[ name ] = "inherit";
				}

				// If a hook was provided, use that value, otherwise just set the specified value
				if ( !hooks || !( "set" in hooks ) ||
					( value = hooks.set( elem, value, extra ) ) !== undefined ) {

					style[ name ] = value;
				}

			} else {

				// If a hook was provided get the non-computed value from there
				if ( hooks && "get" in hooks &&
					( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

					return ret;
				}

				// Otherwise just get the value from the style object
				return style[ name ];
			}
		},

		css: function( elem, name, extra, styles ) {
			var val, num, hooks,
				origName = jQuery.camelCase( name );

			// Make sure that we're working with the right name
			name = jQuery.cssProps[ origName ] ||
				( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );

			// Try prefixed name followed by the unprefixed name
			hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

			// If a hook was provided get the computed value from there
			if ( hooks && "get" in hooks ) {
				val = hooks.get( elem, true, extra );
			}

			// Otherwise, if a way to get the computed value exists, use that
			if ( val === undefined ) {
				val = curCSS( elem, name, styles );
			}

			// Convert "normal" to computed value
			if ( val === "normal" && name in cssNormalTransform ) {
				val = cssNormalTransform[ name ];
			}

			// Make numeric if forced or a qualifier was provided and val looks numeric
			if ( extra === "" || extra ) {
				num = parseFloat( val );
				return extra === true || isFinite( num ) ? num || 0 : val;
			}
			return val;
		}
	} );

	jQuery.each( [ "height", "width" ], function( i, name ) {
		jQuery.cssHooks[ name ] = {
			get: function( elem, computed, extra ) {
				if ( computed ) {

					// Certain elements can have dimension info if we invisibly show them
					// but it must have a current display style that would benefit
					return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&

						// Support: Safari 8+
						// Table columns in Safari have non-zero offsetWidth & zero
						// getBoundingClientRect().width unless display is changed.
						// Support: IE <=11 only
						// Running getBoundingClientRect on a disconnected node
						// in IE throws an error.
						( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?
							swap( elem, cssShow, function() {
								return getWidthOrHeight( elem, name, extra );
							} ) :
							getWidthOrHeight( elem, name, extra );
				}
			},

			set: function( elem, value, extra ) {
				var matches,
					styles = extra && getStyles( elem ),
					subtract = extra && augmentWidthOrHeight(
						elem,
						name,
						extra,
						jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
						styles
					);

				// Convert to pixels if value adjustment is needed
				if ( subtract && ( matches = rcssNum.exec( value ) ) &&
					( matches[ 3 ] || "px" ) !== "px" ) {

					elem.style[ name ] = value;
					value = jQuery.css( elem, name );
				}

				return setPositiveNumber( elem, value, subtract );
			}
		};
	} );

	jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
		function( elem, computed ) {
			if ( computed ) {
				return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
					elem.getBoundingClientRect().left -
						swap( elem, { marginLeft: 0 }, function() {
							return elem.getBoundingClientRect().left;
						} )
					) + "px";
			}
		}
	);

	// These hooks are used by animate to expand properties
	jQuery.each( {
		margin: "",
		padding: "",
		border: "Width"
	}, function( prefix, suffix ) {
		jQuery.cssHooks[ prefix + suffix ] = {
			expand: function( value ) {
				var i = 0,
					expanded = {},

					// Assumes a single number if not a string
					parts = typeof value === "string" ? value.split( " " ) : [ value ];

				for ( ; i < 4; i++ ) {
					expanded[ prefix + cssExpand[ i ] + suffix ] =
						parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
				}

				return expanded;
			}
		};

		if ( !rmargin.test( prefix ) ) {
			jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
		}
	} );

	jQuery.fn.extend( {
		css: function( name, value ) {
			return access( this, function( elem, name, value ) {
				var styles, len,
					map = {},
					i = 0;

				if ( jQuery.isArray( name ) ) {
					styles = getStyles( elem );
					len = name.length;

					for ( ; i < len; i++ ) {
						map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
					}

					return map;
				}

				return value !== undefined ?
					jQuery.style( elem, name, value ) :
					jQuery.css( elem, name );
			}, name, value, arguments.length > 1 );
		}
	} );


	function Tween( elem, options, prop, end, easing ) {
		return new Tween.prototype.init( elem, options, prop, end, easing );
	}
	jQuery.Tween = Tween;

	Tween.prototype = {
		constructor: Tween,
		init: function( elem, options, prop, end, easing, unit ) {
			this.elem = elem;
			this.prop = prop;
			this.easing = easing || jQuery.easing._default;
			this.options = options;
			this.start = this.now = this.cur();
			this.end = end;
			this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
		},
		cur: function() {
			var hooks = Tween.propHooks[ this.prop ];

			return hooks && hooks.get ?
				hooks.get( this ) :
				Tween.propHooks._default.get( this );
		},
		run: function( percent ) {
			var eased,
				hooks = Tween.propHooks[ this.prop ];

			if ( this.options.duration ) {
				this.pos = eased = jQuery.easing[ this.easing ](
					percent, this.options.duration * percent, 0, 1, this.options.duration
				);
			} else {
				this.pos = eased = percent;
			}
			this.now = ( this.end - this.start ) * eased + this.start;

			if ( this.options.step ) {
				this.options.step.call( this.elem, this.now, this );
			}

			if ( hooks && hooks.set ) {
				hooks.set( this );
			} else {
				Tween.propHooks._default.set( this );
			}
			return this;
		}
	};

	Tween.prototype.init.prototype = Tween.prototype;

	Tween.propHooks = {
		_default: {
			get: function( tween ) {
				var result;

				// Use a property on the element directly when it is not a DOM element,
				// or when there is no matching style property that exists.
				if ( tween.elem.nodeType !== 1 ||
					tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
					return tween.elem[ tween.prop ];
				}

				// Passing an empty string as a 3rd parameter to .css will automatically
				// attempt a parseFloat and fallback to a string if the parse fails.
				// Simple values such as "10px" are parsed to Float;
				// complex values such as "rotate(1rad)" are returned as-is.
				result = jQuery.css( tween.elem, tween.prop, "" );

				// Empty strings, null, undefined and "auto" are converted to 0.
				return !result || result === "auto" ? 0 : result;
			},
			set: function( tween ) {

				// Use step hook for back compat.
				// Use cssHook if its there.
				// Use .style if available and use plain properties where available.
				if ( jQuery.fx.step[ tween.prop ] ) {
					jQuery.fx.step[ tween.prop ]( tween );
				} else if ( tween.elem.nodeType === 1 &&
					( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null ||
						jQuery.cssHooks[ tween.prop ] ) ) {
					jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
				} else {
					tween.elem[ tween.prop ] = tween.now;
				}
			}
		}
	};

	// Support: IE <=9 only
	// Panic based approach to setting things on disconnected nodes
	Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
		set: function( tween ) {
			if ( tween.elem.nodeType && tween.elem.parentNode ) {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	};

	jQuery.easing = {
		linear: function( p ) {
			return p;
		},
		swing: function( p ) {
			return 0.5 - Math.cos( p * Math.PI ) / 2;
		},
		_default: "swing"
	};

	jQuery.fx = Tween.prototype.init;

	// Back compat <1.8 extension point
	jQuery.fx.step = {};




	var
		fxNow, timerId,
		rfxtypes = /^(?:toggle|show|hide)$/,
		rrun = /queueHooks$/;

	function raf() {
		if ( timerId ) {
			window.requestAnimationFrame( raf );
			jQuery.fx.tick();
		}
	}

	// Animations created synchronously will run synchronously
	function createFxNow() {
		window.setTimeout( function() {
			fxNow = undefined;
		} );
		return ( fxNow = jQuery.now() );
	}

	// Generate parameters to create a standard animation
	function genFx( type, includeWidth ) {
		var which,
			i = 0,
			attrs = { height: type };

		// If we include width, step value is 1 to do all cssExpand values,
		// otherwise step value is 2 to skip over Left and Right
		includeWidth = includeWidth ? 1 : 0;
		for ( ; i < 4; i += 2 - includeWidth ) {
			which = cssExpand[ i ];
			attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
		}

		if ( includeWidth ) {
			attrs.opacity = attrs.width = type;
		}

		return attrs;
	}

	function createTween( value, prop, animation ) {
		var tween,
			collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
			index = 0,
			length = collection.length;
		for ( ; index < length; index++ ) {
			if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

				// We're done with this property
				return tween;
			}
		}
	}

	function defaultPrefilter( elem, props, opts ) {
		var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
			isBox = "width" in props || "height" in props,
			anim = this,
			orig = {},
			style = elem.style,
			hidden = elem.nodeType && isHiddenWithinTree( elem ),
			dataShow = dataPriv.get( elem, "fxshow" );

		// Queue-skipping animations hijack the fx hooks
		if ( !opts.queue ) {
			hooks = jQuery._queueHooks( elem, "fx" );
			if ( hooks.unqueued == null ) {
				hooks.unqueued = 0;
				oldfire = hooks.empty.fire;
				hooks.empty.fire = function() {
					if ( !hooks.unqueued ) {
						oldfire();
					}
				};
			}
			hooks.unqueued++;

			anim.always( function() {

				// Ensure the complete handler is called before this completes
				anim.always( function() {
					hooks.unqueued--;
					if ( !jQuery.queue( elem, "fx" ).length ) {
						hooks.empty.fire();
					}
				} );
			} );
		}

		// Detect show/hide animations
		for ( prop in props ) {
			value = props[ prop ];
			if ( rfxtypes.test( value ) ) {
				delete props[ prop ];
				toggle = toggle || value === "toggle";
				if ( value === ( hidden ? "hide" : "show" ) ) {

					// Pretend to be hidden if this is a "show" and
					// there is still data from a stopped show/hide
					if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
						hidden = true;

					// Ignore all other no-op show/hide data
					} else {
						continue;
					}
				}
				orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
			}
		}

		// Bail out if this is a no-op like .hide().hide()
		propTween = !jQuery.isEmptyObject( props );
		if ( !propTween && jQuery.isEmptyObject( orig ) ) {
			return;
		}

		// Restrict "overflow" and "display" styles during box animations
		if ( isBox && elem.nodeType === 1 ) {

			// Support: IE <=9 - 11, Edge 12 - 13
			// Record all 3 overflow attributes because IE does not infer the shorthand
			// from identically-valued overflowX and overflowY
			opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

			// Identify a display type, preferring old show/hide data over the CSS cascade
			restoreDisplay = dataShow && dataShow.display;
			if ( restoreDisplay == null ) {
				restoreDisplay = dataPriv.get( elem, "display" );
			}
			display = jQuery.css( elem, "display" );
			if ( display === "none" ) {
				if ( restoreDisplay ) {
					display = restoreDisplay;
				} else {

					// Get nonempty value(s) by temporarily forcing visibility
					showHide( [ elem ], true );
					restoreDisplay = elem.style.display || restoreDisplay;
					display = jQuery.css( elem, "display" );
					showHide( [ elem ] );
				}
			}

			// Animate inline elements as inline-block
			if ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {
				if ( jQuery.css( elem, "float" ) === "none" ) {

					// Restore the original display value at the end of pure show/hide animations
					if ( !propTween ) {
						anim.done( function() {
							style.display = restoreDisplay;
						} );
						if ( restoreDisplay == null ) {
							display = style.display;
							restoreDisplay = display === "none" ? "" : display;
						}
					}
					style.display = "inline-block";
				}
			}
		}

		if ( opts.overflow ) {
			style.overflow = "hidden";
			anim.always( function() {
				style.overflow = opts.overflow[ 0 ];
				style.overflowX = opts.overflow[ 1 ];
				style.overflowY = opts.overflow[ 2 ];
			} );
		}

		// Implement show/hide animations
		propTween = false;
		for ( prop in orig ) {

			// General show/hide setup for this element animation
			if ( !propTween ) {
				if ( dataShow ) {
					if ( "hidden" in dataShow ) {
						hidden = dataShow.hidden;
					}
				} else {
					dataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );
				}

				// Store hidden/visible for toggle so `.stop().toggle()` "reverses"
				if ( toggle ) {
					dataShow.hidden = !hidden;
				}

				// Show elements before animating them
				if ( hidden ) {
					showHide( [ elem ], true );
				}

				/* eslint-disable no-loop-func */

				anim.done( function() {

				/* eslint-enable no-loop-func */

					// The final step of a "hide" animation is actually hiding the element
					if ( !hidden ) {
						showHide( [ elem ] );
					}
					dataPriv.remove( elem, "fxshow" );
					for ( prop in orig ) {
						jQuery.style( elem, prop, orig[ prop ] );
					}
				} );
			}

			// Per-property setup
			propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
			if ( !( prop in dataShow ) ) {
				dataShow[ prop ] = propTween.start;
				if ( hidden ) {
					propTween.end = propTween.start;
					propTween.start = 0;
				}
			}
		}
	}

	function propFilter( props, specialEasing ) {
		var index, name, easing, value, hooks;

		// camelCase, specialEasing and expand cssHook pass
		for ( index in props ) {
			name = jQuery.camelCase( index );
			easing = specialEasing[ name ];
			value = props[ index ];
			if ( jQuery.isArray( value ) ) {
				easing = value[ 1 ];
				value = props[ index ] = value[ 0 ];
			}

			if ( index !== name ) {
				props[ name ] = value;
				delete props[ index ];
			}

			hooks = jQuery.cssHooks[ name ];
			if ( hooks && "expand" in hooks ) {
				value = hooks.expand( value );
				delete props[ name ];

				// Not quite $.extend, this won't overwrite existing keys.
				// Reusing 'index' because we have the correct "name"
				for ( index in value ) {
					if ( !( index in props ) ) {
						props[ index ] = value[ index ];
						specialEasing[ index ] = easing;
					}
				}
			} else {
				specialEasing[ name ] = easing;
			}
		}
	}

	function Animation( elem, properties, options ) {
		var result,
			stopped,
			index = 0,
			length = Animation.prefilters.length,
			deferred = jQuery.Deferred().always( function() {

				// Don't match elem in the :animated selector
				delete tick.elem;
			} ),
			tick = function() {
				if ( stopped ) {
					return false;
				}
				var currentTime = fxNow || createFxNow(),
					remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

					// Support: Android 2.3 only
					// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
					temp = remaining / animation.duration || 0,
					percent = 1 - temp,
					index = 0,
					length = animation.tweens.length;

				for ( ; index < length; index++ ) {
					animation.tweens[ index ].run( percent );
				}

				deferred.notifyWith( elem, [ animation, percent, remaining ] );

				if ( percent < 1 && length ) {
					return remaining;
				} else {
					deferred.resolveWith( elem, [ animation ] );
					return false;
				}
			},
			animation = deferred.promise( {
				elem: elem,
				props: jQuery.extend( {}, properties ),
				opts: jQuery.extend( true, {
					specialEasing: {},
					easing: jQuery.easing._default
				}, options ),
				originalProperties: properties,
				originalOptions: options,
				startTime: fxNow || createFxNow(),
				duration: options.duration,
				tweens: [],
				createTween: function( prop, end ) {
					var tween = jQuery.Tween( elem, animation.opts, prop, end,
							animation.opts.specialEasing[ prop ] || animation.opts.easing );
					animation.tweens.push( tween );
					return tween;
				},
				stop: function( gotoEnd ) {
					var index = 0,

						// If we are going to the end, we want to run all the tweens
						// otherwise we skip this part
						length = gotoEnd ? animation.tweens.length : 0;
					if ( stopped ) {
						return this;
					}
					stopped = true;
					for ( ; index < length; index++ ) {
						animation.tweens[ index ].run( 1 );
					}

					// Resolve when we played the last frame; otherwise, reject
					if ( gotoEnd ) {
						deferred.notifyWith( elem, [ animation, 1, 0 ] );
						deferred.resolveWith( elem, [ animation, gotoEnd ] );
					} else {
						deferred.rejectWith( elem, [ animation, gotoEnd ] );
					}
					return this;
				}
			} ),
			props = animation.props;

		propFilter( props, animation.opts.specialEasing );

		for ( ; index < length; index++ ) {
			result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
			if ( result ) {
				if ( jQuery.isFunction( result.stop ) ) {
					jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
						jQuery.proxy( result.stop, result );
				}
				return result;
			}
		}

		jQuery.map( props, createTween, animation );

		if ( jQuery.isFunction( animation.opts.start ) ) {
			animation.opts.start.call( elem, animation );
		}

		jQuery.fx.timer(
			jQuery.extend( tick, {
				elem: elem,
				anim: animation,
				queue: animation.opts.queue
			} )
		);

		// attach callbacks from options
		return animation.progress( animation.opts.progress )
			.done( animation.opts.done, animation.opts.complete )
			.fail( animation.opts.fail )
			.always( animation.opts.always );
	}

	jQuery.Animation = jQuery.extend( Animation, {

		tweeners: {
			"*": [ function( prop, value ) {
				var tween = this.createTween( prop, value );
				adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
				return tween;
			} ]
		},

		tweener: function( props, callback ) {
			if ( jQuery.isFunction( props ) ) {
				callback = props;
				props = [ "*" ];
			} else {
				props = props.match( rnotwhite );
			}

			var prop,
				index = 0,
				length = props.length;

			for ( ; index < length; index++ ) {
				prop = props[ index ];
				Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
				Animation.tweeners[ prop ].unshift( callback );
			}
		},

		prefilters: [ defaultPrefilter ],

		prefilter: function( callback, prepend ) {
			if ( prepend ) {
				Animation.prefilters.unshift( callback );
			} else {
				Animation.prefilters.push( callback );
			}
		}
	} );

	jQuery.speed = function( speed, easing, fn ) {
		var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
			complete: fn || !fn && easing ||
				jQuery.isFunction( speed ) && speed,
			duration: speed,
			easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
		};

		// Go to the end state if fx are off or if document is hidden
		if ( jQuery.fx.off || document.hidden ) {
			opt.duration = 0;

		} else {
			opt.duration = typeof opt.duration === "number" ?
				opt.duration : opt.duration in jQuery.fx.speeds ?
					jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;
		}

		// Normalize opt.queue - true/undefined/null -> "fx"
		if ( opt.queue == null || opt.queue === true ) {
			opt.queue = "fx";
		}

		// Queueing
		opt.old = opt.complete;

		opt.complete = function() {
			if ( jQuery.isFunction( opt.old ) ) {
				opt.old.call( this );
			}

			if ( opt.queue ) {
				jQuery.dequeue( this, opt.queue );
			}
		};

		return opt;
	};

	jQuery.fn.extend( {
		fadeTo: function( speed, to, easing, callback ) {

			// Show any hidden elements after setting opacity to 0
			return this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()

				// Animate to the value specified
				.end().animate( { opacity: to }, speed, easing, callback );
		},
		animate: function( prop, speed, easing, callback ) {
			var empty = jQuery.isEmptyObject( prop ),
				optall = jQuery.speed( speed, easing, callback ),
				doAnimation = function() {

					// Operate on a copy of prop so per-property easing won't be lost
					var anim = Animation( this, jQuery.extend( {}, prop ), optall );

					// Empty animations, or finishing resolves immediately
					if ( empty || dataPriv.get( this, "finish" ) ) {
						anim.stop( true );
					}
				};
				doAnimation.finish = doAnimation;

			return empty || optall.queue === false ?
				this.each( doAnimation ) :
				this.queue( optall.queue, doAnimation );
		},
		stop: function( type, clearQueue, gotoEnd ) {
			var stopQueue = function( hooks ) {
				var stop = hooks.stop;
				delete hooks.stop;
				stop( gotoEnd );
			};

			if ( typeof type !== "string" ) {
				gotoEnd = clearQueue;
				clearQueue = type;
				type = undefined;
			}
			if ( clearQueue && type !== false ) {
				this.queue( type || "fx", [] );
			}

			return this.each( function() {
				var dequeue = true,
					index = type != null && type + "queueHooks",
					timers = jQuery.timers,
					data = dataPriv.get( this );

				if ( index ) {
					if ( data[ index ] && data[ index ].stop ) {
						stopQueue( data[ index ] );
					}
				} else {
					for ( index in data ) {
						if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
							stopQueue( data[ index ] );
						}
					}
				}

				for ( index = timers.length; index--; ) {
					if ( timers[ index ].elem === this &&
						( type == null || timers[ index ].queue === type ) ) {

						timers[ index ].anim.stop( gotoEnd );
						dequeue = false;
						timers.splice( index, 1 );
					}
				}

				// Start the next in the queue if the last step wasn't forced.
				// Timers currently will call their complete callbacks, which
				// will dequeue but only if they were gotoEnd.
				if ( dequeue || !gotoEnd ) {
					jQuery.dequeue( this, type );
				}
			} );
		},
		finish: function( type ) {
			if ( type !== false ) {
				type = type || "fx";
			}
			return this.each( function() {
				var index,
					data = dataPriv.get( this ),
					queue = data[ type + "queue" ],
					hooks = data[ type + "queueHooks" ],
					timers = jQuery.timers,
					length = queue ? queue.length : 0;

				// Enable finishing flag on private data
				data.finish = true;

				// Empty the queue first
				jQuery.queue( this, type, [] );

				if ( hooks && hooks.stop ) {
					hooks.stop.call( this, true );
				}

				// Look for any active animations, and finish them
				for ( index = timers.length; index--; ) {
					if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
						timers[ index ].anim.stop( true );
						timers.splice( index, 1 );
					}
				}

				// Look for any animations in the old queue and finish them
				for ( index = 0; index < length; index++ ) {
					if ( queue[ index ] && queue[ index ].finish ) {
						queue[ index ].finish.call( this );
					}
				}

				// Turn off finishing flag
				delete data.finish;
			} );
		}
	} );

	jQuery.each( [ "toggle", "show", "hide" ], function( i, name ) {
		var cssFn = jQuery.fn[ name ];
		jQuery.fn[ name ] = function( speed, easing, callback ) {
			return speed == null || typeof speed === "boolean" ?
				cssFn.apply( this, arguments ) :
				this.animate( genFx( name, true ), speed, easing, callback );
		};
	} );

	// Generate shortcuts for custom animations
	jQuery.each( {
		slideDown: genFx( "show" ),
		slideUp: genFx( "hide" ),
		slideToggle: genFx( "toggle" ),
		fadeIn: { opacity: "show" },
		fadeOut: { opacity: "hide" },
		fadeToggle: { opacity: "toggle" }
	}, function( name, props ) {
		jQuery.fn[ name ] = function( speed, easing, callback ) {
			return this.animate( props, speed, easing, callback );
		};
	} );

	jQuery.timers = [];
	jQuery.fx.tick = function() {
		var timer,
			i = 0,
			timers = jQuery.timers;

		fxNow = jQuery.now();

		for ( ; i < timers.length; i++ ) {
			timer = timers[ i ];

			// Checks the timer has not already been removed
			if ( !timer() && timers[ i ] === timer ) {
				timers.splice( i--, 1 );
			}
		}

		if ( !timers.length ) {
			jQuery.fx.stop();
		}
		fxNow = undefined;
	};

	jQuery.fx.timer = function( timer ) {
		jQuery.timers.push( timer );
		if ( timer() ) {
			jQuery.fx.start();
		} else {
			jQuery.timers.pop();
		}
	};

	jQuery.fx.interval = 13;
	jQuery.fx.start = function() {
		if ( !timerId ) {
			timerId = window.requestAnimationFrame ?
				window.requestAnimationFrame( raf ) :
				window.setInterval( jQuery.fx.tick, jQuery.fx.interval );
		}
	};

	jQuery.fx.stop = function() {
		if ( window.cancelAnimationFrame ) {
			window.cancelAnimationFrame( timerId );
		} else {
			window.clearInterval( timerId );
		}

		timerId = null;
	};

	jQuery.fx.speeds = {
		slow: 600,
		fast: 200,

		// Default speed
		_default: 400
	};


	// Based off of the plugin by Clint Helfers, with permission.
	// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
	jQuery.fn.delay = function( time, type ) {
		time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
		type = type || "fx";

		return this.queue( type, function( next, hooks ) {
			var timeout = window.setTimeout( next, time );
			hooks.stop = function() {
				window.clearTimeout( timeout );
			};
		} );
	};


	( function() {
		var input = document.createElement( "input" ),
			select = document.createElement( "select" ),
			opt = select.appendChild( document.createElement( "option" ) );

		input.type = "checkbox";

		// Support: Android <=4.3 only
		// Default value for a checkbox should be "on"
		support.checkOn = input.value !== "";

		// Support: IE <=11 only
		// Must access selectedIndex to make default options select
		support.optSelected = opt.selected;

		// Support: IE <=11 only
		// An input loses its value after becoming a radio
		input = document.createElement( "input" );
		input.value = "t";
		input.type = "radio";
		support.radioValue = input.value === "t";
	} )();


	var boolHook,
		attrHandle = jQuery.expr.attrHandle;

	jQuery.fn.extend( {
		attr: function( name, value ) {
			return access( this, jQuery.attr, name, value, arguments.length > 1 );
		},

		removeAttr: function( name ) {
			return this.each( function() {
				jQuery.removeAttr( this, name );
			} );
		}
	} );

	jQuery.extend( {
		attr: function( elem, name, value ) {
			var ret, hooks,
				nType = elem.nodeType;

			// Don't get/set attributes on text, comment and attribute nodes
			if ( nType === 3 || nType === 8 || nType === 2 ) {
				return;
			}

			// Fallback to prop when attributes are not supported
			if ( typeof elem.getAttribute === "undefined" ) {
				return jQuery.prop( elem, name, value );
			}

			// Attribute hooks are determined by the lowercase version
			// Grab necessary hook if one is defined
			if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
				hooks = jQuery.attrHooks[ name.toLowerCase() ] ||
					( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
			}

			if ( value !== undefined ) {
				if ( value === null ) {
					jQuery.removeAttr( elem, name );
					return;
				}

				if ( hooks && "set" in hooks &&
					( ret = hooks.set( elem, value, name ) ) !== undefined ) {
					return ret;
				}

				elem.setAttribute( name, value + "" );
				return value;
			}

			if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
				return ret;
			}

			ret = jQuery.find.attr( elem, name );

			// Non-existent attributes return null, we normalize to undefined
			return ret == null ? undefined : ret;
		},

		attrHooks: {
			type: {
				set: function( elem, value ) {
					if ( !support.radioValue && value === "radio" &&
						jQuery.nodeName( elem, "input" ) ) {
						var val = elem.value;
						elem.setAttribute( "type", value );
						if ( val ) {
							elem.value = val;
						}
						return value;
					}
				}
			}
		},

		removeAttr: function( elem, value ) {
			var name,
				i = 0,
				attrNames = value && value.match( rnotwhite );

			if ( attrNames && elem.nodeType === 1 ) {
				while ( ( name = attrNames[ i++ ] ) ) {
					elem.removeAttribute( name );
				}
			}
		}
	} );

	// Hooks for boolean attributes
	boolHook = {
		set: function( elem, value, name ) {
			if ( value === false ) {

				// Remove boolean attributes when set to false
				jQuery.removeAttr( elem, name );
			} else {
				elem.setAttribute( name, name );
			}
			return name;
		}
	};

	jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
		var getter = attrHandle[ name ] || jQuery.find.attr;

		attrHandle[ name ] = function( elem, name, isXML ) {
			var ret, handle,
				lowercaseName = name.toLowerCase();

			if ( !isXML ) {

				// Avoid an infinite loop by temporarily removing this function from the getter
				handle = attrHandle[ lowercaseName ];
				attrHandle[ lowercaseName ] = ret;
				ret = getter( elem, name, isXML ) != null ?
					lowercaseName :
					null;
				attrHandle[ lowercaseName ] = handle;
			}
			return ret;
		};
	} );




	var rfocusable = /^(?:input|select|textarea|button)$/i,
		rclickable = /^(?:a|area)$/i;

	jQuery.fn.extend( {
		prop: function( name, value ) {
			return access( this, jQuery.prop, name, value, arguments.length > 1 );
		},

		removeProp: function( name ) {
			return this.each( function() {
				delete this[ jQuery.propFix[ name ] || name ];
			} );
		}
	} );

	jQuery.extend( {
		prop: function( elem, name, value ) {
			var ret, hooks,
				nType = elem.nodeType;

			// Don't get/set properties on text, comment and attribute nodes
			if ( nType === 3 || nType === 8 || nType === 2 ) {
				return;
			}

			if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

				// Fix name and attach hooks
				name = jQuery.propFix[ name ] || name;
				hooks = jQuery.propHooks[ name ];
			}

			if ( value !== undefined ) {
				if ( hooks && "set" in hooks &&
					( ret = hooks.set( elem, value, name ) ) !== undefined ) {
					return ret;
				}

				return ( elem[ name ] = value );
			}

			if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
				return ret;
			}

			return elem[ name ];
		},

		propHooks: {
			tabIndex: {
				get: function( elem ) {

					// Support: IE <=9 - 11 only
					// elem.tabIndex doesn't always return the
					// correct value when it hasn't been explicitly set
					// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
					// Use proper attribute retrieval(#12072)
					var tabindex = jQuery.find.attr( elem, "tabindex" );

					return tabindex ?
						parseInt( tabindex, 10 ) :
						rfocusable.test( elem.nodeName ) ||
							rclickable.test( elem.nodeName ) && elem.href ?
								0 :
								-1;
				}
			}
		},

		propFix: {
			"for": "htmlFor",
			"class": "className"
		}
	} );

	// Support: IE <=11 only
	// Accessing the selectedIndex property
	// forces the browser to respect setting selected
	// on the option
	// The getter ensures a default option is selected
	// when in an optgroup
	if ( !support.optSelected ) {
		jQuery.propHooks.selected = {
			get: function( elem ) {
				var parent = elem.parentNode;
				if ( parent && parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
				return null;
			},
			set: function( elem ) {
				var parent = elem.parentNode;
				if ( parent ) {
					parent.selectedIndex;

					if ( parent.parentNode ) {
						parent.parentNode.selectedIndex;
					}
				}
			}
		};
	}

	jQuery.each( [
		"tabIndex",
		"readOnly",
		"maxLength",
		"cellSpacing",
		"cellPadding",
		"rowSpan",
		"colSpan",
		"useMap",
		"frameBorder",
		"contentEditable"
	], function() {
		jQuery.propFix[ this.toLowerCase() ] = this;
	} );




	var rclass = /[\t\r\n\f]/g;

	function getClass( elem ) {
		return elem.getAttribute && elem.getAttribute( "class" ) || "";
	}

	jQuery.fn.extend( {
		addClass: function( value ) {
			var classes, elem, cur, curValue, clazz, j, finalValue,
				i = 0;

			if ( jQuery.isFunction( value ) ) {
				return this.each( function( j ) {
					jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
				} );
			}

			if ( typeof value === "string" && value ) {
				classes = value.match( rnotwhite ) || [];

				while ( ( elem = this[ i++ ] ) ) {
					curValue = getClass( elem );
					cur = elem.nodeType === 1 &&
						( " " + curValue + " " ).replace( rclass, " " );

					if ( cur ) {
						j = 0;
						while ( ( clazz = classes[ j++ ] ) ) {
							if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
								cur += clazz + " ";
							}
						}

						// Only assign if different to avoid unneeded rendering.
						finalValue = jQuery.trim( cur );
						if ( curValue !== finalValue ) {
							elem.setAttribute( "class", finalValue );
						}
					}
				}
			}

			return this;
		},

		removeClass: function( value ) {
			var classes, elem, cur, curValue, clazz, j, finalValue,
				i = 0;

			if ( jQuery.isFunction( value ) ) {
				return this.each( function( j ) {
					jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
				} );
			}

			if ( !arguments.length ) {
				return this.attr( "class", "" );
			}

			if ( typeof value === "string" && value ) {
				classes = value.match( rnotwhite ) || [];

				while ( ( elem = this[ i++ ] ) ) {
					curValue = getClass( elem );

					// This expression is here for better compressibility (see addClass)
					cur = elem.nodeType === 1 &&
						( " " + curValue + " " ).replace( rclass, " " );

					if ( cur ) {
						j = 0;
						while ( ( clazz = classes[ j++ ] ) ) {

							// Remove *all* instances
							while ( cur.indexOf( " " + clazz + " " ) > -1 ) {
								cur = cur.replace( " " + clazz + " ", " " );
							}
						}

						// Only assign if different to avoid unneeded rendering.
						finalValue = jQuery.trim( cur );
						if ( curValue !== finalValue ) {
							elem.setAttribute( "class", finalValue );
						}
					}
				}
			}

			return this;
		},

		toggleClass: function( value, stateVal ) {
			var type = typeof value;

			if ( typeof stateVal === "boolean" && type === "string" ) {
				return stateVal ? this.addClass( value ) : this.removeClass( value );
			}

			if ( jQuery.isFunction( value ) ) {
				return this.each( function( i ) {
					jQuery( this ).toggleClass(
						value.call( this, i, getClass( this ), stateVal ),
						stateVal
					);
				} );
			}

			return this.each( function() {
				var className, i, self, classNames;

				if ( type === "string" ) {

					// Toggle individual class names
					i = 0;
					self = jQuery( this );
					classNames = value.match( rnotwhite ) || [];

					while ( ( className = classNames[ i++ ] ) ) {

						// Check each className given, space separated list
						if ( self.hasClass( className ) ) {
							self.removeClass( className );
						} else {
							self.addClass( className );
						}
					}

				// Toggle whole class name
				} else if ( value === undefined || type === "boolean" ) {
					className = getClass( this );
					if ( className ) {

						// Store className if set
						dataPriv.set( this, "__className__", className );
					}

					// If the element has a class name or if we're passed `false`,
					// then remove the whole classname (if there was one, the above saved it).
					// Otherwise bring back whatever was previously saved (if anything),
					// falling back to the empty string if nothing was stored.
					if ( this.setAttribute ) {
						this.setAttribute( "class",
							className || value === false ?
							"" :
							dataPriv.get( this, "__className__" ) || ""
						);
					}
				}
			} );
		},

		hasClass: function( selector ) {
			var className, elem,
				i = 0;

			className = " " + selector + " ";
			while ( ( elem = this[ i++ ] ) ) {
				if ( elem.nodeType === 1 &&
					( " " + getClass( elem ) + " " ).replace( rclass, " " )
						.indexOf( className ) > -1
				) {
					return true;
				}
			}

			return false;
		}
	} );




	var rreturn = /\r/g,
		rspaces = /[\x20\t\r\n\f]+/g;

	jQuery.fn.extend( {
		val: function( value ) {
			var hooks, ret, isFunction,
				elem = this[ 0 ];

			if ( !arguments.length ) {
				if ( elem ) {
					hooks = jQuery.valHooks[ elem.type ] ||
						jQuery.valHooks[ elem.nodeName.toLowerCase() ];

					if ( hooks &&
						"get" in hooks &&
						( ret = hooks.get( elem, "value" ) ) !== undefined
					) {
						return ret;
					}

					ret = elem.value;

					return typeof ret === "string" ?

						// Handle most common string cases
						ret.replace( rreturn, "" ) :

						// Handle cases where value is null/undef or number
						ret == null ? "" : ret;
				}

				return;
			}

			isFunction = jQuery.isFunction( value );

			return this.each( function( i ) {
				var val;

				if ( this.nodeType !== 1 ) {
					return;
				}

				if ( isFunction ) {
					val = value.call( this, i, jQuery( this ).val() );
				} else {
					val = value;
				}

				// Treat null/undefined as ""; convert numbers to string
				if ( val == null ) {
					val = "";

				} else if ( typeof val === "number" ) {
					val += "";

				} else if ( jQuery.isArray( val ) ) {
					val = jQuery.map( val, function( value ) {
						return value == null ? "" : value + "";
					} );
				}

				hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

				// If set returns undefined, fall back to normal setting
				if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
					this.value = val;
				}
			} );
		}
	} );

	jQuery.extend( {
		valHooks: {
			option: {
				get: function( elem ) {

					var val = jQuery.find.attr( elem, "value" );
					return val != null ?
						val :

						// Support: IE <=10 - 11 only
						// option.text throws exceptions (#14686, #14858)
						// Strip and collapse whitespace
						// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
						jQuery.trim( jQuery.text( elem ) ).replace( rspaces, " " );
				}
			},
			select: {
				get: function( elem ) {
					var value, option,
						options = elem.options,
						index = elem.selectedIndex,
						one = elem.type === "select-one",
						values = one ? null : [],
						max = one ? index + 1 : options.length,
						i = index < 0 ?
							max :
							one ? index : 0;

					// Loop through all the selected options
					for ( ; i < max; i++ ) {
						option = options[ i ];

						// Support: IE <=9 only
						// IE8-9 doesn't update selected after form reset (#2551)
						if ( ( option.selected || i === index ) &&

								// Don't return options that are disabled or in a disabled optgroup
								!option.disabled &&
								( !option.parentNode.disabled ||
									!jQuery.nodeName( option.parentNode, "optgroup" ) ) ) {

							// Get the specific value for the option
							value = jQuery( option ).val();

							// We don't need an array for one selects
							if ( one ) {
								return value;
							}

							// Multi-Selects return an array
							values.push( value );
						}
					}

					return values;
				},

				set: function( elem, value ) {
					var optionSet, option,
						options = elem.options,
						values = jQuery.makeArray( value ),
						i = options.length;

					while ( i-- ) {
						option = options[ i ];

						/* eslint-disable no-cond-assign */

						if ( option.selected =
							jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
						) {
							optionSet = true;
						}

						/* eslint-enable no-cond-assign */
					}

					// Force browsers to behave consistently when non-matching value is set
					if ( !optionSet ) {
						elem.selectedIndex = -1;
					}
					return values;
				}
			}
		}
	} );

	// Radios and checkboxes getter/setter
	jQuery.each( [ "radio", "checkbox" ], function() {
		jQuery.valHooks[ this ] = {
			set: function( elem, value ) {
				if ( jQuery.isArray( value ) ) {
					return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
				}
			}
		};
		if ( !support.checkOn ) {
			jQuery.valHooks[ this ].get = function( elem ) {
				return elem.getAttribute( "value" ) === null ? "on" : elem.value;
			};
		}
	} );




	// Return jQuery for attributes-only inclusion


	var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/;

	jQuery.extend( jQuery.event, {

		trigger: function( event, data, elem, onlyHandlers ) {

			var i, cur, tmp, bubbleType, ontype, handle, special,
				eventPath = [ elem || document ],
				type = hasOwn.call( event, "type" ) ? event.type : event,
				namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

			cur = tmp = elem = elem || document;

			// Don't do events on text and comment nodes
			if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
				return;
			}

			// focus/blur morphs to focusin/out; ensure we're not firing them right now
			if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
				return;
			}

			if ( type.indexOf( "." ) > -1 ) {

				// Namespaced trigger; create a regexp to match event type in handle()
				namespaces = type.split( "." );
				type = namespaces.shift();
				namespaces.sort();
			}
			ontype = type.indexOf( ":" ) < 0 && "on" + type;

			// Caller can pass in a jQuery.Event object, Object, or just an event type string
			event = event[ jQuery.expando ] ?
				event :
				new jQuery.Event( type, typeof event === "object" && event );

			// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
			event.isTrigger = onlyHandlers ? 2 : 3;
			event.namespace = namespaces.join( "." );
			event.rnamespace = event.namespace ?
				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
				null;

			// Clean up the event in case it is being reused
			event.result = undefined;
			if ( !event.target ) {
				event.target = elem;
			}

			// Clone any incoming data and prepend the event, creating the handler arg list
			data = data == null ?
				[ event ] :
				jQuery.makeArray( data, [ event ] );

			// Allow special events to draw outside the lines
			special = jQuery.event.special[ type ] || {};
			if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
				return;
			}

			// Determine event propagation path in advance, per W3C events spec (#9951)
			// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
			if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {

				bubbleType = special.delegateType || type;
				if ( !rfocusMorph.test( bubbleType + type ) ) {
					cur = cur.parentNode;
				}
				for ( ; cur; cur = cur.parentNode ) {
					eventPath.push( cur );
					tmp = cur;
				}

				// Only add window if we got to document (e.g., not plain obj or detached DOM)
				if ( tmp === ( elem.ownerDocument || document ) ) {
					eventPath.push( tmp.defaultView || tmp.parentWindow || window );
				}
			}

			// Fire handlers on the event path
			i = 0;
			while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {

				event.type = i > 1 ?
					bubbleType :
					special.bindType || type;

				// jQuery handler
				handle = ( dataPriv.get( cur, "events" ) || {} )[ event.type ] &&
					dataPriv.get( cur, "handle" );
				if ( handle ) {
					handle.apply( cur, data );
				}

				// Native handler
				handle = ontype && cur[ ontype ];
				if ( handle && handle.apply && acceptData( cur ) ) {
					event.result = handle.apply( cur, data );
					if ( event.result === false ) {
						event.preventDefault();
					}
				}
			}
			event.type = type;

			// If nobody prevented the default action, do it now
			if ( !onlyHandlers && !event.isDefaultPrevented() ) {

				if ( ( !special._default ||
					special._default.apply( eventPath.pop(), data ) === false ) &&
					acceptData( elem ) ) {

					// Call a native DOM method on the target with the same name as the event.
					// Don't do default actions on window, that's where global variables be (#6170)
					if ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {

						// Don't re-trigger an onFOO event when we call its FOO() method
						tmp = elem[ ontype ];

						if ( tmp ) {
							elem[ ontype ] = null;
						}

						// Prevent re-triggering of the same event, since we already bubbled it above
						jQuery.event.triggered = type;
						elem[ type ]();
						jQuery.event.triggered = undefined;

						if ( tmp ) {
							elem[ ontype ] = tmp;
						}
					}
				}
			}

			return event.result;
		},

		// Piggyback on a donor event to simulate a different one
		// Used only for `focus(in | out)` events
		simulate: function( type, elem, event ) {
			var e = jQuery.extend(
				new jQuery.Event(),
				event,
				{
					type: type,
					isSimulated: true
				}
			);

			jQuery.event.trigger( e, null, elem );
		}

	} );

	jQuery.fn.extend( {

		trigger: function( type, data ) {
			return this.each( function() {
				jQuery.event.trigger( type, data, this );
			} );
		},
		triggerHandler: function( type, data ) {
			var elem = this[ 0 ];
			if ( elem ) {
				return jQuery.event.trigger( type, data, elem, true );
			}
		}
	} );


	jQuery.each( ( "blur focus focusin focusout resize scroll click dblclick " +
		"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
		"change select submit keydown keypress keyup contextmenu" ).split( " " ),
		function( i, name ) {

		// Handle event binding
		jQuery.fn[ name ] = function( data, fn ) {
			return arguments.length > 0 ?
				this.on( name, null, data, fn ) :
				this.trigger( name );
		};
	} );

	jQuery.fn.extend( {
		hover: function( fnOver, fnOut ) {
			return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
		}
	} );




	support.focusin = "onfocusin" in window;


	// Support: Firefox <=44
	// Firefox doesn't have focus(in | out) events
	// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
	//
	// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
	// focus(in | out) events fire after focus & blur events,
	// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
	// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
	if ( !support.focusin ) {
		jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {

			// Attach a single capturing handler on the document while someone wants focusin/focusout
			var handler = function( event ) {
				jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
			};

			jQuery.event.special[ fix ] = {
				setup: function() {
					var doc = this.ownerDocument || this,
						attaches = dataPriv.access( doc, fix );

					if ( !attaches ) {
						doc.addEventListener( orig, handler, true );
					}
					dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );
				},
				teardown: function() {
					var doc = this.ownerDocument || this,
						attaches = dataPriv.access( doc, fix ) - 1;

					if ( !attaches ) {
						doc.removeEventListener( orig, handler, true );
						dataPriv.remove( doc, fix );

					} else {
						dataPriv.access( doc, fix, attaches );
					}
				}
			};
		} );
	}
	var location = window.location;

	var nonce = jQuery.now();

	var rquery = ( /\?/ );



	// Cross-browser xml parsing
	jQuery.parseXML = function( data ) {
		var xml;
		if ( !data || typeof data !== "string" ) {
			return null;
		}

		// Support: IE 9 - 11 only
		// IE throws on parseFromString with invalid input.
		try {
			xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
		} catch ( e ) {
			xml = undefined;
		}

		if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
			jQuery.error( "Invalid XML: " + data );
		}
		return xml;
	};


	var
		rbracket = /\[\]$/,
		rCRLF = /\r?\n/g,
		rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
		rsubmittable = /^(?:input|select|textarea|keygen)/i;

	function buildParams( prefix, obj, traditional, add ) {
		var name;

		if ( jQuery.isArray( obj ) ) {

			// Serialize array item.
			jQuery.each( obj, function( i, v ) {
				if ( traditional || rbracket.test( prefix ) ) {

					// Treat each array item as a scalar.
					add( prefix, v );

				} else {

					// Item is non-scalar (array or object), encode its numeric index.
					buildParams(
						prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
						v,
						traditional,
						add
					);
				}
			} );

		} else if ( !traditional && jQuery.type( obj ) === "object" ) {

			// Serialize object item.
			for ( name in obj ) {
				buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
			}

		} else {

			// Serialize scalar item.
			add( prefix, obj );
		}
	}

	// Serialize an array of form elements or a set of
	// key/values into a query string
	jQuery.param = function( a, traditional ) {
		var prefix,
			s = [],
			add = function( key, valueOrFunction ) {

				// If value is a function, invoke it and use its return value
				var value = jQuery.isFunction( valueOrFunction ) ?
					valueOrFunction() :
					valueOrFunction;

				s[ s.length ] = encodeURIComponent( key ) + "=" +
					encodeURIComponent( value == null ? "" : value );
			};

		// If an array was passed in, assume that it is an array of form elements.
		if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

			// Serialize the form elements
			jQuery.each( a, function() {
				add( this.name, this.value );
			} );

		} else {

			// If traditional, encode the "old" way (the way 1.3.2 or older
			// did it), otherwise encode params recursively.
			for ( prefix in a ) {
				buildParams( prefix, a[ prefix ], traditional, add );
			}
		}

		// Return the resulting serialization
		return s.join( "&" );
	};

	jQuery.fn.extend( {
		serialize: function() {
			return jQuery.param( this.serializeArray() );
		},
		serializeArray: function() {
			return this.map( function() {

				// Can add propHook for "elements" to filter or add form elements
				var elements = jQuery.prop( this, "elements" );
				return elements ? jQuery.makeArray( elements ) : this;
			} )
			.filter( function() {
				var type = this.type;

				// Use .is( ":disabled" ) so that fieldset[disabled] works
				return this.name && !jQuery( this ).is( ":disabled" ) &&
					rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
					( this.checked || !rcheckableType.test( type ) );
			} )
			.map( function( i, elem ) {
				var val = jQuery( this ).val();

				return val == null ?
					null :
					jQuery.isArray( val ) ?
						jQuery.map( val, function( val ) {
							return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
						} ) :
						{ name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
			} ).get();
		}
	} );


	var
		r20 = /%20/g,
		rhash = /#.*$/,
		rts = /([?&])_=[^&]*/,
		rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

		// #7653, #8125, #8152: local protocol detection
		rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
		rnoContent = /^(?:GET|HEAD)$/,
		rprotocol = /^\/\//,

		/* Prefilters
		 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
		 * 2) These are called:
		 *    - BEFORE asking for a transport
		 *    - AFTER param serialization (s.data is a string if s.processData is true)
		 * 3) key is the dataType
		 * 4) the catchall symbol "*" can be used
		 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
		 */
		prefilters = {},

		/* Transports bindings
		 * 1) key is the dataType
		 * 2) the catchall symbol "*" can be used
		 * 3) selection will start with transport dataType and THEN go to "*" if needed
		 */
		transports = {},

		// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
		allTypes = "*/".concat( "*" ),

		// Anchor tag for parsing the document origin
		originAnchor = document.createElement( "a" );
		originAnchor.href = location.href;

	// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
	function addToPrefiltersOrTransports( structure ) {

		// dataTypeExpression is optional and defaults to "*"
		return function( dataTypeExpression, func ) {

			if ( typeof dataTypeExpression !== "string" ) {
				func = dataTypeExpression;
				dataTypeExpression = "*";
			}

			var dataType,
				i = 0,
				dataTypes = dataTypeExpression.toLowerCase().match( rnotwhite ) || [];

			if ( jQuery.isFunction( func ) ) {

				// For each dataType in the dataTypeExpression
				while ( ( dataType = dataTypes[ i++ ] ) ) {

					// Prepend if requested
					if ( dataType[ 0 ] === "+" ) {
						dataType = dataType.slice( 1 ) || "*";
						( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

					// Otherwise append
					} else {
						( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
					}
				}
			}
		};
	}

	// Base inspection function for prefilters and transports
	function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

		var inspected = {},
			seekingTransport = ( structure === transports );

		function inspect( dataType ) {
			var selected;
			inspected[ dataType ] = true;
			jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
				var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
				if ( typeof dataTypeOrTransport === "string" &&
					!seekingTransport && !inspected[ dataTypeOrTransport ] ) {

					options.dataTypes.unshift( dataTypeOrTransport );
					inspect( dataTypeOrTransport );
					return false;
				} else if ( seekingTransport ) {
					return !( selected = dataTypeOrTransport );
				}
			} );
			return selected;
		}

		return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
	}

	// A special extend for ajax options
	// that takes "flat" options (not to be deep extended)
	// Fixes #9887
	function ajaxExtend( target, src ) {
		var key, deep,
			flatOptions = jQuery.ajaxSettings.flatOptions || {};

		for ( key in src ) {
			if ( src[ key ] !== undefined ) {
				( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
			}
		}
		if ( deep ) {
			jQuery.extend( true, target, deep );
		}

		return target;
	}

	/* Handles responses to an ajax request:
	 * - finds the right dataType (mediates between content-type and expected dataType)
	 * - returns the corresponding response
	 */
	function ajaxHandleResponses( s, jqXHR, responses ) {

		var ct, type, finalDataType, firstDataType,
			contents = s.contents,
			dataTypes = s.dataTypes;

		// Remove auto dataType and get content-type in the process
		while ( dataTypes[ 0 ] === "*" ) {
			dataTypes.shift();
			if ( ct === undefined ) {
				ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
			}
		}

		// Check if we're dealing with a known content-type
		if ( ct ) {
			for ( type in contents ) {
				if ( contents[ type ] && contents[ type ].test( ct ) ) {
					dataTypes.unshift( type );
					break;
				}
			}
		}

		// Check to see if we have a response for the expected dataType
		if ( dataTypes[ 0 ] in responses ) {
			finalDataType = dataTypes[ 0 ];
		} else {

			// Try convertible dataTypes
			for ( type in responses ) {
				if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
					finalDataType = type;
					break;
				}
				if ( !firstDataType ) {
					firstDataType = type;
				}
			}

			// Or just use first one
			finalDataType = finalDataType || firstDataType;
		}

		// If we found a dataType
		// We add the dataType to the list if needed
		// and return the corresponding response
		if ( finalDataType ) {
			if ( finalDataType !== dataTypes[ 0 ] ) {
				dataTypes.unshift( finalDataType );
			}
			return responses[ finalDataType ];
		}
	}

	/* Chain conversions given the request and the original response
	 * Also sets the responseXXX fields on the jqXHR instance
	 */
	function ajaxConvert( s, response, jqXHR, isSuccess ) {
		var conv2, current, conv, tmp, prev,
			converters = {},

			// Work with a copy of dataTypes in case we need to modify it for conversion
			dataTypes = s.dataTypes.slice();

		// Create converters map with lowercased keys
		if ( dataTypes[ 1 ] ) {
			for ( conv in s.converters ) {
				converters[ conv.toLowerCase() ] = s.converters[ conv ];
			}
		}

		current = dataTypes.shift();

		// Convert to each sequential dataType
		while ( current ) {

			if ( s.responseFields[ current ] ) {
				jqXHR[ s.responseFields[ current ] ] = response;
			}

			// Apply the dataFilter if provided
			if ( !prev && isSuccess && s.dataFilter ) {
				response = s.dataFilter( response, s.dataType );
			}

			prev = current;
			current = dataTypes.shift();

			if ( current ) {

				// There's only work to do if current dataType is non-auto
				if ( current === "*" ) {

					current = prev;

				// Convert response if prev dataType is non-auto and differs from current
				} else if ( prev !== "*" && prev !== current ) {

					// Seek a direct converter
					conv = converters[ prev + " " + current ] || converters[ "* " + current ];

					// If none found, seek a pair
					if ( !conv ) {
						for ( conv2 in converters ) {

							// If conv2 outputs current
							tmp = conv2.split( " " );
							if ( tmp[ 1 ] === current ) {

								// If prev can be converted to accepted input
								conv = converters[ prev + " " + tmp[ 0 ] ] ||
									converters[ "* " + tmp[ 0 ] ];
								if ( conv ) {

									// Condense equivalence converters
									if ( conv === true ) {
										conv = converters[ conv2 ];

									// Otherwise, insert the intermediate dataType
									} else if ( converters[ conv2 ] !== true ) {
										current = tmp[ 0 ];
										dataTypes.unshift( tmp[ 1 ] );
									}
									break;
								}
							}
						}
					}

					// Apply converter (if not an equivalence)
					if ( conv !== true ) {

						// Unless errors are allowed to bubble, catch and return them
						if ( conv && s.throws ) {
							response = conv( response );
						} else {
							try {
								response = conv( response );
							} catch ( e ) {
								return {
									state: "parsererror",
									error: conv ? e : "No conversion from " + prev + " to " + current
								};
							}
						}
					}
				}
			}
		}

		return { state: "success", data: response };
	}

	jQuery.extend( {

		// Counter for holding the number of active queries
		active: 0,

		// Last-Modified header cache for next request
		lastModified: {},
		etag: {},

		ajaxSettings: {
			url: location.href,
			type: "GET",
			isLocal: rlocalProtocol.test( location.protocol ),
			global: true,
			processData: true,
			async: true,
			contentType: "application/x-www-form-urlencoded; charset=UTF-8",

			/*
			timeout: 0,
			data: null,
			dataType: null,
			username: null,
			password: null,
			cache: null,
			throws: false,
			traditional: false,
			headers: {},
			*/

			accepts: {
				"*": allTypes,
				text: "text/plain",
				html: "text/html",
				xml: "application/xml, text/xml",
				json: "application/json, text/javascript"
			},

			contents: {
				xml: /\bxml\b/,
				html: /\bhtml/,
				json: /\bjson\b/
			},

			responseFields: {
				xml: "responseXML",
				text: "responseText",
				json: "responseJSON"
			},

			// Data converters
			// Keys separate source (or catchall "*") and destination types with a single space
			converters: {

				// Convert anything to text
				"* text": String,

				// Text to html (true = no transformation)
				"text html": true,

				// Evaluate text as a json expression
				"text json": JSON.parse,

				// Parse text as xml
				"text xml": jQuery.parseXML
			},

			// For options that shouldn't be deep extended:
			// you can add your own custom options here if
			// and when you create one that shouldn't be
			// deep extended (see ajaxExtend)
			flatOptions: {
				url: true,
				context: true
			}
		},

		// Creates a full fledged settings object into target
		// with both ajaxSettings and settings fields.
		// If target is omitted, writes into ajaxSettings.
		ajaxSetup: function( target, settings ) {
			return settings ?

				// Building a settings object
				ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

				// Extending ajaxSettings
				ajaxExtend( jQuery.ajaxSettings, target );
		},

		ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
		ajaxTransport: addToPrefiltersOrTransports( transports ),

		// Main method
		ajax: function( url, options ) {

			// If url is an object, simulate pre-1.5 signature
			if ( typeof url === "object" ) {
				options = url;
				url = undefined;
			}

			// Force options to be an object
			options = options || {};

			var transport,

				// URL without anti-cache param
				cacheURL,

				// Response headers
				responseHeadersString,
				responseHeaders,

				// timeout handle
				timeoutTimer,

				// Url cleanup var
				urlAnchor,

				// Request state (becomes false upon send and true upon completion)
				completed,

				// To know if global events are to be dispatched
				fireGlobals,

				// Loop variable
				i,

				// uncached part of the url
				uncached,

				// Create the final options object
				s = jQuery.ajaxSetup( {}, options ),

				// Callbacks context
				callbackContext = s.context || s,

				// Context for global events is callbackContext if it is a DOM node or jQuery collection
				globalEventContext = s.context &&
					( callbackContext.nodeType || callbackContext.jquery ) ?
						jQuery( callbackContext ) :
						jQuery.event,

				// Deferreds
				deferred = jQuery.Deferred(),
				completeDeferred = jQuery.Callbacks( "once memory" ),

				// Status-dependent callbacks
				statusCode = s.statusCode || {},

				// Headers (they are sent all at once)
				requestHeaders = {},
				requestHeadersNames = {},

				// Default abort message
				strAbort = "canceled",

				// Fake xhr
				jqXHR = {
					readyState: 0,

					// Builds headers hashtable if needed
					getResponseHeader: function( key ) {
						var match;
						if ( completed ) {
							if ( !responseHeaders ) {
								responseHeaders = {};
								while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
									responseHeaders[ match[ 1 ].toLowerCase() ] = match[ 2 ];
								}
							}
							match = responseHeaders[ key.toLowerCase() ];
						}
						return match == null ? null : match;
					},

					// Raw string
					getAllResponseHeaders: function() {
						return completed ? responseHeadersString : null;
					},

					// Caches the header
					setRequestHeader: function( name, value ) {
						if ( completed == null ) {
							name = requestHeadersNames[ name.toLowerCase() ] =
								requestHeadersNames[ name.toLowerCase() ] || name;
							requestHeaders[ name ] = value;
						}
						return this;
					},

					// Overrides response content-type header
					overrideMimeType: function( type ) {
						if ( completed == null ) {
							s.mimeType = type;
						}
						return this;
					},

					// Status-dependent callbacks
					statusCode: function( map ) {
						var code;
						if ( map ) {
							if ( completed ) {

								// Execute the appropriate callbacks
								jqXHR.always( map[ jqXHR.status ] );
							} else {

								// Lazy-add the new callbacks in a way that preserves old ones
								for ( code in map ) {
									statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
								}
							}
						}
						return this;
					},

					// Cancel the request
					abort: function( statusText ) {
						var finalText = statusText || strAbort;
						if ( transport ) {
							transport.abort( finalText );
						}
						done( 0, finalText );
						return this;
					}
				};

			// Attach deferreds
			deferred.promise( jqXHR );

			// Add protocol if not provided (prefilters might expect it)
			// Handle falsy url in the settings object (#10093: consistency with old signature)
			// We also use the url parameter if available
			s.url = ( ( url || s.url || location.href ) + "" )
				.replace( rprotocol, location.protocol + "//" );

			// Alias method option to type as per ticket #12004
			s.type = options.method || options.type || s.method || s.type;

			// Extract dataTypes list
			s.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnotwhite ) || [ "" ];

			// A cross-domain request is in order when the origin doesn't match the current origin.
			if ( s.crossDomain == null ) {
				urlAnchor = document.createElement( "a" );

				// Support: IE <=8 - 11, Edge 12 - 13
				// IE throws exception on accessing the href property if url is malformed,
				// e.g. http://example.com:80x/
				try {
					urlAnchor.href = s.url;

					// Support: IE <=8 - 11 only
					// Anchor's host property isn't correctly set when s.url is relative
					urlAnchor.href = urlAnchor.href;
					s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
						urlAnchor.protocol + "//" + urlAnchor.host;
				} catch ( e ) {

					// If there is an error parsing the URL, assume it is crossDomain,
					// it can be rejected by the transport if it is invalid
					s.crossDomain = true;
				}
			}

			// Convert data if not already a string
			if ( s.data && s.processData && typeof s.data !== "string" ) {
				s.data = jQuery.param( s.data, s.traditional );
			}

			// Apply prefilters
			inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

			// If request was aborted inside a prefilter, stop there
			if ( completed ) {
				return jqXHR;
			}

			// We can fire global events as of now if asked to
			// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
			fireGlobals = jQuery.event && s.global;

			// Watch for a new set of requests
			if ( fireGlobals && jQuery.active++ === 0 ) {
				jQuery.event.trigger( "ajaxStart" );
			}

			// Uppercase the type
			s.type = s.type.toUpperCase();

			// Determine if request has content
			s.hasContent = !rnoContent.test( s.type );

			// Save the URL in case we're toying with the If-Modified-Since
			// and/or If-None-Match header later on
			// Remove hash to simplify url manipulation
			cacheURL = s.url.replace( rhash, "" );

			// More options handling for requests with no content
			if ( !s.hasContent ) {

				// Remember the hash so we can put it back
				uncached = s.url.slice( cacheURL.length );

				// If data is available, append data to url
				if ( s.data ) {
					cacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;

					// #9682: remove data so that it's not used in an eventual retry
					delete s.data;
				}

				// Add anti-cache in uncached url if needed
				if ( s.cache === false ) {
					cacheURL = cacheURL.replace( rts, "" );
					uncached = ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ( nonce++ ) + uncached;
				}

				// Put hash and anti-cache on the URL that will be requested (gh-1732)
				s.url = cacheURL + uncached;

			// Change '%20' to '+' if this is encoded form body content (gh-2658)
			} else if ( s.data && s.processData &&
				( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {
				s.data = s.data.replace( r20, "+" );
			}

			// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
			if ( s.ifModified ) {
				if ( jQuery.lastModified[ cacheURL ] ) {
					jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
				}
				if ( jQuery.etag[ cacheURL ] ) {
					jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
				}
			}

			// Set the correct header, if data is being sent
			if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
				jqXHR.setRequestHeader( "Content-Type", s.contentType );
			}

			// Set the Accepts header for the server, depending on the dataType
			jqXHR.setRequestHeader(
				"Accept",
				s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
					s.accepts[ s.dataTypes[ 0 ] ] +
						( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
					s.accepts[ "*" ]
			);

			// Check for headers option
			for ( i in s.headers ) {
				jqXHR.setRequestHeader( i, s.headers[ i ] );
			}

			// Allow custom headers/mimetypes and early abort
			if ( s.beforeSend &&
				( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {

				// Abort if not done already and return
				return jqXHR.abort();
			}

			// Aborting is no longer a cancellation
			strAbort = "abort";

			// Install callbacks on deferreds
			completeDeferred.add( s.complete );
			jqXHR.done( s.success );
			jqXHR.fail( s.error );

			// Get transport
			transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

			// If no transport, we auto-abort
			if ( !transport ) {
				done( -1, "No Transport" );
			} else {
				jqXHR.readyState = 1;

				// Send global event
				if ( fireGlobals ) {
					globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
				}

				// If request was aborted inside ajaxSend, stop there
				if ( completed ) {
					return jqXHR;
				}

				// Timeout
				if ( s.async && s.timeout > 0 ) {
					timeoutTimer = window.setTimeout( function() {
						jqXHR.abort( "timeout" );
					}, s.timeout );
				}

				try {
					completed = false;
					transport.send( requestHeaders, done );
				} catch ( e ) {

					// Rethrow post-completion exceptions
					if ( completed ) {
						throw e;
					}

					// Propagate others as results
					done( -1, e );
				}
			}

			// Callback for when everything is done
			function done( status, nativeStatusText, responses, headers ) {
				var isSuccess, success, error, response, modified,
					statusText = nativeStatusText;

				// Ignore repeat invocations
				if ( completed ) {
					return;
				}

				completed = true;

				// Clear timeout if it exists
				if ( timeoutTimer ) {
					window.clearTimeout( timeoutTimer );
				}

				// Dereference transport for early garbage collection
				// (no matter how long the jqXHR object will be used)
				transport = undefined;

				// Cache response headers
				responseHeadersString = headers || "";

				// Set readyState
				jqXHR.readyState = status > 0 ? 4 : 0;

				// Determine if successful
				isSuccess = status >= 200 && status < 300 || status === 304;

				// Get response data
				if ( responses ) {
					response = ajaxHandleResponses( s, jqXHR, responses );
				}

				// Convert no matter what (that way responseXXX fields are always set)
				response = ajaxConvert( s, response, jqXHR, isSuccess );

				// If successful, handle type chaining
				if ( isSuccess ) {

					// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
					if ( s.ifModified ) {
						modified = jqXHR.getResponseHeader( "Last-Modified" );
						if ( modified ) {
							jQuery.lastModified[ cacheURL ] = modified;
						}
						modified = jqXHR.getResponseHeader( "etag" );
						if ( modified ) {
							jQuery.etag[ cacheURL ] = modified;
						}
					}

					// if no content
					if ( status === 204 || s.type === "HEAD" ) {
						statusText = "nocontent";

					// if not modified
					} else if ( status === 304 ) {
						statusText = "notmodified";

					// If we have data, let's convert it
					} else {
						statusText = response.state;
						success = response.data;
						error = response.error;
						isSuccess = !error;
					}
				} else {

					// Extract error from statusText and normalize for non-aborts
					error = statusText;
					if ( status || !statusText ) {
						statusText = "error";
						if ( status < 0 ) {
							status = 0;
						}
					}
				}

				// Set data for the fake xhr object
				jqXHR.status = status;
				jqXHR.statusText = ( nativeStatusText || statusText ) + "";

				// Success/Error
				if ( isSuccess ) {
					deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
				} else {
					deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
				}

				// Status-dependent callbacks
				jqXHR.statusCode( statusCode );
				statusCode = undefined;

				if ( fireGlobals ) {
					globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
						[ jqXHR, s, isSuccess ? success : error ] );
				}

				// Complete
				completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

				if ( fireGlobals ) {
					globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

					// Handle the global AJAX counter
					if ( !( --jQuery.active ) ) {
						jQuery.event.trigger( "ajaxStop" );
					}
				}
			}

			return jqXHR;
		},

		getJSON: function( url, data, callback ) {
			return jQuery.get( url, data, callback, "json" );
		},

		getScript: function( url, callback ) {
			return jQuery.get( url, undefined, callback, "script" );
		}
	} );

	jQuery.each( [ "get", "post" ], function( i, method ) {
		jQuery[ method ] = function( url, data, callback, type ) {

			// Shift arguments if data argument was omitted
			if ( jQuery.isFunction( data ) ) {
				type = type || callback;
				callback = data;
				data = undefined;
			}

			// The url can be an options object (which then must have .url)
			return jQuery.ajax( jQuery.extend( {
				url: url,
				type: method,
				dataType: type,
				data: data,
				success: callback
			}, jQuery.isPlainObject( url ) && url ) );
		};
	} );


	jQuery._evalUrl = function( url ) {
		return jQuery.ajax( {
			url: url,

			// Make this explicit, since user can override this through ajaxSetup (#11264)
			type: "GET",
			dataType: "script",
			cache: true,
			async: false,
			global: false,
			"throws": true
		} );
	};


	jQuery.fn.extend( {
		wrapAll: function( html ) {
			var wrap;

			if ( this[ 0 ] ) {
				if ( jQuery.isFunction( html ) ) {
					html = html.call( this[ 0 ] );
				}

				// The elements to wrap the target around
				wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

				if ( this[ 0 ].parentNode ) {
					wrap.insertBefore( this[ 0 ] );
				}

				wrap.map( function() {
					var elem = this;

					while ( elem.firstElementChild ) {
						elem = elem.firstElementChild;
					}

					return elem;
				} ).append( this );
			}

			return this;
		},

		wrapInner: function( html ) {
			if ( jQuery.isFunction( html ) ) {
				return this.each( function( i ) {
					jQuery( this ).wrapInner( html.call( this, i ) );
				} );
			}

			return this.each( function() {
				var self = jQuery( this ),
					contents = self.contents();

				if ( contents.length ) {
					contents.wrapAll( html );

				} else {
					self.append( html );
				}
			} );
		},

		wrap: function( html ) {
			var isFunction = jQuery.isFunction( html );

			return this.each( function( i ) {
				jQuery( this ).wrapAll( isFunction ? html.call( this, i ) : html );
			} );
		},

		unwrap: function( selector ) {
			this.parent( selector ).not( "body" ).each( function() {
				jQuery( this ).replaceWith( this.childNodes );
			} );
			return this;
		}
	} );


	jQuery.expr.pseudos.hidden = function( elem ) {
		return !jQuery.expr.pseudos.visible( elem );
	};
	jQuery.expr.pseudos.visible = function( elem ) {
		return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
	};




	jQuery.ajaxSettings.xhr = function() {
		try {
			return new window.XMLHttpRequest();
		} catch ( e ) {}
	};

	var xhrSuccessStatus = {

			// File protocol always yields status code 0, assume 200
			0: 200,

			// Support: IE <=9 only
			// #1450: sometimes IE returns 1223 when it should be 204
			1223: 204
		},
		xhrSupported = jQuery.ajaxSettings.xhr();

	support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
	support.ajax = xhrSupported = !!xhrSupported;

	jQuery.ajaxTransport( function( options ) {
		var callback, errorCallback;

		// Cross domain only allowed if supported through XMLHttpRequest
		if ( support.cors || xhrSupported && !options.crossDomain ) {
			return {
				send: function( headers, complete ) {
					var i,
						xhr = options.xhr();

					xhr.open(
						options.type,
						options.url,
						options.async,
						options.username,
						options.password
					);

					// Apply custom fields if provided
					if ( options.xhrFields ) {
						for ( i in options.xhrFields ) {
							xhr[ i ] = options.xhrFields[ i ];
						}
					}

					// Override mime type if needed
					if ( options.mimeType && xhr.overrideMimeType ) {
						xhr.overrideMimeType( options.mimeType );
					}

					// X-Requested-With header
					// For cross-domain requests, seeing as conditions for a preflight are
					// akin to a jigsaw puzzle, we simply never set it to be sure.
					// (it can always be set on a per-request basis or even using ajaxSetup)
					// For same-domain requests, won't change header if already provided.
					if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
						headers[ "X-Requested-With" ] = "XMLHttpRequest";
					}

					// Set headers
					for ( i in headers ) {
						xhr.setRequestHeader( i, headers[ i ] );
					}

					// Callback
					callback = function( type ) {
						return function() {
							if ( callback ) {
								callback = errorCallback = xhr.onload =
									xhr.onerror = xhr.onabort = xhr.onreadystatechange = null;

								if ( type === "abort" ) {
									xhr.abort();
								} else if ( type === "error" ) {

									// Support: IE <=9 only
									// On a manual native abort, IE9 throws
									// errors on any property access that is not readyState
									if ( typeof xhr.status !== "number" ) {
										complete( 0, "error" );
									} else {
										complete(

											// File: protocol always yields status 0; see #8605, #14207
											xhr.status,
											xhr.statusText
										);
									}
								} else {
									complete(
										xhrSuccessStatus[ xhr.status ] || xhr.status,
										xhr.statusText,

										// Support: IE <=9 only
										// IE9 has no XHR2 but throws on binary (trac-11426)
										// For XHR2 non-text, let the caller handle it (gh-2498)
										( xhr.responseType || "text" ) !== "text"  ||
										typeof xhr.responseText !== "string" ?
											{ binary: xhr.response } :
											{ text: xhr.responseText },
										xhr.getAllResponseHeaders()
									);
								}
							}
						};
					};

					// Listen to events
					xhr.onload = callback();
					errorCallback = xhr.onerror = callback( "error" );

					// Support: IE 9 only
					// Use onreadystatechange to replace onabort
					// to handle uncaught aborts
					if ( xhr.onabort !== undefined ) {
						xhr.onabort = errorCallback;
					} else {
						xhr.onreadystatechange = function() {

							// Check readyState before timeout as it changes
							if ( xhr.readyState === 4 ) {

								// Allow onerror to be called first,
								// but that will not handle a native abort
								// Also, save errorCallback to a variable
								// as xhr.onerror cannot be accessed
								window.setTimeout( function() {
									if ( callback ) {
										errorCallback();
									}
								} );
							}
						};
					}

					// Create the abort callback
					callback = callback( "abort" );

					try {

						// Do send the request (this may raise an exception)
						xhr.send( options.hasContent && options.data || null );
					} catch ( e ) {

						// #14683: Only rethrow if this hasn't been notified as an error yet
						if ( callback ) {
							throw e;
						}
					}
				},

				abort: function() {
					if ( callback ) {
						callback();
					}
				}
			};
		}
	} );




	// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
	jQuery.ajaxPrefilter( function( s ) {
		if ( s.crossDomain ) {
			s.contents.script = false;
		}
	} );

	// Install script dataType
	jQuery.ajaxSetup( {
		accepts: {
			script: "text/javascript, application/javascript, " +
				"application/ecmascript, application/x-ecmascript"
		},
		contents: {
			script: /\b(?:java|ecma)script\b/
		},
		converters: {
			"text script": function( text ) {
				jQuery.globalEval( text );
				return text;
			}
		}
	} );

	// Handle cache's special case and crossDomain
	jQuery.ajaxPrefilter( "script", function( s ) {
		if ( s.cache === undefined ) {
			s.cache = false;
		}
		if ( s.crossDomain ) {
			s.type = "GET";
		}
	} );

	// Bind script tag hack transport
	jQuery.ajaxTransport( "script", function( s ) {

		// This transport only deals with cross domain requests
		if ( s.crossDomain ) {
			var script, callback;
			return {
				send: function( _, complete ) {
					script = jQuery( "<script>" ).prop( {
						charset: s.scriptCharset,
						src: s.url
					} ).on(
						"load error",
						callback = function( evt ) {
							script.remove();
							callback = null;
							if ( evt ) {
								complete( evt.type === "error" ? 404 : 200, evt.type );
							}
						}
					);

					// Use native DOM manipulation to avoid our domManip AJAX trickery
					document.head.appendChild( script[ 0 ] );
				},
				abort: function() {
					if ( callback ) {
						callback();
					}
				}
			};
		}
	} );




	var oldCallbacks = [],
		rjsonp = /(=)\?(?=&|$)|\?\?/;

	// Default jsonp settings
	jQuery.ajaxSetup( {
		jsonp: "callback",
		jsonpCallback: function() {
			var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
			this[ callback ] = true;
			return callback;
		}
	} );

	// Detect, normalize options and install callbacks for jsonp requests
	jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

		var callbackName, overwritten, responseContainer,
			jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
				"url" :
				typeof s.data === "string" &&
					( s.contentType || "" )
						.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
					rjsonp.test( s.data ) && "data"
			);

		// Handle iff the expected data type is "jsonp" or we have a parameter to set
		if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

			// Get callback name, remembering preexisting value associated with it
			callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
				s.jsonpCallback() :
				s.jsonpCallback;

			// Insert callback into url or form data
			if ( jsonProp ) {
				s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
			} else if ( s.jsonp !== false ) {
				s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
			}

			// Use data converter to retrieve json after script execution
			s.converters[ "script json" ] = function() {
				if ( !responseContainer ) {
					jQuery.error( callbackName + " was not called" );
				}
				return responseContainer[ 0 ];
			};

			// Force json dataType
			s.dataTypes[ 0 ] = "json";

			// Install callback
			overwritten = window[ callbackName ];
			window[ callbackName ] = function() {
				responseContainer = arguments;
			};

			// Clean-up function (fires after converters)
			jqXHR.always( function() {

				// If previous value didn't exist - remove it
				if ( overwritten === undefined ) {
					jQuery( window ).removeProp( callbackName );

				// Otherwise restore preexisting value
				} else {
					window[ callbackName ] = overwritten;
				}

				// Save back as free
				if ( s[ callbackName ] ) {

					// Make sure that re-using the options doesn't screw things around
					s.jsonpCallback = originalSettings.jsonpCallback;

					// Save the callback name for future use
					oldCallbacks.push( callbackName );
				}

				// Call if it was a function and we have a response
				if ( responseContainer && jQuery.isFunction( overwritten ) ) {
					overwritten( responseContainer[ 0 ] );
				}

				responseContainer = overwritten = undefined;
			} );

			// Delegate to script
			return "script";
		}
	} );




	// Support: Safari 8 only
	// In Safari 8 documents created via document.implementation.createHTMLDocument
	// collapse sibling forms: the second one becomes a child of the first one.
	// Because of that, this security measure has to be disabled in Safari 8.
	// https://bugs.webkit.org/show_bug.cgi?id=137337
	support.createHTMLDocument = ( function() {
		var body = document.implementation.createHTMLDocument( "" ).body;
		body.innerHTML = "<form></form><form></form>";
		return body.childNodes.length === 2;
	} )();


	// Argument "data" should be string of html
	// context (optional): If specified, the fragment will be created in this context,
	// defaults to document
	// keepScripts (optional): If true, will include scripts passed in the html string
	jQuery.parseHTML = function( data, context, keepScripts ) {
		if ( typeof data !== "string" ) {
			return [];
		}
		if ( typeof context === "boolean" ) {
			keepScripts = context;
			context = false;
		}

		var base, parsed, scripts;

		if ( !context ) {

			// Stop scripts or inline event handlers from being executed immediately
			// by using document.implementation
			if ( support.createHTMLDocument ) {
				context = document.implementation.createHTMLDocument( "" );

				// Set the base href for the created document
				// so any parsed elements with URLs
				// are based on the document's URL (gh-2965)
				base = context.createElement( "base" );
				base.href = document.location.href;
				context.head.appendChild( base );
			} else {
				context = document;
			}
		}

		parsed = rsingleTag.exec( data );
		scripts = !keepScripts && [];

		// Single tag
		if ( parsed ) {
			return [ context.createElement( parsed[ 1 ] ) ];
		}

		parsed = buildFragment( [ data ], context, scripts );

		if ( scripts && scripts.length ) {
			jQuery( scripts ).remove();
		}

		return jQuery.merge( [], parsed.childNodes );
	};


	/**
	 * Load a url into a page
	 */
	jQuery.fn.load = function( url, params, callback ) {
		var selector, type, response,
			self = this,
			off = url.indexOf( " " );

		if ( off > -1 ) {
			selector = jQuery.trim( url.slice( off ) );
			url = url.slice( 0, off );
		}

		// If it's a function
		if ( jQuery.isFunction( params ) ) {

			// We assume that it's the callback
			callback = params;
			params = undefined;

		// Otherwise, build a param string
		} else if ( params && typeof params === "object" ) {
			type = "POST";
		}

		// If we have elements to modify, make the request
		if ( self.length > 0 ) {
			jQuery.ajax( {
				url: url,

				// If "type" variable is undefined, then "GET" method will be used.
				// Make value of this field explicit since
				// user can override it through ajaxSetup method
				type: type || "GET",
				dataType: "html",
				data: params
			} ).done( function( responseText ) {

				// Save response for use in complete callback
				response = arguments;

				self.html( selector ?

					// If a selector was specified, locate the right elements in a dummy div
					// Exclude scripts to avoid IE 'Permission Denied' errors
					jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

					// Otherwise use the full result
					responseText );

			// If the request succeeds, this function gets "data", "status", "jqXHR"
			// but they are ignored because response was set above.
			// If it fails, this function gets "jqXHR", "status", "error"
			} ).always( callback && function( jqXHR, status ) {
				self.each( function() {
					callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
				} );
			} );
		}

		return this;
	};




	// Attach a bunch of functions for handling common AJAX events
	jQuery.each( [
		"ajaxStart",
		"ajaxStop",
		"ajaxComplete",
		"ajaxError",
		"ajaxSuccess",
		"ajaxSend"
	], function( i, type ) {
		jQuery.fn[ type ] = function( fn ) {
			return this.on( type, fn );
		};
	} );




	jQuery.expr.pseudos.animated = function( elem ) {
		return jQuery.grep( jQuery.timers, function( fn ) {
			return elem === fn.elem;
		} ).length;
	};




	/**
	 * Gets a window from an element
	 */
	function getWindow( elem ) {
		return jQuery.isWindow( elem ) ? elem : elem.nodeType === 9 && elem.defaultView;
	}

	jQuery.offset = {
		setOffset: function( elem, options, i ) {
			var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
				position = jQuery.css( elem, "position" ),
				curElem = jQuery( elem ),
				props = {};

			// Set position first, in-case top/left are set even on static elem
			if ( position === "static" ) {
				elem.style.position = "relative";
			}

			curOffset = curElem.offset();
			curCSSTop = jQuery.css( elem, "top" );
			curCSSLeft = jQuery.css( elem, "left" );
			calculatePosition = ( position === "absolute" || position === "fixed" ) &&
				( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

			// Need to be able to calculate position if either
			// top or left is auto and position is either absolute or fixed
			if ( calculatePosition ) {
				curPosition = curElem.position();
				curTop = curPosition.top;
				curLeft = curPosition.left;

			} else {
				curTop = parseFloat( curCSSTop ) || 0;
				curLeft = parseFloat( curCSSLeft ) || 0;
			}

			if ( jQuery.isFunction( options ) ) {

				// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
				options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
			}

			if ( options.top != null ) {
				props.top = ( options.top - curOffset.top ) + curTop;
			}
			if ( options.left != null ) {
				props.left = ( options.left - curOffset.left ) + curLeft;
			}

			if ( "using" in options ) {
				options.using.call( elem, props );

			} else {
				curElem.css( props );
			}
		}
	};

	jQuery.fn.extend( {
		offset: function( options ) {

			// Preserve chaining for setter
			if ( arguments.length ) {
				return options === undefined ?
					this :
					this.each( function( i ) {
						jQuery.offset.setOffset( this, options, i );
					} );
			}

			var docElem, win, rect, doc,
				elem = this[ 0 ];

			if ( !elem ) {
				return;
			}

			// Support: IE <=11 only
			// Running getBoundingClientRect on a
			// disconnected node in IE throws an error
			if ( !elem.getClientRects().length ) {
				return { top: 0, left: 0 };
			}

			rect = elem.getBoundingClientRect();

			// Make sure element is not hidden (display: none)
			if ( rect.width || rect.height ) {
				doc = elem.ownerDocument;
				win = getWindow( doc );
				docElem = doc.documentElement;

				return {
					top: rect.top + win.pageYOffset - docElem.clientTop,
					left: rect.left + win.pageXOffset - docElem.clientLeft
				};
			}

			// Return zeros for disconnected and hidden elements (gh-2310)
			return rect;
		},

		position: function() {
			if ( !this[ 0 ] ) {
				return;
			}

			var offsetParent, offset,
				elem = this[ 0 ],
				parentOffset = { top: 0, left: 0 };

			// Fixed elements are offset from window (parentOffset = {top:0, left: 0},
			// because it is its only offset parent
			if ( jQuery.css( elem, "position" ) === "fixed" ) {

				// Assume getBoundingClientRect is there when computed position is fixed
				offset = elem.getBoundingClientRect();

			} else {

				// Get *real* offsetParent
				offsetParent = this.offsetParent();

				// Get correct offsets
				offset = this.offset();
				if ( !jQuery.nodeName( offsetParent[ 0 ], "html" ) ) {
					parentOffset = offsetParent.offset();
				}

				// Add offsetParent borders
				parentOffset = {
					top: parentOffset.top + jQuery.css( offsetParent[ 0 ], "borderTopWidth", true ),
					left: parentOffset.left + jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true )
				};
			}

			// Subtract parent offsets and element margins
			return {
				top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
				left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
			};
		},

		// This method will return documentElement in the following cases:
		// 1) For the element inside the iframe without offsetParent, this method will return
		//    documentElement of the parent window
		// 2) For the hidden or detached element
		// 3) For body or html element, i.e. in case of the html node - it will return itself
		//
		// but those exceptions were never presented as a real life use-cases
		// and might be considered as more preferable results.
		//
		// This logic, however, is not guaranteed and can change at any point in the future
		offsetParent: function() {
			return this.map( function() {
				var offsetParent = this.offsetParent;

				while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
					offsetParent = offsetParent.offsetParent;
				}

				return offsetParent || documentElement;
			} );
		}
	} );

	// Create scrollLeft and scrollTop methods
	jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
		var top = "pageYOffset" === prop;

		jQuery.fn[ method ] = function( val ) {
			return access( this, function( elem, method, val ) {
				var win = getWindow( elem );

				if ( val === undefined ) {
					return win ? win[ prop ] : elem[ method ];
				}

				if ( win ) {
					win.scrollTo(
						!top ? val : win.pageXOffset,
						top ? val : win.pageYOffset
					);

				} else {
					elem[ method ] = val;
				}
			}, method, val, arguments.length );
		};
	} );

	// Support: Safari <=7 - 9.1, Chrome <=37 - 49
	// Add the top/left cssHooks using jQuery.fn.position
	// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
	// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
	// getComputedStyle returns percent when specified for top/left/bottom/right;
	// rather than make the css module depend on the offset module, just check for it here
	jQuery.each( [ "top", "left" ], function( i, prop ) {
		jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
			function( elem, computed ) {
				if ( computed ) {
					computed = curCSS( elem, prop );

					// If curCSS returns percentage, fallback to offset
					return rnumnonpx.test( computed ) ?
						jQuery( elem ).position()[ prop ] + "px" :
						computed;
				}
			}
		);
	} );


	// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
	jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
		jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name },
			function( defaultExtra, funcName ) {

			// Margin is only for outerHeight, outerWidth
			jQuery.fn[ funcName ] = function( margin, value ) {
				var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
					extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

				return access( this, function( elem, type, value ) {
					var doc;

					if ( jQuery.isWindow( elem ) ) {

						// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
						return funcName.indexOf( "outer" ) === 0 ?
							elem[ "inner" + name ] :
							elem.document.documentElement[ "client" + name ];
					}

					// Get document width or height
					if ( elem.nodeType === 9 ) {
						doc = elem.documentElement;

						// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
						// whichever is greatest
						return Math.max(
							elem.body[ "scroll" + name ], doc[ "scroll" + name ],
							elem.body[ "offset" + name ], doc[ "offset" + name ],
							doc[ "client" + name ]
						);
					}

					return value === undefined ?

						// Get width or height on the element, requesting but not forcing parseFloat
						jQuery.css( elem, type, extra ) :

						// Set width or height on the element
						jQuery.style( elem, type, value, extra );
				}, type, chainable ? margin : undefined, chainable );
			};
		} );
	} );


	jQuery.fn.extend( {

		bind: function( types, data, fn ) {
			return this.on( types, null, data, fn );
		},
		unbind: function( types, fn ) {
			return this.off( types, null, fn );
		},

		delegate: function( selector, types, data, fn ) {
			return this.on( types, selector, data, fn );
		},
		undelegate: function( selector, types, fn ) {

			// ( namespace ) or ( selector, types [, fn] )
			return arguments.length === 1 ?
				this.off( selector, "**" ) :
				this.off( types, selector || "**", fn );
		}
	} );

	jQuery.parseJSON = JSON.parse;




	// Register as a named AMD module, since jQuery can be concatenated with other
	// files that may use define, but not via a proper concatenation script that
	// understands anonymous AMD modules. A named AMD is safest and most robust
	// way to register. Lowercase jquery is used because AMD module names are
	// derived from file names, and jQuery is normally delivered in a lowercase
	// file name. Do this after creating the global so that if an AMD module wants
	// to call noConflict to hide this version of jQuery, it will work.

	// Note that for maximum portability, libraries that are not jQuery should
	// declare themselves as anonymous modules, and avoid setting a global if an
	// AMD loader is present. jQuery is a special case. For more information, see
	// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

	if ( true ) {
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
			return jQuery;
		}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}





	var

		// Map over jQuery in case of overwrite
		_jQuery = window.jQuery,

		// Map over the $ in case of overwrite
		_$ = window.$;

	jQuery.noConflict = function( deep ) {
		if ( window.$ === jQuery ) {
			window.$ = _$;
		}

		if ( deep && window.jQuery === jQuery ) {
			window.jQuery = _jQuery;
		}

		return jQuery;
	};

	// Expose jQuery and $ identifiers, even in AMD
	// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
	// and CommonJS for browser emulators (#13566)
	if ( !noGlobal ) {
		window.jQuery = window.$ = jQuery;
	}


	return jQuery;
	} );


/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * jQuery UI Spinner 1.12.0
	 * http://jqueryui.com
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license.
	 * http://jquery.org/license
	 */

	//>>label: Spinner
	//>>group: Widgets
	//>>description: Displays buttons to easily input numbers via the keyboard or mouse.
	//>>docs: http://api.jqueryui.com/spinner/
	//>>demos: http://jqueryui.com/spinner/
	//>>css.structure: ../../themes/base/core.css
	//>>css.structure: ../../themes/base/spinner.css
	//>>css.theme: ../../themes/base/theme.css

	( function( factory ) {
		if ( true ) {

			// AMD. Register as an anonymous module.
			!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
				__webpack_require__(1),
				__webpack_require__(3),
				__webpack_require__(6),
				__webpack_require__(12),
				__webpack_require__(13),
				__webpack_require__(5)
			], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else {

			// Browser globals
			factory( jQuery );
		}
	}( function( $ ) {

	function spinnerModifer( fn ) {
		return function() {
			var previous = this.element.val();
			fn.apply( this, arguments );
			this._refresh();
			if ( previous !== this.element.val() ) {
				this._trigger( "change" );
			}
		};
	}

	$.widget( "ui.spinner", {
		version: "1.12.0",
		defaultElement: "<input>",
		widgetEventPrefix: "spin",
		options: {
			classes: {
				"ui-spinner": "ui-corner-all",
				"ui-spinner-down": "ui-corner-br",
				"ui-spinner-up": "ui-corner-tr"
			},
			culture: null,
			icons: {
				down: "ui-icon-triangle-1-s",
				up: "ui-icon-triangle-1-n"
			},
			incremental: true,
			max: null,
			min: null,
			numberFormat: null,
			page: 10,
			step: 1,

			change: null,
			spin: null,
			start: null,
			stop: null
		},

		_create: function() {

			// handle string values that need to be parsed
			this._setOption( "max", this.options.max );
			this._setOption( "min", this.options.min );
			this._setOption( "step", this.options.step );

			// Only format if there is a value, prevents the field from being marked
			// as invalid in Firefox, see #9573.
			if ( this.value() !== "" ) {

				// Format the value, but don't constrain.
				this._value( this.element.val(), true );
			}

			this._draw();
			this._on( this._events );
			this._refresh();

			// Turning off autocomplete prevents the browser from remembering the
			// value when navigating through history, so we re-enable autocomplete
			// if the page is unloaded before the widget is destroyed. #7790
			this._on( this.window, {
				beforeunload: function() {
					this.element.removeAttr( "autocomplete" );
				}
			} );
		},

		_getCreateOptions: function() {
			var options = this._super();
			var element = this.element;

			$.each( [ "min", "max", "step" ], function( i, option ) {
				var value = element.attr( option );
				if ( value != null && value.length ) {
					options[ option ] = value;
				}
			} );

			return options;
		},

		_events: {
			keydown: function( event ) {
				if ( this._start( event ) && this._keydown( event ) ) {
					event.preventDefault();
				}
			},
			keyup: "_stop",
			focus: function() {
				this.previous = this.element.val();
			},
			blur: function( event ) {
				if ( this.cancelBlur ) {
					delete this.cancelBlur;
					return;
				}

				this._stop();
				this._refresh();
				if ( this.previous !== this.element.val() ) {
					this._trigger( "change", event );
				}
			},
			mousewheel: function( event, delta ) {
				if ( !delta ) {
					return;
				}
				if ( !this.spinning && !this._start( event ) ) {
					return false;
				}

				this._spin( ( delta > 0 ? 1 : -1 ) * this.options.step, event );
				clearTimeout( this.mousewheelTimer );
				this.mousewheelTimer = this._delay( function() {
					if ( this.spinning ) {
						this._stop( event );
					}
				}, 100 );
				event.preventDefault();
			},
			"mousedown .ui-spinner-button": function( event ) {
				var previous;

				// We never want the buttons to have focus; whenever the user is
				// interacting with the spinner, the focus should be on the input.
				// If the input is focused then this.previous is properly set from
				// when the input first received focus. If the input is not focused
				// then we need to set this.previous based on the value before spinning.
				previous = this.element[ 0 ] === $.ui.safeActiveElement( this.document[ 0 ] ) ?
					this.previous : this.element.val();
				function checkFocus() {
					var isActive = this.element[ 0 ] === $.ui.safeActiveElement( this.document[ 0 ] );
					if ( !isActive ) {
						this.element.trigger( "focus" );
						this.previous = previous;

						// support: IE
						// IE sets focus asynchronously, so we need to check if focus
						// moved off of the input because the user clicked on the button.
						this._delay( function() {
							this.previous = previous;
						} );
					}
				}

				// Ensure focus is on (or stays on) the text field
				event.preventDefault();
				checkFocus.call( this );

				// Support: IE
				// IE doesn't prevent moving focus even with event.preventDefault()
				// so we set a flag to know when we should ignore the blur event
				// and check (again) if focus moved off of the input.
				this.cancelBlur = true;
				this._delay( function() {
					delete this.cancelBlur;
					checkFocus.call( this );
				} );

				if ( this._start( event ) === false ) {
					return;
				}

				this._repeat( null, $( event.currentTarget )
					.hasClass( "ui-spinner-up" ) ? 1 : -1, event );
			},
			"mouseup .ui-spinner-button": "_stop",
			"mouseenter .ui-spinner-button": function( event ) {

				// button will add ui-state-active if mouse was down while mouseleave and kept down
				if ( !$( event.currentTarget ).hasClass( "ui-state-active" ) ) {
					return;
				}

				if ( this._start( event ) === false ) {
					return false;
				}
				this._repeat( null, $( event.currentTarget )
					.hasClass( "ui-spinner-up" ) ? 1 : -1, event );
			},

			// TODO: do we really want to consider this a stop?
			// shouldn't we just stop the repeater and wait until mouseup before
			// we trigger the stop event?
			"mouseleave .ui-spinner-button": "_stop"
		},

		// Support mobile enhanced option and make backcompat more sane
		_enhance: function() {
			this.uiSpinner = this.element
				.attr( "autocomplete", "off" )
				.wrap( "<span>" )
				.parent()

					// Add buttons
					.append(
						"<a></a><a></a>"
					);
		},

		_draw: function() {
			this._enhance();

			this._addClass( this.uiSpinner, "ui-spinner", "ui-widget ui-widget-content" );
			this._addClass( "ui-spinner-input" );

			this.element.attr( "role", "spinbutton" );

			// Button bindings
			this.buttons = this.uiSpinner.children( "a" )
				.attr( "tabIndex", -1 )
				.attr( "aria-hidden", true )
				.button( {
					classes: {
						"ui-button": ""
					}
				} );

			// TODO: Right now button does not support classes this is already updated in button PR
			this._removeClass( this.buttons, "ui-corner-all" );

			this._addClass( this.buttons.first(), "ui-spinner-button ui-spinner-up" );
			this._addClass( this.buttons.last(), "ui-spinner-button ui-spinner-down" );
			this.buttons.first().button( {
				"icon": this.options.icons.up,
				"showLabel": false
			} );
			this.buttons.last().button( {
				"icon": this.options.icons.down,
				"showLabel": false
			} );

			// IE 6 doesn't understand height: 50% for the buttons
			// unless the wrapper has an explicit height
			if ( this.buttons.height() > Math.ceil( this.uiSpinner.height() * 0.5 ) &&
					this.uiSpinner.height() > 0 ) {
				this.uiSpinner.height( this.uiSpinner.height() );
			}
		},

		_keydown: function( event ) {
			var options = this.options,
				keyCode = $.ui.keyCode;

			switch ( event.keyCode ) {
			case keyCode.UP:
				this._repeat( null, 1, event );
				return true;
			case keyCode.DOWN:
				this._repeat( null, -1, event );
				return true;
			case keyCode.PAGE_UP:
				this._repeat( null, options.page, event );
				return true;
			case keyCode.PAGE_DOWN:
				this._repeat( null, -options.page, event );
				return true;
			}

			return false;
		},

		_start: function( event ) {
			if ( !this.spinning && this._trigger( "start", event ) === false ) {
				return false;
			}

			if ( !this.counter ) {
				this.counter = 1;
			}
			this.spinning = true;
			return true;
		},

		_repeat: function( i, steps, event ) {
			i = i || 500;

			clearTimeout( this.timer );
			this.timer = this._delay( function() {
				this._repeat( 40, steps, event );
			}, i );

			this._spin( steps * this.options.step, event );
		},

		_spin: function( step, event ) {
			var value = this.value() || 0;

			if ( !this.counter ) {
				this.counter = 1;
			}

			value = this._adjustValue( value + step * this._increment( this.counter ) );

			if ( !this.spinning || this._trigger( "spin", event, { value: value } ) !== false ) {
				this._value( value );
				this.counter++;
			}
		},

		_increment: function( i ) {
			var incremental = this.options.incremental;

			if ( incremental ) {
				return $.isFunction( incremental ) ?
					incremental( i ) :
					Math.floor( i * i * i / 50000 - i * i / 500 + 17 * i / 200 + 1 );
			}

			return 1;
		},

		_precision: function() {
			var precision = this._precisionOf( this.options.step );
			if ( this.options.min !== null ) {
				precision = Math.max( precision, this._precisionOf( this.options.min ) );
			}
			return precision;
		},

		_precisionOf: function( num ) {
			var str = num.toString(),
				decimal = str.indexOf( "." );
			return decimal === -1 ? 0 : str.length - decimal - 1;
		},

		_adjustValue: function( value ) {
			var base, aboveMin,
				options = this.options;

			// Make sure we're at a valid step
			// - find out where we are relative to the base (min or 0)
			base = options.min !== null ? options.min : 0;
			aboveMin = value - base;

			// - round to the nearest step
			aboveMin = Math.round( aboveMin / options.step ) * options.step;

			// - rounding is based on 0, so adjust back to our base
			value = base + aboveMin;

			// Fix precision from bad JS floating point math
			value = parseFloat( value.toFixed( this._precision() ) );

			// Clamp the value
			if ( options.max !== null && value > options.max ) {
				return options.max;
			}
			if ( options.min !== null && value < options.min ) {
				return options.min;
			}

			return value;
		},

		_stop: function( event ) {
			if ( !this.spinning ) {
				return;
			}

			clearTimeout( this.timer );
			clearTimeout( this.mousewheelTimer );
			this.counter = 0;
			this.spinning = false;
			this._trigger( "stop", event );
		},

		_setOption: function( key, value ) {
			var prevValue, first, last;

			if ( key === "culture" || key === "numberFormat" ) {
				prevValue = this._parse( this.element.val() );
				this.options[ key ] = value;
				this.element.val( this._format( prevValue ) );
				return;
			}

			if ( key === "max" || key === "min" || key === "step" ) {
				if ( typeof value === "string" ) {
					value = this._parse( value );
				}
			}
			if ( key === "icons" ) {
				first = this.buttons.first().find( ".ui-icon" );
				this._removeClass( first, null, this.options.icons.up );
				this._addClass( first, null, value.up );
				last = this.buttons.last().find( ".ui-icon" );
				this._removeClass( last, null, this.options.icons.down );
				this._addClass( last, null, value.down );
			}

			this._super( key, value );
		},

		_setOptionDisabled: function( value ) {
			this._super( value );

			this._toggleClass( this.uiSpinner, null, "ui-state-disabled", !!value );
			this.element.prop( "disabled", !!value );
			this.buttons.button( value ? "disable" : "enable" );
		},

		_setOptions: spinnerModifer( function( options ) {
			this._super( options );
		} ),

		_parse: function( val ) {
			if ( typeof val === "string" && val !== "" ) {
				val = window.Globalize && this.options.numberFormat ?
					Globalize.parseFloat( val, 10, this.options.culture ) : +val;
			}
			return val === "" || isNaN( val ) ? null : val;
		},

		_format: function( value ) {
			if ( value === "" ) {
				return "";
			}
			return window.Globalize && this.options.numberFormat ?
				Globalize.format( value, this.options.numberFormat, this.options.culture ) :
				value;
		},

		_refresh: function() {
			this.element.attr( {
				"aria-valuemin": this.options.min,
				"aria-valuemax": this.options.max,

				// TODO: what should we do with values that can't be parsed?
				"aria-valuenow": this._parse( this.element.val() )
			} );
		},

		isValid: function() {
			var value = this.value();

			// Null is invalid
			if ( value === null ) {
				return false;
			}

			// If value gets adjusted, it's invalid
			return value === this._adjustValue( value );
		},

		// Update the value without triggering change
		_value: function( value, allowAny ) {
			var parsed;
			if ( value !== "" ) {
				parsed = this._parse( value );
				if ( parsed !== null ) {
					if ( !allowAny ) {
						parsed = this._adjustValue( parsed );
					}
					value = this._format( parsed );
				}
			}
			this.element.val( value );
			this._refresh();
		},

		_destroy: function() {
			this.element
				.prop( "disabled", false )
				.removeAttr( "autocomplete role aria-valuemin aria-valuemax aria-valuenow" );

			this.uiSpinner.replaceWith( this.element );
		},

		stepUp: spinnerModifer( function( steps ) {
			this._stepUp( steps );
		} ),
		_stepUp: function( steps ) {
			if ( this._start() ) {
				this._spin( ( steps || 1 ) * this.options.step );
				this._stop();
			}
		},

		stepDown: spinnerModifer( function( steps ) {
			this._stepDown( steps );
		} ),
		_stepDown: function( steps ) {
			if ( this._start() ) {
				this._spin( ( steps || 1 ) * -this.options.step );
				this._stop();
			}
		},

		pageUp: spinnerModifer( function( pages ) {
			this._stepUp( ( pages || 1 ) * this.options.page );
		} ),

		pageDown: spinnerModifer( function( pages ) {
			this._stepDown( ( pages || 1 ) * this.options.page );
		} ),

		value: function( newVal ) {
			if ( !arguments.length ) {
				return this._parse( this.element.val() );
			}
			spinnerModifer( this._value ).call( this, newVal );
		},

		widget: function() {
			return this.uiSpinner;
		}
	} );

	// DEPRECATED
	// TODO: switch return back to widget declaration at top of file when this is removed
	if ( $.uiBackCompat !== false ) {

		// Backcompat for spinner html extension points
		$.widget( "ui.spinner", $.ui.spinner, {
			_enhance: function() {
				this.uiSpinner = this.element
					.attr( "autocomplete", "off" )
					.wrap( this._uiSpinnerHtml() )
					.parent()

						// Add buttons
						.append( this._buttonHtml() );
			},
			_uiSpinnerHtml: function() {
				return "<span>";
			},

			_buttonHtml: function() {
				return "<a></a><a></a>";
			}
		} );
	}

	return $.ui.spinner;

	} ) );


/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * jQuery UI Button 1.12.0
	 * http://jqueryui.com
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license.
	 * http://jquery.org/license
	 */

	//>>label: Button
	//>>group: Widgets
	//>>description: Enhances a form with themeable buttons.
	//>>docs: http://api.jqueryui.com/button/
	//>>demos: http://jqueryui.com/button/
	//>>css.structure: ../../themes/base/core.css
	//>>css.structure: ../../themes/base/button.css
	//>>css.theme: ../../themes/base/theme.css

	( function( factory ) {
		if ( true ) {

			// AMD. Register as an anonymous module.
			!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
				__webpack_require__(1),

				// These are only for backcompat
				// TODO: Remove after 1.12
				__webpack_require__(4),
				__webpack_require__(7),

				__webpack_require__(12),
				__webpack_require__(5)
			], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else {

			// Browser globals
			factory( jQuery );
		}
	}( function( $ ) {

	$.widget( "ui.button", {
		version: "1.12.0",
		defaultElement: "<button>",
		options: {
			classes: {
				"ui-button": "ui-corner-all"
			},
			disabled: null,
			icon: null,
			iconPosition: "beginning",
			label: null,
			showLabel: true
		},

		_getCreateOptions: function() {
			var disabled,

				// This is to support cases like in jQuery Mobile where the base widget does have
				// an implementation of _getCreateOptions
				options = this._super() || {};

			this.isInput = this.element.is( "input" );

			disabled = this.element[ 0 ].disabled;
			if ( disabled != null ) {
				options.disabled = disabled;
			}

			this.originalLabel = this.isInput ? this.element.val() : this.element.html();
			if ( this.originalLabel ) {
				options.label = this.originalLabel;
			}

			return options;
		},

		_create: function() {
			if ( !this.option.showLabel & !this.options.icon ) {
				this.options.showLabel = true;
			}

			// We have to check the option again here even though we did in _getCreateOptions,
			// because null may have been passed on init which would override what was set in
			// _getCreateOptions
			if ( this.options.disabled == null ) {
				this.options.disabled = this.element[ 0 ].disabled || false;
			}

			this.hasTitle = !!this.element.attr( "title" );

			// Check to see if the label needs to be set or if its already correct
			if ( this.options.label && this.options.label !== this.originalLabel ) {
				if ( this.isInput ) {
					this.element.val( this.options.label );
				} else {
					this.element.html( this.options.label );
				}
			}
			this._addClass( "ui-button", "ui-widget" );
			this._setOption( "disabled", this.options.disabled );
			this._enhance();

			if ( this.element.is( "a" ) ) {
				this._on( {
					"keyup": function( event ) {
						if ( event.keyCode === $.ui.keyCode.SPACE ) {
							event.preventDefault();

							// Support: PhantomJS <= 1.9, IE 8 Only
							// If a native click is available use it so we actually cause navigation
							// otherwise just trigger a click event
							if ( this.element[ 0 ].click ) {
								this.element[ 0 ].click();
							} else {
								this.element.trigger( "click" );
							}
						}
					}
				} );
			}
		},

		_enhance: function() {
			if ( !this.element.is( "button" ) ) {
				this.element.attr( "role", "button" );
			}

			if ( this.options.icon ) {
				this._updateIcon( "icon", this.options.icon );
				this._updateTooltip();
			}
		},

		_updateTooltip: function() {
			this.title = this.element.attr( "title" );

			if ( !this.options.showLabel && !this.title ) {
				this.element.attr( "title", this.options.label );
			}
		},

		_updateIcon: function( option, value ) {
			var icon = option !== "iconPosition",
				position = icon ? this.options.iconPosition : value,
				displayBlock = position === "top" || position === "bottom";

			// Create icon
			if ( !this.icon ) {
				this.icon = $( "<span>" );

				this._addClass( this.icon, "ui-button-icon", "ui-icon" );

				if ( !this.options.showLabel ) {
					this._addClass( "ui-button-icon-only" );
				}
			} else if ( icon ) {

				// If we are updating the icon remove the old icon class
				this._removeClass( this.icon, null, this.options.icon );
			}

			// If we are updating the icon add the new icon class
			if ( icon ) {
				this._addClass( this.icon, null, value );
			}

			this._attachIcon( position );

			// If the icon is on top or bottom we need to add the ui-widget-icon-block class and remove
			// the iconSpace if there is one.
			if ( displayBlock ) {
				this._addClass( this.icon, null, "ui-widget-icon-block" );
				if ( this.iconSpace ) {
					this.iconSpace.remove();
				}
			} else {

				// Position is beginning or end so remove the ui-widget-icon-block class and add the
				// space if it does not exist
				if ( !this.iconSpace ) {
					this.iconSpace = $( "<span> </span>" );
					this._addClass( this.iconSpace, "ui-button-icon-space" );
				}
				this._removeClass( this.icon, null, "ui-wiget-icon-block" );
				this._attachIconSpace( position );
			}
		},

		_destroy: function() {
			this.element.removeAttr( "role" );

			if ( this.icon ) {
				this.icon.remove();
			}
			if ( this.iconSpace ) {
				this.iconSpace.remove();
			}
			if ( !this.hasTitle ) {
				this.element.removeAttr( "title" );
			}
		},

		_attachIconSpace: function( iconPosition ) {
			this.icon[ /^(?:end|bottom)/.test( iconPosition ) ? "before" : "after" ]( this.iconSpace );
		},

		_attachIcon: function( iconPosition ) {
			this.element[ /^(?:end|bottom)/.test( iconPosition ) ? "append" : "prepend" ]( this.icon );
		},

		_setOptions: function( options ) {
			var newShowLabel = options.showLabel === undefined ?
					this.options.showLabel :
					options.showLabel,
				newIcon = options.icon === undefined ? this.options.icon : options.icon;

			if ( !newShowLabel && !newIcon ) {
				options.showLabel = true;
			}
			this._super( options );
		},

		_setOption: function( key, value ) {
			if ( key === "icon" ) {
				if ( value ) {
					this._updateIcon( key, value );
				} else if ( this.icon ) {
					this.icon.remove();
					if ( this.iconSpace ) {
						this.iconSpace.remove();
					}
				}
			}

			if ( key === "iconPosition" ) {
				this._updateIcon( key, value );
			}

			// Make sure we can't end up with a button that has neither text nor icon
			if ( key === "showLabel" ) {
					this._toggleClass( "ui-button-icon-only", null, !value );
					this._updateTooltip();
			}

			if ( key === "label" ) {
				if ( this.isInput ) {
					this.element.val( value );
				} else {

					// If there is an icon, append it, else nothing then append the value
					// this avoids removal of the icon when setting label text
					this.element.html( value );
					if ( this.icon ) {
						this._attachIcon( this.options.iconPosition );
						this._attachIconSpace( this.options.iconPosition );
					}
				}
			}

			this._super( key, value );

			if ( key === "disabled" ) {
				this._toggleClass( null, "ui-state-disabled", value );
				this.element[ 0 ].disabled = value;
				if ( value ) {
					this.element.blur();
				}
			}
		},

		refresh: function() {

			// Make sure to only check disabled if its an element that supports this otherwise
			// check for the disabled class to determine state
			var isDisabled = this.element.is( "input, button" ) ?
				this.element[ 0 ].disabled : this.element.hasClass( "ui-button-disabled" );

			if ( isDisabled !== this.options.disabled ) {
				this._setOptions( { disabled: isDisabled } );
			}

			this._updateTooltip();
		}
	} );

	// DEPRECATED
	if ( $.uiBackCompat !== false ) {

		// Text and Icons options
		$.widget( "ui.button", $.ui.button, {
			options: {
				text: true,
				icons: {
					primary: null,
					secondary: null
				}
			},

			_create: function() {
				if ( this.options.showLabel && !this.options.text ) {
					this.options.showLabel = this.options.text;
				}
				if ( !this.options.showLabel && this.options.text ) {
					this.options.text = this.options.showLabel;
				}
				if ( !this.options.icon && ( this.options.icons.primary ||
						this.options.icons.secondary ) ) {
					if ( this.options.icons.primary ) {
						this.options.icon = this.options.icons.primary;
					} else {
						this.options.icon = this.options.icons.secondary;
						this.options.iconPosition = "end";
					}
				} else if ( this.options.icon ) {
					this.options.icons.primary = this.options.icon;
				}
				this._super();
			},

			_setOption: function( key, value ) {
				if ( key === "text" ) {
					this._super( "showLabel", value );
					return;
				}
				if ( key === "showLabel" ) {
					this.options.text = value;
				}
				if ( key === "icon" ) {
					this.options.icons.primary = value;
				}
				if ( key === "icons" ) {
					if ( value.primary ) {
						this._super( "icon", value.primary );
						this._super( "iconPosition", "beginning" );
					} else if ( value.secondary ) {
						this._super( "icon", value.secondary );
						this._super( "iconPosition", "end" );
					}
				}
				this._superApply( arguments );
			}
		} );

		$.fn.button = ( function( orig ) {
			return function() {
				if ( !this.length || ( this.length && this[ 0 ].tagName !== "INPUT" ) ||
						( this.length && this[ 0 ].tagName === "INPUT" && (
							this.attr( "type" ) !== "checkbox" && this.attr( "type" ) !== "radio"
						) ) ) {
					return orig.apply( this, arguments );
				}
				if ( !$.ui.checkboxradio ) {
					$.error( "Checkboxradio widget missing" );
				}
				if ( arguments.length === 0 ) {
					return this.checkboxradio( {
						"icon": false
					} );
				}
				return this.checkboxradio.apply( this, arguments );
			};
		} )( $.fn.button );

		$.fn.buttonset = function() {
			if ( !$.ui.controlgroup ) {
				$.error( "Controlgroup widget missing" );
			}
			if ( arguments[ 0 ] === "option" && arguments[ 1 ] === "items" && arguments[ 2 ] ) {
				return this.controlgroup.apply( this,
					[ arguments[ 0 ], "items.button", arguments[ 2 ] ] );
			}
			if ( arguments[ 0 ] === "option" && arguments[ 1 ] === "items" ) {
				return this.controlgroup.apply( this, [ arguments[ 0 ], "items.button" ] );
			}
			if ( typeof arguments[ 0 ] === "object" && arguments[ 0 ].items ) {
				arguments[ 0 ].items = {
					button: arguments[ 0 ].items
				};
			}
			return this.controlgroup.apply( this, arguments );
		};
	}

	return $.ui.button;

	} ) );


/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * jQuery UI Controlgroup 1.12.0
	 * http://jqueryui.com
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license.
	 * http://jquery.org/license
	 */

	//>>label: Controlgroup
	//>>group: Widgets
	//>>description: Visually groups form control widgets
	//>>docs: http://api.jqueryui.com/controlgroup/
	//>>demos: http://jqueryui.com/controlgroup/
	//>>css.structure: ../../themes/base/core.css
	//>>css.structure: ../../themes/base/controlgroup.css
	//>>css.theme: ../../themes/base/theme.css

	( function( factory ) {
		if ( true ) {

			// AMD. Register as an anonymous module.
			!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
				__webpack_require__(1),
				__webpack_require__(5)
			], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else {

			// Browser globals
			factory( jQuery );
		}
	}( function( $ ) {
	var controlgroupCornerRegex = /ui-corner-([a-z]){2,6}/g;

	return $.widget( "ui.controlgroup", {
		version: "1.12.0",
		defaultElement: "<div>",
		options: {
			direction: "horizontal",
			disabled: null,
			onlyVisible: true,
			items: {
				"button": "input[type=button], input[type=submit], input[type=reset], button, a",
				"controlgroupLabel": ".ui-controlgroup-label",
				"checkboxradio": "input[type='checkbox'], input[type='radio']",
				"selectmenu": "select",
				"spinner": ".ui-spinner-input"
			}
		},

		_create: function() {
			this._enhance();
		},

		// To support the enhanced option in jQuery Mobile, we isolate DOM manipulation
		_enhance: function() {
			this.element.attr( "role", "toolbar" );
			this.refresh();
		},

		_destroy: function() {
			this._callChildMethod( "destroy" );
			this.childWidgets.removeData( "ui-controlgroup-data" );
			this.element.removeAttr( "role" );
			if ( this.options.items.controlgroupLabel ) {
				this.element
					.find( this.options.items.controlgroupLabel )
					.find( ".ui-controlgroup-label-contents" )
					.contents().unwrap();
			}
		},

		_initWidgets: function() {
			var that = this,
				childWidgets = [];

			// First we iterate over each of the items options
			$.each( this.options.items, function( widget, selector ) {
				var labels;
				var options = {};

				// Make sure the widget has a selector set
				if ( !selector ) {
					return;
				}

				if ( widget === "controlgroupLabel" ) {
					labels = that.element.find( selector );
					labels.each( function() {
						var element = $( this );

						if ( element.children( ".ui-controlgroup-label-contents" ).length ) {
							return;
						}
						element.contents()
							.wrapAll( "<span class='ui-controlgroup-label-contents'></span>" );
					} );
					that._addClass( labels, null, "ui-widget ui-widget-content ui-state-default" );
					childWidgets = childWidgets.concat( labels.get() );
					return;
				}

				// Make sure the widget actually exists
				if ( !$.fn[ widget ] ) {
					return;
				}

				// We assume everything is in the middle to start because we can't determine
				// first / last elements until all enhancments are done.
				if ( that[ "_" + widget + "Options" ] ) {
					options = that[ "_" + widget + "Options" ]( "middle" );
				}

				// Find instances of this widget inside controlgroup and init them
				that.element
					.find( selector )
					.each( function() {
						var element = $( this );
						var instance = element[ widget ]( "instance" );

						// We need to clone the default options for this type of widget to avoid
						// polluting the variable options which has a wider scope than a single widget.
						var instanceOptions = $.widget.extend( {}, options );

						// If the button is the child of a spinner ignore it
						// TODO: Find a more generic solution
						if ( widget === "button" && element.parent( ".ui-spinner" ).length ) {
							return;
						}

						// Create the widget if it doesn't exist
						if ( !instance ) {
							instance = element[ widget ]()[ widget ]( "instance" );
						}
						if ( instance ) {
							instanceOptions.classes =
								that._resolveClassesValues( instanceOptions.classes, instance );
						}
						element[ widget ]( instanceOptions );

						// Store an instance of the controlgroup to be able to reference
						// from the outermost element for changing options and refresh
						var widgetElement = element[ widget ]( "widget" );
						$.data( widgetElement[ 0 ], "ui-controlgroup-data",
							instance ? instance : element[ widget ]( "instance" ) );

						childWidgets.push( widgetElement[ 0 ] );
					} );
			} );

			this.childWidgets = $( $.unique( childWidgets ) );
			this._addClass( this.childWidgets, "ui-controlgroup-item" );
		},

		_callChildMethod: function( method ) {
			this.childWidgets.each( function() {
				var element = $( this ),
					data = element.data( "ui-controlgroup-data" );
				if ( data && data[ method ] ) {
					data[ method ]();
				}
			} );
		},

		_updateCornerClass: function( element, position ) {
			var remove = "ui-corner-top ui-corner-bottom ui-corner-left ui-corner-right ui-corner-all";
			var add = this._buildSimpleOptions( position, "label" ).classes.label;

			this._removeClass( element, null, remove );
			this._addClass( element, null, add );
		},

		_buildSimpleOptions: function( position, key ) {
			var direction = this.options.direction === "vertical";
			var result = {
				classes: {}
			};
			result.classes[ key ] = {
				"middle": "",
				"first": "ui-corner-" + ( direction ? "top" : "left" ),
				"last": "ui-corner-" + ( direction ? "bottom" : "right" ),
				"only": "ui-corner-all"
			}[ position ];

			return result;
		},

		_spinnerOptions: function( position ) {
			var options = this._buildSimpleOptions( position, "ui-spinner" );

			options.classes[ "ui-spinner-up" ] = "";
			options.classes[ "ui-spinner-down" ] = "";

			return options;
		},

		_buttonOptions: function( position ) {
			return this._buildSimpleOptions( position, "ui-button" );
		},

		_checkboxradioOptions: function( position ) {
			return this._buildSimpleOptions( position, "ui-checkboxradio-label" );
		},

		_selectmenuOptions: function( position ) {
			var direction = this.options.direction === "vertical";
			return {
				width: direction ? "auto" : false,
				classes: {
					middle: {
						"ui-selectmenu-button-open": "",
						"ui-selectmenu-button-closed": ""
					},
					first: {
						"ui-selectmenu-button-open": "ui-corner-" + ( direction ? "top" : "tl" ),
						"ui-selectmenu-button-closed": "ui-corner-" + ( direction ? "top" : "left" )
					},
					last: {
						"ui-selectmenu-button-open": direction ? "" : "ui-corner-tr",
						"ui-selectmenu-button-closed": "ui-corner-" + ( direction ? "bottom" : "right" )
					},
					only: {
						"ui-selectmenu-button-open": "ui-corner-top",
						"ui-selectmenu-button-closed": "ui-corner-all"
					}

				}[ position ]
			};
		},

		_resolveClassesValues: function( classes, instance ) {
			var result = {};
			$.each( classes, function( key ) {
				var current = instance.options.classes[ key ] || "";
				current = current.replace( controlgroupCornerRegex, "" ).trim();
				result[ key ] = ( current + " " + classes[ key ] ).replace( /\s+/g, " " );
			} );
			return result;
		},

		_setOption: function( key, value ) {
			if ( key === "direction" ) {
				this._removeClass( "ui-controlgroup-" + this.options.direction );
			}

			this._super( key, value );
			if ( key === "disabled" ) {
				this._callChildMethod( value ? "disable" : "enable" );
				return;
			}

			this.refresh();
		},

		refresh: function() {
			var children,
				that = this;

			this._addClass( "ui-controlgroup ui-controlgroup-" + this.options.direction );

			if ( this.options.direction === "horizontal" ) {
				this._addClass( null, "ui-helper-clearfix" );
			}
			this._initWidgets();

			children = this.childWidgets;

			// We filter here because we need to track all childWidgets not just the visible ones
			if ( this.options.onlyVisible ) {
				children = children.filter( ":visible" );
			}

			if ( children.length ) {

				// We do this last because we need to make sure all enhancment is done
				// before determining first and last
				$.each( [ "first", "last" ], function( index, value ) {
					var instance = children[ value ]().data( "ui-controlgroup-data" );

					if ( instance && that[ "_" + instance.widgetName + "Options" ] ) {
						var options = that[ "_" + instance.widgetName + "Options" ](
							children.length === 1 ? "only" : value
						);
						options.classes = that._resolveClassesValues( options.classes, instance );
						instance.element[ instance.widgetName ]( options );
					} else {
						that._updateCornerClass( children[ value ](), value );
					}
				} );

				// Finally call the refresh method on each of the child widgets.
				this._callChildMethod( "refresh" );
			}
		}
	} );
	} ) );


/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * jQuery UI Widget 1.12.0
	 * http://jqueryui.com
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license.
	 * http://jquery.org/license
	 */

	//>>label: Widget
	//>>group: Core
	//>>description: Provides a factory for creating stateful widgets with a common API.
	//>>docs: http://api.jqueryui.com/jQuery.widget/
	//>>demos: http://jqueryui.com/widget/

	( function( factory ) {
		if ( true ) {

			// AMD. Register as an anonymous module.
			!(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(1), __webpack_require__(6) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else {

			// Browser globals
			factory( jQuery );
		}
	}( function( $ ) {

	var widgetUuid = 0;
	var widgetSlice = Array.prototype.slice;

	$.cleanData = ( function( orig ) {
		return function( elems ) {
			var events, elem, i;
			for ( i = 0; ( elem = elems[ i ] ) != null; i++ ) {
				try {

					// Only trigger remove when necessary to save time
					events = $._data( elem, "events" );
					if ( events && events.remove ) {
						$( elem ).triggerHandler( "remove" );
					}

				// Http://bugs.jquery.com/ticket/8235
				} catch ( e ) {}
			}
			orig( elems );
		};
	} )( $.cleanData );

	$.widget = function( name, base, prototype ) {
		var existingConstructor, constructor, basePrototype;

		// ProxiedPrototype allows the provided prototype to remain unmodified
		// so that it can be used as a mixin for multiple widgets (#8876)
		var proxiedPrototype = {};

		var namespace = name.split( "." )[ 0 ];
		name = name.split( "." )[ 1 ];
		var fullName = namespace + "-" + name;

		if ( !prototype ) {
			prototype = base;
			base = $.Widget;
		}

		if ( $.isArray( prototype ) ) {
			prototype = $.extend.apply( null, [ {} ].concat( prototype ) );
		}

		// Create selector for plugin
		$.expr[ ":" ][ fullName.toLowerCase() ] = function( elem ) {
			return !!$.data( elem, fullName );
		};

		$[ namespace ] = $[ namespace ] || {};
		existingConstructor = $[ namespace ][ name ];
		constructor = $[ namespace ][ name ] = function( options, element ) {

			// Allow instantiation without "new" keyword
			if ( !this._createWidget ) {
				return new constructor( options, element );
			}

			// Allow instantiation without initializing for simple inheritance
			// must use "new" keyword (the code above always passes args)
			if ( arguments.length ) {
				this._createWidget( options, element );
			}
		};

		// Extend with the existing constructor to carry over any static properties
		$.extend( constructor, existingConstructor, {
			version: prototype.version,

			// Copy the object used to create the prototype in case we need to
			// redefine the widget later
			_proto: $.extend( {}, prototype ),

			// Track widgets that inherit from this widget in case this widget is
			// redefined after a widget inherits from it
			_childConstructors: []
		} );

		basePrototype = new base();

		// We need to make the options hash a property directly on the new instance
		// otherwise we'll modify the options hash on the prototype that we're
		// inheriting from
		basePrototype.options = $.widget.extend( {}, basePrototype.options );
		$.each( prototype, function( prop, value ) {
			if ( !$.isFunction( value ) ) {
				proxiedPrototype[ prop ] = value;
				return;
			}
			proxiedPrototype[ prop ] = ( function() {
				function _super() {
					return base.prototype[ prop ].apply( this, arguments );
				}

				function _superApply( args ) {
					return base.prototype[ prop ].apply( this, args );
				}

				return function() {
					var __super = this._super;
					var __superApply = this._superApply;
					var returnValue;

					this._super = _super;
					this._superApply = _superApply;

					returnValue = value.apply( this, arguments );

					this._super = __super;
					this._superApply = __superApply;

					return returnValue;
				};
			} )();
		} );
		constructor.prototype = $.widget.extend( basePrototype, {

			// TODO: remove support for widgetEventPrefix
			// always use the name + a colon as the prefix, e.g., draggable:start
			// don't prefix for widgets that aren't DOM-based
			widgetEventPrefix: existingConstructor ? ( basePrototype.widgetEventPrefix || name ) : name
		}, proxiedPrototype, {
			constructor: constructor,
			namespace: namespace,
			widgetName: name,
			widgetFullName: fullName
		} );

		// If this widget is being redefined then we need to find all widgets that
		// are inheriting from it and redefine all of them so that they inherit from
		// the new version of this widget. We're essentially trying to replace one
		// level in the prototype chain.
		if ( existingConstructor ) {
			$.each( existingConstructor._childConstructors, function( i, child ) {
				var childPrototype = child.prototype;

				// Redefine the child widget using the same prototype that was
				// originally used, but inherit from the new version of the base
				$.widget( childPrototype.namespace + "." + childPrototype.widgetName, constructor,
					child._proto );
			} );

			// Remove the list of existing child constructors from the old constructor
			// so the old child constructors can be garbage collected
			delete existingConstructor._childConstructors;
		} else {
			base._childConstructors.push( constructor );
		}

		$.widget.bridge( name, constructor );

		return constructor;
	};

	$.widget.extend = function( target ) {
		var input = widgetSlice.call( arguments, 1 );
		var inputIndex = 0;
		var inputLength = input.length;
		var key;
		var value;

		for ( ; inputIndex < inputLength; inputIndex++ ) {
			for ( key in input[ inputIndex ] ) {
				value = input[ inputIndex ][ key ];
				if ( input[ inputIndex ].hasOwnProperty( key ) && value !== undefined ) {

					// Clone objects
					if ( $.isPlainObject( value ) ) {
						target[ key ] = $.isPlainObject( target[ key ] ) ?
							$.widget.extend( {}, target[ key ], value ) :

							// Don't extend strings, arrays, etc. with objects
							$.widget.extend( {}, value );

					// Copy everything else by reference
					} else {
						target[ key ] = value;
					}
				}
			}
		}
		return target;
	};

	$.widget.bridge = function( name, object ) {
		var fullName = object.prototype.widgetFullName || name;
		$.fn[ name ] = function( options ) {
			var isMethodCall = typeof options === "string";
			var args = widgetSlice.call( arguments, 1 );
			var returnValue = this;

			if ( isMethodCall ) {
				this.each( function() {
					var methodValue;
					var instance = $.data( this, fullName );

					if ( options === "instance" ) {
						returnValue = instance;
						return false;
					}

					if ( !instance ) {
						return $.error( "cannot call methods on " + name +
							" prior to initialization; " +
							"attempted to call method '" + options + "'" );
					}

					if ( !$.isFunction( instance[ options ] ) || options.charAt( 0 ) === "_" ) {
						return $.error( "no such method '" + options + "' for " + name +
							" widget instance" );
					}

					methodValue = instance[ options ].apply( instance, args );

					if ( methodValue !== instance && methodValue !== undefined ) {
						returnValue = methodValue && methodValue.jquery ?
							returnValue.pushStack( methodValue.get() ) :
							methodValue;
						return false;
					}
				} );
			} else {

				// Allow multiple hashes to be passed on init
				if ( args.length ) {
					options = $.widget.extend.apply( null, [ options ].concat( args ) );
				}

				this.each( function() {
					var instance = $.data( this, fullName );
					if ( instance ) {
						instance.option( options || {} );
						if ( instance._init ) {
							instance._init();
						}
					} else {
						$.data( this, fullName, new object( options, this ) );
					}
				} );
			}

			return returnValue;
		};
	};

	$.Widget = function( /* options, element */ ) {};
	$.Widget._childConstructors = [];

	$.Widget.prototype = {
		widgetName: "widget",
		widgetEventPrefix: "",
		defaultElement: "<div>",

		options: {
			classes: {},
			disabled: false,

			// Callbacks
			create: null
		},

		_createWidget: function( options, element ) {
			element = $( element || this.defaultElement || this )[ 0 ];
			this.element = $( element );
			this.uuid = widgetUuid++;
			this.eventNamespace = "." + this.widgetName + this.uuid;

			this.bindings = $();
			this.hoverable = $();
			this.focusable = $();
			this.classesElementLookup = {};

			if ( element !== this ) {
				$.data( element, this.widgetFullName, this );
				this._on( true, this.element, {
					remove: function( event ) {
						if ( event.target === element ) {
							this.destroy();
						}
					}
				} );
				this.document = $( element.style ?

					// Element within the document
					element.ownerDocument :

					// Element is window or document
					element.document || element );
				this.window = $( this.document[ 0 ].defaultView || this.document[ 0 ].parentWindow );
			}

			this.options = $.widget.extend( {},
				this.options,
				this._getCreateOptions(),
				options );

			this._create();

			if ( this.options.disabled ) {
				this._setOptionDisabled( this.options.disabled );
			}

			this._trigger( "create", null, this._getCreateEventData() );
			this._init();
		},

		_getCreateOptions: function() {
			return {};
		},

		_getCreateEventData: $.noop,

		_create: $.noop,

		_init: $.noop,

		destroy: function() {
			var that = this;

			this._destroy();
			$.each( this.classesElementLookup, function( key, value ) {
				that._removeClass( value, key );
			} );

			// We can probably remove the unbind calls in 2.0
			// all event bindings should go through this._on()
			this.element
				.off( this.eventNamespace )
				.removeData( this.widgetFullName );
			this.widget()
				.off( this.eventNamespace )
				.removeAttr( "aria-disabled" );

			// Clean up events and states
			this.bindings.off( this.eventNamespace );
		},

		_destroy: $.noop,

		widget: function() {
			return this.element;
		},

		option: function( key, value ) {
			var options = key;
			var parts;
			var curOption;
			var i;

			if ( arguments.length === 0 ) {

				// Don't return a reference to the internal hash
				return $.widget.extend( {}, this.options );
			}

			if ( typeof key === "string" ) {

				// Handle nested keys, e.g., "foo.bar" => { foo: { bar: ___ } }
				options = {};
				parts = key.split( "." );
				key = parts.shift();
				if ( parts.length ) {
					curOption = options[ key ] = $.widget.extend( {}, this.options[ key ] );
					for ( i = 0; i < parts.length - 1; i++ ) {
						curOption[ parts[ i ] ] = curOption[ parts[ i ] ] || {};
						curOption = curOption[ parts[ i ] ];
					}
					key = parts.pop();
					if ( arguments.length === 1 ) {
						return curOption[ key ] === undefined ? null : curOption[ key ];
					}
					curOption[ key ] = value;
				} else {
					if ( arguments.length === 1 ) {
						return this.options[ key ] === undefined ? null : this.options[ key ];
					}
					options[ key ] = value;
				}
			}

			this._setOptions( options );

			return this;
		},

		_setOptions: function( options ) {
			var key;

			for ( key in options ) {
				this._setOption( key, options[ key ] );
			}

			return this;
		},

		_setOption: function( key, value ) {
			if ( key === "classes" ) {
				this._setOptionClasses( value );
			}

			this.options[ key ] = value;

			if ( key === "disabled" ) {
				this._setOptionDisabled( value );
			}

			return this;
		},

		_setOptionClasses: function( value ) {
			var classKey, elements, currentElements;

			for ( classKey in value ) {
				currentElements = this.classesElementLookup[ classKey ];
				if ( value[ classKey ] === this.options.classes[ classKey ] ||
						!currentElements ||
						!currentElements.length ) {
					continue;
				}

				// We are doing this to create a new jQuery object because the _removeClass() call
				// on the next line is going to destroy the reference to the current elements being
				// tracked. We need to save a copy of this collection so that we can add the new classes
				// below.
				elements = $( currentElements.get() );
				this._removeClass( currentElements, classKey );

				// We don't use _addClass() here, because that uses this.options.classes
				// for generating the string of classes. We want to use the value passed in from
				// _setOption(), this is the new value of the classes option which was passed to
				// _setOption(). We pass this value directly to _classes().
				elements.addClass( this._classes( {
					element: elements,
					keys: classKey,
					classes: value,
					add: true
				} ) );
			}
		},

		_setOptionDisabled: function( value ) {
			this._toggleClass( this.widget(), this.widgetFullName + "-disabled", null, !!value );

			// If the widget is becoming disabled, then nothing is interactive
			if ( value ) {
				this._removeClass( this.hoverable, null, "ui-state-hover" );
				this._removeClass( this.focusable, null, "ui-state-focus" );
			}
		},

		enable: function() {
			return this._setOptions( { disabled: false } );
		},

		disable: function() {
			return this._setOptions( { disabled: true } );
		},

		_classes: function( options ) {
			var full = [];
			var that = this;

			options = $.extend( {
				element: this.element,
				classes: this.options.classes || {}
			}, options );

			function processClassString( classes, checkOption ) {
				var current, i;
				for ( i = 0; i < classes.length; i++ ) {
					current = that.classesElementLookup[ classes[ i ] ] || $();
					if ( options.add ) {
						current = $( $.unique( current.get().concat( options.element.get() ) ) );
					} else {
						current = $( current.not( options.element ).get() );
					}
					that.classesElementLookup[ classes[ i ] ] = current;
					full.push( classes[ i ] );
					if ( checkOption && options.classes[ classes[ i ] ] ) {
						full.push( options.classes[ classes[ i ] ] );
					}
				}
			}

			if ( options.keys ) {
				processClassString( options.keys.match( /\S+/g ) || [], true );
			}
			if ( options.extra ) {
				processClassString( options.extra.match( /\S+/g ) || [] );
			}

			return full.join( " " );
		},

		_removeClass: function( element, keys, extra ) {
			return this._toggleClass( element, keys, extra, false );
		},

		_addClass: function( element, keys, extra ) {
			return this._toggleClass( element, keys, extra, true );
		},

		_toggleClass: function( element, keys, extra, add ) {
			add = ( typeof add === "boolean" ) ? add : extra;
			var shift = ( typeof element === "string" || element === null ),
				options = {
					extra: shift ? keys : extra,
					keys: shift ? element : keys,
					element: shift ? this.element : element,
					add: add
				};
			options.element.toggleClass( this._classes( options ), add );
			return this;
		},

		_on: function( suppressDisabledCheck, element, handlers ) {
			var delegateElement;
			var instance = this;

			// No suppressDisabledCheck flag, shuffle arguments
			if ( typeof suppressDisabledCheck !== "boolean" ) {
				handlers = element;
				element = suppressDisabledCheck;
				suppressDisabledCheck = false;
			}

			// No element argument, shuffle and use this.element
			if ( !handlers ) {
				handlers = element;
				element = this.element;
				delegateElement = this.widget();
			} else {
				element = delegateElement = $( element );
				this.bindings = this.bindings.add( element );
			}

			$.each( handlers, function( event, handler ) {
				function handlerProxy() {

					// Allow widgets to customize the disabled handling
					// - disabled as an array instead of boolean
					// - disabled class as method for disabling individual parts
					if ( !suppressDisabledCheck &&
							( instance.options.disabled === true ||
							$( this ).hasClass( "ui-state-disabled" ) ) ) {
						return;
					}
					return ( typeof handler === "string" ? instance[ handler ] : handler )
						.apply( instance, arguments );
				}

				// Copy the guid so direct unbinding works
				if ( typeof handler !== "string" ) {
					handlerProxy.guid = handler.guid =
						handler.guid || handlerProxy.guid || $.guid++;
				}

				var match = event.match( /^([\w:-]*)\s*(.*)$/ );
				var eventName = match[ 1 ] + instance.eventNamespace;
				var selector = match[ 2 ];

				if ( selector ) {
					delegateElement.on( eventName, selector, handlerProxy );
				} else {
					element.on( eventName, handlerProxy );
				}
			} );
		},

		_off: function( element, eventName ) {
			eventName = ( eventName || "" ).split( " " ).join( this.eventNamespace + " " ) +
				this.eventNamespace;
			element.off( eventName ).off( eventName );

			// Clear the stack to avoid memory leaks (#10056)
			this.bindings = $( this.bindings.not( element ).get() );
			this.focusable = $( this.focusable.not( element ).get() );
			this.hoverable = $( this.hoverable.not( element ).get() );
		},

		_delay: function( handler, delay ) {
			function handlerProxy() {
				return ( typeof handler === "string" ? instance[ handler ] : handler )
					.apply( instance, arguments );
			}
			var instance = this;
			return setTimeout( handlerProxy, delay || 0 );
		},

		_hoverable: function( element ) {
			this.hoverable = this.hoverable.add( element );
			this._on( element, {
				mouseenter: function( event ) {
					this._addClass( $( event.currentTarget ), null, "ui-state-hover" );
				},
				mouseleave: function( event ) {
					this._removeClass( $( event.currentTarget ), null, "ui-state-hover" );
				}
			} );
		},

		_focusable: function( element ) {
			this.focusable = this.focusable.add( element );
			this._on( element, {
				focusin: function( event ) {
					this._addClass( $( event.currentTarget ), null, "ui-state-focus" );
				},
				focusout: function( event ) {
					this._removeClass( $( event.currentTarget ), null, "ui-state-focus" );
				}
			} );
		},

		_trigger: function( type, event, data ) {
			var prop, orig;
			var callback = this.options[ type ];

			data = data || {};
			event = $.Event( event );
			event.type = ( type === this.widgetEventPrefix ?
				type :
				this.widgetEventPrefix + type ).toLowerCase();

			// The original event may come from any element
			// so we need to reset the target on the new event
			event.target = this.element[ 0 ];

			// Copy original event properties over to the new event
			orig = event.originalEvent;
			if ( orig ) {
				for ( prop in orig ) {
					if ( !( prop in event ) ) {
						event[ prop ] = orig[ prop ];
					}
				}
			}

			this.element.trigger( event, data );
			return !( $.isFunction( callback ) &&
				callback.apply( this.element[ 0 ], [ event ].concat( data ) ) === false ||
				event.isDefaultPrevented() );
		}
	};

	$.each( { show: "fadeIn", hide: "fadeOut" }, function( method, defaultEffect ) {
		$.Widget.prototype[ "_" + method ] = function( element, options, callback ) {
			if ( typeof options === "string" ) {
				options = { effect: options };
			}

			var hasOptions;
			var effectName = !options ?
				method :
				options === true || typeof options === "number" ?
					defaultEffect :
					options.effect || defaultEffect;

			options = options || {};
			if ( typeof options === "number" ) {
				options = { duration: options };
			}

			hasOptions = !$.isEmptyObject( options );
			options.complete = callback;

			if ( options.delay ) {
				element.delay( options.delay );
			}

			if ( hasOptions && $.effects && $.effects.effect[ effectName ] ) {
				element[ method ]( options );
			} else if ( effectName !== method && element[ effectName ] ) {
				element[ effectName ]( options.duration, options.easing, callback );
			} else {
				element.queue( function( next ) {
					$( this )[ method ]();
					if ( callback ) {
						callback.call( element[ 0 ] );
					}
					next();
				} );
			}
		};
	} );

	return $.widget;

	} ) );


/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;( function( factory ) {
		if ( true ) {

			// AMD. Register as an anonymous module.
			!(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(1) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else {

			// Browser globals
			factory( jQuery );
		}
	} ( function( $ ) {

	$.ui = $.ui || {};

	return $.ui.version = "1.12.0";

	} ) );


/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * jQuery UI Checkboxradio 1.12.0
	 * http://jqueryui.com
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license.
	 * http://jquery.org/license
	 */

	//>>label: Checkboxradio
	//>>group: Widgets
	//>>description: Enhances a form with multiple themeable checkboxes or radio buttons.
	//>>docs: http://api.jqueryui.com/checkboxradio/
	//>>demos: http://jqueryui.com/checkboxradio/
	//>>css.structure: ../../themes/base/core.css
	//>>css.structure: ../../themes/base/button.css
	//>>css.structure: ../../themes/base/checkboxradio.css
	//>>css.theme: ../../themes/base/theme.css

	( function( factory ) {
		if ( true ) {

			// AMD. Register as an anonymous module.
			!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
				__webpack_require__(1),
				__webpack_require__(8),
				__webpack_require__(9),
				__webpack_require__(11),
				__webpack_require__(5)
			], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else {

			// Browser globals
			factory( jQuery );
		}
	}( function( $ ) {

	$.widget( "ui.checkboxradio", [ $.ui.formResetMixin, {
		version: "1.12.0",
		options: {
			disabled: null,
			label: null,
			icon: true,
			classes: {
				"ui-checkboxradio-label": "ui-corner-all",
				"ui-checkboxradio-icon": "ui-corner-all"
			}
		},

		_getCreateOptions: function() {
			var disabled, labels;
			var that = this;
			var options = this._super() || {};

			// We read the type here, because it makes more sense to throw a element type error first,
			// rather then the error for lack of a label. Often if its the wrong type, it
			// won't have a label (e.g. calling on a div, btn, etc)
			this._readType();

			labels = this.element.labels();

			// If there are multiple labels, use the last one
			this.label = $( labels[ labels.length - 1 ] );
			if ( !this.label.length ) {
				$.error( "No label found for checkboxradio widget" );
			}

			this.originalLabel = "";

			// We need to get the label text but this may also need to make sure it does not contain the
			// input itself.
			this.label.contents().not( this.element ).each( function() {

				// The label contents could be text, html, or a mix. We concat each element to get a
				// string representation of the label, without the input as part of it.
				that.originalLabel += this.nodeType === 3 ? $( this ).text() : this.outerHTML;
			} );

			// Set the label option if we found label text
			if ( this.originalLabel ) {
				options.label = this.originalLabel;
			}

			disabled = this.element[ 0 ].disabled;
			if ( disabled != null ) {
				options.disabled = disabled;
			}
			return options;
		},

		_create: function() {
			var checked = this.element[ 0 ].checked;

			this._bindFormResetHandler();

			if ( this.options.disabled == null ) {
				this.options.disabled = this.element[ 0 ].disabled;
			}

			this._setOption( "disabled", this.options.disabled );
			this._addClass( "ui-checkboxradio", "ui-helper-hidden-accessible" );
			this._addClass( this.label, "ui-checkboxradio-label", "ui-button ui-widget" );

			if ( this.type === "radio" ) {
				this._addClass( this.label, "ui-checkboxradio-radio-label" );
			}

			if ( this.options.label && this.options.label !== this.originalLabel ) {
				this._updateLabel();
			} else if ( this.originalLabel ) {
				this.options.label = this.originalLabel;
			}

			this._enhance();

			if ( checked ) {
				this._addClass( this.label, "ui-checkboxradio-checked", "ui-state-active" );
				if ( this.icon ) {
					this._addClass( this.icon, null, "ui-state-hover" );
				}
			}

			this._on( {
				change: "_toggleClasses",
				focus: function() {
					this._addClass( this.label, null, "ui-state-focus ui-visual-focus" );
				},
				blur: function() {
					this._removeClass( this.label, null, "ui-state-focus ui-visual-focus" );
				}
			} );
		},

		_readType: function() {
			var nodeName = this.element[ 0 ].nodeName.toLowerCase();
			this.type = this.element[ 0 ].type;
			if ( nodeName !== "input" || !/radio|checkbox/.test( this.type ) ) {
				$.error( "Can't create checkboxradio on element.nodeName=" + nodeName +
					" and element.type=" + this.type );
			}
		},

		// Support jQuery Mobile enhanced option
		_enhance: function() {
			this._updateIcon( this.element[ 0 ].checked );
		},

		widget: function() {
			return this.label;
		},

		_getRadioGroup: function() {
			var group;
			var name = this.element[ 0 ].name;
			var nameSelector = "input[name='" + $.ui.escapeSelector( name ) + "']";

			if ( !name ) {
				return $( [] );
			}

			if ( this.form.length ) {
				group = $( this.form[ 0 ].elements ).filter( nameSelector );
			} else {

				// Not inside a form, check all inputs that also are not inside a form
				group = $( nameSelector ).filter( function() {
					return $( this ).form().length === 0;
				} );
			}

			return group.not( this.element );
		},

		_toggleClasses: function() {
			var checked = this.element[ 0 ].checked;
			this._toggleClass( this.label, "ui-checkboxradio-checked", "ui-state-active", checked );

			if ( this.options.icon && this.type === "checkbox" ) {
				this._toggleClass( this.icon, null, "ui-icon-check ui-state-checked", checked )
					._toggleClass( this.icon, null, "ui-icon-blank", !checked );
			}

			if ( this.type === "radio" ) {
				this._getRadioGroup()
					.each( function() {
						var instance = $( this ).checkboxradio( "instance" );

						if ( instance ) {
							instance._removeClass( instance.label,
								"ui-checkboxradio-checked", "ui-state-active" );
						}
					} );
			}
		},

		_destroy: function() {
			this._unbindFormResetHandler();

			if ( this.icon ) {
				this.icon.remove();
				this.iconSpace.remove();
			}
		},

		_setOption: function( key, value ) {

			// We don't allow the value to be set to nothing
			if ( key === "label" && !value ) {
				return;
			}

			this._super( key, value );

			if ( key === "disabled" ) {
				this._toggleClass( this.label, null, "ui-state-disabled", value );
				this.element[ 0 ].disabled = value;

				// Don't refresh when setting disabled
				return;
			}
			this.refresh();
		},

		_updateIcon: function( checked ) {
			var toAdd = "ui-icon ui-icon-background ";

			if ( this.options.icon ) {
				if ( !this.icon ) {
					this.icon = $( "<span>" );
					this.iconSpace = $( "<span> </span>" );
					this._addClass( this.iconSpace, "ui-checkboxradio-icon-space" );
				}

				if ( this.type === "checkbox" ) {
					toAdd += checked ? "ui-icon-check ui-state-checked" : "ui-icon-blank";
					this._removeClass( this.icon, null, checked ? "ui-icon-blank" : "ui-icon-check" );
				} else {
					toAdd += "ui-icon-blank";
				}
				this._addClass( this.icon, "ui-checkboxradio-icon", toAdd );
				if ( !checked ) {
					this._removeClass( this.icon, null, "ui-icon-check ui-state-checked" );
				}
				this.icon.prependTo( this.label ).after( this.iconSpace );
			} else if ( this.icon !== undefined ) {
				this.icon.remove();
				this.iconSpace.remove();
				delete this.icon;
			}
		},

		_updateLabel: function() {

			// Remove the contents of the label ( minus the icon, icon space, and input )
			this.label.contents().not( this.element.add( this.icon ).add( this.iconSpace ) ).remove();
			this.label.append( this.options.label );
		},

		refresh: function() {
			var checked = this.element[ 0 ].checked,
				isDisabled = this.element[ 0 ].disabled;

			this._updateIcon( checked );
			this._toggleClass( this.label, "ui-checkboxradio-checked", "ui-state-active", checked );
			if ( this.options.label !== null ) {
				this._updateLabel();
			}

			if ( isDisabled !== this.options.disabled ) {
				this._setOptions( { "disabled": isDisabled } );
			}
		}

	} ] );

	return $.ui.checkboxradio;

	} ) );


/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;( function( factory ) {
		if ( true ) {

			// AMD. Register as an anonymous module.
			!(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(1), __webpack_require__(6) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else {

			// Browser globals
			factory( jQuery );
		}
	} ( function( $ ) {

	// Internal use only
	return $.ui.escapeSelector = ( function() {
		var selectorEscape = /([!"#$%&'()*+,./:;<=>?@[\]^`{|}~])/g;
		return function( selector ) {
			return selector.replace( selectorEscape, "\\$1" );
		};
	} )();

	} ) );


/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * jQuery UI Form Reset Mixin 1.12.0
	 * http://jqueryui.com
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license.
	 * http://jquery.org/license
	 */

	//>>label: Form Reset Mixin
	//>>group: Core
	//>>description: Refresh input widgets when their form is reset
	//>>docs: http://api.jqueryui.com/form-reset-mixin/

	( function( factory ) {
		if ( true ) {

			// AMD. Register as an anonymous module.
			!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
				__webpack_require__(1),
				__webpack_require__(10),
				__webpack_require__(6)
			], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else {

			// Browser globals
			factory( jQuery );
		}
	}( function( $ ) {

	return $.ui.formResetMixin = {
		_formResetHandler: function() {
			var form = $( this );

			// Wait for the form reset to actually happen before refreshing
			setTimeout( function() {
				var instances = form.data( "ui-form-reset-instances" );
				$.each( instances, function() {
					this.refresh();
				} );
			} );
		},

		_bindFormResetHandler: function() {
			this.form = this.element.form();
			if ( !this.form.length ) {
				return;
			}

			var instances = this.form.data( "ui-form-reset-instances" ) || [];
			if ( !instances.length ) {

				// We don't use _on() here because we use a single event handler per form
				this.form.on( "reset.ui-form-reset", this._formResetHandler );
			}
			instances.push( this );
			this.form.data( "ui-form-reset-instances", instances );
		},

		_unbindFormResetHandler: function() {
			if ( !this.form.length ) {
				return;
			}

			var instances = this.form.data( "ui-form-reset-instances" );
			instances.splice( $.inArray( this, instances ), 1 );
			if ( instances.length ) {
				this.form.data( "ui-form-reset-instances", instances );
			} else {
				this.form
					.removeData( "ui-form-reset-instances" )
					.off( "reset.ui-form-reset" );
			}
		}
	};

	} ) );


/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;( function( factory ) {
		if ( true ) {

			// AMD. Register as an anonymous module.
			!(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(1), __webpack_require__(6) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else {

			// Browser globals
			factory( jQuery );
		}
	} ( function( $ ) {

	// Support: IE8 Only
	// IE8 does not support the form attribute and when it is supplied. It overwrites the form prop
	// with a string, so we need to find the proper form.
	return $.fn.form = function() {
		return typeof this[ 0 ].form === "string" ? this.closest( "form" ) : $( this[ 0 ].form );
	};

	} ) );


/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * jQuery UI Labels 1.12.0
	 * http://jqueryui.com
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license.
	 * http://jquery.org/license
	 */

	//>>label: labels
	//>>group: Core
	//>>description: Find all the labels associated with a given input
	//>>docs: http://api.jqueryui.com/labels/

	( function( factory ) {
		if ( true ) {

			// AMD. Register as an anonymous module.
			!(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(1), __webpack_require__(6), __webpack_require__(8) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else {

			// Browser globals
			factory( jQuery );
		}
	} ( function( $ ) {

	return $.fn.labels = function() {
		var ancestor, selector, id, labels, ancestors;

		// Check control.labels first
		if ( this[ 0 ].labels && this[ 0 ].labels.length ) {
			return this.pushStack( this[ 0 ].labels );
		}

		// Support: IE <= 11, FF <= 37, Android <= 2.3 only
		// Above browsers do not support control.labels. Everything below is to support them
		// as well as document fragments. control.labels does not work on document fragments
		labels = this.eq( 0 ).parents( "label" );

		// Look for the label based on the id
		id = this.attr( "id" );
		if ( id ) {

			// We don't search against the document in case the element
			// is disconnected from the DOM
			ancestor = this.eq( 0 ).parents().last();

			// Get a full set of top level ancestors
			ancestors = ancestor.add( ancestor.length ? ancestor.siblings() : this.siblings() );

			// Create a selector for the label based on the id
			selector = "label[for='" + $.ui.escapeSelector( id ) + "']";

			labels = labels.add( ancestors.find( selector ).addBack( selector ) );

		}

		// Return whatever we have found for labels
		return this.pushStack( labels );
	};

	} ) );


/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * jQuery UI Keycode 1.12.0
	 * http://jqueryui.com
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license.
	 * http://jquery.org/license
	 */

	//>>label: Keycode
	//>>group: Core
	//>>description: Provide keycodes as keynames
	//>>docs: http://api.jqueryui.com/jQuery.ui.keyCode/

	( function( factory ) {
		if ( true ) {

			// AMD. Register as an anonymous module.
			!(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(1), __webpack_require__(6) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else {

			// Browser globals
			factory( jQuery );
		}
	} ( function( $ ) {
	return $.ui.keyCode = {
		BACKSPACE: 8,
		COMMA: 188,
		DELETE: 46,
		DOWN: 40,
		END: 35,
		ENTER: 13,
		ESCAPE: 27,
		HOME: 36,
		LEFT: 37,
		PAGE_DOWN: 34,
		PAGE_UP: 33,
		PERIOD: 190,
		RIGHT: 39,
		SPACE: 32,
		TAB: 9,
		UP: 38
	};

	} ) );


/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;( function( factory ) {
		if ( true ) {

			// AMD. Register as an anonymous module.
			!(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(1), __webpack_require__(6) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else {

			// Browser globals
			factory( jQuery );
		}
	} ( function( $ ) {
	return $.ui.safeActiveElement = function( document ) {
		var activeElement;

		// Support: IE 9 only
		// IE9 throws an "Unspecified error" accessing document.activeElement from an <iframe>
		try {
			activeElement = document.activeElement;
		} catch ( error ) {
			activeElement = document.body;
		}

		// Support: IE 9 - 11 only
		// IE may return null instead of an element
		// Interestingly, this only seems to occur when NOT in an iframe
		if ( !activeElement ) {
			activeElement = document.body;
		}

		// Support: IE 11 only
		// IE11 returns a seemingly empty object in some cases when accessing
		// document.activeElement from an <iframe>
		if ( !activeElement.nodeName ) {
			activeElement = document.body;
		}

		return activeElement;
	};

	} ) );


/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * jQuery UI Selectmenu 1.12.0
	 * http://jqueryui.com
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license.
	 * http://jquery.org/license
	 */

	//>>label: Selectmenu
	//>>group: Widgets
	// jscs:disable maximumLineLength
	//>>description: Duplicates and extends the functionality of a native HTML select element, allowing it to be customizable in behavior and appearance far beyond the limitations of a native select.
	// jscs:enable maximumLineLength
	//>>docs: http://api.jqueryui.com/selectmenu/
	//>>demos: http://jqueryui.com/selectmenu/
	//>>css.structure: ../../themes/base/core.css
	//>>css.structure: ../../themes/base/selectmenu.css, ../../themes/base/button.css
	//>>css.theme: ../../themes/base/theme.css

	( function( factory ) {
		if ( true ) {

			// AMD. Register as an anonymous module.
			!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
				__webpack_require__(1),
				__webpack_require__(15),
				__webpack_require__(8),
				__webpack_require__(9),
				__webpack_require__(12),
				__webpack_require__(11),
				__webpack_require__(16),
				__webpack_require__(17),
				__webpack_require__(6),
				__webpack_require__(5)
			], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else {

			// Browser globals
			factory( jQuery );
		}
	}( function( $ ) {

	return $.widget( "ui.selectmenu", [ $.ui.formResetMixin, {
		version: "1.12.0",
		defaultElement: "<select>",
		options: {
			appendTo: null,
			classes: {
				"ui-selectmenu-button-open": "ui-corner-top",
				"ui-selectmenu-button-closed": "ui-corner-all"
			},
			disabled: null,
			icons: {
				button: "ui-icon-triangle-1-s"
			},
			position: {
				my: "left top",
				at: "left bottom",
				collision: "none"
			},
			width: false,

			// Callbacks
			change: null,
			close: null,
			focus: null,
			open: null,
			select: null
		},

		_create: function() {
			var selectmenuId = this.element.uniqueId().attr( "id" );
			this.ids = {
				element: selectmenuId,
				button: selectmenuId + "-button",
				menu: selectmenuId + "-menu"
			};

			this._drawButton();
			this._drawMenu();
			this._bindFormResetHandler();

			this._rendered = false;
			this.menuItems = $();
		},

		_drawButton: function() {
			var icon,
				that = this,
				item = this._parseOption(
					this.element.find( "option:selected" ),
					this.element[ 0 ].selectedIndex
				);

			// Associate existing label with the new button
			this.labels = this.element.labels().attr( "for", this.ids.button );
			this._on( this.labels, {
				click: function( event ) {
					this.button.focus();
					event.preventDefault();
				}
			} );

			// Hide original select element
			this.element.hide();

			// Create button
			this.button = $( "<span>", {
				tabindex: this.options.disabled ? -1 : 0,
				id: this.ids.button,
				role: "combobox",
				"aria-expanded": "false",
				"aria-autocomplete": "list",
				"aria-owns": this.ids.menu,
				"aria-haspopup": "true",
				title: this.element.attr( "title" )
			} )
				.insertAfter( this.element );

			this._addClass( this.button, "ui-selectmenu-button ui-selectmenu-button-closed",
				"ui-button ui-widget" );

			icon = $( "<span>" ).appendTo( this.button );
			this._addClass( icon, "ui-selectmenu-icon", "ui-icon " + this.options.icons.button );
			this.buttonItem = this._renderButtonItem( item )
				.appendTo( this.button );

			if ( this.options.width !== false ) {
				this._resizeButton();
			}

			this._on( this.button, this._buttonEvents );
			this.button.one( "focusin", function() {

				// Delay rendering the menu items until the button receives focus.
				// The menu may have already been rendered via a programmatic open.
				if ( !that._rendered ) {
					that._refreshMenu();
				}
			} );
		},

		_drawMenu: function() {
			var that = this;

			// Create menu
			this.menu = $( "<ul>", {
				"aria-hidden": "true",
				"aria-labelledby": this.ids.button,
				id: this.ids.menu
			} );

			// Wrap menu
			this.menuWrap = $( "<div>" ).append( this.menu );
			this._addClass( this.menuWrap, "ui-selectmenu-menu", "ui-front" );
			this.menuWrap.appendTo( this._appendTo() );

			// Initialize menu widget
			this.menuInstance = this.menu
				.menu( {
					classes: {
						"ui-menu": "ui-corner-bottom"
					},
					role: "listbox",
					select: function( event, ui ) {
						event.preventDefault();

						// Support: IE8
						// If the item was selected via a click, the text selection
						// will be destroyed in IE
						that._setSelection();

						that._select( ui.item.data( "ui-selectmenu-item" ), event );
					},
					focus: function( event, ui ) {
						var item = ui.item.data( "ui-selectmenu-item" );

						// Prevent inital focus from firing and check if its a newly focused item
						if ( that.focusIndex != null && item.index !== that.focusIndex ) {
							that._trigger( "focus", event, { item: item } );
							if ( !that.isOpen ) {
								that._select( item, event );
							}
						}
						that.focusIndex = item.index;

						that.button.attr( "aria-activedescendant",
							that.menuItems.eq( item.index ).attr( "id" ) );
					}
				} )
				.menu( "instance" );

			// Don't close the menu on mouseleave
			this.menuInstance._off( this.menu, "mouseleave" );

			// Cancel the menu's collapseAll on document click
			this.menuInstance._closeOnDocumentClick = function() {
				return false;
			};

			// Selects often contain empty items, but never contain dividers
			this.menuInstance._isDivider = function() {
				return false;
			};
		},

		refresh: function() {
			this._refreshMenu();
			this.buttonItem.replaceWith(
				this.buttonItem = this._renderButtonItem(

					// Fall back to an empty object in case there are no options
					this._getSelectedItem().data( "ui-selectmenu-item" ) || {}
				)
			);
			if ( this.options.width === null ) {
				this._resizeButton();
			}
		},

		_refreshMenu: function() {
			var item,
				options = this.element.find( "option" );

			this.menu.empty();

			this._parseOptions( options );
			this._renderMenu( this.menu, this.items );

			this.menuInstance.refresh();
			this.menuItems = this.menu.find( "li" )
				.not( ".ui-selectmenu-optgroup" )
					.find( ".ui-menu-item-wrapper" );

			this._rendered = true;

			if ( !options.length ) {
				return;
			}

			item = this._getSelectedItem();

			// Update the menu to have the correct item focused
			this.menuInstance.focus( null, item );
			this._setAria( item.data( "ui-selectmenu-item" ) );

			// Set disabled state
			this._setOption( "disabled", this.element.prop( "disabled" ) );
		},

		open: function( event ) {
			if ( this.options.disabled ) {
				return;
			}

			// If this is the first time the menu is being opened, render the items
			if ( !this._rendered ) {
				this._refreshMenu();
			} else {

				// Menu clears focus on close, reset focus to selected item
				this._removeClass( this.menu.find( ".ui-state-active" ), null, "ui-state-active" );
				this.menuInstance.focus( null, this._getSelectedItem() );
			}

			// If there are no options, don't open the menu
			if ( !this.menuItems.length ) {
				return;
			}

			this.isOpen = true;
			this._toggleAttr();
			this._resizeMenu();
			this._position();

			this._on( this.document, this._documentClick );

			this._trigger( "open", event );
		},

		_position: function() {
			this.menuWrap.position( $.extend( { of: this.button }, this.options.position ) );
		},

		close: function( event ) {
			if ( !this.isOpen ) {
				return;
			}

			this.isOpen = false;
			this._toggleAttr();

			this.range = null;
			this._off( this.document );

			this._trigger( "close", event );
		},

		widget: function() {
			return this.button;
		},

		menuWidget: function() {
			return this.menu;
		},

		_renderButtonItem: function( item ) {
			var buttonItem = $( "<span>" );

			this._setText( buttonItem, item.label );
			this._addClass( buttonItem, "ui-selectmenu-text" );

			return buttonItem;
		},

		_renderMenu: function( ul, items ) {
			var that = this,
				currentOptgroup = "";

			$.each( items, function( index, item ) {
				var li;

				if ( item.optgroup !== currentOptgroup ) {
					li = $( "<li>", {
						text: item.optgroup
					} );
					that._addClass( li, "ui-selectmenu-optgroup", "ui-menu-divider" +
						( item.element.parent( "optgroup" ).prop( "disabled" ) ?
							" ui-state-disabled" :
							"" ) );

					li.appendTo( ul );

					currentOptgroup = item.optgroup;
				}

				that._renderItemData( ul, item );
			} );
		},

		_renderItemData: function( ul, item ) {
			return this._renderItem( ul, item ).data( "ui-selectmenu-item", item );
		},

		_renderItem: function( ul, item ) {
			var li = $( "<li>" ),
				wrapper = $( "<div>", {
					title: item.element.attr( "title" )
				} );

			if ( item.disabled ) {
				this._addClass( li, null, "ui-state-disabled" );
			}
			this._setText( wrapper, item.label );

			return li.append( wrapper ).appendTo( ul );
		},

		_setText: function( element, value ) {
			if ( value ) {
				element.text( value );
			} else {
				element.html( "&#160;" );
			}
		},

		_move: function( direction, event ) {
			var item, next,
				filter = ".ui-menu-item";

			if ( this.isOpen ) {
				item = this.menuItems.eq( this.focusIndex ).parent( "li" );
			} else {
				item = this.menuItems.eq( this.element[ 0 ].selectedIndex ).parent( "li" );
				filter += ":not(.ui-state-disabled)";
			}

			if ( direction === "first" || direction === "last" ) {
				next = item[ direction === "first" ? "prevAll" : "nextAll" ]( filter ).eq( -1 );
			} else {
				next = item[ direction + "All" ]( filter ).eq( 0 );
			}

			if ( next.length ) {
				this.menuInstance.focus( event, next );
			}
		},

		_getSelectedItem: function() {
			return this.menuItems.eq( this.element[ 0 ].selectedIndex ).parent( "li" );
		},

		_toggle: function( event ) {
			this[ this.isOpen ? "close" : "open" ]( event );
		},

		_setSelection: function() {
			var selection;

			if ( !this.range ) {
				return;
			}

			if ( window.getSelection ) {
				selection = window.getSelection();
				selection.removeAllRanges();
				selection.addRange( this.range );

			// Support: IE8
			} else {
				this.range.select();
			}

			// Support: IE
			// Setting the text selection kills the button focus in IE, but
			// restoring the focus doesn't kill the selection.
			this.button.focus();
		},

		_documentClick: {
			mousedown: function( event ) {
				if ( !this.isOpen ) {
					return;
				}

				if ( !$( event.target ).closest( ".ui-selectmenu-menu, #" +
						$.ui.escapeSelector( this.ids.button ) ).length ) {
					this.close( event );
				}
			}
		},

		_buttonEvents: {

			// Prevent text selection from being reset when interacting with the selectmenu (#10144)
			mousedown: function() {
				var selection;

				if ( window.getSelection ) {
					selection = window.getSelection();
					if ( selection.rangeCount ) {
						this.range = selection.getRangeAt( 0 );
					}

				// Support: IE8
				} else {
					this.range = document.selection.createRange();
				}
			},

			click: function( event ) {
				this._setSelection();
				this._toggle( event );
			},

			keydown: function( event ) {
				var preventDefault = true;
				switch ( event.keyCode ) {
				case $.ui.keyCode.TAB:
				case $.ui.keyCode.ESCAPE:
					this.close( event );
					preventDefault = false;
					break;
				case $.ui.keyCode.ENTER:
					if ( this.isOpen ) {
						this._selectFocusedItem( event );
					}
					break;
				case $.ui.keyCode.UP:
					if ( event.altKey ) {
						this._toggle( event );
					} else {
						this._move( "prev", event );
					}
					break;
				case $.ui.keyCode.DOWN:
					if ( event.altKey ) {
						this._toggle( event );
					} else {
						this._move( "next", event );
					}
					break;
				case $.ui.keyCode.SPACE:
					if ( this.isOpen ) {
						this._selectFocusedItem( event );
					} else {
						this._toggle( event );
					}
					break;
				case $.ui.keyCode.LEFT:
					this._move( "prev", event );
					break;
				case $.ui.keyCode.RIGHT:
					this._move( "next", event );
					break;
				case $.ui.keyCode.HOME:
				case $.ui.keyCode.PAGE_UP:
					this._move( "first", event );
					break;
				case $.ui.keyCode.END:
				case $.ui.keyCode.PAGE_DOWN:
					this._move( "last", event );
					break;
				default:
					this.menu.trigger( event );
					preventDefault = false;
				}

				if ( preventDefault ) {
					event.preventDefault();
				}
			}
		},

		_selectFocusedItem: function( event ) {
			var item = this.menuItems.eq( this.focusIndex ).parent( "li" );
			if ( !item.hasClass( "ui-state-disabled" ) ) {
				this._select( item.data( "ui-selectmenu-item" ), event );
			}
		},

		_select: function( item, event ) {
			var oldIndex = this.element[ 0 ].selectedIndex;

			// Change native select element
			this.element[ 0 ].selectedIndex = item.index;
			this.buttonItem.replaceWith( this.buttonItem = this._renderButtonItem( item ) );
			this._setAria( item );
			this._trigger( "select", event, { item: item } );

			if ( item.index !== oldIndex ) {
				this._trigger( "change", event, { item: item } );
			}

			this.close( event );
		},

		_setAria: function( item ) {
			var id = this.menuItems.eq( item.index ).attr( "id" );

			this.button.attr( {
				"aria-labelledby": id,
				"aria-activedescendant": id
			} );
			this.menu.attr( "aria-activedescendant", id );
		},

		_setOption: function( key, value ) {
			if ( key === "icons" ) {
				var icon = this.button.find( "span.ui-icon" );
				this._removeClass( icon, null, this.options.icons.button )
					._addClass( icon, null, value.button );
			}

			this._super( key, value );

			if ( key === "appendTo" ) {
				this.menuWrap.appendTo( this._appendTo() );
			}

			if ( key === "width" ) {
				this._resizeButton();
			}
		},

		_setOptionDisabled: function( value ) {
			this._super( value );

			this.menuInstance.option( "disabled", value );
			this.button.attr( "aria-disabled", value );
			this._toggleClass( this.button, null, "ui-state-disabled", value );

			this.element.prop( "disabled", value );
			if ( value ) {
				this.button.attr( "tabindex", -1 );
				this.close();
			} else {
				this.button.attr( "tabindex", 0 );
			}
		},

		_appendTo: function() {
			var element = this.options.appendTo;

			if ( element ) {
				element = element.jquery || element.nodeType ?
					$( element ) :
					this.document.find( element ).eq( 0 );
			}

			if ( !element || !element[ 0 ] ) {
				element = this.element.closest( ".ui-front, dialog" );
			}

			if ( !element.length ) {
				element = this.document[ 0 ].body;
			}

			return element;
		},

		_toggleAttr: function() {
			this.button.attr( "aria-expanded", this.isOpen );

			// We can't use two _toggleClass() calls here, because we need to make sure
			// we always remove classes first and add them second, otherwise if both classes have the
			// same theme class, it will be removed after we add it.
			this._removeClass( this.button, "ui-selectmenu-button-" +
				( this.isOpen ? "closed" : "open" ) )
				._addClass( this.button, "ui-selectmenu-button-" +
					( this.isOpen ? "open" : "closed" ) )
				._toggleClass( this.menuWrap, "ui-selectmenu-open", null, this.isOpen );

			this.menu.attr( "aria-hidden", !this.isOpen );
		},

		_resizeButton: function() {
			var width = this.options.width;

			// For `width: false`, just remove inline style and stop
			if ( width === false ) {
				this.button.css( "width", "" );
				return;
			}

			// For `width: null`, match the width of the original element
			if ( width === null ) {
				width = this.element.show().outerWidth();
				this.element.hide();
			}

			this.button.outerWidth( width );
		},

		_resizeMenu: function() {
			this.menu.outerWidth( Math.max(
				this.button.outerWidth(),

				// Support: IE10
				// IE10 wraps long text (possibly a rounding bug)
				// so we add 1px to avoid the wrapping
				this.menu.width( "" ).outerWidth() + 1
			) );
		},

		_getCreateOptions: function() {
			var options = this._super();

			options.disabled = this.element.prop( "disabled" );

			return options;
		},

		_parseOptions: function( options ) {
			var that = this,
				data = [];
			options.each( function( index, item ) {
				data.push( that._parseOption( $( item ), index ) );
			} );
			this.items = data;
		},

		_parseOption: function( option, index ) {
			var optgroup = option.parent( "optgroup" );

			return {
				element: option,
				index: index,
				value: option.val(),
				label: option.text(),
				optgroup: optgroup.attr( "label" ) || "",
				disabled: optgroup.prop( "disabled" ) || option.prop( "disabled" )
			};
		},

		_destroy: function() {
			this._unbindFormResetHandler();
			this.menuWrap.remove();
			this.button.remove();
			this.element.show();
			this.element.removeUniqueId();
			this.labels.attr( "for", this.ids.element );
		}
	} ] );

	} ) );


/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * jQuery UI Menu 1.12.0
	 * http://jqueryui.com
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license.
	 * http://jquery.org/license
	 */

	//>>label: Menu
	//>>group: Widgets
	//>>description: Creates nestable menus.
	//>>docs: http://api.jqueryui.com/menu/
	//>>demos: http://jqueryui.com/menu/
	//>>css.structure: ../../themes/base/core.css
	//>>css.structure: ../../themes/base/menu.css
	//>>css.theme: ../../themes/base/theme.css

	( function( factory ) {
		if ( true ) {

			// AMD. Register as an anonymous module.
			!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
				__webpack_require__(1),
				__webpack_require__(12),
				__webpack_require__(16),
				__webpack_require__(13),
				__webpack_require__(17),
				__webpack_require__(6),
				__webpack_require__(5)
			], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else {

			// Browser globals
			factory( jQuery );
		}
	}( function( $ ) {

	return $.widget( "ui.menu", {
		version: "1.12.0",
		defaultElement: "<ul>",
		delay: 300,
		options: {
			icons: {
				submenu: "ui-icon-caret-1-e"
			},
			items: "> *",
			menus: "ul",
			position: {
				my: "left top",
				at: "right top"
			},
			role: "menu",

			// Callbacks
			blur: null,
			focus: null,
			select: null
		},

		_create: function() {
			this.activeMenu = this.element;

			// Flag used to prevent firing of the click handler
			// as the event bubbles up through nested menus
			this.mouseHandled = false;
			this.element
				.uniqueId()
				.attr( {
					role: this.options.role,
					tabIndex: 0
				} );

			this._addClass( "ui-menu", "ui-widget ui-widget-content" );
			this._on( {

				// Prevent focus from sticking to links inside menu after clicking
				// them (focus should always stay on UL during navigation).
				"mousedown .ui-menu-item": function( event ) {
					event.preventDefault();
				},
				"click .ui-menu-item": function( event ) {
					var target = $( event.target );
					var active = $( $.ui.safeActiveElement( this.document[ 0 ] ) );
					if ( !this.mouseHandled && target.not( ".ui-state-disabled" ).length ) {
						this.select( event );

						// Only set the mouseHandled flag if the event will bubble, see #9469.
						if ( !event.isPropagationStopped() ) {
							this.mouseHandled = true;
						}

						// Open submenu on click
						if ( target.has( ".ui-menu" ).length ) {
							this.expand( event );
						} else if ( !this.element.is( ":focus" ) &&
								active.closest( ".ui-menu" ).length ) {

							// Redirect focus to the menu
							this.element.trigger( "focus", [ true ] );

							// If the active item is on the top level, let it stay active.
							// Otherwise, blur the active item since it is no longer visible.
							if ( this.active && this.active.parents( ".ui-menu" ).length === 1 ) {
								clearTimeout( this.timer );
							}
						}
					}
				},
				"mouseenter .ui-menu-item": function( event ) {

					// Ignore mouse events while typeahead is active, see #10458.
					// Prevents focusing the wrong item when typeahead causes a scroll while the mouse
					// is over an item in the menu
					if ( this.previousFilter ) {
						return;
					}

					var actualTarget = $( event.target ).closest( ".ui-menu-item" ),
						target = $( event.currentTarget );

					// Ignore bubbled events on parent items, see #11641
					if ( actualTarget[ 0 ] !== target[ 0 ] ) {
						return;
					}

					// Remove ui-state-active class from siblings of the newly focused menu item
					// to avoid a jump caused by adjacent elements both having a class with a border
					this._removeClass( target.siblings().children( ".ui-state-active" ),
						null, "ui-state-active" );
					this.focus( event, target );
				},
				mouseleave: "collapseAll",
				"mouseleave .ui-menu": "collapseAll",
				focus: function( event, keepActiveItem ) {

					// If there's already an active item, keep it active
					// If not, activate the first item
					var item = this.active || this.element.find( this.options.items ).eq( 0 );

					if ( !keepActiveItem ) {
						this.focus( event, item );
					}
				},
				blur: function( event ) {
					this._delay( function() {
						var notContained = !$.contains(
							this.element[ 0 ],
							$.ui.safeActiveElement( this.document[ 0 ] )
						);
						if ( notContained ) {
							this.collapseAll( event );
						}
					} );
				},
				keydown: "_keydown"
			} );

			this.refresh();

			// Clicks outside of a menu collapse any open menus
			this._on( this.document, {
				click: function( event ) {
					if ( this._closeOnDocumentClick( event ) ) {
						this.collapseAll( event );
					}

					// Reset the mouseHandled flag
					this.mouseHandled = false;
				}
			} );
		},

		_destroy: function() {
			var items = this.element.find( ".ui-menu-item" )
					.removeAttr( "role aria-disabled" ),
				submenus = items.children( ".ui-menu-item-wrapper" )
					.removeUniqueId()
					.removeAttr( "tabIndex role aria-haspopup" );

			// Destroy (sub)menus
			this.element
				.removeAttr( "aria-activedescendant" )
				.find( ".ui-menu" ).addBack()
					.removeAttr( "role aria-labelledby aria-expanded aria-hidden aria-disabled " +
						"tabIndex" )
					.removeUniqueId()
					.show();

			submenus.children().each( function() {
				var elem = $( this );
				if ( elem.data( "ui-menu-submenu-caret" ) ) {
					elem.remove();
				}
			} );
		},

		_keydown: function( event ) {
			var match, prev, character, skip,
				preventDefault = true;

			switch ( event.keyCode ) {
			case $.ui.keyCode.PAGE_UP:
				this.previousPage( event );
				break;
			case $.ui.keyCode.PAGE_DOWN:
				this.nextPage( event );
				break;
			case $.ui.keyCode.HOME:
				this._move( "first", "first", event );
				break;
			case $.ui.keyCode.END:
				this._move( "last", "last", event );
				break;
			case $.ui.keyCode.UP:
				this.previous( event );
				break;
			case $.ui.keyCode.DOWN:
				this.next( event );
				break;
			case $.ui.keyCode.LEFT:
				this.collapse( event );
				break;
			case $.ui.keyCode.RIGHT:
				if ( this.active && !this.active.is( ".ui-state-disabled" ) ) {
					this.expand( event );
				}
				break;
			case $.ui.keyCode.ENTER:
			case $.ui.keyCode.SPACE:
				this._activate( event );
				break;
			case $.ui.keyCode.ESCAPE:
				this.collapse( event );
				break;
			default:
				preventDefault = false;
				prev = this.previousFilter || "";
				character = String.fromCharCode( event.keyCode );
				skip = false;

				clearTimeout( this.filterTimer );

				if ( character === prev ) {
					skip = true;
				} else {
					character = prev + character;
				}

				match = this._filterMenuItems( character );
				match = skip && match.index( this.active.next() ) !== -1 ?
					this.active.nextAll( ".ui-menu-item" ) :
					match;

				// If no matches on the current filter, reset to the last character pressed
				// to move down the menu to the first item that starts with that character
				if ( !match.length ) {
					character = String.fromCharCode( event.keyCode );
					match = this._filterMenuItems( character );
				}

				if ( match.length ) {
					this.focus( event, match );
					this.previousFilter = character;
					this.filterTimer = this._delay( function() {
						delete this.previousFilter;
					}, 1000 );
				} else {
					delete this.previousFilter;
				}
			}

			if ( preventDefault ) {
				event.preventDefault();
			}
		},

		_activate: function( event ) {
			if ( this.active && !this.active.is( ".ui-state-disabled" ) ) {
				if ( this.active.children( "[aria-haspopup='true']" ).length ) {
					this.expand( event );
				} else {
					this.select( event );
				}
			}
		},

		refresh: function() {
			var menus, items, newSubmenus, newItems, newWrappers,
				that = this,
				icon = this.options.icons.submenu,
				submenus = this.element.find( this.options.menus );

			this._toggleClass( "ui-menu-icons", null, !!this.element.find( ".ui-icon" ).length );

			// Initialize nested menus
			newSubmenus = submenus.filter( ":not(.ui-menu)" )
				.hide()
				.attr( {
					role: this.options.role,
					"aria-hidden": "true",
					"aria-expanded": "false"
				} )
				.each( function() {
					var menu = $( this ),
						item = menu.prev(),
						submenuCaret = $( "<span>" ).data( "ui-menu-submenu-caret", true );

					that._addClass( submenuCaret, "ui-menu-icon", "ui-icon " + icon );
					item
						.attr( "aria-haspopup", "true" )
						.prepend( submenuCaret );
					menu.attr( "aria-labelledby", item.attr( "id" ) );
				} );

			this._addClass( newSubmenus, "ui-menu", "ui-widget ui-widget-content ui-front" );

			menus = submenus.add( this.element );
			items = menus.find( this.options.items );

			// Initialize menu-items containing spaces and/or dashes only as dividers
			items.not( ".ui-menu-item" ).each( function() {
				var item = $( this );
				if ( that._isDivider( item ) ) {
					that._addClass( item, "ui-menu-divider", "ui-widget-content" );
				}
			} );

			// Don't refresh list items that are already adapted
			newItems = items.not( ".ui-menu-item, .ui-menu-divider" );
			newWrappers = newItems.children()
				.not( ".ui-menu" )
					.uniqueId()
					.attr( {
						tabIndex: -1,
						role: this._itemRole()
					} );
			this._addClass( newItems, "ui-menu-item" )
				._addClass( newWrappers, "ui-menu-item-wrapper" );

			// Add aria-disabled attribute to any disabled menu item
			items.filter( ".ui-state-disabled" ).attr( "aria-disabled", "true" );

			// If the active item has been removed, blur the menu
			if ( this.active && !$.contains( this.element[ 0 ], this.active[ 0 ] ) ) {
				this.blur();
			}
		},

		_itemRole: function() {
			return {
				menu: "menuitem",
				listbox: "option"
			}[ this.options.role ];
		},

		_setOption: function( key, value ) {
			if ( key === "icons" ) {
				var icons = this.element.find( ".ui-menu-icon" );
				this._removeClass( icons, null, this.options.icons.submenu )
					._addClass( icons, null, value.submenu );
			}
			this._super( key, value );
		},

		_setOptionDisabled: function( value ) {
			this._super( value );

			this.element.attr( "aria-disabled", String( value ) );
			this._toggleClass( null, "ui-state-disabled", !!value );
		},

		focus: function( event, item ) {
			var nested, focused, activeParent;
			this.blur( event, event && event.type === "focus" );

			this._scrollIntoView( item );

			this.active = item.first();

			focused = this.active.children( ".ui-menu-item-wrapper" );
			this._addClass( focused, null, "ui-state-active" );

			// Only update aria-activedescendant if there's a role
			// otherwise we assume focus is managed elsewhere
			if ( this.options.role ) {
				this.element.attr( "aria-activedescendant", focused.attr( "id" ) );
			}

			// Highlight active parent menu item, if any
			activeParent = this.active
				.parent()
					.closest( ".ui-menu-item" )
						.children( ".ui-menu-item-wrapper" );
			this._addClass( activeParent, null, "ui-state-active" );

			if ( event && event.type === "keydown" ) {
				this._close();
			} else {
				this.timer = this._delay( function() {
					this._close();
				}, this.delay );
			}

			nested = item.children( ".ui-menu" );
			if ( nested.length && event && ( /^mouse/.test( event.type ) ) ) {
				this._startOpening( nested );
			}
			this.activeMenu = item.parent();

			this._trigger( "focus", event, { item: item } );
		},

		_scrollIntoView: function( item ) {
			var borderTop, paddingTop, offset, scroll, elementHeight, itemHeight;
			if ( this._hasScroll() ) {
				borderTop = parseFloat( $.css( this.activeMenu[ 0 ], "borderTopWidth" ) ) || 0;
				paddingTop = parseFloat( $.css( this.activeMenu[ 0 ], "paddingTop" ) ) || 0;
				offset = item.offset().top - this.activeMenu.offset().top - borderTop - paddingTop;
				scroll = this.activeMenu.scrollTop();
				elementHeight = this.activeMenu.height();
				itemHeight = item.outerHeight();

				if ( offset < 0 ) {
					this.activeMenu.scrollTop( scroll + offset );
				} else if ( offset + itemHeight > elementHeight ) {
					this.activeMenu.scrollTop( scroll + offset - elementHeight + itemHeight );
				}
			}
		},

		blur: function( event, fromFocus ) {
			if ( !fromFocus ) {
				clearTimeout( this.timer );
			}

			if ( !this.active ) {
				return;
			}

			this._removeClass( this.active.children( ".ui-menu-item-wrapper" ),
				null, "ui-state-active" );

			this._trigger( "blur", event, { item: this.active } );
			this.active = null;
		},

		_startOpening: function( submenu ) {
			clearTimeout( this.timer );

			// Don't open if already open fixes a Firefox bug that caused a .5 pixel
			// shift in the submenu position when mousing over the caret icon
			if ( submenu.attr( "aria-hidden" ) !== "true" ) {
				return;
			}

			this.timer = this._delay( function() {
				this._close();
				this._open( submenu );
			}, this.delay );
		},

		_open: function( submenu ) {
			var position = $.extend( {
				of: this.active
			}, this.options.position );

			clearTimeout( this.timer );
			this.element.find( ".ui-menu" ).not( submenu.parents( ".ui-menu" ) )
				.hide()
				.attr( "aria-hidden", "true" );

			submenu
				.show()
				.removeAttr( "aria-hidden" )
				.attr( "aria-expanded", "true" )
				.position( position );
		},

		collapseAll: function( event, all ) {
			clearTimeout( this.timer );
			this.timer = this._delay( function() {

				// If we were passed an event, look for the submenu that contains the event
				var currentMenu = all ? this.element :
					$( event && event.target ).closest( this.element.find( ".ui-menu" ) );

				// If we found no valid submenu ancestor, use the main menu to close all
				// sub menus anyway
				if ( !currentMenu.length ) {
					currentMenu = this.element;
				}

				this._close( currentMenu );

				this.blur( event );

				// Work around active item staying active after menu is blurred
				this._removeClass( currentMenu.find( ".ui-state-active" ), null, "ui-state-active" );

				this.activeMenu = currentMenu;
			}, this.delay );
		},

		// With no arguments, closes the currently active menu - if nothing is active
		// it closes all menus.  If passed an argument, it will search for menus BELOW
		_close: function( startMenu ) {
			if ( !startMenu ) {
				startMenu = this.active ? this.active.parent() : this.element;
			}

			startMenu.find( ".ui-menu" )
				.hide()
				.attr( "aria-hidden", "true" )
				.attr( "aria-expanded", "false" );
		},

		_closeOnDocumentClick: function( event ) {
			return !$( event.target ).closest( ".ui-menu" ).length;
		},

		_isDivider: function( item ) {

			// Match hyphen, em dash, en dash
			return !/[^\-\u2014\u2013\s]/.test( item.text() );
		},

		collapse: function( event ) {
			var newItem = this.active &&
				this.active.parent().closest( ".ui-menu-item", this.element );
			if ( newItem && newItem.length ) {
				this._close();
				this.focus( event, newItem );
			}
		},

		expand: function( event ) {
			var newItem = this.active &&
				this.active
					.children( ".ui-menu " )
						.find( this.options.items )
							.first();

			if ( newItem && newItem.length ) {
				this._open( newItem.parent() );

				// Delay so Firefox will not hide activedescendant change in expanding submenu from AT
				this._delay( function() {
					this.focus( event, newItem );
				} );
			}
		},

		next: function( event ) {
			this._move( "next", "first", event );
		},

		previous: function( event ) {
			this._move( "prev", "last", event );
		},

		isFirstItem: function() {
			return this.active && !this.active.prevAll( ".ui-menu-item" ).length;
		},

		isLastItem: function() {
			return this.active && !this.active.nextAll( ".ui-menu-item" ).length;
		},

		_move: function( direction, filter, event ) {
			var next;
			if ( this.active ) {
				if ( direction === "first" || direction === "last" ) {
					next = this.active
						[ direction === "first" ? "prevAll" : "nextAll" ]( ".ui-menu-item" )
						.eq( -1 );
				} else {
					next = this.active
						[ direction + "All" ]( ".ui-menu-item" )
						.eq( 0 );
				}
			}
			if ( !next || !next.length || !this.active ) {
				next = this.activeMenu.find( this.options.items )[ filter ]();
			}

			this.focus( event, next );
		},

		nextPage: function( event ) {
			var item, base, height;

			if ( !this.active ) {
				this.next( event );
				return;
			}
			if ( this.isLastItem() ) {
				return;
			}
			if ( this._hasScroll() ) {
				base = this.active.offset().top;
				height = this.element.height();
				this.active.nextAll( ".ui-menu-item" ).each( function() {
					item = $( this );
					return item.offset().top - base - height < 0;
				} );

				this.focus( event, item );
			} else {
				this.focus( event, this.activeMenu.find( this.options.items )
					[ !this.active ? "first" : "last" ]() );
			}
		},

		previousPage: function( event ) {
			var item, base, height;
			if ( !this.active ) {
				this.next( event );
				return;
			}
			if ( this.isFirstItem() ) {
				return;
			}
			if ( this._hasScroll() ) {
				base = this.active.offset().top;
				height = this.element.height();
				this.active.prevAll( ".ui-menu-item" ).each( function() {
					item = $( this );
					return item.offset().top - base + height > 0;
				} );

				this.focus( event, item );
			} else {
				this.focus( event, this.activeMenu.find( this.options.items ).first() );
			}
		},

		_hasScroll: function() {
			return this.element.outerHeight() < this.element.prop( "scrollHeight" );
		},

		select: function( event ) {

			// TODO: It should never be possible to not have an active item at this
			// point, but the tests don't trigger mouseenter before click.
			this.active = this.active || $( event.target ).closest( ".ui-menu-item" );
			var ui = { item: this.active };
			if ( !this.active.has( ".ui-menu" ).length ) {
				this.collapseAll( event, true );
			}
			this._trigger( "select", event, ui );
		},

		_filterMenuItems: function( character ) {
			var escapedCharacter = character.replace( /[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&" ),
				regex = new RegExp( "^" + escapedCharacter, "i" );

			return this.activeMenu
				.find( this.options.items )

					// Only match on items, not dividers or other content (#10571)
					.filter( ".ui-menu-item" )
						.filter( function() {
							return regex.test(
								$.trim( $( this ).children( ".ui-menu-item-wrapper" ).text() ) );
						} );
		}
	} );

	} ) );


/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * jQuery UI Position 1.12.0
	 * http://jqueryui.com
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license.
	 * http://jquery.org/license
	 *
	 * http://api.jqueryui.com/position/
	 */

	//>>label: Position
	//>>group: Core
	//>>description: Positions elements relative to other elements.
	//>>docs: http://api.jqueryui.com/position/
	//>>demos: http://jqueryui.com/position/

	( function( factory ) {
		if ( true ) {

			// AMD. Register as an anonymous module.
			!(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(1), __webpack_require__(6) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else {

			// Browser globals
			factory( jQuery );
		}
	}( function( $ ) {
	( function() {
	var cachedScrollbarWidth, supportsOffsetFractions,
		max = Math.max,
		abs = Math.abs,
		round = Math.round,
		rhorizontal = /left|center|right/,
		rvertical = /top|center|bottom/,
		roffset = /[\+\-]\d+(\.[\d]+)?%?/,
		rposition = /^\w+/,
		rpercent = /%$/,
		_position = $.fn.position;

	// Support: IE <=9 only
	supportsOffsetFractions = function() {
		var element = $( "<div>" )
				.css( "position", "absolute" )
				.appendTo( "body" )
				.offset( {
					top: 1.5,
					left: 1.5
				} ),
			support = element.offset().top === 1.5;

		element.remove();

		supportsOffsetFractions = function() {
			return support;
		};

		return support;
	};

	function getOffsets( offsets, width, height ) {
		return [
			parseFloat( offsets[ 0 ] ) * ( rpercent.test( offsets[ 0 ] ) ? width / 100 : 1 ),
			parseFloat( offsets[ 1 ] ) * ( rpercent.test( offsets[ 1 ] ) ? height / 100 : 1 )
		];
	}

	function parseCss( element, property ) {
		return parseInt( $.css( element, property ), 10 ) || 0;
	}

	function getDimensions( elem ) {
		var raw = elem[ 0 ];
		if ( raw.nodeType === 9 ) {
			return {
				width: elem.width(),
				height: elem.height(),
				offset: { top: 0, left: 0 }
			};
		}
		if ( $.isWindow( raw ) ) {
			return {
				width: elem.width(),
				height: elem.height(),
				offset: { top: elem.scrollTop(), left: elem.scrollLeft() }
			};
		}
		if ( raw.preventDefault ) {
			return {
				width: 0,
				height: 0,
				offset: { top: raw.pageY, left: raw.pageX }
			};
		}
		return {
			width: elem.outerWidth(),
			height: elem.outerHeight(),
			offset: elem.offset()
		};
	}

	$.position = {
		scrollbarWidth: function() {
			if ( cachedScrollbarWidth !== undefined ) {
				return cachedScrollbarWidth;
			}
			var w1, w2,
				div = $( "<div " +
					"style='display:block;position:absolute;width:50px;height:50px;overflow:hidden;'>" +
					"<div style='height:100px;width:auto;'></div></div>" ),
				innerDiv = div.children()[ 0 ];

			$( "body" ).append( div );
			w1 = innerDiv.offsetWidth;
			div.css( "overflow", "scroll" );

			w2 = innerDiv.offsetWidth;

			if ( w1 === w2 ) {
				w2 = div[ 0 ].clientWidth;
			}

			div.remove();

			return ( cachedScrollbarWidth = w1 - w2 );
		},
		getScrollInfo: function( within ) {
			var overflowX = within.isWindow || within.isDocument ? "" :
					within.element.css( "overflow-x" ),
				overflowY = within.isWindow || within.isDocument ? "" :
					within.element.css( "overflow-y" ),
				hasOverflowX = overflowX === "scroll" ||
					( overflowX === "auto" && within.width < within.element[ 0 ].scrollWidth ),
				hasOverflowY = overflowY === "scroll" ||
					( overflowY === "auto" && within.height < within.element[ 0 ].scrollHeight );
			return {
				width: hasOverflowY ? $.position.scrollbarWidth() : 0,
				height: hasOverflowX ? $.position.scrollbarWidth() : 0
			};
		},
		getWithinInfo: function( element ) {
			var withinElement = $( element || window ),
				isWindow = $.isWindow( withinElement[ 0 ] ),
				isDocument = !!withinElement[ 0 ] && withinElement[ 0 ].nodeType === 9,
				hasOffset = !isWindow && !isDocument;
			return {
				element: withinElement,
				isWindow: isWindow,
				isDocument: isDocument,
				offset: hasOffset ? $( element ).offset() : { left: 0, top: 0 },
				scrollLeft: withinElement.scrollLeft(),
				scrollTop: withinElement.scrollTop(),
				width: withinElement.outerWidth(),
				height: withinElement.outerHeight()
			};
		}
	};

	$.fn.position = function( options ) {
		if ( !options || !options.of ) {
			return _position.apply( this, arguments );
		}

		// Make a copy, we don't want to modify arguments
		options = $.extend( {}, options );

		var atOffset, targetWidth, targetHeight, targetOffset, basePosition, dimensions,
			target = $( options.of ),
			within = $.position.getWithinInfo( options.within ),
			scrollInfo = $.position.getScrollInfo( within ),
			collision = ( options.collision || "flip" ).split( " " ),
			offsets = {};

		dimensions = getDimensions( target );
		if ( target[ 0 ].preventDefault ) {

			// Force left top to allow flipping
			options.at = "left top";
		}
		targetWidth = dimensions.width;
		targetHeight = dimensions.height;
		targetOffset = dimensions.offset;

		// Clone to reuse original targetOffset later
		basePosition = $.extend( {}, targetOffset );

		// Force my and at to have valid horizontal and vertical positions
		// if a value is missing or invalid, it will be converted to center
		$.each( [ "my", "at" ], function() {
			var pos = ( options[ this ] || "" ).split( " " ),
				horizontalOffset,
				verticalOffset;

			if ( pos.length === 1 ) {
				pos = rhorizontal.test( pos[ 0 ] ) ?
					pos.concat( [ "center" ] ) :
					rvertical.test( pos[ 0 ] ) ?
						[ "center" ].concat( pos ) :
						[ "center", "center" ];
			}
			pos[ 0 ] = rhorizontal.test( pos[ 0 ] ) ? pos[ 0 ] : "center";
			pos[ 1 ] = rvertical.test( pos[ 1 ] ) ? pos[ 1 ] : "center";

			// Calculate offsets
			horizontalOffset = roffset.exec( pos[ 0 ] );
			verticalOffset = roffset.exec( pos[ 1 ] );
			offsets[ this ] = [
				horizontalOffset ? horizontalOffset[ 0 ] : 0,
				verticalOffset ? verticalOffset[ 0 ] : 0
			];

			// Reduce to just the positions without the offsets
			options[ this ] = [
				rposition.exec( pos[ 0 ] )[ 0 ],
				rposition.exec( pos[ 1 ] )[ 0 ]
			];
		} );

		// Normalize collision option
		if ( collision.length === 1 ) {
			collision[ 1 ] = collision[ 0 ];
		}

		if ( options.at[ 0 ] === "right" ) {
			basePosition.left += targetWidth;
		} else if ( options.at[ 0 ] === "center" ) {
			basePosition.left += targetWidth / 2;
		}

		if ( options.at[ 1 ] === "bottom" ) {
			basePosition.top += targetHeight;
		} else if ( options.at[ 1 ] === "center" ) {
			basePosition.top += targetHeight / 2;
		}

		atOffset = getOffsets( offsets.at, targetWidth, targetHeight );
		basePosition.left += atOffset[ 0 ];
		basePosition.top += atOffset[ 1 ];

		return this.each( function() {
			var collisionPosition, using,
				elem = $( this ),
				elemWidth = elem.outerWidth(),
				elemHeight = elem.outerHeight(),
				marginLeft = parseCss( this, "marginLeft" ),
				marginTop = parseCss( this, "marginTop" ),
				collisionWidth = elemWidth + marginLeft + parseCss( this, "marginRight" ) +
					scrollInfo.width,
				collisionHeight = elemHeight + marginTop + parseCss( this, "marginBottom" ) +
					scrollInfo.height,
				position = $.extend( {}, basePosition ),
				myOffset = getOffsets( offsets.my, elem.outerWidth(), elem.outerHeight() );

			if ( options.my[ 0 ] === "right" ) {
				position.left -= elemWidth;
			} else if ( options.my[ 0 ] === "center" ) {
				position.left -= elemWidth / 2;
			}

			if ( options.my[ 1 ] === "bottom" ) {
				position.top -= elemHeight;
			} else if ( options.my[ 1 ] === "center" ) {
				position.top -= elemHeight / 2;
			}

			position.left += myOffset[ 0 ];
			position.top += myOffset[ 1 ];

			// If the browser doesn't support fractions, then round for consistent results
			if ( !supportsOffsetFractions() ) {
				position.left = round( position.left );
				position.top = round( position.top );
			}

			collisionPosition = {
				marginLeft: marginLeft,
				marginTop: marginTop
			};

			$.each( [ "left", "top" ], function( i, dir ) {
				if ( $.ui.position[ collision[ i ] ] ) {
					$.ui.position[ collision[ i ] ][ dir ]( position, {
						targetWidth: targetWidth,
						targetHeight: targetHeight,
						elemWidth: elemWidth,
						elemHeight: elemHeight,
						collisionPosition: collisionPosition,
						collisionWidth: collisionWidth,
						collisionHeight: collisionHeight,
						offset: [ atOffset[ 0 ] + myOffset[ 0 ], atOffset [ 1 ] + myOffset[ 1 ] ],
						my: options.my,
						at: options.at,
						within: within,
						elem: elem
					} );
				}
			} );

			if ( options.using ) {

				// Adds feedback as second argument to using callback, if present
				using = function( props ) {
					var left = targetOffset.left - position.left,
						right = left + targetWidth - elemWidth,
						top = targetOffset.top - position.top,
						bottom = top + targetHeight - elemHeight,
						feedback = {
							target: {
								element: target,
								left: targetOffset.left,
								top: targetOffset.top,
								width: targetWidth,
								height: targetHeight
							},
							element: {
								element: elem,
								left: position.left,
								top: position.top,
								width: elemWidth,
								height: elemHeight
							},
							horizontal: right < 0 ? "left" : left > 0 ? "right" : "center",
							vertical: bottom < 0 ? "top" : top > 0 ? "bottom" : "middle"
						};
					if ( targetWidth < elemWidth && abs( left + right ) < targetWidth ) {
						feedback.horizontal = "center";
					}
					if ( targetHeight < elemHeight && abs( top + bottom ) < targetHeight ) {
						feedback.vertical = "middle";
					}
					if ( max( abs( left ), abs( right ) ) > max( abs( top ), abs( bottom ) ) ) {
						feedback.important = "horizontal";
					} else {
						feedback.important = "vertical";
					}
					options.using.call( this, props, feedback );
				};
			}

			elem.offset( $.extend( position, { using: using } ) );
		} );
	};

	$.ui.position = {
		fit: {
			left: function( position, data ) {
				var within = data.within,
					withinOffset = within.isWindow ? within.scrollLeft : within.offset.left,
					outerWidth = within.width,
					collisionPosLeft = position.left - data.collisionPosition.marginLeft,
					overLeft = withinOffset - collisionPosLeft,
					overRight = collisionPosLeft + data.collisionWidth - outerWidth - withinOffset,
					newOverRight;

				// Element is wider than within
				if ( data.collisionWidth > outerWidth ) {

					// Element is initially over the left side of within
					if ( overLeft > 0 && overRight <= 0 ) {
						newOverRight = position.left + overLeft + data.collisionWidth - outerWidth -
							withinOffset;
						position.left += overLeft - newOverRight;

					// Element is initially over right side of within
					} else if ( overRight > 0 && overLeft <= 0 ) {
						position.left = withinOffset;

					// Element is initially over both left and right sides of within
					} else {
						if ( overLeft > overRight ) {
							position.left = withinOffset + outerWidth - data.collisionWidth;
						} else {
							position.left = withinOffset;
						}
					}

				// Too far left -> align with left edge
				} else if ( overLeft > 0 ) {
					position.left += overLeft;

				// Too far right -> align with right edge
				} else if ( overRight > 0 ) {
					position.left -= overRight;

				// Adjust based on position and margin
				} else {
					position.left = max( position.left - collisionPosLeft, position.left );
				}
			},
			top: function( position, data ) {
				var within = data.within,
					withinOffset = within.isWindow ? within.scrollTop : within.offset.top,
					outerHeight = data.within.height,
					collisionPosTop = position.top - data.collisionPosition.marginTop,
					overTop = withinOffset - collisionPosTop,
					overBottom = collisionPosTop + data.collisionHeight - outerHeight - withinOffset,
					newOverBottom;

				// Element is taller than within
				if ( data.collisionHeight > outerHeight ) {

					// Element is initially over the top of within
					if ( overTop > 0 && overBottom <= 0 ) {
						newOverBottom = position.top + overTop + data.collisionHeight - outerHeight -
							withinOffset;
						position.top += overTop - newOverBottom;

					// Element is initially over bottom of within
					} else if ( overBottom > 0 && overTop <= 0 ) {
						position.top = withinOffset;

					// Element is initially over both top and bottom of within
					} else {
						if ( overTop > overBottom ) {
							position.top = withinOffset + outerHeight - data.collisionHeight;
						} else {
							position.top = withinOffset;
						}
					}

				// Too far up -> align with top
				} else if ( overTop > 0 ) {
					position.top += overTop;

				// Too far down -> align with bottom edge
				} else if ( overBottom > 0 ) {
					position.top -= overBottom;

				// Adjust based on position and margin
				} else {
					position.top = max( position.top - collisionPosTop, position.top );
				}
			}
		},
		flip: {
			left: function( position, data ) {
				var within = data.within,
					withinOffset = within.offset.left + within.scrollLeft,
					outerWidth = within.width,
					offsetLeft = within.isWindow ? within.scrollLeft : within.offset.left,
					collisionPosLeft = position.left - data.collisionPosition.marginLeft,
					overLeft = collisionPosLeft - offsetLeft,
					overRight = collisionPosLeft + data.collisionWidth - outerWidth - offsetLeft,
					myOffset = data.my[ 0 ] === "left" ?
						-data.elemWidth :
						data.my[ 0 ] === "right" ?
							data.elemWidth :
							0,
					atOffset = data.at[ 0 ] === "left" ?
						data.targetWidth :
						data.at[ 0 ] === "right" ?
							-data.targetWidth :
							0,
					offset = -2 * data.offset[ 0 ],
					newOverRight,
					newOverLeft;

				if ( overLeft < 0 ) {
					newOverRight = position.left + myOffset + atOffset + offset + data.collisionWidth -
						outerWidth - withinOffset;
					if ( newOverRight < 0 || newOverRight < abs( overLeft ) ) {
						position.left += myOffset + atOffset + offset;
					}
				} else if ( overRight > 0 ) {
					newOverLeft = position.left - data.collisionPosition.marginLeft + myOffset +
						atOffset + offset - offsetLeft;
					if ( newOverLeft > 0 || abs( newOverLeft ) < overRight ) {
						position.left += myOffset + atOffset + offset;
					}
				}
			},
			top: function( position, data ) {
				var within = data.within,
					withinOffset = within.offset.top + within.scrollTop,
					outerHeight = within.height,
					offsetTop = within.isWindow ? within.scrollTop : within.offset.top,
					collisionPosTop = position.top - data.collisionPosition.marginTop,
					overTop = collisionPosTop - offsetTop,
					overBottom = collisionPosTop + data.collisionHeight - outerHeight - offsetTop,
					top = data.my[ 1 ] === "top",
					myOffset = top ?
						-data.elemHeight :
						data.my[ 1 ] === "bottom" ?
							data.elemHeight :
							0,
					atOffset = data.at[ 1 ] === "top" ?
						data.targetHeight :
						data.at[ 1 ] === "bottom" ?
							-data.targetHeight :
							0,
					offset = -2 * data.offset[ 1 ],
					newOverTop,
					newOverBottom;
				if ( overTop < 0 ) {
					newOverBottom = position.top + myOffset + atOffset + offset + data.collisionHeight -
						outerHeight - withinOffset;
					if ( newOverBottom < 0 || newOverBottom < abs( overTop ) ) {
						position.top += myOffset + atOffset + offset;
					}
				} else if ( overBottom > 0 ) {
					newOverTop = position.top - data.collisionPosition.marginTop + myOffset + atOffset +
						offset - offsetTop;
					if ( newOverTop > 0 || abs( newOverTop ) < overBottom ) {
						position.top += myOffset + atOffset + offset;
					}
				}
			}
		},
		flipfit: {
			left: function() {
				$.ui.position.flip.left.apply( this, arguments );
				$.ui.position.fit.left.apply( this, arguments );
			},
			top: function() {
				$.ui.position.flip.top.apply( this, arguments );
				$.ui.position.fit.top.apply( this, arguments );
			}
		}
	};

	} )();

	return $.ui.position;

	} ) );


/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * jQuery UI Unique ID 1.12.0
	 * http://jqueryui.com
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license.
	 * http://jquery.org/license
	 */

	//>>label: uniqueId
	//>>group: Core
	//>>description: Functions to generate and remove uniqueId's
	//>>docs: http://api.jqueryui.com/uniqueId/

	( function( factory ) {
		if ( true ) {

			// AMD. Register as an anonymous module.
			!(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(1), __webpack_require__(6) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else {

			// Browser globals
			factory( jQuery );
		}
	} ( function( $ ) {

	return $.fn.extend( {
		uniqueId: ( function() {
			var uuid = 0;

			return function() {
				return this.each( function() {
					if ( !this.id ) {
						this.id = "ui-id-" + ( ++uuid );
					}
				} );
			};
		} )(),

		removeUniqueId: function() {
			return this.each( function() {
				if ( /^ui-id-\d+$/.test( this.id ) ) {
					$( this ).removeAttr( "id" );
				}
			} );
		}
	} );

	} ) );


/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * jQuery UI Tooltip 1.12.0
	 * http://jqueryui.com
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license.
	 * http://jquery.org/license
	 */

	//>>label: Tooltip
	//>>group: Widgets
	//>>description: Shows additional information for any element on hover or focus.
	//>>docs: http://api.jqueryui.com/tooltip/
	//>>demos: http://jqueryui.com/tooltip/
	//>>css.structure: ../../themes/base/core.css
	//>>css.structure: ../../themes/base/tooltip.css
	//>>css.theme: ../../themes/base/theme.css

	( function( factory ) {
		if ( true ) {

			// AMD. Register as an anonymous module.
			!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
				__webpack_require__(1),
				__webpack_require__(12),
				__webpack_require__(16),
				__webpack_require__(17),
				__webpack_require__(6),
				__webpack_require__(5)
			], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else {

			// Browser globals
			factory( jQuery );
		}
	}( function( $ ) {

	$.widget( "ui.tooltip", {
		version: "1.12.0",
		options: {
			classes: {
				"ui-tooltip": "ui-corner-all ui-widget-shadow"
			},
			content: function() {

				// support: IE<9, Opera in jQuery <1.7
				// .text() can't accept undefined, so coerce to a string
				var title = $( this ).attr( "title" ) || "";

				// Escape title, since we're going from an attribute to raw HTML
				return $( "<a>" ).text( title ).html();
			},
			hide: true,

			// Disabled elements have inconsistent behavior across browsers (#8661)
			items: "[title]:not([disabled])",
			position: {
				my: "left top+15",
				at: "left bottom",
				collision: "flipfit flip"
			},
			show: true,
			track: false,

			// Callbacks
			close: null,
			open: null
		},

		_addDescribedBy: function( elem, id ) {
			var describedby = ( elem.attr( "aria-describedby" ) || "" ).split( /\s+/ );
			describedby.push( id );
			elem
				.data( "ui-tooltip-id", id )
				.attr( "aria-describedby", $.trim( describedby.join( " " ) ) );
		},

		_removeDescribedBy: function( elem ) {
			var id = elem.data( "ui-tooltip-id" ),
				describedby = ( elem.attr( "aria-describedby" ) || "" ).split( /\s+/ ),
				index = $.inArray( id, describedby );

			if ( index !== -1 ) {
				describedby.splice( index, 1 );
			}

			elem.removeData( "ui-tooltip-id" );
			describedby = $.trim( describedby.join( " " ) );
			if ( describedby ) {
				elem.attr( "aria-describedby", describedby );
			} else {
				elem.removeAttr( "aria-describedby" );
			}
		},

		_create: function() {
			this._on( {
				mouseover: "open",
				focusin: "open"
			} );

			// IDs of generated tooltips, needed for destroy
			this.tooltips = {};

			// IDs of parent tooltips where we removed the title attribute
			this.parents = {};

			// Append the aria-live region so tooltips announce correctly
			this.liveRegion = $( "<div>" )
				.attr( {
					role: "log",
					"aria-live": "assertive",
					"aria-relevant": "additions"
				} )
				.appendTo( this.document[ 0 ].body );
			this._addClass( this.liveRegion, null, "ui-helper-hidden-accessible" );

			this.disabledTitles = $( [] );
		},

		_setOption: function( key, value ) {
			var that = this;

			this._super( key, value );

			if ( key === "content" ) {
				$.each( this.tooltips, function( id, tooltipData ) {
					that._updateContent( tooltipData.element );
				} );
			}
		},

		_setOptionDisabled: function( value ) {
			this[ value ? "_disable" : "_enable" ]();
		},

		_disable: function() {
			var that = this;

			// Close open tooltips
			$.each( this.tooltips, function( id, tooltipData ) {
				var event = $.Event( "blur" );
				event.target = event.currentTarget = tooltipData.element[ 0 ];
				that.close( event, true );
			} );

			// Remove title attributes to prevent native tooltips
			this.disabledTitles = this.disabledTitles.add(
				this.element.find( this.options.items ).addBack()
					.filter( function() {
						var element = $( this );
						if ( element.is( "[title]" ) ) {
							return element
								.data( "ui-tooltip-title", element.attr( "title" ) )
								.removeAttr( "title" );
						}
					} )
			);
		},

		_enable: function() {

			// restore title attributes
			this.disabledTitles.each( function() {
				var element = $( this );
				if ( element.data( "ui-tooltip-title" ) ) {
					element.attr( "title", element.data( "ui-tooltip-title" ) );
				}
			} );
			this.disabledTitles = $( [] );
		},

		open: function( event ) {
			var that = this,
				target = $( event ? event.target : this.element )

					// we need closest here due to mouseover bubbling,
					// but always pointing at the same event target
					.closest( this.options.items );

			// No element to show a tooltip for or the tooltip is already open
			if ( !target.length || target.data( "ui-tooltip-id" ) ) {
				return;
			}

			if ( target.attr( "title" ) ) {
				target.data( "ui-tooltip-title", target.attr( "title" ) );
			}

			target.data( "ui-tooltip-open", true );

			// Kill parent tooltips, custom or native, for hover
			if ( event && event.type === "mouseover" ) {
				target.parents().each( function() {
					var parent = $( this ),
						blurEvent;
					if ( parent.data( "ui-tooltip-open" ) ) {
						blurEvent = $.Event( "blur" );
						blurEvent.target = blurEvent.currentTarget = this;
						that.close( blurEvent, true );
					}
					if ( parent.attr( "title" ) ) {
						parent.uniqueId();
						that.parents[ this.id ] = {
							element: this,
							title: parent.attr( "title" )
						};
						parent.attr( "title", "" );
					}
				} );
			}

			this._registerCloseHandlers( event, target );
			this._updateContent( target, event );
		},

		_updateContent: function( target, event ) {
			var content,
				contentOption = this.options.content,
				that = this,
				eventType = event ? event.type : null;

			if ( typeof contentOption === "string" || contentOption.nodeType ||
					contentOption.jquery ) {
				return this._open( event, target, contentOption );
			}

			content = contentOption.call( target[ 0 ], function( response ) {

				// IE may instantly serve a cached response for ajax requests
				// delay this call to _open so the other call to _open runs first
				that._delay( function() {

					// Ignore async response if tooltip was closed already
					if ( !target.data( "ui-tooltip-open" ) ) {
						return;
					}

					// JQuery creates a special event for focusin when it doesn't
					// exist natively. To improve performance, the native event
					// object is reused and the type is changed. Therefore, we can't
					// rely on the type being correct after the event finished
					// bubbling, so we set it back to the previous value. (#8740)
					if ( event ) {
						event.type = eventType;
					}
					this._open( event, target, response );
				} );
			} );
			if ( content ) {
				this._open( event, target, content );
			}
		},

		_open: function( event, target, content ) {
			var tooltipData, tooltip, delayedShow, a11yContent,
				positionOption = $.extend( {}, this.options.position );

			if ( !content ) {
				return;
			}

			// Content can be updated multiple times. If the tooltip already
			// exists, then just update the content and bail.
			tooltipData = this._find( target );
			if ( tooltipData ) {
				tooltipData.tooltip.find( ".ui-tooltip-content" ).html( content );
				return;
			}

			// If we have a title, clear it to prevent the native tooltip
			// we have to check first to avoid defining a title if none exists
			// (we don't want to cause an element to start matching [title])
			//
			// We use removeAttr only for key events, to allow IE to export the correct
			// accessible attributes. For mouse events, set to empty string to avoid
			// native tooltip showing up (happens only when removing inside mouseover).
			if ( target.is( "[title]" ) ) {
				if ( event && event.type === "mouseover" ) {
					target.attr( "title", "" );
				} else {
					target.removeAttr( "title" );
				}
			}

			tooltipData = this._tooltip( target );
			tooltip = tooltipData.tooltip;
			this._addDescribedBy( target, tooltip.attr( "id" ) );
			tooltip.find( ".ui-tooltip-content" ).html( content );

			// Support: Voiceover on OS X, JAWS on IE <= 9
			// JAWS announces deletions even when aria-relevant="additions"
			// Voiceover will sometimes re-read the entire log region's contents from the beginning
			this.liveRegion.children().hide();
			a11yContent = $( "<div>" ).html( tooltip.find( ".ui-tooltip-content" ).html() );
			a11yContent.removeAttr( "name" ).find( "[name]" ).removeAttr( "name" );
			a11yContent.removeAttr( "id" ).find( "[id]" ).removeAttr( "id" );
			a11yContent.appendTo( this.liveRegion );

			function position( event ) {
				positionOption.of = event;
				if ( tooltip.is( ":hidden" ) ) {
					return;
				}
				tooltip.position( positionOption );
			}
			if ( this.options.track && event && /^mouse/.test( event.type ) ) {
				this._on( this.document, {
					mousemove: position
				} );

				// trigger once to override element-relative positioning
				position( event );
			} else {
				tooltip.position( $.extend( {
					of: target
				}, this.options.position ) );
			}

			tooltip.hide();

			this._show( tooltip, this.options.show );

			// Handle tracking tooltips that are shown with a delay (#8644). As soon
			// as the tooltip is visible, position the tooltip using the most recent
			// event.
			// Adds the check to add the timers only when both delay and track options are set (#14682)
			if ( this.options.track && this.options.show && this.options.show.delay ) {
				delayedShow = this.delayedShow = setInterval( function() {
					if ( tooltip.is( ":visible" ) ) {
						position( positionOption.of );
						clearInterval( delayedShow );
					}
				}, $.fx.interval );
			}

			this._trigger( "open", event, { tooltip: tooltip } );
		},

		_registerCloseHandlers: function( event, target ) {
			var events = {
				keyup: function( event ) {
					if ( event.keyCode === $.ui.keyCode.ESCAPE ) {
						var fakeEvent = $.Event( event );
						fakeEvent.currentTarget = target[ 0 ];
						this.close( fakeEvent, true );
					}
				}
			};

			// Only bind remove handler for delegated targets. Non-delegated
			// tooltips will handle this in destroy.
			if ( target[ 0 ] !== this.element[ 0 ] ) {
				events.remove = function() {
					this._removeTooltip( this._find( target ).tooltip );
				};
			}

			if ( !event || event.type === "mouseover" ) {
				events.mouseleave = "close";
			}
			if ( !event || event.type === "focusin" ) {
				events.focusout = "close";
			}
			this._on( true, target, events );
		},

		close: function( event ) {
			var tooltip,
				that = this,
				target = $( event ? event.currentTarget : this.element ),
				tooltipData = this._find( target );

			// The tooltip may already be closed
			if ( !tooltipData ) {

				// We set ui-tooltip-open immediately upon open (in open()), but only set the
				// additional data once there's actually content to show (in _open()). So even if the
				// tooltip doesn't have full data, we always remove ui-tooltip-open in case we're in
				// the period between open() and _open().
				target.removeData( "ui-tooltip-open" );
				return;
			}

			tooltip = tooltipData.tooltip;

			// Disabling closes the tooltip, so we need to track when we're closing
			// to avoid an infinite loop in case the tooltip becomes disabled on close
			if ( tooltipData.closing ) {
				return;
			}

			// Clear the interval for delayed tracking tooltips
			clearInterval( this.delayedShow );

			// Only set title if we had one before (see comment in _open())
			// If the title attribute has changed since open(), don't restore
			if ( target.data( "ui-tooltip-title" ) && !target.attr( "title" ) ) {
				target.attr( "title", target.data( "ui-tooltip-title" ) );
			}

			this._removeDescribedBy( target );

			tooltipData.hiding = true;
			tooltip.stop( true );
			this._hide( tooltip, this.options.hide, function() {
				that._removeTooltip( $( this ) );
			} );

			target.removeData( "ui-tooltip-open" );
			this._off( target, "mouseleave focusout keyup" );

			// Remove 'remove' binding only on delegated targets
			if ( target[ 0 ] !== this.element[ 0 ] ) {
				this._off( target, "remove" );
			}
			this._off( this.document, "mousemove" );

			if ( event && event.type === "mouseleave" ) {
				$.each( this.parents, function( id, parent ) {
					$( parent.element ).attr( "title", parent.title );
					delete that.parents[ id ];
				} );
			}

			tooltipData.closing = true;
			this._trigger( "close", event, { tooltip: tooltip } );
			if ( !tooltipData.hiding ) {
				tooltipData.closing = false;
			}
		},

		_tooltip: function( element ) {
			var tooltip = $( "<div>" ).attr( "role", "tooltip" ),
				content = $( "<div>" ).appendTo( tooltip ),
				id = tooltip.uniqueId().attr( "id" );

			this._addClass( content, "ui-tooltip-content" );
			this._addClass( tooltip, "ui-tooltip", "ui-widget ui-widget-content" );

			tooltip.appendTo( this._appendTo( element ) );

			return this.tooltips[ id ] = {
				element: element,
				tooltip: tooltip
			};
		},

		_find: function( target ) {
			var id = target.data( "ui-tooltip-id" );
			return id ? this.tooltips[ id ] : null;
		},

		_removeTooltip: function( tooltip ) {
			tooltip.remove();
			delete this.tooltips[ tooltip.attr( "id" ) ];
		},

		_appendTo: function( target ) {
			var element = target.closest( ".ui-front, dialog" );

			if ( !element.length ) {
				element = this.document[ 0 ].body;
			}

			return element;
		},

		_destroy: function() {
			var that = this;

			// Close open tooltips
			$.each( this.tooltips, function( id, tooltipData ) {

				// Delegate to close method to handle common cleanup
				var event = $.Event( "blur" ),
					element = tooltipData.element;
				event.target = event.currentTarget = element[ 0 ];
				that.close( event, true );

				// Remove immediately; destroying an open tooltip doesn't use the
				// hide animation
				$( "#" + id ).remove();

				// Restore the title
				if ( element.data( "ui-tooltip-title" ) ) {

					// If the title attribute has changed since open(), don't restore
					if ( !element.attr( "title" ) ) {
						element.attr( "title", element.data( "ui-tooltip-title" ) );
					}
					element.removeData( "ui-tooltip-title" );
				}
			} );
			this.liveRegion.remove();
		}
	} );

	// DEPRECATED
	// TODO: Switch return back to widget declaration at top of file when this is removed
	if ( $.uiBackCompat !== false ) {

		// Backcompat for tooltipClass option
		$.widget( "ui.tooltip", $.ui.tooltip, {
			options: {
				tooltipClass: null
			},
			_tooltip: function() {
				var tooltipData = this._superApply( arguments );
				if ( this.options.tooltipClass ) {
					tooltipData.tooltip.addClass( this.options.tooltipClass );
				}
				return tooltipData;
			}
		} );
	}

	return $.ui.tooltip;

	} ) );


/***/ },
/* 19 */
/***/ function(module, exports) {

	"use strict";

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	/*!
	 * ==========================================================
	 *  COLOR PICKER PLUGIN 1.1.0
	 * ==========================================================
	 * Author: Taufik Nurrohman <http://latitudu.com>
	 * License: MIT
	 * ----------------------------------------------------------
	 */

	var CP = function CP(target, how) {

	    var w = window,
	        d = document,
	        r = this,
	        _ = false,
	        hooks = {},
	        picker = d.createElement('div');

	    function isset(x) {
	        return typeof x !== "undefined";
	    }

	    function edge(a, b, c) {
	        if (a < b) return b;
	        if (a > c) return c;
	        return a;
	    }

	    // trigger color picker panel on click by default
	    if (!isset(how)) {
	        how = ["mousedown", "touchstart"];
	    }

	    // [h, s, v] ... 0 <= h, s, v <= 1
	    function HSV2RGB(a) {
	        var h = +a[0],
	            s = +a[1],
	            v = +a[2],
	            r,
	            g,
	            b,
	            i,
	            f,
	            p,
	            q,
	            t;
	        i = Math.floor(h * 6);
	        f = h * 6 - i;
	        p = v * (1 - s);
	        q = v * (1 - f * s);
	        t = v * (1 - (1 - f) * s);
	        if (isNaN(i)) i = 0;
	        if (isNaN(q)) q = 0;
	        if (isNaN(t)) t = 0;
	        switch (i % 6) {
	            case 0:
	                r = v, g = t, b = p;
	                break;
	            case 1:
	                r = q, g = v, b = p;
	                break;
	            case 2:
	                r = p, g = v, b = t;
	                break;
	            case 3:
	                r = p, g = q, b = v;
	                break;
	            case 4:
	                r = t, g = p, b = v;
	                break;
	            case 5:
	                r = v, g = p, b = q;
	                break;
	        }
	        return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
	    }

	    function HSV2HEX(a) {
	        return RGB2HEX(HSV2RGB(a));
	    }

	    // [r, g, b] ... 0 <= r, g, b <= 255
	    function RGB2HSV(a) {
	        var r = +a[0],
	            g = +a[1],
	            b = +a[2],
	            max = Math.max(r, g, b),
	            min = Math.min(r, g, b),
	            d = max - min,
	            h,
	            s = max === 0 ? 0 : d / max,
	            v = max / 255;
	        switch (max) {
	            case min:
	                h = 0;
	                break;
	            case r:
	                h = g - b + d * (g < b ? 6 : 0);
	                h /= 6 * d;
	                break;
	            case g:
	                h = b - r + d * 2;
	                h /= 6 * d;
	                break;
	            case b:
	                h = r - g + d * 4;
	                h /= 6 * d;
	                break;
	        }
	        return [h, s, v];
	    }

	    function RGB2HEX(a) {
	        var s = +a[2] | +a[1] << 8 | +a[0] << 16;
	        s = '000000' + s.toString(16);
	        return s.slice(-6);
	    }

	    // rrggbb or rgb
	    function HEX2HSV(s) {
	        return RGB2HSV(HEX2RGB(s));
	    }

	    function HEX2RGB(s) {
	        if (s.length === 3) {
	            s = s.replace(/./g, '$&$&');
	        }
	        return [parseInt(s[0] + s[1], 16), parseInt(s[2] + s[3], 16), parseInt(s[4] + s[5], 16)];
	    }

	    // convert range from `0` to `360` and `0` to `100` in color into range from `0` to `1`
	    function _2HSV_pri(a) {
	        return [+a[0] / 360, +a[1] / 100, +a[2] / 100];
	    }

	    // convert range from `0` to `1` into `0` to `360` and `0` to `100` in color
	    function _2HSV_pub(a) {
	        return [Math.round(+a[0] * 360), Math.round(+a[1] * 100), Math.round(+a[2] * 100)];
	    }

	    // *
	    r.parse = function (x) {
	        if ((typeof x === "undefined" ? "undefined" : _typeof(x)) === "object") return x;
	        var rgb = /\s*rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)\s*$/i.exec(x),
	            hsv = /\s*hsv\s*\(\s*(\d+)\s*,\s*(\d+)%\s*,\s*(\d+)%\s*\)\s*$/i.exec(x),
	            hex = x[0] === '#' && x.match(/^#([\da-f]{3}|[\da-f]{6})$/);
	        if (hex) {
	            return HEX2HSV(x.slice(1));
	        } else if (hsv) {
	            return _2HSV_pri([+hsv[1], +hsv[2], +hsv[3]]);
	        } else if (rgb) {
	            return RGB2HSV([+rgb[1], +rgb[2], +rgb[3]]);
	        }
	        return [0, 1, 1]; // default is red
	    };

	    // add event
	    function on(ev, el, fn) {
	        return el.addEventListener(ev, fn, false);
	    }

	    // remove event
	    function off(ev, el, fn) {
	        return el.removeEventListener(ev, fn);
	    }

	    // get mouse/finger coordinate
	    function point(el, e) {
	        var x = !!e.touches ? e.touches[0].pageX : e.pageX,
	            y = !!e.touches ? e.touches[0].pageY : e.pageY,
	            left = offset(el).l,
	            top = offset(el).t;
	        while (el = el.offsetParent) {
	            left += offset(el).l;
	            top += offset(el).t;
	        }
	        return {
	            x: x - left,
	            y: y - top
	        };
	    }

	    // get position
	    function offset(el) {
	        return {
	            l: el.offsetLeft,
	            t: el.offsetTop
	        };
	    }

	    // get closest parent
	    function closest(a, b) {
	        while ((a = a.parentElement) && a !== b) {}
	        return a;
	    }

	    // prevent default
	    function prevent(e) {
	        if (e) e.preventDefault();
	    }

	    // get dimension
	    function size(el) {
	        return {
	            w: el.offsetWidth,
	            h: el.offsetHeight
	        };
	    }

	    // get color data
	    function get_data(a) {
	        return _ || (isset(a) ? a : false);
	    }

	    // set color data
	    function set_data(a) {
	        _ = a;
	    }

	    // add hook
	    function add(ev, fn, id) {
	        if (!isset(ev)) return hooks;
	        if (!isset(fn)) return hooks[ev];
	        if (!isset(hooks[ev])) hooks[ev] = {};
	        if (!isset(id)) id = Object.keys(hooks[ev]).length;
	        return hooks[ev][id] = fn, r;
	    }

	    // remove hook
	    function remove(ev, id) {
	        if (!isset(ev)) return hooks = {}, r;
	        if (!isset(id)) return hooks[ev] = {}, r;
	        return delete hooks[ev][id], r;
	    }

	    // trigger hook
	    function trigger(ev, a, id) {
	        if (!isset(hooks[ev])) return r;
	        if (!isset(id)) {
	            for (var i in hooks[ev]) {
	                hooks[ev][i].apply(r, a);
	            }
	        } else {
	            if (isset(hooks[ev][id])) {
	                hooks[ev][id].apply(r, a);
	            }
	        }
	        return r;
	    }

	    // initialize data ...
	    set_data(r.parse(target.getAttribute('data-color') || target.value || [0, 1, 1]));

	    // generate color picker pane ...
	    picker.className = 'color-picker';
	    picker.innerHTML = '<div class="color-picker-control"><span class="color-picker-h"><i></i></span><span class="color-picker-sv"><i></i></span></div>';
	    var b = d.body,
	        h = d.documentElement,
	        c = picker.firstChild.children,
	        HSV = get_data([0, 1, 1]),
	        // default is red
	    H = c[0],
	        SV = c[1],
	        H_point = H.firstChild,
	        SV_point = SV.firstChild,
	        start_H = false,
	        start_SV = false,
	        drag_H = false,
	        drag_SV = false,
	        left = 0,
	        top = 0,
	        P_W = 0,
	        P_H = 0,
	        v = HSV2HEX(HSV),
	        set,
	        exit;

	    // on update ...
	    function trigger_(k, x) {
	        if (!k || k === "h") {
	            trigger("change:h", x);
	        }
	        if (!k || k === "sv") {
	            trigger("change:sv", x);
	        }
	        trigger("change", x);
	    }

	    // delay
	    function delay(fn, t) {
	        return w.setTimeout(fn, t);
	    }

	    // is visible?
	    function visible() {
	        return picker.parentNode;
	    }

	    // fit to window
	    function fit() {
	        var w_W = /* w.innerWidth */size(h).w,
	            w_H = w.innerHeight,
	            w_L = Math.max(b.scrollLeft, h.scrollLeft),
	            w_T = Math.max(b.scrollTop, h.scrollTop),
	            width = w_W + w_L,
	            height = w_H + w_T;
	        left = offset(target).l;
	        top = offset(target).t + size(target).h;
	        if (left + P_W > width) {
	            left = width - P_W;
	        }
	        if (top + P_H > height) {
	            top = height - P_H;
	        }
	        picker.style.left = left + 'px';
	        picker.style.top = top + 'px';
	        return trigger("fit", [r]), r;
	    };

	    // create
	    function create(first, bucket) {
	        if (!first) {
	            (bucket || b).appendChild(picker), r.visible = true;
	        }
	        P_W = size(picker).w;
	        P_H = size(picker).h;
	        var H_H = size(H).h,
	            SV_W = size(SV).w,
	            SV_H = size(SV).h,
	            H_point_H = size(H_point).h,
	            SV_point_W = size(SV_point).w,
	            SV_point_H = size(SV_point).h;
	        if (first) {
	            var i;

	            (function () {
	                var click = function click(e) {
	                    var t = e.target,
	                        is_target = t === target || closest(t, target) === target;
	                    if (is_target) {
	                        create();
	                    } else {
	                        exit();
	                    }
	                    trigger(is_target ? "enter" : "exit", [r]);
	                };

	                picker.style.left = '-9999px';
	                picker.style.top = '-9999px';

	                if (how !== false) {
	                    i = how.length;

	                    while (i--) {
	                        on(how[i], target, click);
	                    }
	                }
	                r.create = function () {
	                    return create(1), trigger("create", [r]), r;
	                };
	                r.destroy = function () {
	                    if (how !== false) {
	                        var i = how.length;
	                        while (i--) {
	                            off(how[i], target, click);
	                        }
	                    }
	                    exit(), set_data(false);
	                    return trigger("destroy", [r]), r;
	                };
	            })();
	        } else {
	            fit();
	        }
	        set = function set() {
	            HSV = get_data(HSV), color();
	            H_point.style.top = H_H - H_point_H / 2 - H_H * +HSV[0] + 'px';
	            SV_point.style.right = SV_W - SV_point_W / 2 - SV_W * +HSV[1] + 'px';
	            SV_point.style.top = SV_H - SV_point_H / 2 - SV_H * +HSV[2] + 'px';
	        };
	        exit = function exit(e) {
	            if (visible()) {
	                visible().removeChild(picker);
	                r.visible = false;
	            }
	            off("touchstart", H, down_H);
	            off("mousedown", H, down_H);
	            off("touchstart", SV, down_SV);
	            off("mousedown", SV, down_SV);
	            off("touchmove", d, move);
	            off("mousemove", d, move);
	            off("touchend", d, stop);
	            off("mouseup", d, stop);
	            off("resize", w, fit);
	            return r;
	        };
	        function color(e) {
	            var a = HSV2RGB(HSV),
	                b = HSV2RGB([HSV[0], 1, 1]);
	            SV.style.backgroundColor = 'rgb(' + b.join(',') + ')';
	            set_data(HSV);
	            prevent(e);
	        };
	        set();
	        function do_H(e) {
	            var y = edge(point(H, e).y, 0, H_H);
	            HSV[0] = (H_H - y) / H_H;
	            H_point.style.top = y - H_point_H / 2 + 'px';
	            color(e);
	        }
	        function do_SV(e) {
	            var o = point(SV, e),
	                x = edge(o.x, 0, SV_W),
	                y = edge(o.y, 0, SV_H);
	            HSV[1] = 1 - (SV_W - x) / SV_W;
	            HSV[2] = (SV_H - y) / SV_H;
	            SV_point.style.right = SV_W - x - SV_point_W / 2 + 'px';
	            SV_point.style.top = y - SV_point_H / 2 + 'px';
	            color(e);
	        }
	        function move(e) {
	            if (drag_H) {
	                do_H(e), v = HSV2HEX(HSV);
	                if (!start_H) {
	                    trigger("drag:h", [v, r]);
	                    trigger("drag", [v, r]);
	                    trigger_("h", [v, r]);
	                }
	            }
	            if (drag_SV) {
	                do_SV(e), v = HSV2HEX(HSV);
	                if (!start_SV) {
	                    trigger("drag:sv", [v, r]);
	                    trigger("drag", [v, r]);
	                    trigger_("sv", [v, r]);
	                }
	            }
	            start_H = false, start_SV = false;
	        }
	        function stop(e) {
	            var t = e.target,
	                k = drag_H ? "h" : "sv",
	                a = [HSV2HEX(HSV), r],
	                is_target = t === target || closest(t, target) === target,
	                is_picker = t === picker || closest(t, picker) === picker;
	            if (!is_target && !is_picker) {
	                // click outside the target or picker element to exit
	                if (visible() && how !== false) exit(), trigger("exit", [r]), trigger_(0, a);
	            } else {
	                if (is_picker) {
	                    trigger("stop:" + k, a);
	                    trigger("stop", a);
	                    trigger_(k, a);
	                }
	            }
	            drag_H = false, drag_SV = false;
	        }
	        function down_H(e) {
	            start_H = true, drag_H = true, move(e), prevent(e);
	            trigger("start:h", [v, r]);
	            trigger("start", [v, r]);
	            trigger_("h", [v, r]);
	        }
	        function down_SV(e) {
	            start_SV = true, drag_SV = true, move(e), prevent(e);
	            trigger("start:sv", [v, r]);
	            trigger("start", [v, r]);
	            trigger_("sv", [v, r]);
	        }
	        if (!first) {
	            on("touchstart", H, down_H);
	            on("mousedown", H, down_H);
	            on("touchstart", SV, down_SV);
	            on("mousedown", SV, down_SV);
	            on("touchmove", d, move);
	            on("mousemove", d, move);
	            on("touchend", d, stop);
	            on("mouseup", d, stop);
	            on("resize", w, fit);
	        }
	    }create(1);

	    delay(function () {
	        var a = [HSV2HEX(HSV), r];
	        trigger("create", a);
	        trigger_(0, a);
	    }, 0);

	    // register to global ...
	    r.target = target;
	    r.picker = picker;
	    r.visible = false;
	    r.on = add;
	    r.off = remove;
	    r.trigger = trigger;
	    r.fit = fit;
	    r.set = function (a) {
	        if (!isset(a)) return get_data();
	        if (typeof a === "string") {
	            a = r.parse(a);
	        }
	        return set_data(a), set(), r;
	    };
	    r.HSV2RGB = function (a) {
	        return HSV2RGB(_2HSV_pri(a));
	    };
	    r._HSV2RGB = HSV2RGB;
	    r.HSV2HEX = function (a) {
	        return HSV2HEX(_2HSV_pri(a));
	    };
	    r._HSV2HEX = HSV2HEX;
	    r.RGB2HSV = function (a) {
	        return _2HSV_pub(RGB2HSV(a));
	    };
	    r._RGB2HSV = RGB2HSV;
	    r.RGB2HEX = RGB2HEX;
	    r.HEX2HSV = function (s) {
	        return _2HSV_pub(HEX2HSV(s));
	    };
	    r._HEX2HSV = HEX2HSV;
	    r.HEX2RGB = HEX2RGB;
	    r.hooks = hooks;
	    r.enter = function (bucket) {
	        return create(0, bucket);
	    };
	    r.exit = exit;

	    // return the global object
	    return r;
	};

	/*** EXPORTS FROM exports-loader ***/

	/*** EXPORTS FROM exports-loader ***/
	module.exports = CP;

/***/ },
/* 20 */
/***/ function(module, exports) {

	/*

	  OpenLayers.js -- OpenLayers Map Viewer Library

	  Copyright (c) 2006-2015 by OpenLayers Contributors
	  Published under the 2-clause BSD license.
	  See https://raw.githubusercontent.com/openlayers/ol2/master/license.txt for the full text of the license, and https://raw.githubusercontent.com/openlayers/ol2/master/authors.txt for full list of contributors.

	  Includes compressed code under the following licenses:

	  (For uncompressed versions of the code used, please see the
	  OpenLayers Github repository: <https://github.com/openlayers/ol2>)

	*/

	/**
	 * Contains XMLHttpRequest.js <http://code.google.com/p/xmlhttprequest/>
	 * Copyright 2007 Sergey Ilinsky (http://www.ilinsky.com)
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 * http://www.apache.org/licenses/LICENSE-2.0
	 */

	/**
	 * OpenLayers.Util.pagePosition is based on Yahoo's getXY method, which is
	 * Copyright (c) 2006, Yahoo! Inc.
	 * All rights reserved.
	 *
	 * Redistribution and use of this software in source and binary forms, with or
	 * without modification, are permitted provided that the following conditions
	 * are met:
	 *
	 * * Redistributions of source code must retain the above copyright notice,
	 *   this list of conditions and the following disclaimer.
	 *
	 * * Redistributions in binary form must reproduce the above copyright notice,
	 *   this list of conditions and the following disclaimer in the documentation
	 *   and/or other materials provided with the distribution.
	 *
	 * * Neither the name of Yahoo! Inc. nor the names of its contributors may be
	 *   used to endorse or promote products derived from this software without
	 *   specific prior written permission of Yahoo! Inc.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
	 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
	 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
	 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
	 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
	 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
	 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
	 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
	 * POSSIBILITY OF SUCH DAMAGE.
	 */
	/* ======================================================================
	    OpenLayers/SingleFile.js
	   ====================================================================== */

	/* Copyright (c) 2006-2015 by OpenLayers Contributors (see authors.txt for
	 * full list of contributors). Published under the 2-clause BSD license.
	 * See license.txt in the OpenLayers distribution or repository for the
	 * full text of the license. */

	var OpenLayers = {
	    /**
	     * Constant: VERSION_NUMBER
	     */
	    VERSION_NUMBER: "Release 2.14 dev",

	    /**
	     * Constant: singleFile
	     * TODO: remove this in 3.0 when we stop supporting build profiles that
	     * include OpenLayers.js
	     */
	    singleFile: true,

	    /**
	     * Method: _getScriptLocation
	     * Return the path to this script. This is also implemented in
	     * OpenLayers.js
	     *
	     * Returns:
	     * {String} Path to this script
	     */
	    _getScriptLocation: (function() {
	        var r = new RegExp("(^|(.*?\\/))(OpenLayers[^\\/]*?\\.js)(\\?|$)"),
	            s = document.getElementsByTagName('script'),
	            src, m, l = "";
	        for(var i=0, len=s.length; i<len; i++) {
	            src = s[i].getAttribute('src');
	            if(src) {
	                m = src.match(r);
	                if(m) {
	                    l = m[1];
	                    break;
	                }
	            }
	        }
	        return (function() { return l; });
	    })(),
	    
	    /**
	     * Property: ImgPath
	     * {String} Set this to the path where control images are stored, a path  
	     * given here must end with a slash. If set to '' (which is the default) 
	     * OpenLayers will use its script location + "img/".
	     * 
	     * You will need to set this property when you have a singlefile build of 
	     * OpenLayers that either is not named "OpenLayers.js" or if you move
	     * the file in a way such that the image directory cannot be derived from 
	     * the script location.
	     * 
	     * If your custom OpenLayers build is named "my-custom-ol.js" and the images
	     * of OpenLayers are in a folder "/resources/external/images/ol" a correct
	     * way of including OpenLayers in your HTML would be:
	     * 
	     * (code)
	     *   <script src="/path/to/my-custom-ol.js" type="text/javascript"></script>
	     *   <script type="text/javascript">
	     *      // tell OpenLayers where the control images are
	     *      // remember the trailing slash
	     *      OpenLayers.ImgPath = "/resources/external/images/ol/";
	     *   </script>
	     * (end code)
	     * 
	     * Please remember that when your OpenLayers script is not named 
	     * "OpenLayers.js" you will have to make sure that the default theme is 
	     * loaded into the page by including an appropriate <link>-tag, 
	     * e.g.:
	     * 
	     * (code)
	     *   <link rel="stylesheet" href="/path/to/default/style.css"  type="text/css">
	     * (end code)
	     */
	    ImgPath : ''
	};
	/* ======================================================================
	    OpenLayers/BaseTypes/Class.js
	   ====================================================================== */

	/* Copyright (c) 2006-2015 by OpenLayers Contributors (see authors.txt for
	 * full list of contributors). Published under the 2-clause BSD license.
	 * See license.txt in the OpenLayers distribution or repository for the
	 * full text of the license. */

	/**
	 * @requires OpenLayers/SingleFile.js
	 */

	/**
	 * Constructor: OpenLayers.Class
	 * Base class used to construct all other classes. Includes support for 
	 *     multiple inheritance. 
	 *     
	 * This constructor is new in OpenLayers 2.5.  At OpenLayers 3.0, the old 
	 *     syntax for creating classes and dealing with inheritance 
	 *     will be removed.
	 * 
	 * To create a new OpenLayers-style class, use the following syntax:
	 * (code)
	 *     var MyClass = OpenLayers.Class(prototype);
	 * (end)
	 *
	 * To create a new OpenLayers-style class with multiple inheritance, use the
	 *     following syntax:
	 * (code)
	 *     var MyClass = OpenLayers.Class(Class1, Class2, prototype);
	 * (end)
	 * 
	 * Note that instanceof reflection will only reveal Class1 as superclass.
	 *
	 */
	OpenLayers.Class = function() {
	    var len = arguments.length;
	    var P = arguments[0];
	    var F = arguments[len-1];

	    var C = typeof F.initialize == "function" ?
	        F.initialize :
	        function(){ P.prototype.initialize.apply(this, arguments); };

	    if (len > 1) {
	        var newArgs = [C, P].concat(
	                Array.prototype.slice.call(arguments).slice(1, len-1), F);
	        OpenLayers.inherit.apply(null, newArgs);
	    } else {
	        C.prototype = F;
	    }
	    return C;
	};

	/**
	 * Function: OpenLayers.inherit
	 *
	 * Parameters:
	 * C - {Object} the class that inherits
	 * P - {Object} the superclass to inherit from
	 *
	 * In addition to the mandatory C and P parameters, an arbitrary number of
	 * objects can be passed, which will extend C.
	 */
	OpenLayers.inherit = function(C, P) {
	   var F = function() {};
	   F.prototype = P.prototype;
	   C.prototype = new F;
	   var i, l, o;
	   for(i=2, l=arguments.length; i<l; i++) {
	       o = arguments[i];
	       if(typeof o === "function") {
	           o = o.prototype;
	       }
	       OpenLayers.Util.extend(C.prototype, o);
	   }
	};

	/**
	 * APIFunction: extend
	 * Copy all properties of a source object to a destination object.  Modifies
	 *     the passed in destination object.  Any properties on the source object
	 *     that are set to undefined will not be (re)set on the destination object.
	 *
	 * Parameters:
	 * destination - {Object} The object that will be modified
	 * source - {Object} The object with properties to be set on the destination
	 *
	 * Returns:
	 * {Object} The destination object.
	 */
	OpenLayers.Util = OpenLayers.Util || {};
	OpenLayers.Util.extend = function(destination, source) {
	    destination = destination || {};
	    if (source) {
	        for (var property in source) {
	            var value = source[property];
	            if (value !== undefined) {
	                destination[property] = value;
	            }
	        }

	        /**
	         * IE doesn't include the toString property when iterating over an object's
	         * properties with the for(property in object) syntax.  Explicitly check if
	         * the source has its own toString property.
	         */

	        /*
	         * FF/Windows < 2.0.0.13 reports "Illegal operation on WrappedNative
	         * prototype object" when calling hawOwnProperty if the source object
	         * is an instance of window.Event.
	         */

	        var sourceIsEvt = typeof window.Event == "function"
	                          && source instanceof window.Event;

	        if (!sourceIsEvt
	           && source.hasOwnProperty && source.hasOwnProperty("toString")) {
	            destination.toString = source.toString;
	        }
	    }
	    return destination;
	};
	/* ======================================================================
	    OpenLayers/BaseTypes.js
	   ====================================================================== */

	/* Copyright (c) 2006-2015 by OpenLayers Contributors (see authors.txt for
	 * full list of contributors). Published under the 2-clause BSD license.
	 * See license.txt in the OpenLayers distribution or repository for the
	 * full text of the license. */

	/**
	 * @requires OpenLayers/SingleFile.js
	 */

	/** 
	 * Header: OpenLayers Base Types
	 * OpenLayers custom string, number and function functions are described here.
	 */

	/**
	 * Namespace: OpenLayers.String
	 * Contains convenience functions for string manipulation.
	 */
	OpenLayers.String = {

	    /**
	     * APIFunction: startsWith
	     * Test whether a string starts with another string. 
	     * 
	     * Parameters:
	     * str - {String} The string to test.
	     * sub - {String} The substring to look for.
	     *  
	     * Returns:
	     * {Boolean} The first string starts with the second.
	     */
	    startsWith: function(str, sub) {
	        return (str.indexOf(sub) == 0);
	    },

	    /**
	     * APIFunction: contains
	     * Test whether a string contains another string.
	     * 
	     * Parameters:
	     * str - {String} The string to test.
	     * sub - {String} The substring to look for.
	     * 
	     * Returns:
	     * {Boolean} The first string contains the second.
	     */
	    contains: function(str, sub) {
	        return (str.indexOf(sub) != -1);
	    },
	    
	    /**
	     * APIFunction: trim
	     * Removes leading and trailing whitespace characters from a string.
	     * 
	     * Parameters:
	     * str - {String} The (potentially) space padded string.  This string is not
	     *     modified.
	     * 
	     * Returns:
	     * {String} A trimmed version of the string with all leading and 
	     *     trailing spaces removed.
	     */
	    trim: function(str) {
	        return str.replace(/^\s\s*/, '').replace(/\s\s*$/, '');
	    },
	    
	    /**
	     * APIFunction: camelize
	     * Camel-case a hyphenated string. 
	     *     Ex. "chicken-head" becomes "chickenHead", and
	     *     "-chicken-head" becomes "ChickenHead".
	     *
	     * Parameters:
	     * str - {String} The string to be camelized.  The original is not modified.
	     * 
	     * Returns:
	     * {String} The string, camelized
	     */
	    camelize: function(str) {
	        var oStringList = str.split('-');
	        var camelizedString = oStringList[0];
	        for (var i=1, len=oStringList.length; i<len; i++) {
	            var s = oStringList[i];
	            camelizedString += s.charAt(0).toUpperCase() + s.substring(1);
	        }
	        return camelizedString;
	    },
	    
	    /**
	     * APIFunction: format
	     * Given a string with tokens in the form ${token}, return a string
	     *     with tokens replaced with properties from the given context
	     *     object.  Represent a literal "${" by doubling it, e.g. "${${".
	     *
	     * Parameters:
	     * template - {String} A string with tokens to be replaced.  A template
	     *     has the form "literal ${token}" where the token will be replaced
	     *     by the value of context["token"].
	     * context - {Object} An optional object with properties corresponding
	     *     to the tokens in the format string.  If no context is sent, the
	     *     window object will be used.
	     * args - {Array} Optional arguments to pass to any functions found in
	     *     the context.  If a context property is a function, the token
	     *     will be replaced by the return from the function called with
	     *     these arguments.
	     *
	     * Returns:
	     * {String} A string with tokens replaced from the context object.
	     */
	    format: function(template, context, args) {
	        if(!context) {
	            context = window;
	        }

	        // Example matching: 
	        // str   = ${foo.bar}
	        // match = foo.bar
	        var replacer = function(str, match) {
	            var replacement;

	            // Loop through all subs. Example: ${a.b.c}
	            // 0 -> replacement = context[a];
	            // 1 -> replacement = context[a][b];
	            // 2 -> replacement = context[a][b][c];
	            var subs = match.split(/\.+/);
	            for (var i=0; i< subs.length; i++) {
	                if (i == 0) {
	                    replacement = context;
	                }
	                if (replacement === undefined) {
	                    break;
	                }
	                replacement = replacement[subs[i]];
	            }

	            if(typeof replacement == "function") {
	                replacement = args ?
	                    replacement.apply(null, args) :
	                    replacement();
	            }

	            // If replacement is undefined, return the string 'undefined'.
	            // This is a workaround for a bugs in browsers not properly 
	            // dealing with non-participating groups in regular expressions:
	            // http://blog.stevenlevithan.com/archives/npcg-javascript
	            if (typeof replacement == 'undefined') {
	                return 'undefined';
	            } else {
	                return replacement; 
	            }
	        };

	        return template.replace(OpenLayers.String.tokenRegEx, replacer);
	    },

	    /**
	     * Property: tokenRegEx
	     * Used to find tokens in a string.
	     * Examples: ${a}, ${a.b.c}, ${a-b}, ${5}
	     */
	    tokenRegEx:  /\$\{([\w.]+?)\}/g,
	    
	    /**
	     * Property: numberRegEx
	     * Used to test strings as numbers.
	     */
	    numberRegEx: /^([+-]?)(?=\d|\.\d)\d*(\.\d*)?([Ee]([+-]?\d+))?$/,
	    
	    /**
	     * APIFunction: isNumeric
	     * Determine whether a string contains only a numeric value.
	     *
	     * Examples:
	     * (code)
	     * OpenLayers.String.isNumeric("6.02e23") // true
	     * OpenLayers.String.isNumeric("12 dozen") // false
	     * OpenLayers.String.isNumeric("4") // true
	     * OpenLayers.String.isNumeric(" 4 ") // false
	     * (end)
	     *
	     * Returns:
	     * {Boolean} String contains only a number.
	     */
	    isNumeric: function(value) {
	        return OpenLayers.String.numberRegEx.test(value);
	    },
	    
	    /**
	     * APIFunction: numericIf
	     * Converts a string that appears to be a numeric value into a number.
	     * 
	     * Parameters:
	     * value - {String}
	     * trimWhitespace - {Boolean}
	     *
	     * Returns:
	     * {Number|String} a Number if the passed value is a number, a String
	     *     otherwise. 
	     */
	    numericIf: function(value, trimWhitespace) {
	        var originalValue = value;
	        if (trimWhitespace === true && value != null && value.replace) {
	            value = value.replace(/^\s*|\s*$/g, "");
	        }
	        return OpenLayers.String.isNumeric(value) ? parseFloat(value) : originalValue;
	    }

	};

	/**
	 * Namespace: OpenLayers.Number
	 * Contains convenience functions for manipulating numbers.
	 */
	OpenLayers.Number = {

	    /**
	     * Property: decimalSeparator
	     * Decimal separator to use when formatting numbers.
	     */
	    decimalSeparator: ".",
	    
	    /**
	     * Property: thousandsSeparator
	     * Thousands separator to use when formatting numbers.
	     */
	    thousandsSeparator: ",",
	    
	    /**
	     * APIFunction: limitSigDigs
	     * Limit the number of significant digits on a float.
	     * 
	     * Parameters:
	     * num - {Float}
	     * sig - {Integer}
	     * 
	     * Returns:
	     * {Float} The number, rounded to the specified number of significant
	     *     digits.
	     */
	    limitSigDigs: function(num, sig) {
	        var fig = 0;
	        if (sig > 0) {
	            fig = parseFloat(num.toPrecision(sig));
	        }
	        return fig;
	    },
	    
	    /**
	     * APIFunction: format
	     * Formats a number for output.
	     * 
	     * Parameters:
	     * num  - {Float}
	     * dec  - {Integer} Number of decimal places to round to.
	     *        Defaults to 0. Set to null to leave decimal places unchanged.
	     * tsep - {String} Thousands separator.
	     *        Default is ",".
	     * dsep - {String} Decimal separator.
	     *        Default is ".".
	     *
	     * Returns:
	     * {String} A string representing the formatted number.
	     */
	    format: function(num, dec, tsep, dsep) {
	        dec = (typeof dec != "undefined") ? dec : 0; 
	        tsep = (typeof tsep != "undefined") ? tsep :
	            OpenLayers.Number.thousandsSeparator; 
	        dsep = (typeof dsep != "undefined") ? dsep :
	            OpenLayers.Number.decimalSeparator;

	        if (dec != null) {
	            num = parseFloat(num.toFixed(dec));
	        }

	        var parts = num.toString().split(".");
	        if (parts.length == 1 && dec == null) {
	            // integer where we do not want to touch the decimals
	            dec = 0;
	        }
	        
	        var integer = parts[0];
	        if (tsep) {
	            var thousands = /(-?[0-9]+)([0-9]{3})/; 
	            while(thousands.test(integer)) { 
	                integer = integer.replace(thousands, "$1" + tsep + "$2"); 
	            }
	        }
	        
	        var str;
	        if (dec == 0) {
	            str = integer;
	        } else {
	            var rem = parts.length > 1 ? parts[1] : "0";
	            if (dec != null) {
	                rem = rem + new Array(dec - rem.length + 1).join("0");
	            }
	            str = integer + dsep + rem;
	        }
	        return str;
	    },

	    /**
	     * Method: zeroPad
	     * Create a zero padded string optionally with a radix for casting numbers.
	     *
	     * Parameters:
	     * num - {Number} The number to be zero padded.
	     * len - {Number} The length of the string to be returned.
	     * radix - {Number} An integer between 2 and 36 specifying the base to use
	     *     for representing numeric values.
	     */
	    zeroPad: function(num, len, radix) {
	        var str = num.toString(radix || 10);
	        while (str.length < len) {
	            str = "0" + str;
	        }
	        return str;
	    }    
	};

	/**
	 * Namespace: OpenLayers.Function
	 * Contains convenience functions for function manipulation.
	 */
	OpenLayers.Function = {
	    /**
	     * APIFunction: bind
	     * Bind a function to an object.  Method to easily create closures with
	     *     'this' altered.
	     * 
	     * Parameters:
	     * func - {Function} Input function.
	     * object - {Object} The object to bind to the input function (as this).
	     * 
	     * Returns:
	     * {Function} A closure with 'this' set to the passed in object.
	     */
	    bind: function(func, object) {
	        // create a reference to all arguments past the second one
	        var args = Array.prototype.slice.call(arguments, 2);
	        return function() {
	            // Push on any additional arguments from the actual function call.
	            // These will come after those sent to the bind call.
	            var newArgs = args.concat(
	                Array.prototype.slice.call(arguments, 0)
	            );
	            return func.apply(object, newArgs);
	        };
	    },
	    
	    /**
	     * APIFunction: bindAsEventListener
	     * Bind a function to an object, and configure it to receive the event
	     *     object as first parameter when called. 
	     * 
	     * Parameters:
	     * func - {Function} Input function to serve as an event listener.
	     * object - {Object} A reference to this.
	     * 
	     * Returns:
	     * {Function}
	     */
	    bindAsEventListener: function(func, object) {
	        return function(event) {
	            return func.call(object, event || window.event);
	        };
	    },
	    
	    /**
	     * APIFunction: False
	     * A simple function to that just does "return false". We use this to 
	     * avoid attaching anonymous functions to DOM event handlers, which 
	     * causes "issues" on IE<8.
	     * 
	     * Usage:
	     * document.onclick = OpenLayers.Function.False;
	     * 
	     * Returns:
	     * {Boolean}
	     */
	    False : function() {
	        return false;
	    },

	    /**
	     * APIFunction: True
	     * A simple function to that just does "return true". We use this to 
	     * avoid attaching anonymous functions to DOM event handlers, which 
	     * causes "issues" on IE<8.
	     * 
	     * Usage:
	     * document.onclick = OpenLayers.Function.True;
	     * 
	     * Returns:
	     * {Boolean}
	     */
	    True : function() {
	        return true;
	    },
	    
	    /**
	     * APIFunction: Void
	     * A reusable function that returns ``undefined``.
	     *
	     * Returns:
	     * {undefined}
	     */
	    Void: function() {}

	};

	/**
	 * Namespace: OpenLayers.Array
	 * Contains convenience functions for array manipulation.
	 */
	OpenLayers.Array = {

	    /**
	     * APIMethod: filter
	     * Filter an array.  Provides the functionality of the
	     *     Array.prototype.filter extension to the ECMA-262 standard.  Where
	     *     available, Array.prototype.filter will be used.
	     *
	     * Based on well known example from http://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Global_Objects/Array/filter
	     *
	     * Parameters:
	     * array - {Array} The array to be filtered.  This array is not mutated.
	     *     Elements added to this array by the callback will not be visited.
	     * callback - {Function} A function that is called for each element in
	     *     the array.  If this function returns true, the element will be
	     *     included in the return.  The function will be called with three
	     *     arguments: the element in the array, the index of that element, and
	     *     the array itself.  If the optional caller parameter is specified
	     *     the callback will be called with this set to caller.
	     * caller - {Object} Optional object to be set as this when the callback
	     *     is called.
	     *
	     * Returns:
	     * {Array} An array of elements from the passed in array for which the
	     *     callback returns true.
	     */
	    filter: function(array, callback, caller) {
	        var selected = [];
	        if (Array.prototype.filter) {
	            selected = array.filter(callback, caller);
	        } else {
	            var len = array.length;
	            if (typeof callback != "function") {
	                throw new TypeError();
	            }
	            for(var i=0; i<len; i++) {
	                if (i in array) {
	                    var val = array[i];
	                    if (callback.call(caller, val, i, array)) {
	                        selected.push(val);
	                    }
	                }
	            }        
	        }
	        return selected;
	    }
	    
	};
	/* ======================================================================
	    OpenLayers/BaseTypes/Bounds.js
	   ====================================================================== */

	/* Copyright (c) 2006-2015 by OpenLayers Contributors (see authors.txt for
	 * full list of contributors). Published under the 2-clause BSD license.
	 * See license.txt in the OpenLayers distribution or repository for the
	 * full text of the license. */

	/**
	 * @requires OpenLayers/BaseTypes/Class.js
	 */

	/**
	 * Class: OpenLayers.Bounds
	 * Instances of this class represent bounding boxes.  Data stored as left,
	 * bottom, right, top floats. All values are initialized to null, however,
	 * you should make sure you set them before using the bounds for anything.
	 * 
	 * Possible use case:
	 * (code)
	 *     bounds = new OpenLayers.Bounds();
	 *     bounds.extend(new OpenLayers.LonLat(4,5));
	 *     bounds.extend(new OpenLayers.LonLat(5,6));
	 *     bounds.toBBOX(); // returns 4,5,5,6
	 * (end)
	 */
	OpenLayers.Bounds = OpenLayers.Class({

	    /**
	     * Property: left
	     * {Number} Minimum horizontal coordinate.
	     */
	    left: null,

	    /**
	     * Property: bottom
	     * {Number} Minimum vertical coordinate.
	     */
	    bottom: null,

	    /**
	     * Property: right
	     * {Number} Maximum horizontal coordinate.
	     */
	    right: null,

	    /**
	     * Property: top
	     * {Number} Maximum vertical coordinate.
	     */
	    top: null,
	    
	    /**
	     * Property: centerLonLat
	     * {<OpenLayers.LonLat>} A cached center location.  This should not be
	     *     accessed directly.  Use <getCenterLonLat> instead.
	     */
	    centerLonLat: null,

	    /**
	     * Constructor: OpenLayers.Bounds
	     * Construct a new bounds object. Coordinates can either be passed as four
	     * arguments, or as a single argument.
	     *
	     * Parameters (four arguments):
	     * left - {Number} The left bounds of the box.  Note that for width
	     *        calculations, this is assumed to be less than the right value.
	     * bottom - {Number} The bottom bounds of the box.  Note that for height
	     *          calculations, this is assumed to be less than the top value.
	     * right - {Number} The right bounds.
	     * top - {Number} The top bounds.
	     *
	     * Parameters (single argument):
	     * bounds - {Array(Number)} [left, bottom, right, top]
	     */
	    initialize: function(left, bottom, right, top) {
	        if (OpenLayers.Util.isArray(left)) {
	            top = left[3];
	            right = left[2];
	            bottom = left[1];
	            left = left[0];
	        }
	        if (left != null) {
	            this.left = OpenLayers.Util.toFloat(left);
	        }
	        if (bottom != null) {
	            this.bottom = OpenLayers.Util.toFloat(bottom);
	        }
	        if (right != null) {
	            this.right = OpenLayers.Util.toFloat(right);
	        }
	        if (top != null) {
	            this.top = OpenLayers.Util.toFloat(top);
	        }
	    },

	    /**
	     * Method: clone
	     * Create a cloned instance of this bounds.
	     *
	     * Returns:
	     * {<OpenLayers.Bounds>} A fresh copy of the bounds
	     */
	    clone:function() {
	        return new OpenLayers.Bounds(this.left, this.bottom, 
	                                     this.right, this.top);
	    },

	    /**
	     * Method: equals
	     * Test a two bounds for equivalence.
	     *
	     * Parameters:
	     * bounds - {<OpenLayers.Bounds>}
	     *
	     * Returns:
	     * {Boolean} The passed-in bounds object has the same left,
	     *           right, top, bottom components as this.  Note that if bounds 
	     *           passed in is null, returns false.
	     */
	    equals:function(bounds) {
	        var equals = false;
	        if (bounds != null) {
	            equals = ((this.left == bounds.left) && 
	                      (this.right == bounds.right) &&
	                      (this.top == bounds.top) && 
	                      (this.bottom == bounds.bottom));
	        }
	        return equals;
	    },

	    /** 
	     * APIMethod: toString
	     * Returns a string representation of the bounds object.
	     * 
	     * Returns:
	     * {String} String representation of bounds object. 
	     */
	    toString:function() {
	        return [this.left, this.bottom, this.right, this.top].join(",");
	    },

	    /**
	     * APIMethod: toArray
	     * Returns an array representation of the bounds object.
	     *
	     * Returns an array of left, bottom, right, top properties, or -- when the
	     *     optional parameter is true -- an array of the  bottom, left, top,
	     *     right properties.
	     *
	     * Parameters:
	     * reverseAxisOrder - {Boolean} Should we reverse the axis order?
	     *
	     * Returns:
	     * {Array} array of left, bottom, right, top
	     */
	    toArray: function(reverseAxisOrder) {
	        if (reverseAxisOrder === true) {
	            return [this.bottom, this.left, this.top, this.right];
	        } else {
	            return [this.left, this.bottom, this.right, this.top];
	        }
	    },    

	    /** 
	     * APIMethod: toBBOX
	     * Returns a boundingbox-string representation of the bounds object.
	     * 
	     * Parameters:
	     * decimal - {Integer} How many decimal places in the bbox coords?
	     *                     Default is 6
	     * reverseAxisOrder - {Boolean} Should we reverse the axis order?
	     * 
	     * Returns:
	     * {String} Simple String representation of bounds object.
	     *          (e.g. "5,42,10,45")
	     */
	    toBBOX:function(decimal, reverseAxisOrder) {
	        if (decimal== null) {
	            decimal = 6; 
	        }
	        var mult = Math.pow(10, decimal);
	        var xmin = Math.round(this.left * mult) / mult;
	        var ymin = Math.round(this.bottom * mult) / mult;
	        var xmax = Math.round(this.right * mult) / mult;
	        var ymax = Math.round(this.top * mult) / mult;
	        if (reverseAxisOrder === true) {
	            return ymin + "," + xmin + "," + ymax + "," + xmax;
	        } else {
	            return xmin + "," + ymin + "," + xmax + "," + ymax;
	        }
	    },
	 
	    /**
	     * APIMethod: toGeometry
	     * Create a new polygon geometry based on this bounds.
	     *
	     * Returns:
	     * {<OpenLayers.Geometry.Polygon>} A new polygon with the coordinates
	     *     of this bounds.
	     */
	    toGeometry: function() {
	        return new OpenLayers.Geometry.Polygon([
	            new OpenLayers.Geometry.LinearRing([
	                new OpenLayers.Geometry.Point(this.left, this.bottom),
	                new OpenLayers.Geometry.Point(this.right, this.bottom),
	                new OpenLayers.Geometry.Point(this.right, this.top),
	                new OpenLayers.Geometry.Point(this.left, this.top)
	            ])
	        ]);
	    },
	    
	    /**
	     * APIMethod: getWidth
	     * Returns the width of the bounds.
	     * 
	     * Returns:
	     * {Float} The width of the bounds (right minus left).
	     */
	    getWidth:function() {
	        return (this.right - this.left);
	    },

	    /**
	     * APIMethod: getHeight
	     * Returns the height of the bounds.
	     * 
	     * Returns:
	     * {Float} The height of the bounds (top minus bottom).
	     */
	    getHeight:function() {
	        return (this.top - this.bottom);
	    },

	    /**
	     * APIMethod: getSize
	     * Returns an <OpenLayers.Size> object of the bounds.
	     * 
	     * Returns:
	     * {<OpenLayers.Size>} The size of the bounds.
	     */
	    getSize:function() {
	        return new OpenLayers.Size(this.getWidth(), this.getHeight());
	    },

	    /**
	     * APIMethod: getCenterPixel
	     * Returns the <OpenLayers.Pixel> object which represents the center of the
	     *     bounds.
	     * 
	     * Returns:
	     * {<OpenLayers.Pixel>} The center of the bounds in pixel space.
	     */
	    getCenterPixel:function() {
	        return new OpenLayers.Pixel( (this.left + this.right) / 2,
	                                     (this.bottom + this.top) / 2);
	    },

	    /**
	     * APIMethod: getCenterLonLat
	     * Returns the <OpenLayers.LonLat> object which represents the center of the
	     *     bounds.
	     *
	     * Returns:
	     * {<OpenLayers.LonLat>} The center of the bounds in map space.
	     */
	    getCenterLonLat:function() {
	        if(!this.centerLonLat) {
	            this.centerLonLat = new OpenLayers.LonLat(
	                (this.left + this.right) / 2, (this.bottom + this.top) / 2
	            );
	        }
	        return this.centerLonLat;
	    },

	    /**
	     * APIMethod: scale
	     * Scales the bounds around a pixel or lonlat. Note that the new 
	     *     bounds may return non-integer properties, even if a pixel
	     *     is passed. 
	     * 
	     * Parameters:
	     * ratio - {Float} 
	     * origin - {<OpenLayers.Pixel> or <OpenLayers.LonLat>}
	     *          Default is center.
	     *
	     * Returns:
	     * {<OpenLayers.Bounds>} A new bounds that is scaled by ratio
	     *                      from origin.
	     */
	    scale: function(ratio, origin){
	        if(origin == null){
	            origin = this.getCenterLonLat();
	        }
	        
	        var origx,origy;

	        // get origin coordinates
	        if(origin.CLASS_NAME == "OpenLayers.LonLat"){
	            origx = origin.lon;
	            origy = origin.lat;
	        } else {
	            origx = origin.x;
	            origy = origin.y;
	        }

	        var left = (this.left - origx) * ratio + origx;
	        var bottom = (this.bottom - origy) * ratio + origy;
	        var right = (this.right - origx) * ratio + origx;
	        var top = (this.top - origy) * ratio + origy;
	        
	        return new OpenLayers.Bounds(left, bottom, right, top);
	    },

	    /**
	     * APIMethod: add
	     * Shifts the coordinates of the bound by the given horizontal and vertical
	     *     deltas.
	     *
	     * (start code)
	     * var bounds = new OpenLayers.Bounds(0, 0, 10, 10);
	     * bounds.toString();
	     * // => "0,0,10,10"
	     *
	     * bounds.add(-1.5, 4).toString();
	     * // => "-1.5,4,8.5,14"
	     * (end)
	     *
	     * This method will throw a TypeError if it is passed null as an argument.
	     *
	     * Parameters:
	     * x - {Float} horizontal delta
	     * y - {Float} vertical delta
	     *
	     * Returns:
	     * {<OpenLayers.Bounds>} A new bounds whose coordinates are the same as
	     *     this, but shifted by the passed-in x and y values.
	     */
	    add:function(x, y) {
	        if ( (x == null) || (y == null) ) {
	            throw new TypeError('Bounds.add cannot receive null values');
	        }
	        return new OpenLayers.Bounds(this.left + x, this.bottom + y,
	                                     this.right + x, this.top + y);
	    },
	    
	    /**
	     * APIMethod: extend
	     * Extend the bounds to include the <OpenLayers.LonLat>,
	     *     <OpenLayers.Geometry.Point> or <OpenLayers.Bounds> specified.
	     *
	     * Please note that this function assumes that left < right and
	     *     bottom < top.
	     *
	     * Parameters:
	     * object - {<OpenLayers.LonLat>, <OpenLayers.Geometry.Point> or
	     *     <OpenLayers.Bounds>} The object to be included in the new bounds
	     *     object.
	     */
	    extend:function(object) {
	        if (object) {
	            switch(object.CLASS_NAME) {
	                case "OpenLayers.LonLat":
	                    this.extendXY(object.lon, object.lat);
	                    break;
	                case "OpenLayers.Geometry.Point":
	                    this.extendXY(object.x, object.y);
	                    break;

	                case "OpenLayers.Bounds":
	                    // clear cached center location
	                    this.centerLonLat = null;

	                    if ( (this.left == null) || (object.left < this.left)) {
	                        this.left = object.left;
	                    }
	                    if ( (this.bottom == null) || (object.bottom < this.bottom) ) {
	                        this.bottom = object.bottom;
	                    }
	                    if ( (this.right == null) || (object.right > this.right) ) {
	                        this.right = object.right;
	                    }
	                    if ( (this.top == null) || (object.top > this.top) ) {
	                        this.top = object.top;
	                    }
	                    break;
	            }
	        }
	    },

	    /**
	     * APIMethod: extendXY
	     * Extend the bounds to include the XY coordinate specified.
	     *
	     * Parameters:
	     * x - {number} The X part of the the coordinate.
	     * y - {number} The Y part of the the coordinate.
	     */
	    extendXY:function(x, y) {
	        // clear cached center location
	        this.centerLonLat = null;

	        if ((this.left == null) || (x < this.left)) {
	            this.left = x;
	        }
	        if ((this.bottom == null) || (y < this.bottom)) {
	            this.bottom = y;
	        }
	        if ((this.right == null) || (x > this.right)) {
	            this.right = x;
	        }
	        if ((this.top == null) || (y > this.top)) {
	            this.top = y;
	        }
	    },

	    /**
	     * APIMethod: containsLonLat
	     * Returns whether the bounds object contains the given <OpenLayers.LonLat>.
	     * 
	     * Parameters:
	     * ll - {<OpenLayers.LonLat>|Object} OpenLayers.LonLat or an
	     *     object with a 'lon' and 'lat' properties.
	     * options - {Object} Optional parameters
	     *
	     * Acceptable options:
	     * inclusive - {Boolean} Whether or not to include the border.
	     *     Default is true.
	     * worldBounds - {<OpenLayers.Bounds>} If a worldBounds is provided, the
	     *     ll will be considered as contained if it exceeds the world bounds,
	     *     but can be wrapped around the dateline so it is contained by this
	     *     bounds.
	     *
	     * Returns:
	     * {Boolean} The passed-in lonlat is within this bounds.
	     */
	    containsLonLat: function(ll, options) {
	        if (typeof options === "boolean") {
	            options =  {inclusive: options};
	        }
	        options = options || {};
	        var contains = this.contains(ll.lon, ll.lat, options.inclusive),
	            worldBounds = options.worldBounds;
	        if (worldBounds && !contains) {
	            var worldWidth = worldBounds.getWidth();
	            var worldCenterX = (worldBounds.left + worldBounds.right) / 2;
	            var worldsAway = Math.round((ll.lon - worldCenterX) / worldWidth);
	            contains = this.containsLonLat({
	                lon: ll.lon - worldsAway * worldWidth,
	                lat: ll.lat
	            }, {inclusive: options.inclusive});
	        }
	        return contains;
	    },

	    /**
	     * APIMethod: containsPixel
	     * Returns whether the bounds object contains the given <OpenLayers.Pixel>.
	     * 
	     * Parameters:
	     * px - {<OpenLayers.Pixel>}
	     * inclusive - {Boolean} Whether or not to include the border. Default is
	     *     true.
	     *
	     * Returns:
	     * {Boolean} The passed-in pixel is within this bounds.
	     */
	    containsPixel:function(px, inclusive) {
	        return this.contains(px.x, px.y, inclusive);
	    },
	    
	    /**
	     * APIMethod: contains
	     * Returns whether the bounds object contains the given x and y.
	     * 
	     * Parameters:
	     * x - {Float}
	     * y - {Float}
	     * inclusive - {Boolean} Whether or not to include the border. Default is
	     *     true.
	     *
	     * Returns:
	     * {Boolean} Whether or not the passed-in coordinates are within this
	     *     bounds.
	     */
	    contains:function(x, y, inclusive) {
	        //set default
	        if (inclusive == null) {
	            inclusive = true;
	        }

	        if (x == null || y == null) {
	            return false;
	        }

	        x = OpenLayers.Util.toFloat(x);
	        y = OpenLayers.Util.toFloat(y);

	        var contains = false;
	        if (inclusive) {
	            contains = ((x >= this.left) && (x <= this.right) && 
	                        (y >= this.bottom) && (y <= this.top));
	        } else {
	            contains = ((x > this.left) && (x < this.right) && 
	                        (y > this.bottom) && (y < this.top));
	        }              
	        return contains;
	    },

	    /**
	     * APIMethod: intersectsBounds
	     * Determine whether the target bounds intersects this bounds.  Bounds are
	     *     considered intersecting if any of their edges intersect or if one
	     *     bounds contains the other.
	     * 
	     * Parameters:
	     * bounds - {<OpenLayers.Bounds>} The target bounds.
	     * options - {Object} Optional parameters.
	     * 
	     * Acceptable options:
	     * inclusive - {Boolean} Treat coincident borders as intersecting.  Default
	     *     is true.  If false, bounds that do not overlap but only touch at the
	     *     border will not be considered as intersecting.
	     * worldBounds - {<OpenLayers.Bounds>} If a worldBounds is provided, two
	     *     bounds will be considered as intersecting if they intersect when 
	     *     shifted to within the world bounds.  This applies only to bounds that
	     *     cross or are completely outside the world bounds.
	     *
	     * Returns:
	     * {Boolean} The passed-in bounds object intersects this bounds.
	     */
	    intersectsBounds:function(bounds, options) {
	        if (typeof options === "boolean") {
	            options =  {inclusive: options};
	        }
	        options = options || {};
	        if (options.worldBounds) {
	            var self = this.wrapDateLine(options.worldBounds);
	            bounds = bounds.wrapDateLine(options.worldBounds);
	        } else {
	            self = this;
	        }
	        if (options.inclusive == null) {
	            options.inclusive = true;
	        }
	        var intersects = false;
	        var mightTouch = (
	            self.left == bounds.right ||
	            self.right == bounds.left ||
	            self.top == bounds.bottom ||
	            self.bottom == bounds.top
	        );
	        
	        // if the two bounds only touch at an edge, and inclusive is false,
	        // then the bounds don't *really* intersect.
	        if (options.inclusive || !mightTouch) {
	            // otherwise, if one of the boundaries even partially contains another,
	            // inclusive of the edges, then they do intersect.
	            var inBottom = (
	                ((bounds.bottom >= self.bottom) && (bounds.bottom <= self.top)) ||
	                ((self.bottom >= bounds.bottom) && (self.bottom <= bounds.top))
	            );
	            var inTop = (
	                ((bounds.top >= self.bottom) && (bounds.top <= self.top)) ||
	                ((self.top > bounds.bottom) && (self.top < bounds.top))
	            );
	            var inLeft = (
	                ((bounds.left >= self.left) && (bounds.left <= self.right)) ||
	                ((self.left >= bounds.left) && (self.left <= bounds.right))
	            );
	            var inRight = (
	                ((bounds.right >= self.left) && (bounds.right <= self.right)) ||
	                ((self.right >= bounds.left) && (self.right <= bounds.right))
	            );
	            intersects = ((inBottom || inTop) && (inLeft || inRight));
	        }
	        // document me
	        if (options.worldBounds && !intersects) {
	            var world = options.worldBounds;
	            var width = world.getWidth();
	            var selfCrosses = !world.containsBounds(self);
	            var boundsCrosses = !world.containsBounds(bounds);
	            if (selfCrosses && !boundsCrosses) {
	                bounds = bounds.add(-width, 0);
	                intersects = self.intersectsBounds(bounds, {inclusive: options.inclusive});
	            } else if (boundsCrosses && !selfCrosses) {
	                self = self.add(-width, 0);
	                intersects = bounds.intersectsBounds(self, {inclusive: options.inclusive});                
	            }
	        }
	        return intersects;
	    },
	    
	    /**
	     * APIMethod: containsBounds
	     * Returns whether the bounds object contains the given <OpenLayers.Bounds>.
	     * 
	     * bounds - {<OpenLayers.Bounds>} The target bounds.
	     * partial - {Boolean} If any of the target corners is within this bounds
	     *     consider the bounds contained.  Default is false.  If false, the
	     *     entire target bounds must be contained within this bounds.
	     * inclusive - {Boolean} Treat shared edges as contained.  Default is
	     *     true.
	     *
	     * Returns:
	     * {Boolean} The passed-in bounds object is contained within this bounds. 
	     */
	    containsBounds:function(bounds, partial, inclusive) {
	        if (partial == null) {
	            partial = false;
	        }
	        if (inclusive == null) {
	            inclusive = true;
	        }
	        var bottomLeft  = this.contains(bounds.left, bounds.bottom, inclusive);
	        var bottomRight = this.contains(bounds.right, bounds.bottom, inclusive);
	        var topLeft  = this.contains(bounds.left, bounds.top, inclusive);
	        var topRight = this.contains(bounds.right, bounds.top, inclusive);
	        
	        return (partial) ? (bottomLeft || bottomRight || topLeft || topRight)
	                         : (bottomLeft && bottomRight && topLeft && topRight);
	    },

	    /** 
	     * APIMethod: determineQuadrant
	     * Returns the the quadrant ("br", "tr", "tl", "bl") in which the given
	     *     <OpenLayers.LonLat> lies.
	     *
	     * Parameters:
	     * lonlat - {<OpenLayers.LonLat>}
	     *
	     * Returns:
	     * {String} The quadrant ("br" "tr" "tl" "bl") of the bounds in which the
	     *     coordinate lies.
	     */
	    determineQuadrant: function(lonlat) {
	    
	        var quadrant = "";
	        var center = this.getCenterLonLat();
	        
	        quadrant += (lonlat.lat < center.lat) ? "b" : "t";
	        quadrant += (lonlat.lon < center.lon) ? "l" : "r";
	    
	        return quadrant; 
	    },
	    
	    /**
	     * APIMethod: transform
	     * Transform the Bounds object from source to dest. 
	     *
	     * Parameters: 
	     * source - {<OpenLayers.Projection>} Source projection. 
	     * dest   - {<OpenLayers.Projection>} Destination projection. 
	     *
	     * Returns:
	     * {<OpenLayers.Bounds>} Itself, for use in chaining operations.
	     */
	    transform: function(source, dest) {
	        // clear cached center location
	        this.centerLonLat = null;
	        var ll = OpenLayers.Projection.transform(
	            {'x': this.left, 'y': this.bottom}, source, dest);
	        var lr = OpenLayers.Projection.transform(
	            {'x': this.right, 'y': this.bottom}, source, dest);
	        var ul = OpenLayers.Projection.transform(
	            {'x': this.left, 'y': this.top}, source, dest);
	        var ur = OpenLayers.Projection.transform(
	            {'x': this.right, 'y': this.top}, source, dest);
	        this.left   = Math.min(ll.x, ul.x);
	        this.bottom = Math.min(ll.y, lr.y);
	        this.right  = Math.max(lr.x, ur.x);
	        this.top    = Math.max(ul.y, ur.y);
	        return this;
	    },

	    /**
	     * APIMethod: wrapDateLine
	     * Wraps the bounds object around the dateline.
	     *  
	     * Parameters:
	     * maxExtent - {<OpenLayers.Bounds>}
	     * options - {Object} Some possible options are:
	     *
	     * Allowed Options:
	     *                    leftTolerance - {float} Allow for a margin of error 
	     *                                            with the 'left' value of this 
	     *                                            bound.
	     *                                            Default is 0.
	     *                    rightTolerance - {float} Allow for a margin of error 
	     *                                             with the 'right' value of 
	     *                                             this bound.
	     *                                             Default is 0.
	     * 
	     * Returns:
	     * {<OpenLayers.Bounds>} A copy of this bounds, but wrapped around the 
	     *                       "dateline" (as specified by the borders of 
	     *                       maxExtent). Note that this function only returns 
	     *                       a different bounds value if this bounds is 
	     *                       *entirely* outside of the maxExtent. If this 
	     *                       bounds straddles the dateline (is part in/part 
	     *                       out of maxExtent), the returned bounds will always 
	     *                       cross the left edge of the given maxExtent.
	     *.
	     */
	    wrapDateLine: function(maxExtent, options) {    
	        options = options || {};
	        
	        var leftTolerance = options.leftTolerance || 0;
	        var rightTolerance = options.rightTolerance || 0;

	        var newBounds = this.clone();
	    
	        if (maxExtent) {
	            var width = maxExtent.getWidth();

	            //shift right?
	            while (newBounds.left < maxExtent.left && 
	                   newBounds.right - rightTolerance <= maxExtent.left ) { 
	                newBounds = newBounds.add(width, 0);
	            }

	            //shift left?
	            while (newBounds.left + leftTolerance >= maxExtent.right && 
	                   newBounds.right > maxExtent.right ) { 
	                newBounds = newBounds.add(-width, 0);
	            }
	           
	            // crosses right only? force left
	            var newLeft = newBounds.left + leftTolerance;
	            if (newLeft < maxExtent.right && newLeft > maxExtent.left && 
	                   newBounds.right - rightTolerance > maxExtent.right) {
	                newBounds = newBounds.add(-width, 0);
	            }
	        }
	                
	        return newBounds;
	    },

	    CLASS_NAME: "OpenLayers.Bounds"
	});

	/** 
	 * APIFunction: fromString
	 * Alternative constructor that builds a new OpenLayers.Bounds from a 
	 *     parameter string.
	 *
	 * (begin code)
	 * OpenLayers.Bounds.fromString("5,42,10,45");
	 * // => equivalent to ...
	 * new OpenLayers.Bounds(5, 42, 10, 45);
	 * (end)
	 *
	 * Parameters: 
	 * str - {String} Comma-separated bounds string. (e.g. "5,42,10,45")
	 * reverseAxisOrder - {Boolean} Does the string use reverse axis order?
	 *
	 * Returns:
	 * {<OpenLayers.Bounds>} New bounds object built from the 
	 *                       passed-in String.
	 */
	OpenLayers.Bounds.fromString = function(str, reverseAxisOrder) {
	    var bounds = str.split(",");
	    return OpenLayers.Bounds.fromArray(bounds, reverseAxisOrder);
	};

	/** 
	 * APIFunction: fromArray
	 * Alternative constructor that builds a new OpenLayers.Bounds from an array.
	 *
	 * (begin code)
	 * OpenLayers.Bounds.fromArray( [5, 42, 10, 45] );
	 * // => equivalent to ...
	 * new OpenLayers.Bounds(5, 42, 10, 45);
	 * (end)
	 *
	 * Parameters:
	 * bbox - {Array(Float)} Array of bounds values (e.g. [5,42,10,45])
	 * reverseAxisOrder - {Boolean} Does the array use reverse axis order?
	 *
	 * Returns:
	 * {<OpenLayers.Bounds>} New bounds object built from the passed-in Array.
	 */
	OpenLayers.Bounds.fromArray = function(bbox, reverseAxisOrder) {
	    return reverseAxisOrder === true ?
	           new OpenLayers.Bounds(bbox[1], bbox[0], bbox[3], bbox[2]) :
	           new OpenLayers.Bounds(bbox[0], bbox[1], bbox[2], bbox[3]);
	};

	/** 
	 * APIFunction: fromSize
	 * Alternative constructor that builds a new OpenLayers.Bounds from a size.
	 *
	 * (begin code)
	 * OpenLayers.Bounds.fromSize( new OpenLayers.Size(10, 20) );
	 * // => equivalent to ...
	 * new OpenLayers.Bounds(0, 20, 10, 0);
	 * (end)
	 *
	 * Parameters:
	 * size - {<OpenLayers.Size> or Object} <OpenLayers.Size> or an object with
	 *     both 'w' and 'h' properties.
	 *
	 * Returns:
	 * {<OpenLayers.Bounds>} New bounds object built from the passed-in size.
	 */
	OpenLayers.Bounds.fromSize = function(size) {
	    return new OpenLayers.Bounds(0,
	                                 size.h,
	                                 size.w,
	                                 0);
	};

	/**
	 * Function: oppositeQuadrant
	 * Get the opposite quadrant for a given quadrant string.
	 *
	 * (begin code)
	 * OpenLayers.Bounds.oppositeQuadrant( "tl" );
	 * // => "br"
	 *
	 * OpenLayers.Bounds.oppositeQuadrant( "tr" );
	 * // => "bl"
	 * (end)
	 *
	 * Parameters:
	 * quadrant - {String} two character quadrant shortstring
	 *
	 * Returns:
	 * {String} The opposing quadrant ("br" "tr" "tl" "bl"). For Example, if 
	 *          you pass in "bl" it returns "tr", if you pass in "br" it 
	 *          returns "tl", etc.
	 */
	OpenLayers.Bounds.oppositeQuadrant = function(quadrant) {
	    var opp = "";
	    
	    opp += (quadrant.charAt(0) == 't') ? 'b' : 't';
	    opp += (quadrant.charAt(1) == 'l') ? 'r' : 'l';
	    
	    return opp;
	};
	/* ======================================================================
	    OpenLayers/BaseTypes/Element.js
	   ====================================================================== */

	/* Copyright (c) 2006-2015 by OpenLayers Contributors (see authors.txt for
	 * full list of contributors). Published under the 2-clause BSD license.
	 * See license.txt in the OpenLayers distribution or repository for the
	 * full text of the license. */

	/**
	 * @requires OpenLayers/Util.js
	 * @requires OpenLayers/BaseTypes.js
	 */

	/**
	 * Namespace: OpenLayers.Element
	 */
	OpenLayers.Element = {

	    /**
	     * APIFunction: visible
	     * 
	     * Parameters: 
	     * element - {DOMElement}
	     * 
	     * Returns:
	     * {Boolean} Is the element visible?
	     */
	    visible: function(element) {
	        return OpenLayers.Util.getElement(element).style.display != 'none';
	    },

	    /**
	     * APIFunction: toggle
	     * Toggle the visibility of element(s) passed in
	     * 
	     * Parameters:
	     * element - {DOMElement} Actually user can pass any number of elements
	     */
	    toggle: function() {
	        for (var i=0, len=arguments.length; i<len; i++) {
	            var element = OpenLayers.Util.getElement(arguments[i]);
	            var display = OpenLayers.Element.visible(element) ? 'none' 
	                                                              : '';
	            element.style.display = display;
	        }
	    },

	    /**
	     * APIFunction: remove
	     * Remove the specified element from the DOM.
	     * 
	     * Parameters:
	     * element - {DOMElement}
	     */
	    remove: function(element) {
	        element = OpenLayers.Util.getElement(element);
	        element.parentNode.removeChild(element);
	    },

	    /**
	     * APIFunction: getHeight
	     *  
	     * Parameters:
	     * element - {DOMElement}
	     * 
	     * Returns:
	     * {Integer} The offset height of the element passed in
	     */
	    getHeight: function(element) {
	        element = OpenLayers.Util.getElement(element);
	        return element.offsetHeight;
	    },

	    /**
	     * Function: hasClass
	     * Tests if an element has the given CSS class name.
	     *
	     * Parameters:
	     * element - {DOMElement} A DOM element node.
	     * name - {String} The CSS class name to search for.
	     *
	     * Returns:
	     * {Boolean} The element has the given class name.
	     */
	    hasClass: function(element, name) {
	        var names = element.className;
	        return (!!names && new RegExp("(^|\\s)" + name + "(\\s|$)").test(names));
	    },
	    
	    /**
	     * Function: addClass
	     * Add a CSS class name to an element.  Safe where element already has
	     *     the class name.
	     *
	     * Parameters:
	     * element - {DOMElement} A DOM element node.
	     * name - {String} The CSS class name to add.
	     *
	     * Returns:
	     * {DOMElement} The element.
	     */
	    addClass: function(element, name) {
	        if(!OpenLayers.Element.hasClass(element, name)) {
	            element.className += (element.className ? " " : "") + name;
	        }
	        return element;
	    },

	    /**
	     * Function: removeClass
	     * Remove a CSS class name from an element.  Safe where element does not
	     *     have the class name.
	     *
	     * Parameters:
	     * element - {DOMElement} A DOM element node.
	     * name - {String} The CSS class name to remove.
	     *
	     * Returns:
	     * {DOMElement} The element.
	     */
	    removeClass: function(element, name) {
	        var names = element.className;
	        if(names) {
	            element.className = OpenLayers.String.trim(
	                names.replace(
	                    new RegExp("(^|\\s+)" + name + "(\\s+|$)"), " "
	                )
	            );
	        }
	        return element;
	    },

	    /**
	     * Function: toggleClass
	     * Remove a CSS class name from an element if it exists.  Add the class name
	     *     if it doesn't exist.
	     *
	     * Parameters:
	     * element - {DOMElement} A DOM element node.
	     * name - {String} The CSS class name to toggle.
	     *
	     * Returns:
	     * {DOMElement} The element.
	     */
	    toggleClass: function(element, name) {
	        if(OpenLayers.Element.hasClass(element, name)) {
	            OpenLayers.Element.removeClass(element, name);
	        } else {
	            OpenLayers.Element.addClass(element, name);
	        }
	        return element;
	    },

	    /**
	     * APIFunction: getStyle
	     * 
	     * Parameters:
	     * element - {DOMElement}
	     * style - {?}
	     * 
	     * Returns:
	     * {?}
	     */
	    getStyle: function(element, style) {
	        element = OpenLayers.Util.getElement(element);

	        var value = null;
	        if (element && element.style) {
	            value = element.style[OpenLayers.String.camelize(style)];
	            if (!value) {
	                if (document.defaultView && 
	                    document.defaultView.getComputedStyle) {
	                    
	                    var css = document.defaultView.getComputedStyle(element, null);
	                    value = css ? css.getPropertyValue(style) : null;
	                } else if (element.currentStyle) {
	                    value = element.currentStyle[OpenLayers.String.camelize(style)];
	                }
	            }
	        
	            var positions = ['left', 'top', 'right', 'bottom'];
	            if (window.opera &&
	                (OpenLayers.Util.indexOf(positions,style) != -1) &&
	                (OpenLayers.Element.getStyle(element, 'position') == 'static')) { 
	                value = 'auto';
	            }
	        }
	    
	        return value == 'auto' ? null : value;
	    }

	};
	/* ======================================================================
	    OpenLayers/BaseTypes/LonLat.js
	   ====================================================================== */

	/* Copyright (c) 2006-2015 by OpenLayers Contributors (see authors.txt for
	 * full list of contributors). Published under the 2-clause BSD license.
	 * See license.txt in the OpenLayers distribution or repository for the
	 * full text of the license. */

	/**
	 * @requires OpenLayers/BaseTypes/Class.js
	 */

	/**
	 * Class: OpenLayers.LonLat
	 * This class represents a longitude and latitude pair
	 */
	OpenLayers.LonLat = OpenLayers.Class({

	    /** 
	     * APIProperty: lon
	     * {Float} The x-axis coodinate in map units
	     */
	    lon: 0.0,
	    
	    /** 
	     * APIProperty: lat
	     * {Float} The y-axis coordinate in map units
	     */
	    lat: 0.0,

	    /**
	     * Constructor: OpenLayers.LonLat
	     * Create a new map location. Coordinates can be passed either as two
	     * arguments, or as a single argument.
	     *
	     * Parameters (two arguments):
	     * lon - {Number} The x-axis coordinate in map units.  If your map is in
	     *     a geographic projection, this will be the Longitude.  Otherwise,
	     *     it will be the x coordinate of the map location in your map units.
	     * lat - {Number} The y-axis coordinate in map units.  If your map is in
	     *     a geographic projection, this will be the Latitude.  Otherwise,
	     *     it will be the y coordinate of the map location in your map units.
	     *
	     * Parameters (single argument):
	     * location - {Array(Float)} [lon, lat]
	     */
	    initialize: function(lon, lat) {
	        if (OpenLayers.Util.isArray(lon)) {
	            lat = lon[1];
	            lon = lon[0];
	        }
	        this.lon = OpenLayers.Util.toFloat(lon);
	        this.lat = OpenLayers.Util.toFloat(lat);
	    },
	    
	    /**
	     * Method: toString
	     * Return a readable string version of the lonlat
	     *
	     * Returns:
	     * {String} String representation of OpenLayers.LonLat object. 
	     *           (e.g. <i>"lon=5,lat=42"</i>)
	     */
	    toString:function() {
	        return ("lon=" + this.lon + ",lat=" + this.lat);
	    },

	    /** 
	     * APIMethod: toShortString
	     * 
	     * Returns:
	     * {String} Shortened String representation of OpenLayers.LonLat object. 
	     *         (e.g. <i>"5, 42"</i>)
	     */
	    toShortString:function() {
	        return (this.lon + ", " + this.lat);
	    },

	    /** 
	     * APIMethod: clone
	     * 
	     * Returns:
	     * {<OpenLayers.LonLat>} New OpenLayers.LonLat object with the same lon 
	     *                       and lat values
	     */
	    clone:function() {
	        return new OpenLayers.LonLat(this.lon, this.lat);
	    },

	    /** 
	     * APIMethod: add
	     * 
	     * Parameters:
	     * lon - {Float}
	     * lat - {Float}
	     * 
	     * Returns:
	     * {<OpenLayers.LonLat>} A new OpenLayers.LonLat object with the lon and 
	     *                       lat passed-in added to this's. 
	     */
	    add:function(lon, lat) {
	        if ( (lon == null) || (lat == null) ) {
	            throw new TypeError('LonLat.add cannot receive null values');
	        }
	        return new OpenLayers.LonLat(this.lon + OpenLayers.Util.toFloat(lon), 
	                                     this.lat + OpenLayers.Util.toFloat(lat));
	    },

	    /** 
	     * APIMethod: equals
	     * 
	     * Parameters:
	     * ll - {<OpenLayers.LonLat>}
	     * 
	     * Returns:
	     * {Boolean} Boolean value indicating whether the passed-in 
	     *           <OpenLayers.LonLat> object has the same lon and lat 
	     *           components as this.
	     *           Note: if ll passed in is null, returns false
	     */
	    equals:function(ll) {
	        var equals = false;
	        if (ll != null) {
	            equals = ((this.lon == ll.lon && this.lat == ll.lat) ||
	                      (isNaN(this.lon) && isNaN(this.lat) && isNaN(ll.lon) && isNaN(ll.lat)));
	        }
	        return equals;
	    },

	    /**
	     * APIMethod: transform
	     * Transform the LonLat object from source to dest. This transformation is
	     *    *in place*: if you want a *new* lonlat, use .clone() first.
	     *
	     * Parameters: 
	     * source - {<OpenLayers.Projection>} Source projection. 
	     * dest   - {<OpenLayers.Projection>} Destination projection. 
	     *
	     * Returns:
	     * {<OpenLayers.LonLat>} Itself, for use in chaining operations.
	     */
	    transform: function(source, dest) {
	        var point = OpenLayers.Projection.transform(
	            {'x': this.lon, 'y': this.lat}, source, dest);
	        this.lon = point.x;
	        this.lat = point.y;
	        return this;
	    },
	    
	    /**
	     * APIMethod: wrapDateLine
	     * 
	     * Parameters:
	     * maxExtent - {<OpenLayers.Bounds>}
	     * 
	     * Returns:
	     * {<OpenLayers.LonLat>} A copy of this lonlat, but wrapped around the 
	     *                       "dateline" (as specified by the borders of 
	     *                       maxExtent)
	     */
	    wrapDateLine: function(maxExtent) {    

	        var newLonLat = this.clone();
	    
	        if (maxExtent) {
	            //shift right?
	            while (newLonLat.lon < maxExtent.left) {
	                newLonLat.lon +=  maxExtent.getWidth();
	            }    
	           
	            //shift left?
	            while (newLonLat.lon > maxExtent.right) {
	                newLonLat.lon -= maxExtent.getWidth();
	            }    
	        }
	                
	        return newLonLat;
	    },

	    CLASS_NAME: "OpenLayers.LonLat"
	});

	/** 
	 * Function: fromString
	 * Alternative constructor that builds a new <OpenLayers.LonLat> from a 
	 *     parameter string
	 * 
	 * Parameters:
	 * str - {String} Comma-separated Lon,Lat coordinate string. 
	 *                 (e.g. <i>"5,40"</i>)
	 * 
	 * Returns:
	 * {<OpenLayers.LonLat>} New <OpenLayers.LonLat> object built from the 
	 *                       passed-in String.
	 */
	OpenLayers.LonLat.fromString = function(str) {
	    var pair = str.split(",");
	    return new OpenLayers.LonLat(pair[0], pair[1]);
	};

	/** 
	 * Function: fromArray
	 * Alternative constructor that builds a new <OpenLayers.LonLat> from an 
	 *     array of two numbers that represent lon- and lat-values.
	 * 
	 * Parameters:
	 * arr - {Array(Float)} Array of lon/lat values (e.g. [5,-42])
	 * 
	 * Returns:
	 * {<OpenLayers.LonLat>} New <OpenLayers.LonLat> object built from the 
	 *                       passed-in array.
	 */
	OpenLayers.LonLat.fromArray = function(arr) {
	    var gotArr = OpenLayers.Util.isArray(arr),
	        lon = gotArr && arr[0],
	        lat = gotArr && arr[1];
	    return new OpenLayers.LonLat(lon, lat);
	};
	/* ======================================================================
	    OpenLayers/BaseTypes/Pixel.js
	   ====================================================================== */

	/* Copyright (c) 2006-2015 by OpenLayers Contributors (see authors.txt for
	 * full list of contributors). Published under the 2-clause BSD license.
	 * See license.txt in the OpenLayers distribution or repository for the
	 * full text of the license. */

	/**
	 * @requires OpenLayers/BaseTypes/Class.js
	 */

	/**
	 * Class: OpenLayers.Pixel
	 * This class represents a screen coordinate, in x and y coordinates
	 */
	OpenLayers.Pixel = OpenLayers.Class({
	    
	    /**
	     * APIProperty: x
	     * {Number} The x coordinate
	     */
	    x: 0.0,

	    /**
	     * APIProperty: y
	     * {Number} The y coordinate
	     */
	    y: 0.0,
	    
	    /**
	     * Constructor: OpenLayers.Pixel
	     * Create a new OpenLayers.Pixel instance
	     *
	     * Parameters:
	     * x - {Number} The x coordinate
	     * y - {Number} The y coordinate
	     *
	     * Returns:
	     * An instance of OpenLayers.Pixel
	     */
	    initialize: function(x, y) {
	        this.x = parseFloat(x);
	        this.y = parseFloat(y);
	    },
	    
	    /**
	     * Method: toString
	     * Cast this object into a string
	     *
	     * Returns:
	     * {String} The string representation of Pixel. ex: "x=200.4,y=242.2"
	     */
	    toString:function() {
	        return ("x=" + this.x + ",y=" + this.y);
	    },

	    /**
	     * APIMethod: clone
	     * Return a clone of this pixel object
	     *
	     * Returns:
	     * {<OpenLayers.Pixel>} A clone pixel
	     */
	    clone:function() {
	        return new OpenLayers.Pixel(this.x, this.y); 
	    },
	    
	    /**
	     * APIMethod: equals
	     * Determine whether one pixel is equivalent to another
	     *
	     * Parameters:
	     * px - {<OpenLayers.Pixel>|Object} An OpenLayers.Pixel or an object with
	     *                                  a 'x' and 'y' properties.
	     *
	     * Returns:
	     * {Boolean} The point passed in as parameter is equal to this. Note that
	     * if px passed in is null, returns false.
	     */
	    equals:function(px) {
	        var equals = false;
	        if (px != null) {
	            equals = ((this.x == px.x && this.y == px.y) ||
	                      (isNaN(this.x) && isNaN(this.y) && isNaN(px.x) && isNaN(px.y)));
	        }
	        return equals;
	    },

	    /**
	     * APIMethod: distanceTo
	     * Returns the distance to the pixel point passed in as a parameter.
	     *
	     * Parameters:
	     * px - {<OpenLayers.Pixel>}
	     *
	     * Returns:
	     * {Float} The pixel point passed in as parameter to calculate the
	     *     distance to.
	     */
	    distanceTo:function(px) {
	        return Math.sqrt(
	            Math.pow(this.x - px.x, 2) +
	            Math.pow(this.y - px.y, 2)
	        );
	    },

	    /**
	     * APIMethod: add
	     *
	     * Parameters:
	     * x - {Integer}
	     * y - {Integer}
	     *
	     * Returns:
	     * {<OpenLayers.Pixel>} A new Pixel with this pixel's x&y augmented by the 
	     * values passed in.
	     */
	    add:function(x, y) {
	        if ( (x == null) || (y == null) ) {
	            throw new TypeError('Pixel.add cannot receive null values');
	        }
	        return new OpenLayers.Pixel(this.x + x, this.y + y);
	    },

	    /**
	    * APIMethod: offset
	    * 
	    * Parameters
	    * px - {<OpenLayers.Pixel>|Object} An OpenLayers.Pixel or an object with
	    *                                  a 'x' and 'y' properties.
	    * 
	    * Returns:
	    * {<OpenLayers.Pixel>} A new Pixel with this pixel's x&y augmented by the 
	    *                      x&y values of the pixel passed in.
	    */
	    offset:function(px) {
	        var newPx = this.clone();
	        if (px) {
	            newPx = this.add(px.x, px.y);
	        }
	        return newPx;
	    },

	    CLASS_NAME: "OpenLayers.Pixel"
	});
	/* ======================================================================
	    OpenLayers/BaseTypes/Size.js
	   ====================================================================== */

	/* Copyright (c) 2006-2015 by OpenLayers Contributors (see authors.txt for
	 * full list of contributors). Published under the 2-clause BSD license.
	 * See license.txt in the OpenLayers distribution or repository for the
	 * full text of the license. */

	/**
	 * @requires OpenLayers/BaseTypes/Class.js
	 */

	/**
	 * Class: OpenLayers.Size
	 * Instances of this class represent a width/height pair
	 */
	OpenLayers.Size = OpenLayers.Class({

	    /**
	     * APIProperty: w
	     * {Number} width
	     */
	    w: 0.0,
	    
	    /**
	     * APIProperty: h
	     * {Number} height
	     */
	    h: 0.0,


	    /**
	     * Constructor: OpenLayers.Size
	     * Create an instance of OpenLayers.Size
	     *
	     * Parameters:
	     * w - {Number} width
	     * h - {Number} height
	     */
	    initialize: function(w, h) {
	        this.w = parseFloat(w);
	        this.h = parseFloat(h);
	    },

	    /**
	     * Method: toString
	     * Return the string representation of a size object
	     *
	     * Returns:
	     * {String} The string representation of OpenLayers.Size object. 
	     * (e.g. <i>"w=55,h=66"</i>)
	     */
	    toString:function() {
	        return ("w=" + this.w + ",h=" + this.h);
	    },

	    /**
	     * APIMethod: clone
	     * Create a clone of this size object
	     *
	     * Returns:
	     * {<OpenLayers.Size>} A new OpenLayers.Size object with the same w and h
	     * values
	     */
	    clone:function() {
	        return new OpenLayers.Size(this.w, this.h);
	    },

	    /**
	     *
	     * APIMethod: equals
	     * Determine where this size is equal to another
	     *
	     * Parameters:
	     * sz - {<OpenLayers.Size>|Object} An OpenLayers.Size or an object with
	     *                                  a 'w' and 'h' properties.
	     *
	     * Returns: 
	     * {Boolean} The passed in size has the same h and w properties as this one.
	     * Note that if sz passed in is null, returns false.
	     */
	    equals:function(sz) {
	        var equals = false;
	        if (sz != null) {
	            equals = ((this.w == sz.w && this.h == sz.h) ||
	                      (isNaN(this.w) && isNaN(this.h) && isNaN(sz.w) && isNaN(sz.h)));
	        }
	        return equals;
	    },

	    CLASS_NAME: "OpenLayers.Size"
	});
	/* ======================================================================
	    OpenLayers/Console.js
	   ====================================================================== */

	/* Copyright (c) 2006-2015 by OpenLayers Contributors (see authors.txt for
	 * full list of contributors). Published under the 2-clause BSD license.
	 * See license.txt in the OpenLayers distribution or repository for the
	 * full text of the license. */

	/**
	 * @requires OpenLayers/BaseTypes/Class.js
	 */

	/**
	 * Namespace: OpenLayers.Console
	 * The OpenLayers.Console namespace is used for debugging and error logging.
	 * If the Firebug Lite (../Firebug/firebug.js) is included before this script,
	 * calls to OpenLayers.Console methods will get redirected to window.console.
	 * This makes use of the Firebug extension where available and allows for
	 * cross-browser debugging Firebug style.
	 *
	 * Note:
	 * Note that behavior will differ with the Firebug extension and Firebug Lite.
	 * Most notably, the Firebug Lite console does not currently allow for
	 * hyperlinks to code or for clicking on object to explore their properties.
	 * 
	 */
	OpenLayers.Console = {
	    /**
	     * Create empty functions for all console methods.  The real value of these
	     * properties will be set if Firebug Lite (../Firebug/firebug.js script) is
	     * included.  We explicitly require the Firebug Lite script to trigger
	     * functionality of the OpenLayers.Console methods.
	     */
	    
	    /**
	     * APIFunction: log
	     * Log an object in the console.  The Firebug Lite console logs string
	     * representation of objects.  Given multiple arguments, they will
	     * be cast to strings and logged with a space delimiter.  If the first
	     * argument is a string with printf-like formatting, subsequent arguments
	     * will be used in string substitution.  Any additional arguments (beyond
	     * the number substituted in a format string) will be appended in a space-
	     * delimited line.
	     * 
	     * Parameters:
	     * object - {Object}
	     */
	    log: function() {},

	    /**
	     * APIFunction: debug
	     * Writes a message to the console, including a hyperlink to the line
	     * where it was called.
	     *
	     * May be called with multiple arguments as with OpenLayers.Console.log().
	     * 
	     * Parameters:
	     * object - {Object}
	     */
	    debug: function() {},

	    /**
	     * APIFunction: info
	     * Writes a message to the console with the visual "info" icon and color
	     * coding and a hyperlink to the line where it was called.
	     *
	     * May be called with multiple arguments as with OpenLayers.Console.log().
	     * 
	     * Parameters:
	     * object - {Object}
	     */
	    info: function() {},

	    /**
	     * APIFunction: warn
	     * Writes a message to the console with the visual "warning" icon and
	     * color coding and a hyperlink to the line where it was called.
	     *
	     * May be called with multiple arguments as with OpenLayers.Console.log().
	     * 
	     * Parameters:
	     * object - {Object}
	     */
	    warn: function() {},

	    /**
	     * APIFunction: error
	     * Writes a message to the console with the visual "error" icon and color
	     * coding and a hyperlink to the line where it was called.
	     *
	     * May be called with multiple arguments as with OpenLayers.Console.log().
	     * 
	     * Parameters:
	     * object - {Object}
	     */
	    error: function() {},
	    
	    /**
	     * APIFunction: userError
	     * A single interface for showing error messages to the user. The default
	     * behavior is a Javascript alert, though this can be overridden by
	     * reassigning OpenLayers.Console.userError to a different function.
	     *
	     * Expects a single error message
	     * 
	     * Parameters:
	     * error - {Object}
	     */
	    userError: function(error) {
	        alert(error);
	    },

	    /**
	     * APIFunction: assert
	     * Tests that an expression is true. If not, it will write a message to
	     * the console and throw an exception.
	     *
	     * May be called with multiple arguments as with OpenLayers.Console.log().
	     * 
	     * Parameters:
	     * object - {Object}
	     */
	    assert: function() {},

	    /**
	     * APIFunction: dir
	     * Prints an interactive listing of all properties of the object. This
	     * looks identical to the view that you would see in the DOM tab.
	     * 
	     * Parameters:
	     * object - {Object}
	     */
	    dir: function() {},

	    /**
	     * APIFunction: dirxml
	     * Prints the XML source tree of an HTML or XML element. This looks
	     * identical to the view that you would see in the HTML tab. You can click
	     * on any node to inspect it in the HTML tab.
	     * 
	     * Parameters:
	     * object - {Object}
	     */
	    dirxml: function() {},

	    /**
	     * APIFunction: trace
	     * Prints an interactive stack trace of JavaScript execution at the point
	     * where it is called.  The stack trace details the functions on the stack,
	     * as well as the values that were passed as arguments to each function.
	     * You can click each function to take you to its source in the Script tab,
	     * and click each argument value to inspect it in the DOM or HTML tabs.
	     * 
	     */
	    trace: function() {},

	    /**
	     * APIFunction: group
	     * Writes a message to the console and opens a nested block to indent all
	     * future messages sent to the console. Call OpenLayers.Console.groupEnd()
	     * to close the block.
	     *
	     * May be called with multiple arguments as with OpenLayers.Console.log().
	     * 
	     * Parameters:
	     * object - {Object}
	     */
	    group: function() {},

	    /**
	     * APIFunction: groupEnd
	     * Closes the most recently opened block created by a call to
	     * OpenLayers.Console.group
	     */
	    groupEnd: function() {},
	    
	    /**
	     * APIFunction: time
	     * Creates a new timer under the given name. Call
	     * OpenLayers.Console.timeEnd(name)
	     * with the same name to stop the timer and print the time elapsed.
	     *
	     * Parameters:
	     * name - {String}
	     */
	    time: function() {},

	    /**
	     * APIFunction: timeEnd
	     * Stops a timer created by a call to OpenLayers.Console.time(name) and
	     * writes the time elapsed.
	     *
	     * Parameters:
	     * name - {String}
	     */
	    timeEnd: function() {},

	    /**
	     * APIFunction: profile
	     * Turns on the JavaScript profiler. The optional argument title would
	     * contain the text to be printed in the header of the profile report.
	     *
	     * This function is not currently implemented in Firebug Lite.
	     * 
	     * Parameters:
	     * title - {String} Optional title for the profiler
	     */
	    profile: function() {},

	    /**
	     * APIFunction: profileEnd
	     * Turns off the JavaScript profiler and prints its report.
	     * 
	     * This function is not currently implemented in Firebug Lite.
	     */
	    profileEnd: function() {},

	    /**
	     * APIFunction: count
	     * Writes the number of times that the line of code where count was called
	     * was executed. The optional argument title will print a message in
	     * addition to the number of the count.
	     *
	     * This function is not currently implemented in Firebug Lite.
	     *
	     * Parameters:
	     * title - {String} Optional title to be printed with count
	     */
	    count: function() {},

	    CLASS_NAME: "OpenLayers.Console"
	};

	/**
	 * Execute an anonymous function to extend the OpenLayers.Console namespace
	 * if the firebug.js script is included.  This closure is used so that the
	 * "scripts" and "i" variables don't pollute the global namespace.
	 */
	(function() {
	    /**
	     * If Firebug Lite is included (before this script), re-route all
	     * OpenLayers.Console calls to the console object.
	     */
	    var scripts = document.getElementsByTagName("script");
	    for(var i=0, len=scripts.length; i<len; ++i) {
	        if(scripts[i].src.indexOf("firebug.js") != -1) {
	            if(console) {
	                OpenLayers.Util.extend(OpenLayers.Console, console);
	                break;
	            }
	        }
	    }
	})();
	/* ======================================================================
	    OpenLayers/Lang.js
	   ====================================================================== */

	/* Copyright (c) 2006-2015 by OpenLayers Contributors (see authors.txt for
	 * full list of contributors). Published under the 2-clause BSD license.
	 * See license.txt in the OpenLayers distribution or repository for the
	 * full text of the license. */

	/**
	 * @requires OpenLayers/BaseTypes.js
	 * @requires OpenLayers/Console.js
	 */

	/**
	 * Namespace: OpenLayers.Lang
	 * Internationalization namespace.  Contains dictionaries in various languages
	 *     and methods to set and get the current language.
	 */
	OpenLayers.Lang = {
	    
	    /** 
	     * Property: code
	     * {String}  Current language code to use in OpenLayers.  Use the
	     *     <setCode> method to set this value and the <getCode> method to
	     *     retrieve it.
	     */
	    code: null,

	    /** 
	     * APIProperty: defaultCode
	     * {String} Default language to use when a specific language can't be
	     *     found.  Default is "en".
	     */
	    defaultCode: "en",
	        
	    /**
	     * APIFunction: getCode
	     * Get the current language code.
	     *
	     * Returns:
	     * {String} The current language code.
	     */
	    getCode: function() {
	        if(!OpenLayers.Lang.code) {
	            OpenLayers.Lang.setCode();
	        }
	        return OpenLayers.Lang.code;
	    },
	    
	    /**
	     * APIFunction: setCode
	     * Set the language code for string translation.  This code is used by
	     *     the <OpenLayers.Lang.translate> method.
	     *
	     * Parameters:
	     * code - {String} These codes follow the IETF recommendations at
	     *     http://www.ietf.org/rfc/rfc3066.txt.  If no value is set, the
	     *     browser's language setting will be tested.  If no <OpenLayers.Lang>
	     *     dictionary exists for the code, the <OpenLayers.String.defaultLang>
	     *     will be used.
	     */
	    setCode: function(code) {
	        var lang;
	        if(!code) {
	            code = (OpenLayers.BROWSER_NAME == "msie") ?
	                navigator.userLanguage : navigator.language;
	        }
	        var parts = code.split('-');
	        parts[0] = parts[0].toLowerCase();
	        if(typeof OpenLayers.Lang[parts[0]] == "object") {
	            lang = parts[0];
	        }

	        // check for regional extensions
	        if(parts[1]) {
	            var testLang = parts[0] + '-' + parts[1].toUpperCase();
	            if(typeof OpenLayers.Lang[testLang] == "object") {
	                lang = testLang;
	            }
	        }
	        if(!lang) {
	            OpenLayers.Console.warn(
	                'Failed to find OpenLayers.Lang.' + parts.join("-") +
	                ' dictionary, falling back to default language'
	            );
	            lang = OpenLayers.Lang.defaultCode;
	        }
	        
	        OpenLayers.Lang.code = lang;
	    },

	    /**
	     * APIMethod: translate
	     * Looks up a key from a dictionary based on the current language string.
	     *     The value of <getCode> will be used to determine the appropriate
	     *     dictionary.  Dictionaries are stored in <OpenLayers.Lang>.
	     *
	     * Parameters:
	     * key - {String} The key for an i18n string value in the dictionary.
	     * context - {Object} Optional context to be used with
	     *     <OpenLayers.String.format>.
	     * 
	     * Returns:
	     * {String} A internationalized string.
	     */
	    translate: function(key, context) {
	        var dictionary = OpenLayers.Lang[OpenLayers.Lang.getCode()];
	        var message = dictionary && dictionary[key];
	        if(!message) {
	            // Message not found, fall back to message key
	            message = key;
	        }
	        if(context) {
	            message = OpenLayers.String.format(message, context);
	        }
	        return message;
	    }
	    
	};


	/**
	 * APIMethod: OpenLayers.i18n
	 * Alias for <OpenLayers.Lang.translate>.  Looks up a key from a dictionary
	 *     based on the current language string. The value of
	 *     <OpenLayers.Lang.getCode> will be used to determine the appropriate
	 *     dictionary.  Dictionaries are stored in <OpenLayers.Lang>.
	 *
	 * Parameters:
	 * key - {String} The key for an i18n string value in the dictionary.
	 * context - {Object} Optional context to be used with
	 *     <OpenLayers.String.format>.
	 * 
	 * Returns:
	 * {String} A internationalized string.
	 */
	OpenLayers.i18n = OpenLayers.Lang.translate;
	/* ======================================================================
	    OpenLayers/Util.js
	   ====================================================================== */

	/* Copyright (c) 2006-2015 by OpenLayers Contributors (see authors.txt for
	 * full list of contributors). Published under the 2-clause BSD license.
	 * See license.txt in the OpenLayers distribution or repository for the
	 * full text of the license. */

	/**
	 * @requires OpenLayers/BaseTypes.js
	 * @requires OpenLayers/BaseTypes/Bounds.js
	 * @requires OpenLayers/BaseTypes/Element.js
	 * @requires OpenLayers/BaseTypes/LonLat.js
	 * @requires OpenLayers/BaseTypes/Pixel.js
	 * @requires OpenLayers/BaseTypes/Size.js
	 * @requires OpenLayers/Lang.js
	 */

	/**
	 * Namespace: Util
	 */
	OpenLayers.Util = OpenLayers.Util || {};

	/** 
	 * Function: getElement
	 * This is the old $() from prototype
	 *
	 * Parameters:
	 * e - {String or DOMElement or Window}
	 *
	 * Returns:
	 * {Array(DOMElement) or DOMElement}
	 */
	OpenLayers.Util.getElement = function() {
	    var elements = [];

	    for (var i=0, len=arguments.length; i<len; i++) {
	        var element = arguments[i];
	        if (typeof element == 'string') {
	            element = document.getElementById(element);
	        }
	        if (arguments.length == 1) {
	            return element;
	        }
	        elements.push(element);
	    }
	    return elements;
	};

	/**
	 * Function: isElement
	 * A cross-browser implementation of "e instanceof Element".
	 *
	 * Parameters:
	 * o - {Object} The object to test.
	 *
	 * Returns:
	 * {Boolean}
	 */
	OpenLayers.Util.isElement = function(o) {
	    return !!(o && o.nodeType === 1);
	};

	/**
	 * Function: isArray
	 * Tests that the provided object is an array.
	 * This test handles the cross-IFRAME case not caught
	 * by "a instanceof Array" and should be used instead.
	 * 
	 * Parameters:
	 * a - {Object} the object test.
	 * 
	 * Returns:
	 * {Boolean} true if the object is an array.
	 */
	OpenLayers.Util.isArray = function(a) {
	    return (Object.prototype.toString.call(a) === '[object Array]');
	};

	/** 
	 * Function: removeItem
	 * Remove an object from an array. Iterates through the array
	 *     to find the item, then removes it.
	 *
	 * Parameters:
	 * array - {Array}
	 * item - {Object}
	 * 
	 * Returns:
	 * {Array} A reference to the array
	 */
	OpenLayers.Util.removeItem = function(array, item) {
	    for(var i = array.length - 1; i >= 0; i--) {
	        if(array[i] == item) {
	            array.splice(i,1);
	            //break;more than once??
	        }
	    }
	    return array;
	};

	/** 
	 * Function: indexOf
	 * Seems to exist already in FF, but not in MOZ.
	 * 
	 * Parameters:
	 * array - {Array}
	 * obj - {*}
	 * 
	 * Returns:
	 * {Integer} The index at which the first object was found in the array.
	 *           If not found, returns -1.
	 */
	OpenLayers.Util.indexOf = function(array, obj) {
	    // use the build-in function if available.
	    if (typeof array.indexOf == "function") {
	        return array.indexOf(obj);
	    } else {
	        for (var i = 0, len = array.length; i < len; i++) {
	            if (array[i] == obj) {
	                return i;
	            }
	        }
	        return -1;   
	    }
	};


	/**
	 * Property: dotless
	 * {RegExp}
	 * Compiled regular expression to match dots (".").  This is used for replacing
	 *     dots in identifiers.  Because object identifiers are frequently used for
	 *     DOM element identifiers by the library, we avoid using dots to make for
	 *     more sensible CSS selectors.
	 *
	 * TODO: Use a module pattern to avoid bloating the API with stuff like this.
	 */
	OpenLayers.Util.dotless = /\./g;

	/**
	 * Function: modifyDOMElement
	 * 
	 * Modifies many properties of a DOM element all at once.  Passing in 
	 * null to an individual parameter will avoid setting the attribute.
	 *
	 * Parameters:
	 * element - {DOMElement} DOM element to modify.
	 * id - {String} The element id attribute to set.  Note that dots (".") will be
	 *     replaced with underscore ("_") in setting the element id.
	 * px - {<OpenLayers.Pixel>|Object} The element left and top position,
	 *                                  OpenLayers.Pixel or an object with
	 *                                  a 'x' and 'y' properties.
	 * sz - {<OpenLayers.Size>|Object} The element width and height,
	 *                                 OpenLayers.Size or an object with a
	 *                                 'w' and 'h' properties.
	 * position - {String}       The position attribute.  eg: absolute, 
	 *                           relative, etc.
	 * border - {String}         The style.border attribute.  eg:
	 *                           solid black 2px
	 * overflow - {String}       The style.overview attribute.  
	 * opacity - {Float}         Fractional value (0.0 - 1.0)
	 */
	OpenLayers.Util.modifyDOMElement = function(element, id, px, sz, position, 
	                                            border, overflow, opacity) {

	    if (id) {
	        element.id = id.replace(OpenLayers.Util.dotless, "_");
	    }
	    if (px) {
	        element.style.left = px.x + "px";
	        element.style.top = px.y + "px";
	    }
	    if (sz) {
	        element.style.width = sz.w + "px";
	        element.style.height = sz.h + "px";
	    }
	    if (position) {
	        element.style.position = position;
	    }
	    if (border) {
	        element.style.border = border;
	    }
	    if (overflow) {
	        element.style.overflow = overflow;
	    }
	    if (parseFloat(opacity) >= 0.0 && parseFloat(opacity) < 1.0) {
	        element.style.filter = 'alpha(opacity=' + (opacity * 100) + ')';
	        element.style.opacity = opacity;
	    } else if (parseFloat(opacity) == 1.0) {
	        element.style.filter = '';
	        element.style.opacity = '';
	    }
	};

	/** 
	 * Function: createDiv
	 * Creates a new div and optionally set some standard attributes.
	 * Null may be passed to each parameter if you do not wish to
	 * set a particular attribute.
	 * Note - zIndex is NOT set on the resulting div.
	 * 
	 * Parameters:
	 * id - {String} An identifier for this element.  If no id is
	 *               passed an identifier will be created 
	 *               automatically.  Note that dots (".") will be replaced with
	 *               underscore ("_") when generating ids.
	 * px - {<OpenLayers.Pixel>|Object} The element left and top position,
	 *                                  OpenLayers.Pixel or an object with
	 *                                  a 'x' and 'y' properties.
	 * sz - {<OpenLayers.Size>|Object} The element width and height,
	 *                                 OpenLayers.Size or an object with a
	 *                                 'w' and 'h' properties.
	 * imgURL - {String} A url pointing to an image to use as a 
	 *                   background image.
	 * position - {String} The style.position value. eg: absolute,
	 *                     relative etc.
	 * border - {String} The the style.border value. 
	 *                   eg: 2px solid black
	 * overflow - {String} The style.overflow value. Eg. hidden
	 * opacity - {Float} Fractional value (0.0 - 1.0)
	 * 
	 * Returns: 
	 * {DOMElement} A DOM Div created with the specified attributes.
	 */
	OpenLayers.Util.createDiv = function(id, px, sz, imgURL, position, 
	                                     border, overflow, opacity) {

	    var dom = document.createElement('div');

	    if (imgURL) {
	        dom.style.backgroundImage = 'url(' + imgURL + ')';
	    }

	    //set generic properties
	    if (!id) {
	        id = OpenLayers.Util.createUniqueID("OpenLayersDiv");
	    }
	    if (!position) {
	        position = "absolute";
	    }
	    OpenLayers.Util.modifyDOMElement(dom, id, px, sz, position, 
	                                     border, overflow, opacity);

	    return dom;
	};

	/**
	 * Function: createImage
	 * Creates an img element with specific attribute values.
	 *  
	 * Parameters:
	 * id - {String} The id field for the img.  If none assigned one will be
	 *               automatically generated.
	 * px - {<OpenLayers.Pixel>|Object} The element left and top position,
	 *                                  OpenLayers.Pixel or an object with
	 *                                  a 'x' and 'y' properties.
	 * sz - {<OpenLayers.Size>|Object} The element width and height,
	 *                                 OpenLayers.Size or an object with a
	 *                                 'w' and 'h' properties.
	 * imgURL - {String} The url to use as the image source.
	 * position - {String} The style.position value.
	 * border - {String} The border to place around the image.
	 * opacity - {Float} Fractional value (0.0 - 1.0)
	 * delayDisplay - {Boolean} If true waits until the image has been
	 *                          loaded.
	 * 
	 * Returns:
	 * {DOMElement} A DOM Image created with the specified attributes.
	 */
	OpenLayers.Util.createImage = function(id, px, sz, imgURL, position, border,
	                                       opacity, delayDisplay) {

	    var image = document.createElement("img");

	    //set generic properties
	    if (!id) {
	        id = OpenLayers.Util.createUniqueID("OpenLayersDiv");
	    }
	    if (!position) {
	        position = "relative";
	    }
	    OpenLayers.Util.modifyDOMElement(image, id, px, sz, position, 
	                                     border, null, opacity);

	    if (delayDisplay) {
	        image.style.display = "none";
	        function display() {
	            image.style.display = "";
	            OpenLayers.Event.stopObservingElement(image);
	        }
	        OpenLayers.Event.observe(image, "load", display);
	        OpenLayers.Event.observe(image, "error", display);
	    }
	    
	    //set special properties
	    image.style.alt = id;
	    image.galleryImg = "no";
	    if (imgURL) {
	        image.src = imgURL;
	    }
	        
	    return image;
	};

	/**
	 * Property: IMAGE_RELOAD_ATTEMPTS
	 * {Integer} How many times should we try to reload an image before giving up?
	 *           Default is 0
	 */
	OpenLayers.IMAGE_RELOAD_ATTEMPTS = 0;

	/**
	 * Property: alphaHackNeeded
	 * {Boolean} true if the png alpha hack is necessary and possible, false otherwise.
	 */
	OpenLayers.Util.alphaHackNeeded = null;

	/**
	 * Function: alphaHack
	 * Checks whether it's necessary (and possible) to use the png alpha
	 * hack which allows alpha transparency for png images under Internet
	 * Explorer.
	 * 
	 * Returns:
	 * {Boolean} true if the png alpha hack is necessary and possible, false otherwise.
	 */
	OpenLayers.Util.alphaHack = function() {
	    if (OpenLayers.Util.alphaHackNeeded == null) {
	        var arVersion = navigator.appVersion.split("MSIE");
	        var version = parseFloat(arVersion[1]);
	        var filter = false;
	    
	        // IEs4Lin dies when trying to access document.body.filters, because 
	        // the property is there, but requires a DLL that can't be provided. This
	        // means that we need to wrap this in a try/catch so that this can
	        // continue.
	    
	        try { 
	            filter = !!(document.body.filters);
	        } catch (e) {}    
	    
	        OpenLayers.Util.alphaHackNeeded = (filter && 
	                                           (version >= 5.5) && (version < 7));
	    }
	    return OpenLayers.Util.alphaHackNeeded;
	};

	/** 
	 * Function: modifyAlphaImageDiv
	 * 
	 * Parameters:
	 * div - {DOMElement} Div containing Alpha-adjusted Image
	 * id - {String}
	 * px - {<OpenLayers.Pixel>|Object} OpenLayers.Pixel or an object with
	 *                                  a 'x' and 'y' properties.
	 * sz - {<OpenLayers.Size>|Object} OpenLayers.Size or an object with
	 *                                 a 'w' and 'h' properties.
	 * imgURL - {String}
	 * position - {String}
	 * border - {String}
	 * sizing - {String} 'crop', 'scale', or 'image'. Default is "scale"
	 * opacity - {Float} Fractional value (0.0 - 1.0)
	 */ 
	OpenLayers.Util.modifyAlphaImageDiv = function(div, id, px, sz, imgURL, 
	                                               position, border, sizing, 
	                                               opacity) {

	    OpenLayers.Util.modifyDOMElement(div, id, px, sz, position,
	                                     null, null, opacity);

	    var img = div.childNodes[0];

	    if (imgURL) {
	        img.src = imgURL;
	    }
	    OpenLayers.Util.modifyDOMElement(img, div.id + "_innerImage", null, sz, 
	                                     "relative", border);
	    
	    if (OpenLayers.Util.alphaHack()) {
	        if(div.style.display != "none") {
	            div.style.display = "inline-block";
	        }
	        if (sizing == null) {
	            sizing = "scale";
	        }
	        
	        div.style.filter = "progid:DXImageTransform.Microsoft" +
	                           ".AlphaImageLoader(src='" + img.src + "', " +
	                           "sizingMethod='" + sizing + "')";
	        if (parseFloat(div.style.opacity) >= 0.0 && 
	            parseFloat(div.style.opacity) < 1.0) {
	            div.style.filter += " alpha(opacity=" + div.style.opacity * 100 + ")";
	        }

	        img.style.filter = "alpha(opacity=0)";
	    }
	};

	/** 
	 * Function: createAlphaImageDiv
	 * 
	 * Parameters:
	 * id - {String}
	 * px - {<OpenLayers.Pixel>|Object} OpenLayers.Pixel or an object with
	 *                                  a 'x' and 'y' properties.
	 * sz - {<OpenLayers.Size>|Object} OpenLayers.Size or an object with
	 *                                 a 'w' and 'h' properties.
	 * imgURL - {String}
	 * position - {String}
	 * border - {String}
	 * sizing - {String} 'crop', 'scale', or 'image'. Default is "scale"
	 * opacity - {Float} Fractional value (0.0 - 1.0)
	 * delayDisplay - {Boolean} If true waits until the image has been
	 *                          loaded.
	 * 
	 * Returns:
	 * {DOMElement} A DOM Div created with a DOM Image inside it. If the hack is 
	 *              needed for transparency in IE, it is added.
	 */ 
	OpenLayers.Util.createAlphaImageDiv = function(id, px, sz, imgURL, 
	                                               position, border, sizing, 
	                                               opacity, delayDisplay) {
	    
	    var div = OpenLayers.Util.createDiv();
	    var img = OpenLayers.Util.createImage(null, null, null, null, null, null, 
	                                          null, delayDisplay);
	    img.className = "olAlphaImg";
	    div.appendChild(img);

	    OpenLayers.Util.modifyAlphaImageDiv(div, id, px, sz, imgURL, position, 
	                                        border, sizing, opacity);
	    
	    return div;
	};


	/** 
	 * Function: upperCaseObject
	 * Creates a new hashtable and copies over all the keys from the 
	 *     passed-in object, but storing them under an uppercased
	 *     version of the key at which they were stored.
	 * 
	 * Parameters: 
	 * object - {Object}
	 * 
	 * Returns: 
	 * {Object} A new Object with all the same keys but uppercased
	 */
	OpenLayers.Util.upperCaseObject = function (object) {
	    var uObject = {};
	    for (var key in object) {
	        uObject[key.toUpperCase()] = object[key];
	    }
	    return uObject;
	};

	/** 
	 * Function: applyDefaults
	 * Takes an object and copies any properties that don't exist from
	 *     another properties, by analogy with OpenLayers.Util.extend() from
	 *     Prototype.js.
	 * 
	 * Parameters:
	 * to - {Object} The destination object.
	 * from - {Object} The source object.  Any properties of this object that
	 *     are undefined in the to object will be set on the to object.
	 *
	 * Returns:
	 * {Object} A reference to the to object.  Note that the to argument is modified
	 *     in place and returned by this function.
	 */
	OpenLayers.Util.applyDefaults = function (to, from) {
	    to = to || {};
	    /*
	     * FF/Windows < 2.0.0.13 reports "Illegal operation on WrappedNative
	     * prototype object" when calling hawOwnProperty if the source object is an
	     * instance of window.Event.
	     */
	    var fromIsEvt = typeof window.Event == "function"
	                    && from instanceof window.Event;

	    for (var key in from) {
	        if (to[key] === undefined ||
	            (!fromIsEvt && from.hasOwnProperty
	             && from.hasOwnProperty(key) && !to.hasOwnProperty(key))) {
	            to[key] = from[key];
	        }
	    }
	    /**
	     * IE doesn't include the toString property when iterating over an object's
	     * properties with the for(property in object) syntax.  Explicitly check if
	     * the source has its own toString property.
	     */
	    if(!fromIsEvt && from && from.hasOwnProperty
	       && from.hasOwnProperty('toString') && !to.hasOwnProperty('toString')) {
	        to.toString = from.toString;
	    }
	    
	    return to;
	};

	/**
	 * Function: getParameterString
	 * 
	 * Parameters:
	 * params - {Object}
	 * 
	 * Returns:
	 * {String} A concatenation of the properties of an object in 
	 *          http parameter notation. 
	 *          (ex. <i>"key1=value1&key2=value2&key3=value3"</i>)
	 *          If a parameter is actually a list, that parameter will then
	 *          be set to a comma-seperated list of values (foo,bar) instead
	 *          of being URL escaped (foo%3Abar). 
	 */
	OpenLayers.Util.getParameterString = function(params) {
	    var paramsArray = [];
	    
	    for (var key in params) {
	      var value = params[key];
	      if ((value != null) && (typeof value != 'function')) {
	        var encodedValue;
	        if (typeof value == 'object' && value.constructor == Array) {
	          /* value is an array; encode items and separate with "," */
	          var encodedItemArray = [];
	          var item;
	          for (var itemIndex=0, len=value.length; itemIndex<len; itemIndex++) {
	            item = value[itemIndex];
	            encodedItemArray.push(encodeURIComponent(
	                (item === null || item === undefined) ? "" : item)
	            );
	          }
	          encodedValue = encodedItemArray.join(",");
	        }
	        else {
	          /* value is a string; simply encode */
	          encodedValue = encodeURIComponent(value);
	        }
	        paramsArray.push(encodeURIComponent(key) + "=" + encodedValue);
	      }
	    }
	    
	    return paramsArray.join("&");
	};

	/**
	 * Function: urlAppend
	 * Appends a parameter string to a url. This function includes the logic for
	 * using the appropriate character (none, & or ?) to append to the url before
	 * appending the param string.
	 * 
	 * Parameters:
	 * url - {String} The url to append to
	 * paramStr - {String} The param string to append
	 * 
	 * Returns:
	 * {String} The new url
	 */
	OpenLayers.Util.urlAppend = function(url, paramStr) {
	    var newUrl = url;
	    if(paramStr) {
	        var parts = (url + " ").split(/[?&]/);
	        newUrl += (parts.pop() === " " ?
	            paramStr :
	            parts.length ? "&" + paramStr : "?" + paramStr);
	    }
	    return newUrl;
	};

	/** 
	 * Function: getImagesLocation
	 * 
	 * Returns:
	 * {String} The fully formatted image location string
	 */
	OpenLayers.Util.getImagesLocation = function() {
	    return OpenLayers.ImgPath || (OpenLayers._getScriptLocation() + "img/");
	};

	/** 
	 * Function: getImageLocation
	 * 
	 * Returns:
	 * {String} The fully formatted location string for a specified image
	 */
	OpenLayers.Util.getImageLocation = function(image) {
	    return OpenLayers.Util.getImagesLocation() + image;
	};


	/** 
	 * Function: Try
	 * Execute functions until one of them doesn't throw an error. 
	 *     Capitalized because "try" is a reserved word in JavaScript.
	 *     Taken directly from OpenLayers.Util.Try()
	 * 
	 * Parameters:
	 * [*] - {Function} Any number of parameters may be passed to Try()
	 *    It will attempt to execute each of them until one of them 
	 *    successfully executes. 
	 *    If none executes successfully, returns null.
	 * 
	 * Returns:
	 * {*} The value returned by the first successfully executed function.
	 */
	OpenLayers.Util.Try = function() {
	    var returnValue = null;

	    for (var i=0, len=arguments.length; i<len; i++) {
	      var lambda = arguments[i];
	      try {
	        returnValue = lambda();
	        break;
	      } catch (e) {}
	    }

	    return returnValue;
	};

	/**
	 * Function: getXmlNodeValue
	 * 
	 * Parameters:
	 * node - {XMLNode}
	 * 
	 * Returns:
	 * {String} The text value of the given node, without breaking in firefox or IE
	 */
	OpenLayers.Util.getXmlNodeValue = function(node) {
	    var val = null;
	    OpenLayers.Util.Try( 
	        function() {
	            val = node.text;
	            if (!val) {
	                val = node.textContent;
	            }
	            if (!val) {
	                val = node.firstChild.nodeValue;
	            }
	        }, 
	        function() {
	            val = node.textContent;
	        }); 
	    return val;
	};

	/** 
	 * Function: mouseLeft
	 * 
	 * Parameters:
	 * evt - {Event}
	 * div - {HTMLDivElement}
	 * 
	 * Returns:
	 * {Boolean}
	 */
	OpenLayers.Util.mouseLeft = function (evt, div) {
	    // start with the element to which the mouse has moved
	    var target = (evt.relatedTarget) ? evt.relatedTarget : evt.toElement;
	    // walk up the DOM tree.
	    while (target != div && target != null) {
	        target = target.parentNode;
	    }
	    // if the target we stop at isn't the div, then we've left the div.
	    return (target != div);
	};

	/**
	 * Property: precision
	 * {Number} The number of significant digits to retain to avoid
	 * floating point precision errors.
	 *
	 * We use 14 as a "safe" default because, although IEEE 754 double floats
	 * (standard on most modern operating systems) support up to about 16
	 * significant digits, 14 significant digits are sufficient to represent
	 * sub-millimeter accuracy in any coordinate system that anyone is likely to
	 * use with OpenLayers.
	 *
	 * If DEFAULT_PRECISION is set to 0, the original non-truncating behavior
	 * of OpenLayers <2.8 is preserved. Be aware that this will cause problems
	 * with certain projections, e.g. spherical Mercator.
	 *
	 */
	OpenLayers.Util.DEFAULT_PRECISION = 14;

	/**
	 * Function: toFloat
	 * Convenience method to cast an object to a Number, rounded to the
	 * desired floating point precision.
	 *
	 * Parameters:
	 * number    - {Number} The number to cast and round.
	 * precision - {Number} An integer suitable for use with
	 *      Number.toPrecision(). Defaults to OpenLayers.Util.DEFAULT_PRECISION.
	 *      If set to 0, no rounding is performed.
	 *
	 * Returns:
	 * {Number} The cast, rounded number.
	 */
	OpenLayers.Util.toFloat = function (number, precision) {
	    if (precision == null) {
	        precision = OpenLayers.Util.DEFAULT_PRECISION;
	    }
	    if (typeof number !== "number") {
	        number = parseFloat(number);
	    }
	    return precision === 0 ? number :
	                             parseFloat(number.toPrecision(precision));
	};

	/**
	 * Function: rad
	 * 
	 * Parameters:
	 * x - {Float}
	 * 
	 * Returns:
	 * {Float}
	 */
	OpenLayers.Util.rad = function(x) {return x*Math.PI/180;};

	/**
	 * Function: deg
	 *
	 * Parameters:
	 * x - {Float}
	 *
	 * Returns:
	 * {Float}
	 */
	OpenLayers.Util.deg = function(x) {return x*180/Math.PI;};

	/**
	 * Property: VincentyConstants
	 * {Object} Constants for Vincenty functions.
	 */
	OpenLayers.Util.VincentyConstants = {
	    a: 6378137,
	    b: 6356752.3142,
	    f: 1/298.257223563
	};

	/**
	 * APIFunction: distVincenty
	 * Given two objects representing points with geographic coordinates, this
	 *     calculates the distance between those points on the surface of an
	 *     ellipsoid.
	 *
	 * Parameters:
	 * p1 - {<OpenLayers.LonLat>} (or any object with both .lat, .lon properties)
	 * p2 - {<OpenLayers.LonLat>} (or any object with both .lat, .lon properties)
	 *
	 * Returns:
	 * {Float} The distance (in km) between the two input points as measured on an
	 *     ellipsoid.  Note that the input point objects must be in geographic
	 *     coordinates (decimal degrees) and the return distance is in kilometers.
	 */
	OpenLayers.Util.distVincenty = function(p1, p2) {
	    var ct = OpenLayers.Util.VincentyConstants;
	    var a = ct.a, b = ct.b, f = ct.f;

	    var L = OpenLayers.Util.rad(p2.lon - p1.lon);
	    var U1 = Math.atan((1-f) * Math.tan(OpenLayers.Util.rad(p1.lat)));
	    var U2 = Math.atan((1-f) * Math.tan(OpenLayers.Util.rad(p2.lat)));
	    var sinU1 = Math.sin(U1), cosU1 = Math.cos(U1);
	    var sinU2 = Math.sin(U2), cosU2 = Math.cos(U2);
	    var lambda = L, lambdaP = 2*Math.PI;
	    var iterLimit = 20;
	    while (Math.abs(lambda-lambdaP) > 1e-12 && --iterLimit>0) {
	        var sinLambda = Math.sin(lambda), cosLambda = Math.cos(lambda);
	        var sinSigma = Math.sqrt((cosU2*sinLambda) * (cosU2*sinLambda) +
	        (cosU1*sinU2-sinU1*cosU2*cosLambda) * (cosU1*sinU2-sinU1*cosU2*cosLambda));
	        if (sinSigma==0) {
	            return 0;  // co-incident points
	        }
	        var cosSigma = sinU1*sinU2 + cosU1*cosU2*cosLambda;
	        var sigma = Math.atan2(sinSigma, cosSigma);
	        var alpha = Math.asin(cosU1 * cosU2 * sinLambda / sinSigma);
	        var cosSqAlpha = Math.cos(alpha) * Math.cos(alpha);
	        var cos2SigmaM = cosSigma - 2*sinU1*sinU2/cosSqAlpha;
	        var C = f/16*cosSqAlpha*(4+f*(4-3*cosSqAlpha));
	        lambdaP = lambda;
	        lambda = L + (1-C) * f * Math.sin(alpha) *
	        (sigma + C*sinSigma*(cos2SigmaM+C*cosSigma*(-1+2*cos2SigmaM*cos2SigmaM)));
	    }
	    if (iterLimit==0) {
	        return NaN;  // formula failed to converge
	    }
	    var uSq = cosSqAlpha * (a*a - b*b) / (b*b);
	    var A = 1 + uSq/16384*(4096+uSq*(-768+uSq*(320-175*uSq)));
	    var B = uSq/1024 * (256+uSq*(-128+uSq*(74-47*uSq)));
	    var deltaSigma = B*sinSigma*(cos2SigmaM+B/4*(cosSigma*(-1+2*cos2SigmaM*cos2SigmaM)-
	        B/6*cos2SigmaM*(-3+4*sinSigma*sinSigma)*(-3+4*cos2SigmaM*cos2SigmaM)));
	    var s = b*A*(sigma-deltaSigma);
	    var d = s.toFixed(3)/1000; // round to 1mm precision
	    return d;
	};

	/**
	 * APIFunction: destinationVincenty
	 * Calculate destination point given start point lat/long (numeric degrees),
	 * bearing (numeric degrees) & distance (in m).
	 * Adapted from Chris Veness work, see
	 * http://www.movable-type.co.uk/scripts/latlong-vincenty-direct.html
	 *
	 * Parameters:
	 * lonlat  - {<OpenLayers.LonLat>} (or any object with both .lat, .lon
	 *     properties) The start point.
	 * brng     - {Float} The bearing (degrees).
	 * dist     - {Float} The ground distance (meters).
	 *
	 * Returns:
	 * {<OpenLayers.LonLat>} The destination point.
	 */
	OpenLayers.Util.destinationVincenty = function(lonlat, brng, dist) {
	    var u = OpenLayers.Util;
	    var ct = u.VincentyConstants;
	    var a = ct.a, b = ct.b, f = ct.f;

	    var lon1 = lonlat.lon;
	    var lat1 = lonlat.lat;

	    var s = dist;
	    var alpha1 = u.rad(brng);
	    var sinAlpha1 = Math.sin(alpha1);
	    var cosAlpha1 = Math.cos(alpha1);

	    var tanU1 = (1-f) * Math.tan(u.rad(lat1));
	    var cosU1 = 1 / Math.sqrt((1 + tanU1*tanU1)), sinU1 = tanU1*cosU1;
	    var sigma1 = Math.atan2(tanU1, cosAlpha1);
	    var sinAlpha = cosU1 * sinAlpha1;
	    var cosSqAlpha = 1 - sinAlpha*sinAlpha;
	    var uSq = cosSqAlpha * (a*a - b*b) / (b*b);
	    var A = 1 + uSq/16384*(4096+uSq*(-768+uSq*(320-175*uSq)));
	    var B = uSq/1024 * (256+uSq*(-128+uSq*(74-47*uSq)));

	    var sigma = s / (b*A), sigmaP = 2*Math.PI;
	    while (Math.abs(sigma-sigmaP) > 1e-12) {
	        var cos2SigmaM = Math.cos(2*sigma1 + sigma);
	        var sinSigma = Math.sin(sigma);
	        var cosSigma = Math.cos(sigma);
	        var deltaSigma = B*sinSigma*(cos2SigmaM+B/4*(cosSigma*(-1+2*cos2SigmaM*cos2SigmaM)-
	            B/6*cos2SigmaM*(-3+4*sinSigma*sinSigma)*(-3+4*cos2SigmaM*cos2SigmaM)));
	        sigmaP = sigma;
	        sigma = s / (b*A) + deltaSigma;
	    }

	    var tmp = sinU1*sinSigma - cosU1*cosSigma*cosAlpha1;
	    var lat2 = Math.atan2(sinU1*cosSigma + cosU1*sinSigma*cosAlpha1,
	        (1-f)*Math.sqrt(sinAlpha*sinAlpha + tmp*tmp));
	    var lambda = Math.atan2(sinSigma*sinAlpha1, cosU1*cosSigma - sinU1*sinSigma*cosAlpha1);
	    var C = f/16*cosSqAlpha*(4+f*(4-3*cosSqAlpha));
	    var L = lambda - (1-C) * f * sinAlpha *
	        (sigma + C*sinSigma*(cos2SigmaM+C*cosSigma*(-1+2*cos2SigmaM*cos2SigmaM)));

	    var revAz = Math.atan2(sinAlpha, -tmp);  // final bearing

	    return new OpenLayers.LonLat(lon1+u.deg(L), u.deg(lat2));
	};

	/**
	 * Function: getParameters
	 * Parse the parameters from a URL or from the current page itself into a 
	 *     JavaScript Object. Note that parameter values with commas are separated
	 *     out into an Array.
	 * 
	 * Parameters:
	 * url - {String} Optional url used to extract the query string.
	 *                If url is null or is not supplied, query string is taken 
	 *                from the page location.
	 * options - {Object} Additional options. Optional.
	 *
	 * Valid options:
	 *   splitArgs - {Boolean} Split comma delimited params into arrays? Default is
	 *       true.
	 * 
	 * Returns:
	 * {Object} An object of key/value pairs from the query string.
	 */
	OpenLayers.Util.getParameters = function(url, options) {
	    options = options || {};
	    // if no url specified, take it from the location bar
	    url = (url === null || url === undefined) ? window.location.href : url;

	    //parse out parameters portion of url string
	    var paramsString = "";
	    if (OpenLayers.String.contains(url, '?')) {
	        var start = url.indexOf('?') + 1;
	        var end = OpenLayers.String.contains(url, "#") ?
	                    url.indexOf('#') : url.length;
	        paramsString = url.substring(start, end);
	    }

	    var parameters = {};
	    var pairs = paramsString.split(/[&;]/);
	    for(var i=0, len=pairs.length; i<len; ++i) {
	        var keyValue = pairs[i].split('=');
	        if (keyValue[0]) {

	            var key = keyValue[0];
	            try {
	                key = decodeURIComponent(key);
	            } catch (err) {
	                key = unescape(key);
	            }
	            
	            // being liberal by replacing "+" with " "
	            var value = (keyValue[1] || '').replace(/\+/g, " ");

	            try {
	                value = decodeURIComponent(value);
	            } catch (err) {
	                value = unescape(value);
	            }
	            
	            // follow OGC convention of comma delimited values
	            if (options.splitArgs !== false) {
	                value = value.split(",");
	            }

	            //if there's only one value, do not return as array                    
	            if (value.length == 1) {
	                value = value[0];
	            }                
	            
	            parameters[key] = value;
	         }
	     }
	    return parameters;
	};

	/**
	 * Property: lastSeqID
	 * {Integer} The ever-incrementing count variable.
	 *           Used for generating unique ids.
	 */
	OpenLayers.Util.lastSeqID = 0;

	/**
	 * Function: createUniqueID
	 * Create a unique identifier for this session.  Each time this function
	 *     is called, a counter is incremented.  The return will be the optional
	 *     prefix (defaults to "id_") appended with the counter value.
	 * 
	 * Parameters:
	 * prefix - {String} Optional string to prefix unique id. Default is "id_".
	 *     Note that dots (".") in the prefix will be replaced with underscore ("_").
	 * 
	 * Returns:
	 * {String} A unique id string, built on the passed in prefix.
	 */
	OpenLayers.Util.createUniqueID = function(prefix) {
	    if (prefix == null) {
	        prefix = "id_";
	    } else {
	        prefix = prefix.replace(OpenLayers.Util.dotless, "_");
	    }
	    OpenLayers.Util.lastSeqID += 1; 
	    return prefix + OpenLayers.Util.lastSeqID;        
	};

	/**
	 * Constant: INCHES_PER_UNIT
	 * {Object} Constant inches per unit -- borrowed from MapServer mapscale.c
	 * derivation of nautical miles from http://en.wikipedia.org/wiki/Nautical_mile
	 * Includes the full set of units supported by CS-MAP (http://trac.osgeo.org/csmap/)
	 * and PROJ.4 (http://trac.osgeo.org/proj/)
	 * The hardcoded table is maintain in a CS-MAP source code module named CSdataU.c
	 * The hardcoded table of PROJ.4 units are in pj_units.c.
	 */
	OpenLayers.INCHES_PER_UNIT = { 
	    'inches': 1.0,
	    'ft': 12.0,
	    'mi': 63360.0,
	    'm': 39.37,
	    'km': 39370,
	    'dd': 4374754,
	    'yd': 36
	};
	OpenLayers.INCHES_PER_UNIT["in"]= OpenLayers.INCHES_PER_UNIT.inches;
	OpenLayers.INCHES_PER_UNIT["degrees"] = OpenLayers.INCHES_PER_UNIT.dd;
	OpenLayers.INCHES_PER_UNIT["nmi"] = 1852 * OpenLayers.INCHES_PER_UNIT.m;

	// Units from CS-Map
	OpenLayers.METERS_PER_INCH = 0.02540005080010160020;
	OpenLayers.Util.extend(OpenLayers.INCHES_PER_UNIT, {
	    "Inch": OpenLayers.INCHES_PER_UNIT.inches,
	    "Meter": 1.0 / OpenLayers.METERS_PER_INCH,   //EPSG:9001
	    "Foot": 0.30480060960121920243 / OpenLayers.METERS_PER_INCH,   //EPSG:9003
	    "IFoot": 0.30480000000000000000 / OpenLayers.METERS_PER_INCH,   //EPSG:9002
	    "ClarkeFoot": 0.3047972651151 / OpenLayers.METERS_PER_INCH,   //EPSG:9005
	    "SearsFoot": 0.30479947153867624624 / OpenLayers.METERS_PER_INCH,   //EPSG:9041
	    "GoldCoastFoot": 0.30479971018150881758 / OpenLayers.METERS_PER_INCH,   //EPSG:9094
	    "IInch": 0.02540000000000000000 / OpenLayers.METERS_PER_INCH,
	    "MicroInch": 0.00002540000000000000 / OpenLayers.METERS_PER_INCH,
	    "Mil": 0.00000002540000000000 / OpenLayers.METERS_PER_INCH,
	    "Centimeter": 0.01000000000000000000 / OpenLayers.METERS_PER_INCH,
	    "Kilometer": 1000.00000000000000000000 / OpenLayers.METERS_PER_INCH,   //EPSG:9036
	    "Yard": 0.91440182880365760731 / OpenLayers.METERS_PER_INCH,
	    "SearsYard": 0.914398414616029 / OpenLayers.METERS_PER_INCH,   //EPSG:9040
	    "IndianYard": 0.91439853074444079983 / OpenLayers.METERS_PER_INCH,   //EPSG:9084
	    "IndianYd37": 0.91439523 / OpenLayers.METERS_PER_INCH,   //EPSG:9085
	    "IndianYd62": 0.9143988 / OpenLayers.METERS_PER_INCH,   //EPSG:9086
	    "IndianYd75": 0.9143985 / OpenLayers.METERS_PER_INCH,   //EPSG:9087
	    "IndianFoot": 0.30479951 / OpenLayers.METERS_PER_INCH,   //EPSG:9080
	    "IndianFt37": 0.30479841 / OpenLayers.METERS_PER_INCH,   //EPSG:9081
	    "IndianFt62": 0.3047996 / OpenLayers.METERS_PER_INCH,   //EPSG:9082
	    "IndianFt75": 0.3047995 / OpenLayers.METERS_PER_INCH,   //EPSG:9083
	    "Mile": 1609.34721869443738887477 / OpenLayers.METERS_PER_INCH,
	    "IYard": 0.91440000000000000000 / OpenLayers.METERS_PER_INCH,   //EPSG:9096
	    "IMile": 1609.34400000000000000000 / OpenLayers.METERS_PER_INCH,   //EPSG:9093
	    "NautM": 1852.00000000000000000000 / OpenLayers.METERS_PER_INCH,   //EPSG:9030
	    "Lat-66": 110943.316488932731 / OpenLayers.METERS_PER_INCH,
	    "Lat-83": 110946.25736872234125 / OpenLayers.METERS_PER_INCH,
	    "Decimeter": 0.10000000000000000000 / OpenLayers.METERS_PER_INCH,
	    "Millimeter": 0.00100000000000000000 / OpenLayers.METERS_PER_INCH,
	    "Dekameter": 10.00000000000000000000 / OpenLayers.METERS_PER_INCH,
	    "Decameter": 10.00000000000000000000 / OpenLayers.METERS_PER_INCH,
	    "Hectometer": 100.00000000000000000000 / OpenLayers.METERS_PER_INCH,
	    "GermanMeter": 1.0000135965 / OpenLayers.METERS_PER_INCH,   //EPSG:9031
	    "CaGrid": 0.999738 / OpenLayers.METERS_PER_INCH,
	    "ClarkeChain": 20.1166194976 / OpenLayers.METERS_PER_INCH,   //EPSG:9038
	    "GunterChain": 20.11684023368047 / OpenLayers.METERS_PER_INCH,   //EPSG:9033
	    "BenoitChain": 20.116782494375872 / OpenLayers.METERS_PER_INCH,   //EPSG:9062
	    "SearsChain": 20.11676512155 / OpenLayers.METERS_PER_INCH,   //EPSG:9042
	    "ClarkeLink": 0.201166194976 / OpenLayers.METERS_PER_INCH,   //EPSG:9039
	    "GunterLink": 0.2011684023368047 / OpenLayers.METERS_PER_INCH,   //EPSG:9034
	    "BenoitLink": 0.20116782494375872 / OpenLayers.METERS_PER_INCH,   //EPSG:9063
	    "SearsLink": 0.2011676512155 / OpenLayers.METERS_PER_INCH,   //EPSG:9043
	    "Rod": 5.02921005842012 / OpenLayers.METERS_PER_INCH,
	    "IntnlChain": 20.1168 / OpenLayers.METERS_PER_INCH,   //EPSG:9097
	    "IntnlLink": 0.201168 / OpenLayers.METERS_PER_INCH,   //EPSG:9098
	    "Perch": 5.02921005842012 / OpenLayers.METERS_PER_INCH,
	    "Pole": 5.02921005842012 / OpenLayers.METERS_PER_INCH,
	    "Furlong": 201.1684023368046 / OpenLayers.METERS_PER_INCH,
	    "Rood": 3.778266898 / OpenLayers.METERS_PER_INCH,
	    "CapeFoot": 0.3047972615 / OpenLayers.METERS_PER_INCH,
	    "Brealey": 375.00000000000000000000 / OpenLayers.METERS_PER_INCH,
	    "ModAmFt": 0.304812252984505969011938 / OpenLayers.METERS_PER_INCH,
	    "Fathom": 1.8288 / OpenLayers.METERS_PER_INCH,
	    "NautM-UK": 1853.184 / OpenLayers.METERS_PER_INCH,
	    "50kilometers": 50000.0 / OpenLayers.METERS_PER_INCH,
	    "150kilometers": 150000.0 / OpenLayers.METERS_PER_INCH
	});

	//unit abbreviations supported by PROJ.4
	OpenLayers.Util.extend(OpenLayers.INCHES_PER_UNIT, {
	    "mm": OpenLayers.INCHES_PER_UNIT["Meter"] / 1000.0,
	    "cm": OpenLayers.INCHES_PER_UNIT["Meter"] / 100.0,
	    "dm": OpenLayers.INCHES_PER_UNIT["Meter"] * 100.0,
	    "km": OpenLayers.INCHES_PER_UNIT["Meter"] * 1000.0,
	    "kmi": OpenLayers.INCHES_PER_UNIT["nmi"],    //International Nautical Mile
	    "fath": OpenLayers.INCHES_PER_UNIT["Fathom"], //International Fathom
	    "ch": OpenLayers.INCHES_PER_UNIT["IntnlChain"],  //International Chain
	    "link": OpenLayers.INCHES_PER_UNIT["IntnlLink"], //International Link
	    "us-in": OpenLayers.INCHES_PER_UNIT["inches"], //U.S. Surveyor's Inch
	    "us-ft": OpenLayers.INCHES_PER_UNIT["Foot"], //U.S. Surveyor's Foot
	    "us-yd": OpenLayers.INCHES_PER_UNIT["Yard"], //U.S. Surveyor's Yard
	    "us-ch": OpenLayers.INCHES_PER_UNIT["GunterChain"], //U.S. Surveyor's Chain
	    "us-mi": OpenLayers.INCHES_PER_UNIT["Mile"],   //U.S. Surveyor's Statute Mile
	    "ind-yd": OpenLayers.INCHES_PER_UNIT["IndianYd37"],  //Indian Yard
	    "ind-ft": OpenLayers.INCHES_PER_UNIT["IndianFt37"],  //Indian Foot
	    "ind-ch": 20.11669506 / OpenLayers.METERS_PER_INCH  //Indian Chain
	});

	/** 
	 * Constant: DOTS_PER_INCH
	 * {Integer} 72 (A sensible default)
	 */
	OpenLayers.DOTS_PER_INCH = 72;

	/**
	 * Function: normalizeScale
	 * 
	 * Parameters:
	 * scale - {float}
	 * 
	 * Returns:
	 * {Float} A normalized scale value, in 1 / X format. 
	 *         This means that if a value less than one ( already 1/x) is passed
	 *         in, it just returns scale directly. Otherwise, it returns 
	 *         1 / scale
	 */
	OpenLayers.Util.normalizeScale = function (scale) {
	    var normScale = (scale > 1.0) ? (1.0 / scale) 
	                                  : scale;
	    return normScale;
	};

	/**
	 * Function: getResolutionFromScale
	 * 
	 * Parameters:
	 * scale - {Float}
	 * units - {String} Index into OpenLayers.INCHES_PER_UNIT hashtable.
	 *                  Default is degrees
	 * 
	 * Returns:
	 * {Float} The corresponding resolution given passed-in scale and unit 
	 *     parameters.  If the given scale is falsey, the returned resolution will
	 *     be undefined.
	 */
	OpenLayers.Util.getResolutionFromScale = function (scale, units) {
	    var resolution;
	    if (scale) {
	        if (units == null) {
	            units = "degrees";
	        }
	        var normScale = OpenLayers.Util.normalizeScale(scale);
	        resolution = 1 / (normScale * OpenLayers.INCHES_PER_UNIT[units]
	                                        * OpenLayers.DOTS_PER_INCH);        
	    }
	    return resolution;
	};

	/**
	 * Function: getScaleFromResolution
	 * 
	 * Parameters:
	 * resolution - {Float}
	 * units - {String} Index into OpenLayers.INCHES_PER_UNIT hashtable.
	 *                  Default is degrees
	 * 
	 * Returns:
	 * {Float} The corresponding scale given passed-in resolution and unit 
	 *         parameters.
	 */
	OpenLayers.Util.getScaleFromResolution = function (resolution, units) {

	    if (units == null) {
	        units = "degrees";
	    }

	    var scale = resolution * OpenLayers.INCHES_PER_UNIT[units] *
	                    OpenLayers.DOTS_PER_INCH;
	    return scale;
	};

	/**
	 * Function: pagePosition
	 * Calculates the position of an element on the page (see
	 * http://code.google.com/p/doctype/wiki/ArticlePageOffset)
	 *
	 * OpenLayers.Util.pagePosition is based on Yahoo's getXY method, which is
	 * Copyright (c) 2006, Yahoo! Inc.
	 * All rights reserved.
	 * 
	 * Redistribution and use of this software in source and binary forms, with or
	 * without modification, are permitted provided that the following conditions
	 * are met:
	 * 
	 * * Redistributions of source code must retain the above copyright notice,
	 *   this list of conditions and the following disclaimer.
	 * 
	 * * Redistributions in binary form must reproduce the above copyright notice,
	 *   this list of conditions and the following disclaimer in the documentation
	 *   and/or other materials provided with the distribution.
	 * 
	 * * Neither the name of Yahoo! Inc. nor the names of its contributors may be
	 *   used to endorse or promote products derived from this software without
	 *   specific prior written permission of Yahoo! Inc.
	 * 
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
	 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
	 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
	 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
	 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
	 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
	 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
	 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
	 * POSSIBILITY OF SUCH DAMAGE.
	 *
	 * Parameters:
	 * forElement - {DOMElement}
	 * 
	 * Returns:
	 * {Array} two item array, Left value then Top value.
	 */
	OpenLayers.Util.pagePosition =  function(forElement) {
	    // NOTE: If element is hidden (display none or disconnected or any the
	    // ancestors are hidden) we get (0,0) by default but we still do the
	    // accumulation of scroll position.

	    var pos = [0, 0];
	    var viewportElement = OpenLayers.Util.getViewportElement();
	    if (!forElement || forElement == window || forElement == viewportElement) {
	        // viewport is always at 0,0 as that defined the coordinate system for
	        // this function - this avoids special case checks in the code below
	        return pos;
	    }

	    // Gecko browsers normally use getBoxObjectFor to calculate the position.
	    // When invoked for an element with an implicit absolute position though it
	    // can be off by one. Therefore the recursive implementation is used in
	    // those (relatively rare) cases.
	    var BUGGY_GECKO_BOX_OBJECT =
	        OpenLayers.IS_GECKO && document.getBoxObjectFor &&
	        OpenLayers.Element.getStyle(forElement, 'position') == 'absolute' &&
	        (forElement.style.top == '' || forElement.style.left == '');

	    var parent = null;
	    var box;

	    if (forElement.getBoundingClientRect) { // IE
	        box = forElement.getBoundingClientRect();
	        var scrollTop = window.pageYOffset || viewportElement.scrollTop;
	        var scrollLeft = window.pageXOffset || viewportElement.scrollLeft;
	        
	        pos[0] = box.left + scrollLeft;
	        pos[1] = box.top + scrollTop;

	    } else if (document.getBoxObjectFor && !BUGGY_GECKO_BOX_OBJECT) { // gecko
	        // Gecko ignores the scroll values for ancestors, up to 1.9.  See:
	        // https://bugzilla.mozilla.org/show_bug.cgi?id=328881 and
	        // https://bugzilla.mozilla.org/show_bug.cgi?id=330619

	        box = document.getBoxObjectFor(forElement);
	        var vpBox = document.getBoxObjectFor(viewportElement);
	        pos[0] = box.screenX - vpBox.screenX;
	        pos[1] = box.screenY - vpBox.screenY;

	    } else { // safari/opera
	        pos[0] = forElement.offsetLeft;
	        pos[1] = forElement.offsetTop;
	        parent = forElement.offsetParent;
	        if (parent != forElement) {
	            while (parent) {
	                pos[0] += parent.offsetLeft;
	                pos[1] += parent.offsetTop;
	                parent = parent.offsetParent;
	            }
	        }

	        var browser = OpenLayers.BROWSER_NAME;

	        // opera & (safari absolute) incorrectly account for body offsetTop
	        if (browser == "opera" || (browser == "safari" &&
	              OpenLayers.Element.getStyle(forElement, 'position') == 'absolute')) {
	            pos[1] -= document.body.offsetTop;
	        }

	        // accumulate the scroll positions for everything but the body element
	        parent = forElement.offsetParent;
	        while (parent && parent != document.body) {
	            pos[0] -= parent.scrollLeft;
	            // see https://bugs.opera.com/show_bug.cgi?id=249965
	            if (browser != "opera" || parent.tagName != 'TR') {
	                pos[1] -= parent.scrollTop;
	            }
	            parent = parent.offsetParent;
	        }
	    }
	    
	    return pos;
	};

	/**
	 * Function: getViewportElement
	 * Returns die viewport element of the document. The viewport element is
	 * usually document.documentElement, except in IE,where it is either
	 * document.body or document.documentElement, depending on the document's
	 * compatibility mode (see
	 * http://code.google.com/p/doctype/wiki/ArticleClientViewportElement)
	 *
	 * Returns:
	 * {DOMElement}
	 */
	OpenLayers.Util.getViewportElement = function() {
	    var viewportElement = arguments.callee.viewportElement;
	    if (viewportElement == undefined) {
	        viewportElement = (OpenLayers.BROWSER_NAME == "msie" &&
	            document.compatMode != 'CSS1Compat') ? document.body :
	            document.documentElement;
	        arguments.callee.viewportElement = viewportElement;
	    }
	    return viewportElement;
	};

	/** 
	 * Function: isEquivalentUrl
	 * Test two URLs for equivalence. 
	 * 
	 * Setting 'ignoreCase' allows for case-independent comparison.
	 * 
	 * Comparison is based on: 
	 *  - Protocol
	 *  - Host (evaluated without the port)
	 *  - Port (set 'ignorePort80' to ignore "80" values)
	 *  - Hash ( set 'ignoreHash' to disable)
	 *  - Pathname (for relative <-> absolute comparison) 
	 *  - Arguments (so they can be out of order)
	 *  
	 * Parameters:
	 * url1 - {String}
	 * url2 - {String}
	 * options - {Object} Allows for customization of comparison:
	 *                    'ignoreCase' - Default is True
	 *                    'ignorePort80' - Default is True
	 *                    'ignoreHash' - Default is True
	 *
	 * Returns:
	 * {Boolean} Whether or not the two URLs are equivalent
	 */
	OpenLayers.Util.isEquivalentUrl = function(url1, url2, options) {
	    options = options || {};

	    OpenLayers.Util.applyDefaults(options, {
	        ignoreCase: true,
	        ignorePort80: true,
	        ignoreHash: true,
	        splitArgs: false
	    });

	    var urlObj1 = OpenLayers.Util.createUrlObject(url1, options);
	    var urlObj2 = OpenLayers.Util.createUrlObject(url2, options);

	    //compare all keys except for "args" (treated below)
	    for(var key in urlObj1) {
	        if(key !== "args") {
	            if(urlObj1[key] != urlObj2[key]) {
	                return false;
	            }
	        }
	    }

	    // compare search args - irrespective of order
	    for(var key in urlObj1.args) {
	        if(urlObj1.args[key] != urlObj2.args[key]) {
	            return false;
	        }
	        delete urlObj2.args[key];
	    }
	    // urlObj2 shouldn't have any args left
	    for(var key in urlObj2.args) {
	        return false;
	    }
	    
	    return true;
	};

	/**
	 * Function: createUrlObject
	 * 
	 * Parameters:
	 * url - {String}
	 * options - {Object} A hash of options.
	 *
	 * Valid options:
	 *   ignoreCase - {Boolean} lowercase url,
	 *   ignorePort80 - {Boolean} don't include explicit port if port is 80,
	 *   ignoreHash - {Boolean} Don't include part of url after the hash (#).
	 *   splitArgs - {Boolean} Split comma delimited params into arrays? Default is
	 *       true.
	 * 
	 * Returns:
	 * {Object} An object with separate url, a, port, host, and args parsed out 
	 *          and ready for comparison
	 */
	OpenLayers.Util.createUrlObject = function(url, options) {
	    options = options || {};

	    // deal with relative urls first
	    if(!(/^\w+:\/\//).test(url)) {
	        var loc = window.location;
	        var port = loc.port ? ":" + loc.port : "";
	        var fullUrl = loc.protocol + "//" + loc.host.split(":").shift() + port;
	        if(url.indexOf("/") === 0) {
	            // full pathname
	            url = fullUrl + url;
	        } else {
	            // relative to current path
	            var parts = loc.pathname.split("/");
	            parts.pop();
	            url = fullUrl + parts.join("/") + "/" + url;
	        }
	    }
	  
	    if (options.ignoreCase) {
	        url = url.toLowerCase(); 
	    }

	    var a = document.createElement('a');
	    a.href = url;
	    
	    var urlObject = {};
	    
	    //host (without port)
	    urlObject.host = a.host.split(":").shift();

	    //protocol
	    urlObject.protocol = a.protocol;  

	    //port (get uniform browser behavior with port 80 here)
	    if(options.ignorePort80) {
	        urlObject.port = (a.port == "80" || a.port == "0") ? "" : a.port;
	    } else {
	        urlObject.port = (a.port == "" || a.port == "0") ? "80" : a.port;
	    }

	    //hash
	    urlObject.hash = (options.ignoreHash || a.hash === "#") ? "" : a.hash;  
	    
	    //args
	    var queryString = a.search;
	    if (!queryString) {
	        var qMark = url.indexOf("?");
	        queryString = (qMark != -1) ? url.substr(qMark) : "";
	    }
	    urlObject.args = OpenLayers.Util.getParameters(queryString,
	            {splitArgs: options.splitArgs});

	    // pathname
	    //
	    // This is a workaround for Internet Explorer where
	    // window.location.pathname has a leading "/", but
	    // a.pathname has no leading "/".
	    urlObject.pathname = (a.pathname.charAt(0) == "/") ? a.pathname : "/" + a.pathname;
	    
	    return urlObject; 
	};
	 
	/**
	 * Function: removeTail
	 * Takes a url and removes everything after the ? and #
	 * 
	 * Parameters:
	 * url - {String} The url to process
	 * 
	 * Returns:
	 * {String} The string with all queryString and Hash removed
	 */
	OpenLayers.Util.removeTail = function(url) {
	    var head = null;
	    
	    var qMark = url.indexOf("?");
	    var hashMark = url.indexOf("#");

	    if (qMark == -1) {
	        head = (hashMark != -1) ? url.substr(0,hashMark) : url;
	    } else {
	        head = (hashMark != -1) ? url.substr(0,Math.min(qMark, hashMark)) 
	                                  : url.substr(0, qMark);
	    }
	    return head;
	};

	/**
	 * Constant: IS_GECKO
	 * {Boolean} True if the userAgent reports the browser to use the Gecko engine
	 */
	OpenLayers.IS_GECKO = (function() {
	    var ua = navigator.userAgent.toLowerCase();
	    return ua.indexOf("webkit") == -1 && ua.indexOf("gecko") != -1;
	})();

	/**
	 * Constant: CANVAS_SUPPORTED
	 * {Boolean} True if canvas 2d is supported.
	 */
	OpenLayers.CANVAS_SUPPORTED = (function() {
	    var elem = document.createElement('canvas');
	    return !!(elem.getContext && elem.getContext('2d'));
	})();

	/**
	 * Constant: BROWSER_NAME
	 * {String}
	 * A substring of the navigator.userAgent property.  Depending on the userAgent
	 *     property, this will be the empty string or one of the following:
	 *     * "opera" -- Opera
	 *     * "msie"  -- Internet Explorer
	 *     * "safari" -- Safari
	 *     * "firefox" -- Firefox
	 *     * "mozilla" -- Mozilla
	 */
	OpenLayers.BROWSER_NAME = (function() {
	    var name = "";
	    var ua = navigator.userAgent.toLowerCase();
	    if (ua.indexOf("opera") != -1) {
	        name = "opera";
	    } else if (ua.indexOf("msie") != -1) {
	        name = "msie";
	    } else if (ua.indexOf("safari") != -1) {
	        name = "safari";
	    } else if (ua.indexOf("mozilla") != -1) {
	        if (ua.indexOf("firefox") != -1) {
	            name = "firefox";
	        } else {
	            name = "mozilla";
	        }
	    }
	    return name;
	})();

	/**
	 * Function: getBrowserName
	 * 
	 * Returns:
	 * {String} A string which specifies which is the current 
	 *          browser in which we are running. 
	 * 
	 *          Currently-supported browser detection and codes:
	 *           * 'opera' -- Opera
	 *           * 'msie'  -- Internet Explorer
	 *           * 'safari' -- Safari
	 *           * 'firefox' -- Firefox
	 *           * 'mozilla' -- Mozilla
	 * 
	 *          If we are unable to property identify the browser, we 
	 *           return an empty string.
	 */
	OpenLayers.Util.getBrowserName = function() {
	    return OpenLayers.BROWSER_NAME;
	};

	/**
	 * Method: getRenderedDimensions
	 * Renders the contentHTML offscreen to determine actual dimensions for
	 *     popup sizing. As we need layout to determine dimensions the content
	 *     is rendered -9999px to the left and absolute to ensure the 
	 *     scrollbars do not flicker
	 *     
	 * Parameters:
	 * contentHTML
	 * size - {<OpenLayers.Size>} If either the 'w' or 'h' properties is 
	 *     specified, we fix that dimension of the div to be measured. This is 
	 *     useful in the case where we have a limit in one dimension and must 
	 *     therefore meaure the flow in the other dimension.
	 * options - {Object}
	 *
	 * Allowed Options:
	 *     displayClass - {String} Optional parameter.  A CSS class name(s) string
	 *         to provide the CSS context of the rendered content.
	 *     containerElement - {DOMElement} Optional parameter. Insert the HTML to 
	 *         this node instead of the body root when calculating dimensions. 
	 * 
	 * Returns:
	 * {<OpenLayers.Size>}
	 */
	OpenLayers.Util.getRenderedDimensions = function(contentHTML, size, options) {
	    
	    var w, h;
	    
	    // create temp container div with restricted size
	    var container = document.createElement("div");
	    container.style.visibility = "hidden";
	        
	    var containerElement = (options && options.containerElement) 
	        ? options.containerElement : document.body;
	    
	    // Opera and IE7 can't handle a node with position:aboslute if it inherits
	    // position:absolute from a parent.
	    var parentHasPositionAbsolute = false;
	    var superContainer = null;
	    var parent = containerElement;
	    while (parent && parent.tagName.toLowerCase()!="body") {
	        var parentPosition = OpenLayers.Element.getStyle(parent, "position");
	        if(parentPosition == "absolute") {
	            parentHasPositionAbsolute = true;
	            break;
	        } else if (parentPosition && parentPosition != "static") {
	            break;
	        }
	        parent = parent.parentNode;
	    }
	    if(parentHasPositionAbsolute && (containerElement.clientHeight === 0 || 
	                                     containerElement.clientWidth === 0) ){
	        superContainer = document.createElement("div");
	        superContainer.style.visibility = "hidden";
	        superContainer.style.position = "absolute";
	        superContainer.style.overflow = "visible";
	        superContainer.style.width = document.body.clientWidth + "px";
	        superContainer.style.height = document.body.clientHeight + "px";
	        superContainer.appendChild(container);
	    }
	    container.style.position = "absolute";

	    //fix a dimension, if specified.
	    if (size) {
	        if (size.w) {
	            w = size.w;
	            container.style.width = w + "px";
	        } else if (size.h) {
	            h = size.h;
	            container.style.height = h + "px";
	        }
	    }

	    //add css classes, if specified
	    if (options && options.displayClass) {
	        container.className = options.displayClass;
	    }
	    
	    // create temp content div and assign content
	    var content = document.createElement("div");
	    content.innerHTML = contentHTML;
	    
	    // we need overflow visible when calculating the size
	    content.style.overflow = "visible";
	    if (content.childNodes) {
	        for (var i=0, l=content.childNodes.length; i<l; i++) {
	            if (!content.childNodes[i].style) continue;
	            content.childNodes[i].style.overflow = "visible";
	        }
	    }
	    
	    // add content to restricted container 
	    container.appendChild(content);
	    
	    // append container to body for rendering
	    if (superContainer) {
	        containerElement.appendChild(superContainer);
	    } else {
	        containerElement.appendChild(container);
	    }
	    
	    // calculate scroll width of content and add corners and shadow width
	    if (!w) {
	        w = parseInt(content.scrollWidth);
	    
	        // update container width to allow height to adjust
	        container.style.width = w + "px";
	    }        
	    // capture height and add shadow and corner image widths
	    if (!h) {
	        h = parseInt(content.scrollHeight);
	    }

	    // remove elements
	    container.removeChild(content);
	    if (superContainer) {
	        superContainer.removeChild(container);
	        containerElement.removeChild(superContainer);
	    } else {
	        containerElement.removeChild(container);
	    }
	    
	    return new OpenLayers.Size(w, h);
	};

	/**
	 * APIFunction: getScrollbarWidth
	 * This function has been modified by the OpenLayers from the original version,
	 *     written by Matthew Eernisse and released under the Apache 2 
	 *     license here:
	 * 
	 *     http://www.fleegix.org/articles/2006/05/30/getting-the-scrollbar-width-in-pixels
	 * 
	 *     It has been modified simply to cache its value, since it is physically 
	 *     impossible that this code could ever run in more than one browser at 
	 *     once. 
	 * 
	 * Returns:
	 * {Integer}
	 */
	OpenLayers.Util.getScrollbarWidth = function() {
	    
	    var scrollbarWidth = OpenLayers.Util._scrollbarWidth;
	    
	    if (scrollbarWidth == null) {
	        var scr = null;
	        var inn = null;
	        var wNoScroll = 0;
	        var wScroll = 0;
	    
	        // Outer scrolling div
	        scr = document.createElement('div');
	        scr.style.position = 'absolute';
	        scr.style.top = '-1000px';
	        scr.style.left = '-1000px';
	        scr.style.width = '100px';
	        scr.style.height = '50px';
	        // Start with no scrollbar
	        scr.style.overflow = 'hidden';
	    
	        // Inner content div
	        inn = document.createElement('div');
	        inn.style.width = '100%';
	        inn.style.height = '200px';
	    
	        // Put the inner div in the scrolling div
	        scr.appendChild(inn);
	        // Append the scrolling div to the doc
	        document.body.appendChild(scr);
	    
	        // Width of the inner div sans scrollbar
	        wNoScroll = inn.offsetWidth;
	    
	        // Add the scrollbar
	        scr.style.overflow = 'scroll';
	        // Width of the inner div width scrollbar
	        wScroll = inn.offsetWidth;
	    
	        // Remove the scrolling div from the doc
	        document.body.removeChild(document.body.lastChild);
	    
	        // Pixel width of the scroller
	        OpenLayers.Util._scrollbarWidth = (wNoScroll - wScroll);
	        scrollbarWidth = OpenLayers.Util._scrollbarWidth;
	    }

	    return scrollbarWidth;
	};

	/**
	 * APIFunction: getFormattedLonLat
	 * This function will return latitude or longitude value formatted as 
	 *
	 * Parameters:
	 * coordinate - {Float} the coordinate value to be formatted
	 * axis - {String} value of either 'lat' or 'lon' to indicate which axis is to
	 *          to be formatted (default = lat)
	 * dmsOption - {String} specify the precision of the output can be one of:
	 *           'dms' show degrees minutes and seconds
	 *           'dm' show only degrees and minutes
	 *           'd' show only degrees
	 * 
	 * Returns:
	 * {String} the coordinate value formatted as a string
	 */
	OpenLayers.Util.getFormattedLonLat = function(coordinate, axis, dmsOption) {
	    if (!dmsOption) {
	        dmsOption = 'dms';    //default to show degree, minutes, seconds
	    }

	    coordinate = (coordinate+540)%360 - 180; // normalize for sphere being round

	    var abscoordinate = Math.abs(coordinate);
	    var coordinatedegrees = Math.floor(abscoordinate);

	    var coordinateminutes = (abscoordinate - coordinatedegrees)/(1/60);
	    var tempcoordinateminutes = coordinateminutes;
	    coordinateminutes = Math.floor(coordinateminutes);
	    var coordinateseconds = (tempcoordinateminutes - coordinateminutes)/(1/60);
	    coordinateseconds =  Math.round(coordinateseconds*10);
	    coordinateseconds /= 10;

	    if( coordinateseconds >= 60) { 
	        coordinateseconds -= 60; 
	        coordinateminutes += 1; 
	        if( coordinateminutes >= 60) { 
	            coordinateminutes -= 60; 
	            coordinatedegrees += 1; 
	        } 
	    }
	    
	    if( coordinatedegrees < 10 ) {
	        coordinatedegrees = "0" + coordinatedegrees;
	    }
	    var str = coordinatedegrees + "\u00B0";

	    if (dmsOption.indexOf('dm') >= 0) {
	        if( coordinateminutes < 10 ) {
	            coordinateminutes = "0" + coordinateminutes;
	        }
	        str += coordinateminutes + "'";
	  
	        if (dmsOption.indexOf('dms') >= 0) {
	            if( coordinateseconds < 10 ) {
	                coordinateseconds = "0" + coordinateseconds;
	            }
	            str += coordinateseconds + '"';
	        }
	    }
	    
	    if (axis == "lon") {
	        str += coordinate < 0 ? OpenLayers.i18n("W") : OpenLayers.i18n("E");
	    } else {
	        str += coordinate < 0 ? OpenLayers.i18n("S") : OpenLayers.i18n("N");
	    }
	    return str;
	};

	/**
	 * Function: getConstructor
	 * Take an OpenLayers style CLASS_NAME and return a constructor.
	 *
	 * Parameters:
	 * className - {String} The dot delimited class name (e.g. 'OpenLayers.Foo').
	 * 
	 * Returns:
	 * {Function} The constructor.
	 */
	OpenLayers.Util.getConstructor = function(className) {
	    var Constructor;
	    var parts = className.split('.');
	    if (parts[0] === "OpenLayers") {
	        Constructor = OpenLayers;
	    } else {
	        // someone extended our base class and used their own namespace
	        // this will not work when the library is evaluated in a closure
	        // but it is the best we can do (until we ourselves provide a global)
	        Constructor = window[parts[0]];
	    }
	    for (var i = 1, ii = parts.length; i < ii; ++i) {
	        Constructor = Constructor[parts[i]];
	    }
	    return Constructor;
	};
	/* ======================================================================
	    OpenLayers/Events.js
	   ====================================================================== */

	/* Copyright (c) 2006-2015 by OpenLayers Contributors (see authors.txt for
	 * full list of contributors). Published under the 2-clause BSD license.
	 * See license.txt in the OpenLayers distribution or repository for the
	 * full text of the license. */


	/**
	 * @requires OpenLayers/Util.js
	 */

	/**
	 * Namespace: OpenLayers.Event
	 * Utility functions for event handling.
	 */
	OpenLayers.Event = {

	    /** 
	     * Property: observers 
	     * {Object} A hashtable cache of the event observers. Keyed by
	     * element._eventCacheID 
	     */
	    observers: false,

	    /**
	     * Constant: KEY_SPACE
	     * {int}
	     */
	    KEY_SPACE: 32,
	    
	    /** 
	     * Constant: KEY_BACKSPACE 
	     * {int} 
	     */
	    KEY_BACKSPACE: 8,

	    /** 
	     * Constant: KEY_TAB 
	     * {int} 
	     */
	    KEY_TAB: 9,

	    /** 
	     * Constant: KEY_RETURN 
	     * {int} 
	     */
	    KEY_RETURN: 13,

	    /** 
	     * Constant: KEY_ESC 
	     * {int} 
	     */
	    KEY_ESC: 27,

	    /** 
	     * Constant: KEY_LEFT 
	     * {int} 
	     */
	    KEY_LEFT: 37,

	    /** 
	     * Constant: KEY_UP 
	     * {int} 
	     */
	    KEY_UP: 38,

	    /** 
	     * Constant: KEY_RIGHT 
	     * {int} 
	     */
	    KEY_RIGHT: 39,

	    /** 
	     * Constant: KEY_DOWN 
	     * {int} 
	     */
	    KEY_DOWN: 40,

	    /** 
	     * Constant: KEY_DELETE 
	     * {int} 
	     */
	    KEY_DELETE: 46,


	    /**
	     * Method: element
	     * Cross browser event element detection.
	     * 
	     * Parameters:
	     * event - {Event} 
	     * 
	     * Returns:
	     * {DOMElement} The element that caused the event 
	     */
	    element: function(event) {
	        return event.target || event.srcElement;
	    },

	    /**
	     * Method: isSingleTouch
	     * Determine whether event was caused by a single touch
	     *
	     * Parameters:
	     * event - {Event}
	     *
	     * Returns:
	     * {Boolean}
	     */
	    isSingleTouch: function(event) {
	        return event.touches && event.touches.length == 1;
	    },

	    /**
	     * Method: isMultiTouch
	     * Determine whether event was caused by a multi touch
	     *
	     * Parameters:
	     * event - {Event}
	     *
	     * Returns:
	     * {Boolean}
	     */
	    isMultiTouch: function(event) {
	        return event.touches && event.touches.length > 1;
	    },

	    /**
	     * Method: isTouchEvent
	     * Determine whether the event was triggered by a touch
	     * 
	     * Parameters:
	     * evt - {Event}
	     * 
	     * Returns:
	     * {Boolean}
	     */
	    isTouchEvent: function(evt) {
	        return ("" + evt.type).indexOf("touch") === 0 || (
	                "pointerType" in evt && (
	                     evt.pointerType === evt.MSPOINTER_TYPE_TOUCH /*IE10 pointer*/ ||
	                     evt.pointerType === "touch" /*W3C pointer*/));
	    },

	    /**
	     * Method: isLeftClick
	     * Determine whether event was caused by a left click. 
	     *
	     * Parameters:
	     * event - {Event} 
	     * 
	     * Returns:
	     * {Boolean}
	     */
	    isLeftClick: function(event) {
	        return (((event.which) && (event.which == 1)) ||
	                ((event.button) && (event.button == 1)));
	    },

	    /**
	     * Method: isRightClick
	     * Determine whether event was caused by a right mouse click. 
	     *
	     * Parameters:
	     * event - {Event} 
	     * 
	     * Returns:
	     * {Boolean}
	     */
	     isRightClick: function(event) {
	        return (((event.which) && (event.which == 3)) ||
	                ((event.button) && (event.button == 2)));
	    },
	     
	    /**
	     * Method: stop
	     * Stops an event from propagating. 
	     *
	     * Parameters: 
	     * event - {Event} 
	     * allowDefault - {Boolean} If true, we stop the event chain but 
	     *     still allow the default browser behaviour (text selection,
	     *     radio-button clicking, etc).  Default is false.
	     */
	    stop: function(event, allowDefault) {
	        
	        if (!allowDefault) { 
	            OpenLayers.Event.preventDefault(event);
	        }
	                
	        if (event.stopPropagation) {
	            event.stopPropagation();
	        } else {
	            event.cancelBubble = true;
	        }
	    },

	    /**
	     * Method: preventDefault
	     * Cancels the event if it is cancelable, without stopping further
	     * propagation of the event.
	     *
	     * Parameters:
	     * event - {Event}
	     */
	    preventDefault: function(event) {
	        if (event.preventDefault) {
	            event.preventDefault();
	        } else {
	            event.returnValue = false;
	        }
	    },

	    /** 
	     * Method: findElement
	     * 
	     * Parameters:
	     * event - {Event} 
	     * tagName - {String} 
	     * 
	     * Returns:
	     * {DOMElement} The first node with the given tagName, starting from the
	     * node the event was triggered on and traversing the DOM upwards
	     */
	    findElement: function(event, tagName) {
	        var element = OpenLayers.Event.element(event);
	        while (element.parentNode && (!element.tagName ||
	              (element.tagName.toUpperCase() != tagName.toUpperCase()))){
	            element = element.parentNode;
	        }
	        return element;
	    },

	    /** 
	     * Method: observe
	     * 
	     * Parameters:
	     * elementParam - {DOMElement || String} 
	     * name - {String} 
	     * observer - {function} 
	     * useCapture - {Boolean} 
	     */
	    observe: function(elementParam, name, observer, useCapture) {
	        var element = OpenLayers.Util.getElement(elementParam);
	        useCapture = useCapture || false;

	        if (name == 'keypress' &&
	           (navigator.appVersion.match(/Konqueror|Safari|KHTML/)
	           || element.attachEvent)) {
	            name = 'keydown';
	        }

	        //if observers cache has not yet been created, create it
	        if (!this.observers) {
	            this.observers = {};
	        }

	        //if not already assigned, make a new unique cache ID
	        if (!element._eventCacheID) {
	            var idPrefix = "eventCacheID_";
	            if (element.id) {
	                idPrefix = element.id + "_" + idPrefix;
	            }
	            element._eventCacheID = OpenLayers.Util.createUniqueID(idPrefix);
	        }

	        var cacheID = element._eventCacheID;

	        //if there is not yet a hash entry for this element, add one
	        if (!this.observers[cacheID]) {
	            this.observers[cacheID] = [];
	        }

	        //add a new observer to this element's list
	        this.observers[cacheID].push({
	            'element': element,
	            'name': name,
	            'observer': observer,
	            'useCapture': useCapture
	        });

	        //add the actual browser event listener
	        if (element.addEventListener) {
	            element.addEventListener(name, observer, useCapture);
	        } else if (element.attachEvent) {
	            element.attachEvent('on' + name, observer);
	        }
	    },

	    /** 
	     * Method: stopObservingElement
	     * Given the id of an element to stop observing, cycle through the 
	     *   element's cached observers, calling stopObserving on each one, 
	     *   skipping those entries which can no longer be removed.
	     * 
	     * parameters:
	     * elementParam - {DOMElement || String} 
	     */
	    stopObservingElement: function(elementParam) {
	        var element = OpenLayers.Util.getElement(elementParam);
	        var cacheID = element._eventCacheID;

	        this._removeElementObservers(OpenLayers.Event.observers[cacheID]);
	    },

	    /**
	     * Method: _removeElementObservers
	     *
	     * Parameters:
	     * elementObservers - {Array(Object)} Array of (element, name, 
	     *                                         observer, usecapture) objects, 
	     *                                         taken directly from hashtable
	     */
	    _removeElementObservers: function(elementObservers) {
	        if (elementObservers) {
	            for(var i = elementObservers.length-1; i >= 0; i--) {
	                var entry = elementObservers[i];
	                OpenLayers.Event.stopObserving.apply(this, [
	                    entry.element, entry.name, entry.observer, entry.useCapture
	                ]);
	            }
	        }
	    },

	    /**
	     * Method: stopObserving
	     * 
	     * Parameters:
	     * elementParam - {DOMElement || String} 
	     * name - {String} 
	     * observer - {function} 
	     * useCapture - {Boolean} 
	     *  
	     * Returns:
	     * {Boolean} Whether or not the event observer was removed
	     */
	    stopObserving: function(elementParam, name, observer, useCapture) {
	        useCapture = useCapture || false;
	    
	        var element = OpenLayers.Util.getElement(elementParam);
	        var cacheID = element._eventCacheID;

	        if (name == 'keypress') {
	            if ( navigator.appVersion.match(/Konqueror|Safari|KHTML/) || 
	                 element.detachEvent) {
	              name = 'keydown';
	            }
	        }

	        // find element's entry in this.observers cache and remove it
	        var foundEntry = false;
	        var elementObservers = OpenLayers.Event.observers[cacheID];
	        if (elementObservers) {
	    
	            // find the specific event type in the element's list
	            var i=0;
	            while(!foundEntry && i < elementObservers.length) {
	                var cacheEntry = elementObservers[i];
	    
	                if ((cacheEntry.name == name) &&
	                    (cacheEntry.observer == observer) &&
	                    (cacheEntry.useCapture == useCapture)) {
	    
	                    elementObservers.splice(i, 1);
	                    if (elementObservers.length == 0) {
	                        delete OpenLayers.Event.observers[cacheID];
	                    }
	                    foundEntry = true;
	                    break; 
	                }
	                i++;           
	            }
	        }
	    
	        //actually remove the event listener from browser
	        if (foundEntry) {
	            if (element.removeEventListener) {
	                element.removeEventListener(name, observer, useCapture);
	            } else if (element && element.detachEvent) {
	                element.detachEvent('on' + name, observer);
	            }
	        }
	        return foundEntry;
	    },
	    
	    /** 
	     * Method: unloadCache
	     * Cycle through all the element entries in the events cache and call
	     *   stopObservingElement on each. 
	     */
	    unloadCache: function() {
	        // check for OpenLayers.Event before checking for observers, because
	        // OpenLayers.Event may be undefined in IE if no map instance was
	        // created
	        if (OpenLayers.Event && OpenLayers.Event.observers) {
	            for (var cacheID in OpenLayers.Event.observers) {
	                var elementObservers = OpenLayers.Event.observers[cacheID];
	                OpenLayers.Event._removeElementObservers.apply(this, 
	                                                           [elementObservers]);
	            }
	            OpenLayers.Event.observers = false;
	        }
	    },

	    CLASS_NAME: "OpenLayers.Event"
	};

	/* prevent memory leaks in IE */
	OpenLayers.Event.observe(window, 'unload', OpenLayers.Event.unloadCache, false);

	/**
	 * Class: OpenLayers.Events
	 */
	OpenLayers.Events = OpenLayers.Class({

	    /** 
	     * Constant: BROWSER_EVENTS
	     * {Array(String)} supported events 
	     */
	    BROWSER_EVENTS: [
	        "mouseover", "mouseout",
	        "mousedown", "mouseup", "mousemove", 
	        "click", "dblclick", "rightclick", "dblrightclick",
	        "resize", "focus", "blur",
	        "touchstart", "touchmove", "touchend",
	        "keydown"
	    ],
	    
	    /**
	     * Constant: standard pointer model
	     * {string}
	     */
	    TOUCH_MODEL_POINTER: "pointer",

	    /**
	     * Constant: prefixed pointer model (IE10)
	     * {string}
	     */
	    TOUCH_MODEL_MSPOINTER: "MSPointer",

	    /**
	     * Constant: legacy touch model
	     * {string}
	     */
	    TOUCH_MODEL_TOUCH: "touch",

	    /** 
	     * Property: listeners 
	     * {Object} Hashtable of Array(Function): events listener functions  
	     */
	    listeners: null,

	    /** 
	     * Property: object 
	     * {Object}  the code object issuing application events 
	     */
	    object: null,

	    /** 
	     * Property: element 
	     * {DOMElement}  the DOM element receiving browser events 
	     */
	    element: null,

	    /** 
	     * Property: eventHandler 
	     * {Function}  bound event handler attached to elements 
	     */
	    eventHandler: null,

	    /** 
	     * APIProperty: fallThrough 
	     * {Boolean} 
	     */
	    fallThrough: null,

	    /** 
	     * APIProperty: includeXY
	     * {Boolean} Should the .xy property automatically be created for browser
	     *    mouse events? In general, this should be false. If it is true, then
	     *    mouse events will automatically generate a '.xy' property on the 
	     *    event object that is passed. (Prior to OpenLayers 2.7, this was true
	     *    by default.) Otherwise, you can call the getMousePosition on the
	     *    relevant events handler on the object available via the 'evt.object'
	     *    property of the evt object. So, for most events, you can call:
	     *    function named(evt) { 
	     *        this.xy = this.object.events.getMousePosition(evt) 
	     *    } 
	     *
	     *    This option typically defaults to false for performance reasons:
	     *    when creating an events object whose primary purpose is to manage
	     *    relatively positioned mouse events within a div, it may make
	     *    sense to set it to true.
	     *
	     *    This option is also used to control whether the events object caches
	     *    offsets. If this is false, it will not: the reason for this is that
	     *    it is only expected to be called many times if the includeXY property
	     *    is set to true. If you set this to true, you are expected to clear 
	     *    the offset cache manually (using this.clearMouseCache()) if:
	     *        the border of the element changes
	     *        the location of the element in the page changes
	    */
	    includeXY: false,      
	    
	    /**
	     * APIProperty: extensions
	     * {Object} Event extensions registered with this instance. Keys are
	     *     event types, values are {OpenLayers.Events.*} extension instances or
	     *     {Boolean} for events that an instantiated extension provides in
	     *     addition to the one it was created for.
	     *
	     * Extensions create an event in addition to browser events, which usually
	     * fires when a sequence of browser events is completed. Extensions are
	     * automatically instantiated when a listener is registered for an event
	     * provided by an extension.
	     *
	     * Extensions are created in the <OpenLayers.Events> namespace using
	     * <OpenLayers.Class>, and named after the event they provide.
	     * The constructor receives the target <OpenLayers.Events> instance as
	     * argument. Extensions that need to capture browser events before they
	     * propagate can register their listeners events using <register>, with
	     * {extension: true} as 4th argument.
	     *
	     * If an extension creates more than one event, an alias for each event
	     * type should be created and reference the same class. The constructor
	     * should set a reference in the target's extensions registry to itself.
	     *
	     * Below is a minimal extension that provides the "foostart" and "fooend"
	     * event types, which replace the native "click" event type if clicked on
	     * an element with the css class "foo":
	     *
	     * (code)
	     *   OpenLayers.Events.foostart = OpenLayers.Class({
	     *       initialize: function(target) {
	     *           this.target = target;
	     *           this.target.register("click", this, this.doStuff, {extension: true});
	     *           // only required if extension provides more than one event type
	     *           this.target.extensions["foostart"] = true;
	     *           this.target.extensions["fooend"] = true;
	     *       },
	     *       destroy: function() {
	     *           var target = this.target;
	     *           target.unregister("click", this, this.doStuff);
	     *           delete this.target;
	     *           // only required if extension provides more than one event type
	     *           delete target.extensions["foostart"];
	     *           delete target.extensions["fooend"];
	     *       },
	     *       doStuff: function(evt) {
	     *           var propagate = true;
	     *           if (OpenLayers.Event.element(evt).className === "foo") {
	     *               propagate = false;
	     *               var target = this.target;
	     *               target.triggerEvent("foostart");
	     *               window.setTimeout(function() {
	     *                   target.triggerEvent("fooend");
	     *               }, 1000);
	     *           }
	     *           return propagate;
	     *       }
	     *   });
	     *   // only required if extension provides more than one event type
	     *   OpenLayers.Events.fooend = OpenLayers.Events.foostart;
	     * (end)
	     * 
	     */
	    extensions: null,
	    
	    /**
	     * Property: extensionCount
	     * {Object} Keys are event types (like in <listeners>), values are the
	     *     number of extension listeners for each event type.
	     */
	    extensionCount: null,

	    /**
	     * Method: clearMouseListener
	     * A version of <clearMouseCache> that is bound to this instance so that
	     *     it can be used with <OpenLayers.Event.observe> and
	     *     <OpenLayers.Event.stopObserving>.
	     */
	    clearMouseListener: null,

	    /**
	     * Constructor: OpenLayers.Events
	     * Construct an OpenLayers.Events object.
	     *
	     * Parameters:
	     * object - {Object} The js object to which this Events object  is being added
	     * element - {DOMElement} A dom element to respond to browser events
	     * eventTypes - {Array(String)} Deprecated.  Array of custom application
	     *     events.  A listener may be registered for any named event, regardless
	     *     of the values provided here.
	     * fallThrough - {Boolean} Allow events to fall through after these have
	     *                         been handled?
	     * options - {Object} Options for the events object.
	     */
	    initialize: function (object, element, eventTypes, fallThrough, options) {
	        OpenLayers.Util.extend(this, options);
	        this.object     = object;
	        this.fallThrough = fallThrough;
	        this.listeners  = {};
	        this.extensions = {};
	        this.extensionCount = {};
	        this._pointerTouches = [];
	        
	        // if a dom element is specified, add a listeners list 
	        // for browser events on the element and register them
	        if (element != null) {
	            this.attachToElement(element);
	        }
	    },

	    /**
	     * APIMethod: destroy
	     */
	    destroy: function () {
	        for (var e in this.extensions) {
	            if (typeof this.extensions[e] !== "boolean") {
	                this.extensions[e].destroy();
	            }
	        }
	        this.extensions = null;
	        if (this.element) {
	            OpenLayers.Event.stopObservingElement(this.element);
	            if(this.element.hasScrollEvent) {
	                OpenLayers.Event.stopObserving(
	                    window, "scroll", this.clearMouseListener
	                );
	            }
	        }
	        this.element = null;

	        this.listeners = null;
	        this.object = null;
	        this.fallThrough = null;
	        this.eventHandler = null;
	    },

	    /**
	     * APIMethod: addEventType
	     * Deprecated.  Any event can be triggered without adding it first.
	     * 
	     * Parameters:
	     * eventName - {String}
	     */
	    addEventType: function(eventName) {
	    },

	    /**
	     * Method: attachToElement
	     *
	     * Parameters:
	     * element - {HTMLDOMElement} a DOM element to attach browser events to
	     */
	    attachToElement: function (element) {
	        if (this.element) {
	            OpenLayers.Event.stopObservingElement(this.element);
	        } else {
	            // keep a bound copy of handleBrowserEvent() so that we can
	            // pass the same function to both Event.observe() and .stopObserving()
	            this.eventHandler = OpenLayers.Function.bindAsEventListener(
	                this.handleBrowserEvent, this
	            );
	            
	            // to be used with observe and stopObserving
	            this.clearMouseListener = OpenLayers.Function.bind(
	                this.clearMouseCache, this
	            );
	        }
	        this.element = element;
	        var touchModel = this.getTouchModel();
	        var type;
	        for (var i = 0, len = this.BROWSER_EVENTS.length; i < len; i++) {
	            type = this.BROWSER_EVENTS[i];
	            // register the event cross-browser
	            OpenLayers.Event.observe(element, type, this.eventHandler
	            );
	            if ((touchModel === this.TOUCH_MODEL_POINTER ||
	                    touchModel === this.TOUCH_MODEL_MSPOINTER) &&
	                    type.indexOf('touch') === 0) {
	                this.addPointerTouchListener(element, type, this.eventHandler);
	            }
	        }
	        // disable dragstart in IE so that mousedown/move/up works normally
	        OpenLayers.Event.observe(element, "dragstart", OpenLayers.Event.stop);
	    },
	    
	    /**
	     * APIMethod: on
	     * Convenience method for registering listeners with a common scope.
	     *     Internally, this method calls <register> as shown in the examples
	     *     below.
	     *
	     * Example use:
	     * (code)
	     * // register a single listener for the "loadstart" event
	     * events.on({"loadstart": loadStartListener});
	     *
	     * // this is equivalent to the following
	     * events.register("loadstart", undefined, loadStartListener);
	     *
	     * // register multiple listeners to be called with the same `this` object
	     * events.on({
	     *     "loadstart": loadStartListener,
	     *     "loadend": loadEndListener,
	     *     scope: object
	     * });
	     *
	     * // this is equivalent to the following
	     * events.register("loadstart", object, loadStartListener);
	     * events.register("loadend", object, loadEndListener);
	     * (end)
	     *
	     * Parameters:
	     *  object - {Object}     
	     */
	    on: function(object) {
	        for(var type in object) {
	            if(type != "scope" && object.hasOwnProperty(type)) {
	                this.register(type, object.scope, object[type]);
	            }
	        }
	    },

	    /**
	     * APIMethod: register
	     * Register an event on the events object.
	     *
	     * When the event is triggered, the 'func' function will be called, in the
	     * context of 'obj'. Imagine we were to register an event, specifying an 
	     * OpenLayers.Bounds Object as 'obj'. When the event is triggered, the 
	     * context in the callback function will be our Bounds object. This means
	     * that within our callback function, we can access the properties and 
	     * methods of the Bounds object through the "this" variable. So our 
	     * callback could execute something like: 
	     * :    leftStr = "Left: " + this.left;
	     *   
	     *                   or
	     *  
	     * :    centerStr = "Center: " + this.getCenterLonLat();
	     *
	     * Parameters:
	     * type - {String} Name of the event to register
	     * obj - {Object} The object to bind the context to for the callback#.
	     *     If no object is specified, default is the Events's 'object' property.
	     * func - {Function} The callback function. If no callback is 
	     *     specified, this function does nothing.
	     * priority - {Boolean|Object} If true, adds the new listener to the
	     *     *front* of the events queue instead of to the end.
	     *
	     * Valid options for priority:
	     * extension - {Boolean} If true, then the event will be registered as
	     *     extension event. Extension events are handled before all other
	     *     events.
	     */
	    register: function (type, obj, func, priority) {
	        if (type in OpenLayers.Events && !this.extensions[type]) {
	            this.extensions[type] = new OpenLayers.Events[type](this);
	        }
	        if (func != null) {
	            if (obj == null)  {
	                obj = this.object;
	            }
	            var listeners = this.listeners[type];
	            if (!listeners) {
	                listeners = [];
	                this.listeners[type] = listeners;
	                this.extensionCount[type] = 0;
	            }
	            var listener = {obj: obj, func: func};
	            if (priority) {
	                listeners.splice(this.extensionCount[type], 0, listener);
	                if (typeof priority === "object" && priority.extension) {
	                    this.extensionCount[type]++;
	                }
	            } else {
	                listeners.push(listener);
	            }
	        }
	    },

	    /**
	     * APIMethod: registerPriority
	     * Same as register() but adds the new listener to the *front* of the
	     *     events queue instead of to the end.
	     *    
	     *     TODO: get rid of this in 3.0 - Decide whether listeners should be 
	     *     called in the order they were registered or in reverse order.
	     *
	     *
	     * Parameters:
	     * type - {String} Name of the event to register
	     * obj - {Object} The object to bind the context to for the callback#.
	     *                If no object is specified, default is the Events's 
	     *                'object' property.
	     * func - {Function} The callback function. If no callback is 
	     *                   specified, this function does nothing.
	     */
	    registerPriority: function (type, obj, func) {
	        this.register(type, obj, func, true);
	    },
	    
	    /**
	     * APIMethod: un
	     * Convenience method for unregistering listeners with a common scope.
	     *     Internally, this method calls <unregister> as shown in the examples
	     *     below.
	     *
	     * Example use:
	     * (code)
	     * // unregister a single listener for the "loadstart" event
	     * events.un({"loadstart": loadStartListener});
	     *
	     * // this is equivalent to the following
	     * events.unregister("loadstart", undefined, loadStartListener);
	     *
	     * // unregister multiple listeners with the same `this` object
	     * events.un({
	     *     "loadstart": loadStartListener,
	     *     "loadend": loadEndListener,
	     *     scope: object
	     * });
	     *
	     * // this is equivalent to the following
	     * events.unregister("loadstart", object, loadStartListener);
	     * events.unregister("loadend", object, loadEndListener);
	     * (end)
	     */
	    un: function(object) {
	        for(var type in object) {
	            if(type != "scope" && object.hasOwnProperty(type)) {
	                this.unregister(type, object.scope, object[type]);
	            }
	        }
	    },

	    /**
	     * APIMethod: unregister
	     *
	     * Parameters:
	     * type - {String} 
	     * obj - {Object} If none specified, defaults to this.object
	     * func - {Function} 
	     */
	    unregister: function (type, obj, func) {
	        if (obj == null)  {
	            obj = this.object;
	        }
	        var listeners = this.listeners[type];
	        if (listeners != null) {
	            for (var i=0, len=listeners.length; i<len; i++) {
	                if (listeners[i].obj == obj && listeners[i].func == func) {
	                    listeners.splice(i, 1);
	                    break;
	                }
	            }
	        }
	    },

	    /** 
	     * Method: remove
	     * Remove all listeners for a given event type. If type is not registered,
	     *     does nothing.
	     *
	     * Parameters:
	     * type - {String} 
	     */
	    remove: function(type) {
	        if (this.listeners[type] != null) {
	            this.listeners[type] = [];
	        }
	    },

	    /**
	     * APIMethod: triggerEvent
	     * Trigger a specified registered event.  
	     * 
	     * Parameters:
	     * type - {String} 
	     * evt - {Event || Object} will be passed to the listeners.
	     *
	     * Returns:
	     * {Boolean} The last listener return.  If a listener returns false, the
	     *     chain of listeners will stop getting called.
	     */
	    triggerEvent: function (type, evt) {
	        var listeners = this.listeners[type];

	        // fast path
	        if(!listeners || listeners.length == 0) {
	            return undefined;
	        }

	        // prep evt object with object & div references
	        if (evt == null) {
	            evt = {};
	        }
	        evt.object = this.object;
	        evt.element = this.element;
	        if(!evt.type) {
	            evt.type = type;
	        }
	    
	        // execute all callbacks registered for specified type
	        // get a clone of the listeners array to
	        // allow for splicing during callbacks
	        listeners = listeners.slice();
	        var continueChain;
	        for (var i=0, len=listeners.length; i<len; i++) {
	            var callback = listeners[i];
	            // bind the context to callback.obj
	            continueChain = callback.func.apply(callback.obj, [evt]);

	            if ((continueChain != undefined) && (continueChain == false)) {
	                // if callback returns false, execute no more callbacks.
	                break;
	            }
	        }
	        // don't fall through to other DOM elements
	        if (!this.fallThrough) {           
	            OpenLayers.Event.stop(evt, true);
	        }
	        return continueChain;
	    },

	    /**
	     * Method: handleBrowserEvent
	     * Basically just a wrapper to the triggerEvent() function, but takes 
	     *     care to set a property 'xy' on the event with the current mouse 
	     *     position.
	     *
	     * Parameters:
	     * evt - {Event} 
	     */
	    handleBrowserEvent: function (evt) {
	        var type = evt.type, listeners = this.listeners[type];
	        if(!listeners || listeners.length == 0) {
	            // noone's listening, bail out
	            return;
	        }
	        // add clientX & clientY to all events - corresponds to average x, y
	        var touches = evt.touches;
	        if (touches && touches[0]) {
	            var x = 0;
	            var y = 0;
	            var num = touches.length;
	            var touch;
	            for (var i=0; i<num; ++i) {
	                touch = this.getTouchClientXY(touches[i]);
	                x += touch.clientX;
	                y += touch.clientY;
	            }
	            evt.clientX = x / num;
	            evt.clientY = y / num;
	        }
	        if (this.includeXY) {
	            evt.xy = this.getMousePosition(evt);
	        } 
	        this.triggerEvent(type, evt);
	    },
	    
	    /**
	     * Method: getTouchClientXY
	     * WebKit has a few bugs for clientX/clientY. This method detects them
	     * and calculate the correct values.
	     *
	     * Parameters:
	     * evt - {Touch} a Touch object from a TouchEvent
	     * 
	     * Returns:
	     * {Object} An object with only clientX and clientY properties with the
	     * calculated values.
	     */
	    getTouchClientXY: function (evt) {
	        // olMochWin is to override window, used for testing
	        var win = window.olMockWin || window,
	            winPageX = win.pageXOffset,
	            winPageY = win.pageYOffset,
	            x = evt.clientX,
	            y = evt.clientY;
	        
	        if (evt.pageY === 0 && Math.floor(y) > Math.floor(evt.pageY) ||
	            evt.pageX === 0 && Math.floor(x) > Math.floor(evt.pageX)) {
	            // iOS4 include scroll offset in clientX/Y
	            x = x - winPageX;
	            y = y - winPageY;
	        } else if (y < (evt.pageY - winPageY) || x < (evt.pageX - winPageX) ) {
	            // Some Android browsers have totally bogus values for clientX/Y
	            // when scrolling/zooming a page
	            x = evt.pageX - winPageX;
	            y = evt.pageY - winPageY;
	        }
	        
	        evt.olClientX = x;
	        evt.olClientY = y;
	        
	        return {
	            clientX: x,
	            clientY: y
	        };
	    },
	    
	    /**
	     * APIMethod: clearMouseCache
	     * Clear cached data about the mouse position. This should be called any 
	     *     time the element that events are registered on changes position 
	     *     within the page.
	     */
	    clearMouseCache: function() { 
	        this.element.scrolls = null;
	        this.element.lefttop = null;
	        this.element.offsets = null;
	    },      

	    /**
	     * Method: getMousePosition
	     * 
	     * Parameters:
	     * evt - {Event} 
	     * 
	     * Returns:
	     * {<OpenLayers.Pixel>} The current xy coordinate of the mouse, adjusted
	     *                      for offsets
	     */
	    getMousePosition: function (evt) {
	        if (!this.includeXY) {
	            this.clearMouseCache();
	        } else if (!this.element.hasScrollEvent) {
	            OpenLayers.Event.observe(window, "scroll", this.clearMouseListener);
	            this.element.hasScrollEvent = true;
	        }
	        
	        if (!this.element.scrolls) {
	            var viewportElement = OpenLayers.Util.getViewportElement();
	            this.element.scrolls = [
	                window.pageXOffset || viewportElement.scrollLeft,
	                window.pageYOffset || viewportElement.scrollTop
	            ];
	        }

	        if (!this.element.lefttop) {
	            this.element.lefttop = [
	                (document.documentElement.clientLeft || 0),
	                (document.documentElement.clientTop  || 0)
	            ];
	        }
	        
	        if (!this.element.offsets) {
	            this.element.offsets = OpenLayers.Util.pagePosition(this.element);
	        }

	        return new OpenLayers.Pixel(
	            (evt.clientX + this.element.scrolls[0]) - this.element.offsets[0]
	                         - this.element.lefttop[0], 
	            (evt.clientY + this.element.scrolls[1]) - this.element.offsets[1]
	                         - this.element.lefttop[1]
	        ); 
	    },

	    /**
	     * Method: getTouchModel
	     * Get the touch model currently in use.
	     * 
	     * This is cached on OpenLayers.Events as _TOUCH_MODEL 
	     * 
	     * Returns:
	     * {string} The current touch model (TOUCH_MODEL_xxx), null if none
	     */
	    getTouchModel: function() {
	        if (!("_TOUCH_MODEL" in OpenLayers.Events)) {
	            OpenLayers.Events._TOUCH_MODEL =
	                    (window.PointerEvent && "pointer") ||
	                    (window.MSPointerEvent && "MSPointer") ||
	                    (("ontouchdown" in document) && "touch") ||
	                    null;
	        }
	        return OpenLayers.Events._TOUCH_MODEL;
	    },

	    /**
	     * Method: addPointerTouchListener
	     *
	     * Parameters:
	     * element - {DOMElement} The DOM element to register the listener on
	     * type - {String} The event type
	     * handler - {Function} the handler
	     */
	    addPointerTouchListener: function (element, type, handler) {
	        var eventHandler = this.eventHandler;
	        var touches = this._pointerTouches;

	        function pointerHandler(evt) {
	            handler(OpenLayers.Util.applyDefaults({
	                stopPropagation: function() {
	                    for (var i=touches.length-1; i>=0; --i) {
	                        touches[i].stopPropagation();
	                    }
	                },
	                preventDefault: function() {
	                    for (var i=touches.length-1; i>=0; --i) {
	                        touches[i].preventDefault();
	                    }
	                },
	                type: type
	            }, evt));
	        }

	        switch (type) {
	            case 'touchstart':
	                return this.addPointerTouchListenerStart(element, type, pointerHandler);
	            case 'touchend':
	                return this.addPointerTouchListenerEnd(element, type, pointerHandler);
	            case 'touchmove':
	                return this.addPointerTouchListenerMove(element, type, pointerHandler);
	            default:
	                throw 'Unknown touch event type';
	        }
	    },

	    /**
	     * Method: addPointerTouchListenerStart
	     *
	     * Parameters:
	     * element - {DOMElement} The DOM element to register the listener on
	     * type - {String} The event type
	     * handler - {Function} the handler
	     */
	    addPointerTouchListenerStart: function(element, type, handler) {
	        var touches = this._pointerTouches;

	        var cb = function(e) {

	            // pointer could be mouse or pen
	            if (!OpenLayers.Event.isTouchEvent(e)) {
	                return;
	            }

	            var alreadyInArray = false;
	            for (var i=0, ii=touches.length; i<ii; ++i) {
	                if (touches[i].pointerId == e.pointerId) {
	                    alreadyInArray = true;
	                    break;
	                }
	            }
	            if (!alreadyInArray) {
	                touches.push(e);
	            }

	            e.touches = touches.slice();
	            handler(e);
	        };

	        OpenLayers.Event.observe(element,
	                this.getTouchModel() === this.TOUCH_MODEL_MSPOINTER ?
	                        'MSPointerDown' : 'pointerdown',
	                cb);
	        
	        // the pointerId only needs to be removed from the _pointerTouches array
	        // when the pointer has left its element
	        var internalCb = function (e) {

	            // pointer could be mouse or pen
	            if (!OpenLayers.Event.isTouchEvent(e)) {
	            	return;
	            }

	            var up = false;
	            for (var i = 0, ii = touches.length; i < ii; ++i) {
	                if (touches[i].pointerId == e.pointerId) {
	                    if (this.clientWidth != 0 && this.clientHeight != 0) {
	                        if ((Math.ceil(e.clientX) >= this.clientWidth || Math.ceil(e.clientY) >= this.clientHeight)) {
	                            touches.splice(i, 1);
	                        }
	                    }
	                    break;
	                }
	            }
	        };
	        OpenLayers.Event.observe(element,
	                this.getTouchModel() === this.TOUCH_MODEL_MSPOINTER ?
	                        'MSPointerOut' : 'pointerout',
	                internalCb);
	    },

	    /**
	     * Method: addPointerTouchListenerMove
	     *
	     * Parameters:
	     * element - {DOMElement} The DOM element to register the listener on
	     * type - {String} The event type
	     * handler - {Function} the handler
	     */
	    addPointerTouchListenerMove: function (element, type, handler) {
	        var touches = this._pointerTouches;
	        var cb = function(e) {

	            // pointer could be mouse or pen
	            if (!OpenLayers.Event.isTouchEvent(e)) {
	                return;
	            }

	            if (touches.length == 1 && touches[0].pageX == e.pageX &&
	                    touches[0].pageY == e.pageY) {
	                // don't trigger event when pointer has not moved
	                return;
	            }
	            for (var i=0, ii=touches.length; i<ii; ++i) {
	                if (touches[i].pointerId == e.pointerId) {
	                    touches[i] = e;
	                    break;
	                }
	            }

	            e.touches = touches.slice();
	            handler(e);
	        };

	        OpenLayers.Event.observe(element,
	                this.getTouchModel() === this.TOUCH_MODEL_MSPOINTER ?
	                        'MSPointerMove' : 'pointermove',
	                cb);
	    },

	    /**
	     * Method: addPointerTouchListenerEnd
	     *
	     * Parameters:
	     * element - {DOMElement} The DOM element to register the listener on
	     * type - {String} The event type
	     * handler - {Function} the handler
	     */
	    addPointerTouchListenerEnd: function (element, type, handler) {
	        var touches = this._pointerTouches;

	        var cb = function(e) {

	            // pointer could be mouse or pen
	            if (!OpenLayers.Event.isTouchEvent(e)) {
	            	return;
	            }

	            for (var i=0, ii=touches.length; i<ii; ++i) {
	                if (touches[i].pointerId == e.pointerId) {
	                    touches.splice(i, 1);
	                    break;
	                }
	            }
	            
	            e.touches = touches.slice();
	            handler(e);
	        };

	        OpenLayers.Event.observe(element,
	                this.getTouchModel() === this.TOUCH_MODEL_MSPOINTER ?
	                        'MSPointerUp' : 'pointerup',
	                cb);
	    },

	    CLASS_NAME: "OpenLayers.Events"
	});
	/* ======================================================================
	    OpenLayers/Handler.js
	   ====================================================================== */

	/* Copyright (c) 2006-2015 by OpenLayers Contributors (see authors.txt for
	 * full list of contributors). Published under the 2-clause BSD license.
	 * See license.txt in the OpenLayers distribution or repository for the
	 * full text of the license. */

	/**
	 * @requires OpenLayers/BaseTypes/Class.js
	 * @requires OpenLayers/Events.js
	 */

	/**
	 * Class: OpenLayers.Handler
	 * Base class to construct a higher-level handler for event sequences.  All
	 *     handlers have activate and deactivate methods.  In addition, they have
	 *     methods named like browser events.  When a handler is activated, any
	 *     additional methods named like a browser event is registered as a
	 *     listener for the corresponding event.  When a handler is deactivated,
	 *     those same methods are unregistered as event listeners.
	 *
	 * Handlers also typically have a callbacks object with keys named like
	 *     the abstracted events or event sequences that they are in charge of
	 *     handling.  The controls that wrap handlers define the methods that
	 *     correspond to these abstract events - so instead of listening for
	 *     individual browser events, they only listen for the abstract events
	 *     defined by the handler.
	 *     
	 * Handlers are created by controls, which ultimately have the responsibility
	 *     of making changes to the the state of the application.  Handlers
	 *     themselves may make temporary changes, but in general are expected to
	 *     return the application in the same state that they found it.
	 */
	OpenLayers.Handler = OpenLayers.Class({

	    /**
	     * Property: id
	     * {String}
	     */
	    id: null,
	        
	    /**
	     * APIProperty: control
	     * {<OpenLayers.Control>}. The control that initialized this handler.  The
	     *     control is assumed to have a valid map property - that map is used
	     *     in the handler's own setMap method.
	     */
	    control: null,

	    /**
	     * Property: map
	     * {<OpenLayers.Map>}
	     */
	    map: null,

	    /**
	     * APIProperty: keyMask
	     * {Integer} Use bitwise operators and one or more of the OpenLayers.Handler
	     *     constants to construct a keyMask.  The keyMask is used by
	     *     <checkModifiers>.  If the keyMask matches the combination of keys
	     *     down on an event, checkModifiers returns true.
	     *
	     * Example:
	     * (code)
	     *     // handler only responds if the Shift key is down
	     *     handler.keyMask = OpenLayers.Handler.MOD_SHIFT;
	     *
	     *     // handler only responds if Ctrl-Shift is down
	     *     handler.keyMask = OpenLayers.Handler.MOD_SHIFT |
	     *                       OpenLayers.Handler.MOD_CTRL;
	     * (end)
	     */
	    keyMask: null,

	    /**
	     * Property: active
	     * {Boolean}
	     */
	    active: false,
	    
	    /**
	     * Property: evt
	     * {Event} This property references the last event handled by the handler.
	     *     Note that this property is not part of the stable API.  Use of the
	     *     evt property should be restricted to controls in the library
	     *     or other applications that are willing to update with changes to
	     *     the OpenLayers code.
	     */
	    evt: null,
	    
	    /**
	     * Property: touch
	     * {Boolean} Indicates the support of touch events. When touch events are 
	     *     started touch will be true and all mouse related listeners will do 
	     *     nothing.
	     */
	    touch: false,

	    /**
	     * Constructor: OpenLayers.Handler
	     * Construct a handler.
	     *
	     * Parameters:
	     * control - {<OpenLayers.Control>} The control that initialized this
	     *     handler.  The control is assumed to have a valid map property; that
	     *     map is used in the handler's own setMap method.  If a map property
	     *     is present in the options argument it will be used instead.
	     * callbacks - {Object} An object whose properties correspond to abstracted
	     *     events or sequences of browser events.  The values for these
	     *     properties are functions defined by the control that get called by
	     *     the handler.
	     * options - {Object} An optional object whose properties will be set on
	     *     the handler.
	     */
	    initialize: function(control, callbacks, options) {
	        OpenLayers.Util.extend(this, options);
	        this.control = control;
	        this.callbacks = callbacks;

	        var map = this.map || control.map;
	        if (map) {
	            this.setMap(map); 
	        }
	        
	        this.id = OpenLayers.Util.createUniqueID(this.CLASS_NAME + "_");
	    },
	    
	    /**
	     * Method: setMap
	     */
	    setMap: function (map) {
	        this.map = map;
	    },

	    /**
	     * Method: checkModifiers
	     * Check the keyMask on the handler.  If no <keyMask> is set, this always
	     *     returns true.  If a <keyMask> is set and it matches the combination
	     *     of keys down on an event, this returns true.
	     *
	     * Returns:
	     * {Boolean} The keyMask matches the keys down on an event.
	     */
	    checkModifiers: function (evt) {
	        if(this.keyMask == null) {
	            return true;
	        }
	        /* calculate the keyboard modifier mask for this event */
	        var keyModifiers =
	            (evt.shiftKey ? OpenLayers.Handler.MOD_SHIFT : 0) |
	            (evt.ctrlKey  ? OpenLayers.Handler.MOD_CTRL  : 0) |
	            (evt.altKey   ? OpenLayers.Handler.MOD_ALT   : 0) |
	            (evt.metaKey  ? OpenLayers.Handler.MOD_META  : 0);
	    
	        /* if it differs from the handler object's key mask,
	           bail out of the event handler */
	        return (keyModifiers == this.keyMask);
	    },

	    /**
	     * APIMethod: activate
	     * Turn on the handler.  Returns false if the handler was already active.
	     * 
	     * Returns: 
	     * {Boolean} The handler was activated.
	     */
	    activate: function() {
	        if(this.active) {
	            return false;
	        }
	        // register for event handlers defined on this class.
	        var events = OpenLayers.Events.prototype.BROWSER_EVENTS;
	        for (var i=0, len=events.length; i<len; i++) {
	            if (this[events[i]]) {
	                this.register(events[i], this[events[i]]); 
	            }
	        } 
	        this.active = true;
	        return true;
	    },
	    
	    /**
	     * APIMethod: deactivate
	     * Turn off the handler.  Returns false if the handler was already inactive.
	     * 
	     * Returns:
	     * {Boolean} The handler was deactivated.
	     */
	    deactivate: function() {
	        if(!this.active) {
	            return false;
	        }
	        // unregister event handlers defined on this class.
	        var events = OpenLayers.Events.prototype.BROWSER_EVENTS;
	        for (var i=0, len=events.length; i<len; i++) {
	            if (this[events[i]]) {
	                this.unregister(events[i], this[events[i]]); 
	            }
	        } 
	        this.touch = false;
	        this.active = false;
	        return true;
	    },

	    /**
	     * Method: startTouch
	     * Start touch events, this method must be called by subclasses in 
	     *     "touchstart" method. When touch events are started <touch> will be
	     *     true and all mouse related listeners will do nothing.
	     */
	    startTouch: function() {
	        if (!this.touch) {
	            this.touch = true;
	            var events = [
	                "mousedown", "mouseup", "mousemove", "click", "dblclick",
	                "mouseout"
	            ];
	            for (var i=0, len=events.length; i<len; i++) {
	                if (this[events[i]]) {
	                    this.unregister(events[i], this[events[i]]); 
	                }
	            } 
	        }
	    },

	    /**
	    * Method: callback
	    * Trigger the control's named callback with the given arguments
	    *
	    * Parameters:
	    * name - {String} The key for the callback that is one of the properties
	    *     of the handler's callbacks object.
	    * args - {Array(*)} An array of arguments (any type) with which to call 
	    *     the callback (defined by the control).
	    */
	    callback: function (name, args) {
	        if (name && this.callbacks[name]) {
	            this.callbacks[name].apply(this.control, args);
	        }
	    },

	    /**
	    * Method: register
	    * register an event on the map
	    */
	    register: function (name, method) {
	        // TODO: deal with registerPriority in 3.0
	        this.map.events.registerPriority(name, this, method);
	        this.map.events.registerPriority(name, this, this.setEvent);
	    },

	    /**
	    * Method: unregister
	    * unregister an event from the map
	    */
	    unregister: function (name, method) {
	        this.map.events.unregister(name, this, method);   
	        this.map.events.unregister(name, this, this.setEvent);
	    },
	    
	    /**
	     * Method: setEvent
	     * With each registered browser event, the handler sets its own evt
	     *     property.  This property can be accessed by controls if needed
	     *     to get more information about the event that the handler is
	     *     processing.
	     *
	     * This allows modifier keys on the event to be checked (alt, shift, ctrl,
	     *     and meta cannot be checked with the keyboard handler).  For a
	     *     control to determine which modifier keys are associated with the
	     *     event that a handler is currently processing, it should access
	     *     (code)handler.evt.altKey || handler.evt.shiftKey ||
	     *     handler.evt.ctrlKey || handler.evt.metaKey(end).
	     *
	     * Parameters:
	     * evt - {Event} The browser event.
	     */
	    setEvent: function(evt) {
	        this.evt = evt;
	        return true;
	    },

	    /**
	     * Method: destroy
	     * Deconstruct the handler.
	     */
	    destroy: function () {
	        // unregister event listeners
	        this.deactivate();
	        // eliminate circular references
	        this.control = this.map = null;        
	    },

	    CLASS_NAME: "OpenLayers.Handler"
	});

	/**
	 * Constant: OpenLayers.Handler.MOD_NONE
	 * If set as the <keyMask>, <checkModifiers> returns false if any key is down.
	 */
	OpenLayers.Handler.MOD_NONE  = 0;

	/**
	 * Constant: OpenLayers.Handler.MOD_SHIFT
	 * If set as the <keyMask>, <checkModifiers> returns false if Shift is down.
	 */
	OpenLayers.Handler.MOD_SHIFT = 1;

	/**
	 * Constant: OpenLayers.Handler.MOD_CTRL
	 * If set as the <keyMask>, <checkModifiers> returns false if Ctrl is down.
	 */
	OpenLayers.Handler.MOD_CTRL  = 2;

	/**
	 * Constant: OpenLayers.Handler.MOD_ALT
	 * If set as the <keyMask>, <checkModifiers> returns false if Alt is down.
	 */
	OpenLayers.Handler.MOD_ALT   = 4;

	/**
	 * Constant: OpenLayers.Handler.MOD_META
	 * If set as the <keyMask>, <checkModifiers> returns false if Cmd is down.
	 */
	OpenLayers.Handler.MOD_META  = 8;


	/* ======================================================================
	    OpenLayers/Icon.js
	   ====================================================================== */

	/* Copyright (c) 2006-2015 by OpenLayers Contributors (see authors.txt for
	 * full list of contributors). Published under the 2-clause BSD license.
	 * See license.txt in the OpenLayers distribution or repository for the
	 * full text of the license. */

	/**
	 * @requires OpenLayers/BaseTypes/Class.js
	 */

	/**
	 * Class: OpenLayers.Icon
	 * 
	 * The icon represents a graphical icon on the screen.  Typically used in
	 * conjunction with a <OpenLayers.Marker> to represent markers on a screen.
	 *
	 * An icon has a url, size and position.  It also contains an offset which 
	 * allows the center point to be represented correctly.  This can be
	 * provided either as a fixed offset or a function provided to calculate
	 * the desired offset. 
	 * 
	 */
	OpenLayers.Icon = OpenLayers.Class({
	    
	    /** 
	     * Property: url 
	     * {String}  image url
	     */
	    url: null,
	    
	    /** 
	     * Property: size 
	     * {<OpenLayers.Size>|Object} An OpenLayers.Size or
	     * an object with a 'w' and 'h' properties.
	     */
	    size: null,

	    /** 
	     * Property: offset 
	     * {<OpenLayers.Pixel>|Object} distance in pixels to offset the
	     * image when being rendered. An OpenLayers.Pixel or an object
	     * with a 'x' and 'y' properties.
	     */
	    offset: null,    
	    
	    /** 
	     * Property: calculateOffset 
	     * {Function} Function to calculate the offset (based on the size)
	     */
	    calculateOffset: null,    
	    
	    /** 
	     * Property: imageDiv 
	     * {DOMElement} 
	     */
	    imageDiv: null,

	    /** 
	     * Property: px 
	     * {<OpenLayers.Pixel>|Object} An OpenLayers.Pixel or an object
	     * with a 'x' and 'y' properties.
	     */
	    px: null,
	    
	    /** 
	     * Constructor: OpenLayers.Icon
	     * Creates an icon, which is an image tag in a div.  
	     *
	     * url - {String} 
	     * size - {<OpenLayers.Size>|Object} An OpenLayers.Size or an
	     *                                   object with a 'w' and 'h'
	     *                                   properties.
	     * offset - {<OpenLayers.Pixel>|Object} An OpenLayers.Pixel or an
	     *                                      object with a 'x' and 'y'
	     *                                      properties.
	     * calculateOffset - {Function} 
	     */
	    initialize: function(url, size, offset, calculateOffset) {
	        this.url = url;
	        this.size = size || {w: 20, h: 20};
	        this.offset = offset || {x: -(this.size.w/2), y: -(this.size.h/2)};
	        this.calculateOffset = calculateOffset;

	        var id = OpenLayers.Util.createUniqueID("OL_Icon_");
	        this.imageDiv = OpenLayers.Util.createAlphaImageDiv(id);
	    },
	    
	    /** 
	     * Method: destroy
	     * Nullify references and remove event listeners to prevent circular 
	     * references and memory leaks
	     */
	    destroy: function() {
	        // erase any drawn elements
	        this.erase();

	        OpenLayers.Event.stopObservingElement(this.imageDiv.firstChild); 
	        this.imageDiv.innerHTML = "";
	        this.imageDiv = null;
	    },

	    /** 
	     * Method: clone
	     * 
	     * Returns:
	     * {<OpenLayers.Icon>} A fresh copy of the icon.
	     */
	    clone: function() {
	        return new OpenLayers.Icon(this.url, 
	                                   this.size, 
	                                   this.offset, 
	                                   this.calculateOffset);
	    },
	    
	    /**
	     * Method: setSize
	     * 
	     * Parameters:
	     * size - {<OpenLayers.Size>|Object} An OpenLayers.Size or
	     * an object with a 'w' and 'h' properties.
	     */
	    setSize: function(size) {
	        if (size != null) {
	            this.size = size;
	        }
	        this.draw();
	    },
	    
	    /**
	     * Method: setUrl
	     * 
	     * Parameters:
	     * url - {String} 
	     */
	    setUrl: function(url) {
	        if (url != null) {
	            this.url = url;
	        }
	        this.draw();
	    },

	    /** 
	     * Method: draw
	     * Move the div to the given pixel.
	     * 
	     * Parameters:
	     * px - {<OpenLayers.Pixel>|Object} An OpenLayers.Pixel or an
	     *                                  object with a 'x' and 'y' properties.
	     * 
	     * Returns:
	     * {DOMElement} A new DOM Image of this icon set at the location passed-in
	     */
	    draw: function(px) {
	        OpenLayers.Util.modifyAlphaImageDiv(this.imageDiv, 
	                                            null, 
	                                            null, 
	                                            this.size, 
	                                            this.url, 
	                                            "absolute");
	        this.moveTo(px);
	        return this.imageDiv;
	    }, 

	    /** 
	     * Method: erase
	     * Erase the underlying image element.
	     */
	    erase: function() {
	        if (this.imageDiv != null && this.imageDiv.parentNode != null) {
	            OpenLayers.Element.remove(this.imageDiv);
	        }
	    }, 
	    
	    /** 
	     * Method: setOpacity
	     * Change the icon's opacity
	     *
	     * Parameters:
	     * opacity - {float} 
	     */
	    setOpacity: function(opacity) {
	        OpenLayers.Util.modifyAlphaImageDiv(this.imageDiv, null, null, null, 
	                                            null, null, null, null, opacity);

	    },
	    
	    /**
	     * Method: moveTo
	     * move icon to passed in px.
	     *
	     * Parameters:
	     * px - {<OpenLayers.Pixel>|Object} the pixel position to move to.
	     * An OpenLayers.Pixel or an object with a 'x' and 'y' properties.
	     */
	    moveTo: function (px) {
	        //if no px passed in, use stored location
	        if (px != null) {
	            this.px = px;
	        }

	        if (this.imageDiv != null) {
	            if (this.px == null) {
	                this.display(false);
	            } else {
	                if (this.calculateOffset) {
	                    this.offset = this.calculateOffset(this.size);  
	                }
	                OpenLayers.Util.modifyAlphaImageDiv(this.imageDiv, null, {
	                    x: this.px.x + this.offset.x,
	                    y: this.px.y + this.offset.y
	                });
	            }
	        }
	    },
	    
	    /** 
	     * Method: display
	     * Hide or show the icon
	     *
	     * Parameters:
	     * display - {Boolean} 
	     */
	    display: function(display) {
	        this.imageDiv.style.display = (display) ? "" : "none"; 
	    },
	    

	    /**
	     * APIMethod: isDrawn
	     * 
	     * Returns:
	     * {Boolean} Whether or not the icon is drawn.
	     */
	    isDrawn: function() {
	        // nodeType 11 for ie, whose nodes *always* have a parentNode
	        // (of type document fragment)
	        var isDrawn = (this.imageDiv && this.imageDiv.parentNode && 
	                       (this.imageDiv.parentNode.nodeType != 11));    

	        return isDrawn;   
	    },

	    CLASS_NAME: "OpenLayers.Icon"
	});
	/* ======================================================================
	    OpenLayers/Marker.js
	   ====================================================================== */

	/* Copyright (c) 2006-2015 by OpenLayers Contributors (see authors.txt for
	 * full list of contributors). Published under the 2-clause BSD license.
	 * See license.txt in the OpenLayers distribution or repository for the
	 * full text of the license. */


	/**
	 * @requires OpenLayers/BaseTypes/Class.js
	 * @requires OpenLayers/Events.js
	 * @requires OpenLayers/Icon.js
	 */

	/**
	 * Class: OpenLayers.Marker
	 * Instances of OpenLayers.Marker are a combination of a 
	 * <OpenLayers.LonLat> and an <OpenLayers.Icon>.  
	 *
	 * Markers are generally added to a special layer called
	 * <OpenLayers.Layer.Markers>.
	 *
	 * Example:
	 * (code)
	 * var markers = new OpenLayers.Layer.Markers( "Markers" );
	 * map.addLayer(markers);
	 *
	 * var size = new OpenLayers.Size(21,25);
	 * var offset = new OpenLayers.Pixel(-(size.w/2), -size.h);
	 * var icon = new OpenLayers.Icon('http://www.openlayers.org/dev/img/marker.png', size, offset);
	 * markers.addMarker(new OpenLayers.Marker(new OpenLayers.LonLat(0,0),icon));
	 * markers.addMarker(new OpenLayers.Marker(new OpenLayers.LonLat(0,0),icon.clone()));
	 *
	 * (end)
	 *
	 * Note that if you pass an icon into the Marker constructor, it will take
	 * that icon and use it. This means that you should not share icons between
	 * markers -- you use them once, but you should clone() for any additional
	 * markers using that same icon.
	 */
	OpenLayers.Marker = OpenLayers.Class({
	    
	    /** 
	     * Property: icon 
	     * {<OpenLayers.Icon>} The icon used by this marker.
	     */
	    icon: null,

	    /** 
	     * Property: lonlat 
	     * {<OpenLayers.LonLat>} location of object
	     */
	    lonlat: null,
	    
	    /** 
	     * Property: events 
	     * {<OpenLayers.Events>} the event handler.
	     */
	    events: null,
	    
	    /** 
	     * Property: map 
	     * {<OpenLayers.Map>} the map this marker is attached to
	     */
	    map: null,
	    
	    /** 
	     * Constructor: OpenLayers.Marker
	     *
	     * Parameters:
	     * lonlat - {<OpenLayers.LonLat>} the position of this marker
	     * icon - {<OpenLayers.Icon>}  the icon for this marker
	     */
	    initialize: function(lonlat, icon) {
	        this.lonlat = lonlat;
	        
	        var newIcon = (icon) ? icon : OpenLayers.Marker.defaultIcon();
	        if (this.icon == null) {
	            this.icon = newIcon;
	        } else {
	            this.icon.url = newIcon.url;
	            this.icon.size = newIcon.size;
	            this.icon.offset = newIcon.offset;
	            this.icon.calculateOffset = newIcon.calculateOffset;
	        }
	        this.events = new OpenLayers.Events(this, this.icon.imageDiv);
	    },
	    
	    /**
	     * APIMethod: destroy
	     * Destroy the marker. You must first remove the marker from any 
	     * layer which it has been added to, or you will get buggy behavior.
	     * (This can not be done within the marker since the marker does not
	     * know which layer it is attached to.)
	     */
	    destroy: function() {
	        // erase any drawn features
	        this.erase();

	        this.map = null;

	        this.events.destroy();
	        this.events = null;

	        if (this.icon != null) {
	            this.icon.destroy();
	            this.icon = null;
	        }
	    },
	    
	    /** 
	    * Method: draw
	    * Calls draw on the icon, and returns that output.
	    * 
	    * Parameters:
	    * px - {<OpenLayers.Pixel>}
	    * 
	    * Returns:
	    * {DOMElement} A new DOM Image with this marker's icon set at the 
	    * location passed-in
	    */
	    draw: function(px) {
	        return this.icon.draw(px);
	    }, 

	    /** 
	    * Method: erase
	    * Erases any drawn elements for this marker.
	    */
	    erase: function() {
	        if (this.icon != null) {
	            this.icon.erase();
	        }
	    }, 

	    /**
	    * Method: moveTo
	    * Move the marker to the new location.
	    *
	    * Parameters:
	    * px - {<OpenLayers.Pixel>|Object} the pixel position to move to.
	    * An OpenLayers.Pixel or an object with a 'x' and 'y' properties.
	    */
	    moveTo: function (px) {
	        if ((px != null) && (this.icon != null)) {
	            this.icon.moveTo(px);
	        }           
	        this.lonlat = this.map.getLonLatFromLayerPx(px);
	    },

	    /**
	     * APIMethod: isDrawn
	     * 
	     * Returns:
	     * {Boolean} Whether or not the marker is drawn.
	     */
	    isDrawn: function() {
	        var isDrawn = (this.icon && this.icon.isDrawn());
	        return isDrawn;   
	    },

	    /**
	     * Method: onScreen
	     *
	     * Returns:
	     * {Boolean} Whether or not the marker is currently visible on screen.
	     */
	    onScreen:function() {
	        
	        var onScreen = false;
	        if (this.map) {
	            var screenBounds = this.map.getExtent();
	            onScreen = screenBounds.containsLonLat(this.lonlat);
	        }    
	        return onScreen;
	    },
	    
	    /**
	     * Method: inflate
	     * Englarges the markers icon by the specified ratio.
	     *
	     * Parameters:
	     * inflate - {float} the ratio to enlarge the marker by (passing 2
	     *                   will double the size).
	     */
	    inflate: function(inflate) {
	        if (this.icon) {
	            this.icon.setSize({
	                w: this.icon.size.w * inflate,
	                h: this.icon.size.h * inflate
	            });
	        }        
	    },
	    
	    /** 
	     * Method: setOpacity
	     * Change the opacity of the marker by changin the opacity of 
	     *   its icon
	     * 
	     * Parameters:
	     * opacity - {float}  Specified as fraction (0.4, etc)
	     */
	    setOpacity: function(opacity) {
	        this.icon.setOpacity(opacity);
	    },

	    /**
	     * Method: setUrl
	     * Change URL of the Icon Image.
	     * 
	     * url - {String} 
	     */
	    setUrl: function(url) {
	        this.icon.setUrl(url);
	    },    

	    /** 
	     * Method: display
	     * Hide or show the icon
	     * 
	     * display - {Boolean} 
	     */
	    display: function(display) {
	        this.icon.display(display);
	    },

	    CLASS_NAME: "OpenLayers.Marker"
	});


	/**
	 * Function: defaultIcon
	 * Creates a default <OpenLayers.Icon>.
	 * 
	 * Returns:
	 * {<OpenLayers.Icon>} A default OpenLayers.Icon to use for a marker
	 */
	OpenLayers.Marker.defaultIcon = function() {
	    return new OpenLayers.Icon(OpenLayers.Util.getImageLocation("marker.png"),
	                               {w: 21, h: 25}, {x: -10.5, y: -25});
	};
	    

	/* ======================================================================
	    OpenLayers/Util/vendorPrefix.js
	   ====================================================================== */

	/* Copyright (c) 2006-2015 by OpenLayers Contributors (see authors.txt for
	 * full list of contributors). Published under the 2-clause BSD license.
	 * See license.txt in the OpenLayers distribution or repository for the
	 * full text of the license. */

	/**
	 * @requires OpenLayers/SingleFile.js
	 */

	OpenLayers.Util = OpenLayers.Util || {};
	/**
	 * Namespace: OpenLayers.Util.vendorPrefix
	 * A collection of utility functions to detect vendor prefixed features
	 */
	OpenLayers.Util.vendorPrefix = (function() {
	    "use strict";
	    
	    var VENDOR_PREFIXES = ["", "O", "ms", "Moz", "Webkit"],
	        divStyle = document.createElement("div").style,
	        cssCache = {},
	        jsCache = {};

	    
	    /**
	     * Function: domToCss
	     * Converts a upper camel case DOM style property name to a CSS property
	     *      i.e. transformOrigin -> transform-origin
	     *      or   WebkitTransformOrigin -> -webkit-transform-origin
	     *
	     * Parameters:
	     * prefixedDom - {String} The property to convert
	     *
	     * Returns:
	     * {String} The CSS property
	     */
	    function domToCss(prefixedDom) {
	        if (!prefixedDom) { return null; }
	        return prefixedDom.
	            replace(/([A-Z])/g, function(c) { return "-" + c.toLowerCase(); }).
	            replace(/^ms-/, "-ms-");
	    }

	    /**
	     * APIMethod: css
	     * Detect which property is used for a CSS property
	     *
	     * Parameters:
	     * property - {String} The standard (unprefixed) CSS property name
	     *
	     * Returns:
	     * {String} The standard CSS property, prefixed property or null if not
	     *          supported
	     */
	    function css(property) {
	        if (cssCache[property] === undefined) {
	            var domProperty = property.
	                replace(/(-[\s\S])/g, function(c) { return c.charAt(1).toUpperCase(); });
	            var prefixedDom = style(domProperty);
	            cssCache[property] = domToCss(prefixedDom);
	        }
	        return cssCache[property];
	    }

	    /**
	     * APIMethod: js
	     * Detect which property is used for a JS property/method
	     *
	     * Parameters:
	     * obj - {Object} The object to test on
	     * property - {String} The standard (unprefixed) JS property name
	     *
	     * Returns:
	     * {String} The standard JS property, prefixed property or null if not
	     *          supported
	     */
	    function js(obj, property) {
	        if (jsCache[property] === undefined) {
	            var tmpProp,
	                i = 0,
	                l = VENDOR_PREFIXES.length,
	                prefix,
	                isStyleObj = (typeof obj.cssText !== "undefined");

	            jsCache[property] = null;
	            for(; i<l; i++) {
	                prefix = VENDOR_PREFIXES[i];
	                if(prefix) {
	                    if (!isStyleObj) {
	                        // js prefix should be lower-case, while style
	                        // properties have upper case on first character
	                        prefix = prefix.toLowerCase();
	                    }
	                    tmpProp = prefix + property.charAt(0).toUpperCase() + property.slice(1);
	                } else {
	                    tmpProp = property;
	                }

	                if(obj[tmpProp] !== undefined) {
	                    jsCache[property] = tmpProp;
	                    break;
	                }
	            }
	        }
	        return jsCache[property];
	    }
	    
	    /**
	     * APIMethod: style
	     * Detect which property is used for a DOM style property
	     *
	     * Parameters:
	     * property - {String} The standard (unprefixed) style property name
	     *
	     * Returns:
	     * {String} The standard style property, prefixed property or null if not
	     *          supported
	     */
	    function style(property) {
	        return js(divStyle, property);
	    }
	    
	    return {
	        css:      css,
	        js:       js,
	        style:    style,
	        
	        // used for testing
	        cssCache:       cssCache,
	        jsCache:        jsCache
	    };
	}());
	/* ======================================================================
	    OpenLayers/Animation.js
	   ====================================================================== */

	/* Copyright (c) 2006-2015 by OpenLayers Contributors (see authors.txt for
	 * full list of contributors). Published under the 2-clause BSD license.
	 * See license.txt in the OpenLayers distribution or repository for the
	 * full text of the license. */

	/**
	 * @requires OpenLayers/SingleFile.js
	 * @requires OpenLayers/Util/vendorPrefix.js
	 */

	/**
	 * Namespace: OpenLayers.Animation
	 * A collection of utility functions for executing methods that repaint a 
	 *     portion of the browser window.  These methods take advantage of the
	 *     browser's scheduled repaints where requestAnimationFrame is available.
	 */
	OpenLayers.Animation = (function(window) {
	    
	    /**
	     * Property: isNative
	     * {Boolean} true if a native requestAnimationFrame function is available
	     */
	    var requestAnimationFrame = OpenLayers.Util.vendorPrefix.js(window, "requestAnimationFrame");
	    var isNative = !!(requestAnimationFrame);
	    
	    /**
	     * Function: requestFrame
	     * Schedule a function to be called at the next available animation frame.
	     *     Uses the native method where available.  Where requestAnimationFrame is
	     *     not available, setTimeout will be called with a 16ms delay.
	     *
	     * Parameters:
	     * callback - {Function} The function to be called at the next animation frame.
	     * element - {DOMElement} Optional element that visually bounds the animation.
	     */
	    var requestFrame = (function() {
	        var request = window[requestAnimationFrame] ||
	            function(callback, element) {
	                window.setTimeout(callback, 16);
	            };
	        // bind to window to avoid illegal invocation of native function
	        return function(callback, element) {
	            request.apply(window, [callback, element]);
	        };
	    })();
	    
	    // private variables for animation loops
	    var counter = 0;
	    var loops = {};
	    
	    /**
	     * Function: start
	     * Executes a method with <requestFrame> in series for some 
	     *     duration.
	     *
	     * Parameters:
	     * callback - {Function} The function to be called at the next animation frame.
	     * duration - {Number} Optional duration for the loop.  If not provided, the
	     *     animation loop will execute indefinitely.
	     * element - {DOMElement} Optional element that visually bounds the animation.
	     *
	     * Returns:
	     * {Number} Identifier for the animation loop.  Used to stop animations with
	     *     <stop>.
	     */
	    function start(callback, duration, element) {
	        duration = duration > 0 ? duration : Number.POSITIVE_INFINITY;
	        var id = ++counter;
	        var start = +new Date;
	        loops[id] = function() {
	            if (loops[id] && +new Date - start <= duration) {
	                callback();
	                if (loops[id]) {
	                    requestFrame(loops[id], element);
	                }
	            } else {
	                delete loops[id];
	            }
	        };
	        requestFrame(loops[id], element);
	        return id;
	    }
	    
	    /**
	     * Function: stop
	     * Terminates an animation loop started with <start>.
	     *
	     * Parameters:
	     * id - {Number} Identifier returned from <start>.
	     */
	    function stop(id) {
	        delete loops[id];
	    }
	    
	    return {
	        isNative: isNative,
	        requestFrame: requestFrame,
	        start: start,
	        stop: stop
	    };
	    
	})(window);
	/* ======================================================================
	    OpenLayers/Kinetic.js
	   ====================================================================== */

	/* Copyright (c) 2006-2015 by OpenLayers Contributors (see authors.txt for
	 * full list of contributors). Published under the 2-clause BSD license.
	 * See license.txt in the OpenLayers distribution or repository for the
	 * full text of the license. */

	/**
	 * @requires OpenLayers/BaseTypes/Class.js
	 * @requires OpenLayers/Animation.js
	 */

	OpenLayers.Kinetic = OpenLayers.Class({

	    /**
	     * Property: threshold
	     * In most cases changing the threshold isn't needed.
	     * In px/ms, default to 0.
	     */
	    threshold: 0,

	    /**
	     * Property: deceleration
	     * {Float} the deseleration in px/msÂ², default to 0.0035.
	     */
	    deceleration: 0.0035,

	    /**
	     * Property: nbPoints
	     * {Integer} the number of points we use to calculate the kinetic
	     * initial values.
	     */
	    nbPoints: 100,

	    /**
	     * Property: delay
	     * {Float} time to consider to calculate the kinetic initial values.
	     * In ms, default to 200.
	     */
	    delay: 200,

	    /**
	     * Property: points
	     * List of points use to calculate the kinetic initial values.
	     */
	    points: undefined,

	    /**
	     * Property: timerId
	     * ID of the timer.
	     */
	    timerId: undefined,

	    /**
	     * Constructor: OpenLayers.Kinetic
	     *
	     * Parameters:
	     * options - {Object}
	     */
	    initialize: function(options) {
	        OpenLayers.Util.extend(this, options);
	    },

	    /**
	     * Method: begin
	     * Begins the dragging.
	     */
	    begin: function() {
	        OpenLayers.Animation.stop(this.timerId);
	        this.timerId = undefined;
	        this.points = [];
	    },

	    /**
	     * Method: update
	     * Updates during the dragging.
	     *
	     * Parameters:
	     * xy - {<OpenLayers.Pixel>} The new position.
	     */
	    update: function(xy) {
	        this.points.unshift({xy: xy, tick: new Date().getTime()});
	        if (this.points.length > this.nbPoints) {
	            this.points.pop();
	        }
	    },

	    /**
	     * Method: end
	     * Ends the dragging, start the kinetic.
	     *
	     * Parameters:
	     * xy - {<OpenLayers.Pixel>} The last position.
	     *
	     * Returns:
	     * {Object} An object with two properties: "speed", and "theta". The
	     *     "speed" and "theta" values are to be passed to the move 
	     *     function when starting the animation.
	     */
	    end: function(xy) {
	        var last, now = new Date().getTime();
	        for (var i = 0, l = this.points.length, point; i < l; i++) {
	            point = this.points[i];
	            if (now - point.tick > this.delay) {
	                break;
	            }
	            last = point;
	        }
	        if (!last) {
	            return;
	        }
	        var time = new Date().getTime() - last.tick;
	        var dist = Math.sqrt(Math.pow(xy.x - last.xy.x, 2) +
	                             Math.pow(xy.y - last.xy.y, 2));
	        var speed = dist / time;
	        if (speed == 0 || speed < this.threshold) {
	            return;
	        }
	        var theta = Math.asin((xy.y - last.xy.y) / dist);
	        if (last.xy.x <= xy.x) {
	            theta = Math.PI - theta;
	        }
	        return {speed: speed, theta: theta};
	    },

	    /**
	     * Method: move
	     * Launch the kinetic move pan.
	     *
	     * Parameters:
	     * info - {Object} An object with two properties, "speed", and "theta".
	     *     These values are those returned from the "end" call.
	     * callback - {Function} Function called on every step of the animation,
	     *     receives x, y (values to pan), end (is the last point).
	     */
	    move: function(info, callback) {
	        var v0 = info.speed;
	        var fx = Math.cos(info.theta);
	        var fy = -Math.sin(info.theta);

	        var initialTime = new Date().getTime();

	        var lastX = 0;
	        var lastY = 0;

	        var timerCallback = function() {
	            if (this.timerId == null) {
	                return;
	            }

	            var t = new Date().getTime() - initialTime;

	            var p = (-this.deceleration * Math.pow(t, 2)) / 2.0 + v0 * t;
	            var x = p * fx;
	            var y = p * fy;

	            var args = {};
	            args.end = false;
	            var v = -this.deceleration * t + v0;

	            if (v <= 0) {
	                OpenLayers.Animation.stop(this.timerId);
	                this.timerId = null;
	                args.end = true;
	            }

	            args.x = x - lastX;
	            args.y = y - lastY;
	            lastX = x;
	            lastY = y;
	            callback(args.x, args.y, args.end);
	        };

	        this.timerId = OpenLayers.Animation.start(
	            OpenLayers.Function.bind(timerCallback, this)
	        );
	    },

	    CLASS_NAME: "OpenLayers.Kinetic"
	});
	/* ======================================================================
	    OpenLayers/Tween.js
	   ====================================================================== */

	/* Copyright (c) 2006-2015 by OpenLayers Contributors (see authors.txt for
	 * full list of contributors). Published under the 2-clause BSD license.
	 * See license.txt in the OpenLayers distribution or repository for the
	 * full text of the license. */

	/**
	 * @requires OpenLayers/BaseTypes/Class.js
	 * @requires OpenLayers/Animation.js
	 */

	/**
	 * Namespace: OpenLayers.Tween
	 */
	OpenLayers.Tween = OpenLayers.Class({
	    
	    /**
	     * APIProperty: easing
	     * {<OpenLayers.Easing>(Function)} Easing equation used for the animation
	     *     Defaultly set to OpenLayers.Easing.Expo.easeOut
	     */
	    easing: null,
	    
	    /**
	     * APIProperty: begin
	     * {Object} Values to start the animation with
	     */
	    begin: null,
	    
	    /**
	     * APIProperty: finish
	     * {Object} Values to finish the animation with
	     */
	    finish: null,
	    
	    /**
	     * APIProperty: duration
	     * {int} duration of the tween (number of steps)
	     */
	    duration: null,
	    
	    /**
	     * APIProperty: callbacks
	     * {Object} An object with start, eachStep and done properties whose values
	     *     are functions to be call during the animation. They are passed the
	     *     current computed value as argument.
	     */
	    callbacks: null,
	    
	    /**
	     * Property: time
	     * {int} Step counter
	     */
	    time: null,
	    
	    /**
	     * APIProperty: minFrameRate
	     * {Number} The minimum framerate for animations in frames per second. After
	     * each step, the time spent in the animation is compared to the calculated
	     * time at this frame rate. If the animation runs longer than the calculated
	     * time, the next step is skipped. Default is 30.
	     */
	    minFrameRate: null,

	    /**
	     * Property: startTime
	     * {Number} The timestamp of the first execution step. Used for skipping
	     * frames
	     */
	    startTime: null,
	    
	    /**
	     * Property: animationId
	     * {int} Loop id returned by OpenLayers.Animation.start
	     */
	    animationId: null,
	    
	    /**
	     * Property: playing
	     * {Boolean} Tells if the easing is currently playing
	     */
	    playing: false,
	    
	    /** 
	     * Constructor: OpenLayers.Tween
	     * Creates a Tween.
	     *
	     * Parameters:
	     * easing - {<OpenLayers.Easing>(Function)} easing function method to use
	     */ 
	    initialize: function(easing) {
	        this.easing = (easing) ? easing : OpenLayers.Easing.Expo.easeOut;
	    },
	    
	    /**
	     * APIMethod: start
	     * Plays the Tween, and calls the callback method on each step
	     * 
	     * Parameters:
	     * begin - {Object} values to start the animation with
	     * finish - {Object} values to finish the animation with
	     * duration - {int} duration of the tween (number of steps)
	     * options - {Object} hash of options (callbacks (start, eachStep, done),
	     *     minFrameRate)
	     */
	    start: function(begin, finish, duration, options) {
	        this.playing = true;
	        this.begin = begin;
	        this.finish = finish;
	        this.duration = duration;
	        this.callbacks = options.callbacks;
	        this.minFrameRate = options.minFrameRate || 30;
	        this.time = 0;
	        this.startTime = new Date().getTime();
	        OpenLayers.Animation.stop(this.animationId);
	        this.animationId = null;
	        if (this.callbacks && this.callbacks.start) {
	            this.callbacks.start.call(this, this.begin);
	        }
	        this.animationId = OpenLayers.Animation.start(
	            OpenLayers.Function.bind(this.play, this)
	        );
	    },
	    
	    /**
	     * APIMethod: stop
	     * Stops the Tween, and calls the done callback
	     *     Doesn't do anything if animation is already finished
	     */
	    stop: function() {
	        if (!this.playing) {
	            return;
	        }
	        
	        if (this.callbacks && this.callbacks.done) {
	            this.callbacks.done.call(this, this.finish);
	        }
	        OpenLayers.Animation.stop(this.animationId);
	        this.animationId = null;
	        this.playing = false;
	    },
	    
	    /**
	     * Method: play
	     * Calls the appropriate easing method
	     */
	    play: function() {
	        var value = {};
	        for (var i in this.begin) {
	            var b = this.begin[i];
	            var f = this.finish[i];
	            if (b == null || f == null || isNaN(b) || isNaN(f)) {
	                throw new TypeError('invalid value for Tween');
	            }

	            var c = f - b;
	            value[i] = this.easing.apply(this, [this.time, b, c, this.duration]);
	        }
	        this.time++;
	        
	        if (this.callbacks && this.callbacks.eachStep) {
	            // skip frames if frame rate drops below threshold
	            if ((new Date().getTime() - this.startTime) / this.time <= 1000 / this.minFrameRate) {
	                this.callbacks.eachStep.call(this, value);
	            }
	        }
	        
	        if (this.time > this.duration) {
	            this.stop();
	        }
	    },
	    
	    /**
	     * Create empty functions for all easing methods.
	     */
	    CLASS_NAME: "OpenLayers.Tween"
	});

	/**
	 * Namespace: OpenLayers.Easing
	 * 
	 * Credits:
	 *      Easing Equations by Robert Penner, <http://www.robertpenner.com/easing/>
	 */
	OpenLayers.Easing = {
	    /**
	     * Create empty functions for all easing methods.
	     */
	    CLASS_NAME: "OpenLayers.Easing"
	};

	/**
	 * Namespace: OpenLayers.Easing.Linear
	 */
	OpenLayers.Easing.Linear = {
	    
	    /**
	     * Function: easeIn
	     * 
	     * Parameters:
	     * t - {Float} time
	     * b - {Float} beginning position
	     * c - {Float} total change
	     * d - {Float} duration of the transition
	     *
	     * Returns:
	     * {Float}
	     */
	    easeIn: function(t, b, c, d) {
	        return c*t/d + b;
	    },
	    
	    /**
	     * Function: easeOut
	     * 
	     * Parameters:
	     * t - {Float} time
	     * b - {Float} beginning position
	     * c - {Float} total change
	     * d - {Float} duration of the transition
	     *
	     * Returns:
	     * {Float}
	     */
	    easeOut: function(t, b, c, d) {
	        return c*t/d + b;
	    },
	    
	    /**
	     * Function: easeInOut
	     * 
	     * Parameters:
	     * t - {Float} time
	     * b - {Float} beginning position
	     * c - {Float} total change
	     * d - {Float} duration of the transition
	     *
	     * Returns:
	     * {Float}
	     */
	    easeInOut: function(t, b, c, d) {
	        return c*t/d + b;
	    },

	    CLASS_NAME: "OpenLayers.Easing.Linear"
	};

	/**
	 * Namespace: OpenLayers.Easing.Expo
	 */
	OpenLayers.Easing.Expo = {
	    
	    /**
	     * Function: easeIn
	     * 
	     * Parameters:
	     * t - {Float} time
	     * b - {Float} beginning position
	     * c - {Float} total change
	     * d - {Float} duration of the transition
	     *
	     * Returns:
	     * {Float}
	     */
	    easeIn: function(t, b, c, d) {
	        return (t==0) ? b : c * Math.pow(2, 10 * (t/d - 1)) + b;
	    },
	    
	    /**
	     * Function: easeOut
	     * 
	     * Parameters:
	     * t - {Float} time
	     * b - {Float} beginning position
	     * c - {Float} total change
	     * d - {Float} duration of the transition
	     *
	     * Returns:
	     * {Float}
	     */
	    easeOut: function(t, b, c, d) {
	        return (t==d) ? b+c : c * (-Math.pow(2, -10 * t/d) + 1) + b;
	    },
	    
	    /**
	     * Function: easeInOut
	     * 
	     * Parameters:
	     * t - {Float} time
	     * b - {Float} beginning position
	     * c - {Float} total change
	     * d - {Float} duration of the transition
	     *
	     * Returns:
	     * {Float}
	     */
	    easeInOut: function(t, b, c, d) {
	        if (t==0) return b;
	        if (t==d) return b+c;
	        if ((t/=d/2) < 1) return c/2 * Math.pow(2, 10 * (t - 1)) + b;
	        return c/2 * (-Math.pow(2, -10 * --t) + 2) + b;
	    },

	    CLASS_NAME: "OpenLayers.Easing.Expo"
	};

	/**
	 * Namespace: OpenLayers.Easing.Quad
	 */
	OpenLayers.Easing.Quad = {
	    
	    /**
	     * Function: easeIn
	     * 
	     * Parameters:
	     * t - {Float} time
	     * b - {Float} beginning position
	     * c - {Float} total change
	     * d - {Float} duration of the transition
	     *
	     * Returns:
	     * {Float}
	     */
	    easeIn: function(t, b, c, d) {
	        return c*(t/=d)*t + b;
	    },
	    
	    /**
	     * Function: easeOut
	     * 
	     * Parameters:
	     * t - {Float} time
	     * b - {Float} beginning position
	     * c - {Float} total change
	     * d - {Float} duration of the transition
	     *
	     * Returns:
	     * {Float}
	     */
	    easeOut: function(t, b, c, d) {
	        return -c *(t/=d)*(t-2) + b;
	    },
	    
	    /**
	     * Function: easeInOut
	     * 
	     * Parameters:
	     * t - {Float} time
	     * b - {Float} beginning position
	     * c - {Float} total change
	     * d - {Float} duration of the transition
	     *
	     * Returns:
	     * {Float}
	     */
	    easeInOut: function(t, b, c, d) {
	        if ((t/=d/2) < 1) return c/2*t*t + b;
	        return -c/2 * ((--t)*(t-2) - 1) + b;
	    },

	    CLASS_NAME: "OpenLayers.Easing.Quad"
	};
	/* ======================================================================
	    OpenLayers/Projection.js
	   ====================================================================== */

	/* Copyright (c) 2006-2015 by OpenLayers Contributors (see authors.txt for
	 * full list of contributors). Published under the 2-clause BSD license.
	 * See license.txt in the OpenLayers distribution or repository for the
	 * full text of the license. */

	/**
	 * @requires OpenLayers/BaseTypes/Class.js
	 * @requires OpenLayers/Util.js
	 */

	/**
	 * Namespace: OpenLayers.Projection
	 * Methods for coordinate transforms between coordinate systems.  By default,
	 *     OpenLayers ships with the ability to transform coordinates between
	 *     geographic (EPSG:4326) and web or spherical mercator (EPSG:900913 et al.)
	 *     coordinate reference systems.  See the <transform> method for details
	 *     on usage.
	 *
	 * Additional transforms may be added by using the <proj4js at http://proj4js.org/>
	 *     library.  If the proj4js library is included, the <transform> method 
	 *     will work between any two coordinate reference systems with proj4js 
	 *     definitions.
	 *
	 * If the proj4js library is not included, or if you wish to allow transforms
	 *     between arbitrary coordinate reference systems, use the <addTransform>
	 *     method to register a custom transform method.
	 */
	OpenLayers.Projection = OpenLayers.Class({

	    /**
	     * Property: proj
	     * {Object} Proj4js.Proj instance.
	     */
	    proj: null,
	    
	    /**
	     * Property: projCode
	     * {String}
	     */
	    projCode: null,
	    
	    /**
	     * Property: titleRegEx
	     * {RegExp} regular expression to strip the title from a proj4js definition
	     */
	    titleRegEx: /\+title=[^\+]*/,

	    /**
	     * Constructor: OpenLayers.Projection
	     * This class offers several methods for interacting with a wrapped 
	     *     pro4js projection object. 
	     *
	     * Parameters:
	     * projCode - {String} A string identifying the Well Known Identifier for
	     *    the projection.
	     * options - {Object} An optional object to set additional properties
	     *     on the projection.
	     *
	     * Returns:
	     * {<OpenLayers.Projection>} A projection object.
	     */
	    initialize: function(projCode, options) {
	        OpenLayers.Util.extend(this, options);
	        this.projCode = projCode;
	        if (typeof Proj4js == "object") {
	            this.proj = new Proj4js.Proj(projCode);
	        }
	    },
	    
	    /**
	     * APIMethod: getCode
	     * Get the string SRS code.
	     *
	     * Returns:
	     * {String} The SRS code.
	     */
	    getCode: function() {
	        return this.proj ? this.proj.srsCode : this.projCode;
	    },
	   
	    /**
	     * APIMethod: getUnits
	     * Get the units string for the projection -- returns null if 
	     *     proj4js is not available.
	     *
	     * Returns:
	     * {String} The units abbreviation.
	     */
	    getUnits: function() {
	        return this.proj ? this.proj.units : null;
	    },

	    /**
	     * Method: toString
	     * Convert projection to string (getCode wrapper).
	     *
	     * Returns:
	     * {String} The projection code.
	     */
	    toString: function() {
	        return this.getCode();
	    },

	    /**
	     * Method: equals
	     * Test equality of two projection instances.  Determines equality based
	     *     solely on the projection code.
	     *
	     * Returns:
	     * {Boolean} The two projections are equivalent.
	     */
	    equals: function(projection) {
	        var p = projection, equals = false;
	        if (p) {
	            if (!(p instanceof OpenLayers.Projection)) {
	                p = new OpenLayers.Projection(p);
	            }
	            if ((typeof Proj4js == "object") && this.proj.defData && p.proj.defData) {
	                equals = this.proj.defData.replace(this.titleRegEx, "") ==
	                    p.proj.defData.replace(this.titleRegEx, "");
	            } else if (p.getCode) {
	                var source = this.getCode(), target = p.getCode();
	                equals = source == target ||
	                    !!OpenLayers.Projection.transforms[source] &&
	                    OpenLayers.Projection.transforms[source][target] ===
	                        OpenLayers.Projection.nullTransform;
	            }
	        }
	        return equals;   
	    },

	    /* Method: destroy
	     * Destroy projection object.
	     */
	    destroy: function() {
	        delete this.proj;
	        delete this.projCode;
	    },
	    
	    CLASS_NAME: "OpenLayers.Projection" 
	});     

	/**
	 * Property: transforms
	 * {Object} Transforms is an object, with from properties, each of which may
	 * have a to property. This allows you to define projections without 
	 * requiring support for proj4js to be included.
	 *
	 * This object has keys which correspond to a 'source' projection object.  The
	 * keys should be strings, corresponding to the projection.getCode() value.
	 * Each source projection object should have a set of destination projection
	 * keys included in the object. 
	 * 
	 * Each value in the destination object should be a transformation function,
	 * where the function is expected to be passed an object with a .x and a .y
	 * property.  The function should return the object, with the .x and .y
	 * transformed according to the transformation function.
	 *
	 * Note - Properties on this object should not be set directly.  To add a
	 *     transform method to this object, use the <addTransform> method.  For an
	 *     example of usage, see the OpenLayers.Layer.SphericalMercator file.
	 */
	OpenLayers.Projection.transforms = {};

	/**
	 * APIProperty: defaults
	 * {Object} Defaults for the SRS codes known to OpenLayers (currently
	 * EPSG:4326, CRS:84, urn:ogc:def:crs:EPSG:6.6:4326, EPSG:900913, EPSG:3857,
	 * EPSG:102113, EPSG:102100 and OSGEO:41001). Keys are the SRS code, values are
	 * units, maxExtent (the validity extent for the SRS in projected coordinates),
	 * worldExtent (the world's extent in EPSG:4326) and yx (true if this SRS
	 * is known to have a reverse axis order).
	 */
	OpenLayers.Projection.defaults = {
	    "EPSG:4326": {
	        units: "degrees",
	        maxExtent: [-180, -90, 180, 90],
	        worldExtent: [-180, -90, 180, 90],
	        yx: true
	    },
	    "CRS:84": {
	        units: "degrees",
	        maxExtent: [-180, -90, 180, 90],
	        worldExtent: [-180, -90, 180, 90]
	    },
	    "EPSG:900913": {
	        units: "m",
	        maxExtent: [-20037508.34, -20037508.34, 20037508.34, 20037508.34],
	        worldExtent: [-180, -89, 180, 89]
	    }
	};

	/**
	 * APIMethod: addTransform
	 * Set a custom transform method between two projections.  Use this method in
	 *     cases where the proj4js lib is not available or where custom projections
	 *     need to be handled.
	 *
	 * Parameters:
	 * from - {String} The code for the source projection
	 * to - {String} the code for the destination projection
	 * method - {Function} A function that takes a point as an argument and
	 *     transforms that point from the source to the destination projection
	 *     in place.  The original point should be modified.
	 */
	OpenLayers.Projection.addTransform = function(from, to, method) {
	    if (method === OpenLayers.Projection.nullTransform) {
	        var defaults = OpenLayers.Projection.defaults[from];
	        if (defaults && !OpenLayers.Projection.defaults[to]) {
	            OpenLayers.Projection.defaults[to] = defaults;
	        }
	    }
	    if(!OpenLayers.Projection.transforms[from]) {
	        OpenLayers.Projection.transforms[from] = {};
	    }
	    OpenLayers.Projection.transforms[from][to] = method;
	};

	/**
	 * APIMethod: transform
	 * Transform a point coordinate from one projection to another.  Note that
	 *     the input point is transformed in place.
	 * 
	 * Parameters:
	 * point - {<OpenLayers.Geometry.Point> | Object} An object with x and y
	 *     properties representing coordinates in those dimensions.
	 * source - {OpenLayers.Projection} Source map coordinate system
	 * dest - {OpenLayers.Projection} Destination map coordinate system
	 *
	 * Returns:
	 * point - {object} A transformed coordinate.  The original point is modified.
	 */
	OpenLayers.Projection.transform = function(point, source, dest) {
	    if (source && dest) {
	        if (!(source instanceof OpenLayers.Projection)) {
	            source = new OpenLayers.Projection(source);
	        }
	        if (!(dest instanceof OpenLayers.Projection)) {
	            dest = new OpenLayers.Projection(dest);
	        }
	        if (source.proj && dest.proj) {
	            point = Proj4js.transform(source.proj, dest.proj, point);
	        } else {
	            var sourceCode = source.getCode();
	            var destCode = dest.getCode();
	            var transforms = OpenLayers.Projection.transforms;
	            if (transforms[sourceCode] && transforms[sourceCode][destCode]) {
	                transforms[sourceCode][destCode](point);
	            }
	        }
	    }
	    return point;
	};

	/**
	 * APIFunction: nullTransform
	 * A null transformation - useful for defining projection aliases when
	 * proj4js is not available:
	 *
	 * (code)
	 * OpenLayers.Projection.addTransform("EPSG:3857", "EPSG:900913",
	 *     OpenLayers.Projection.nullTransform);
	 * OpenLayers.Projection.addTransform("EPSG:900913", "EPSG:3857",
	 *     OpenLayers.Projection.nullTransform);
	 * (end)
	 */
	OpenLayers.Projection.nullTransform = function(point) {
	    return point;
	};

	/**
	 * Note: Transforms for web mercator <-> geographic
	 * OpenLayers recognizes EPSG:3857, EPSG:900913, EPSG:102113, EPSG:102100 and 
	 * OSGEO:41001. OpenLayers originally started referring to EPSG:900913 as web
	 * mercator. The EPSG has declared EPSG:3857 to be web mercator.
	 * ArcGIS 10 recognizes the EPSG:3857, EPSG:102113, and EPSG:102100 as
	 * equivalent.  See http://blogs.esri.com/Dev/blogs/arcgisserver/archive/2009/11/20/ArcGIS-Online-moving-to-Google-_2F00_-Bing-tiling-scheme_3A00_-What-does-this-mean-for-you_3F00_.aspx#12084.
	 * For geographic, OpenLayers recognizes EPSG:4326, CRS:84 and
	 * urn:ogc:def:crs:EPSG:6.6:4326. OpenLayers also knows about the reverse axis
	 * order for EPSG:4326. 
	 */
	(function() {

	    var pole = 20037508.34;

	    function inverseMercator(xy) {
	        xy.x = 180 * xy.x / pole;
	        xy.y = 180 / Math.PI * (2 * Math.atan(Math.exp((xy.y / pole) * Math.PI)) - Math.PI / 2);
	        return xy;
	    }

	    function forwardMercator(xy) {
	        xy.x = xy.x * pole / 180;
	        var y = Math.log(Math.tan((90 + xy.y) * Math.PI / 360)) / Math.PI * pole;
	        xy.y = Math.max(-20037508.34, Math.min(y, 20037508.34));
	        return xy;
	    }

	    function map(base, codes) {
	        var add = OpenLayers.Projection.addTransform;
	        var same = OpenLayers.Projection.nullTransform;
	        var i, len, code, other, j;
	        for (i=0, len=codes.length; i<len; ++i) {
	            code = codes[i];
	            add(base, code, forwardMercator);
	            add(code, base, inverseMercator);
	            for (j=i+1; j<len; ++j) {
	                other = codes[j];
	                add(code, other, same);
	                add(other, code, same);
	            }
	        }
	    }
	    
	    // list of equivalent codes for web mercator
	    var mercator = ["EPSG:900913", "EPSG:3857", "EPSG:102113", "EPSG:102100", "OSGEO:41001"],
	        geographic = ["CRS:84", "urn:ogc:def:crs:EPSG:6.6:4326", "EPSG:4326"],
	        i;
	    for (i=mercator.length-1; i>=0; --i) {
	        map(mercator[i], geographic);
	    }
	    for (i=geographic.length-1; i>=0; --i) {
	        map(geographic[i], mercator);
	    }

	})();
	/* ======================================================================
	    OpenLayers/Map.js
	   ====================================================================== */

	/* Copyright (c) 2006-2015 by OpenLayers Contributors (see authors.txt for
	 * full list of contributors). Published under the 2-clause BSD license.
	 * See license.txt in the OpenLayers distribution or repository for the
	 * full text of the license. */

	/**
	 * @requires OpenLayers/BaseTypes/Class.js
	 * @requires OpenLayers/Util.js
	 * @requires OpenLayers/Util/vendorPrefix.js
	 * @requires OpenLayers/Events.js
	 * @requires OpenLayers/Tween.js
	 * @requires OpenLayers/Projection.js
	 */

	/**
	 * Class: OpenLayers.Map
	 * Instances of OpenLayers.Map are interactive maps embedded in a web page.
	 * Create a new map with the <OpenLayers.Map> constructor.
	 * 
	 * On their own maps do not provide much functionality.  To extend a map
	 * it's necessary to add controls (<OpenLayers.Control>) and 
	 * layers (<OpenLayers.Layer>) to the map. 
	 */
	OpenLayers.Map = OpenLayers.Class({
	    
	    /**
	     * Constant: Z_INDEX_BASE
	     * {Object} Base z-indexes for different classes of thing 
	     */
	    Z_INDEX_BASE: {
	        BaseLayer: 100,
	        Overlay: 325,
	        Feature: 725,
	        Popup: 750,
	        Control: 1000
	    },

	    /**
	     * APIProperty: events
	     * {<OpenLayers.Events>}
	     *
	     * Register a listener for a particular event with the following syntax:
	     * (code)
	     * map.events.register(type, obj, listener);
	     * (end)
	     *
	     * Listeners will be called with a reference to an event object.  The
	     *     properties of this event depends on exactly what happened.
	     *
	     * All event objects have at least the following properties:
	     * object - {Object} A reference to map.events.object.
	     * element - {DOMElement} A reference to map.events.element.
	     *
	     * Browser events have the following additional properties:
	     * xy - {<OpenLayers.Pixel>} The pixel location of the event (relative
	     *     to the the map viewport).
	     *
	     * Supported map event types:
	     * preaddlayer - triggered before a layer has been added.  The event
	     *     object will include a *layer* property that references the layer  
	     *     to be added. When a listener returns "false" the adding will be 
	     *     aborted.
	     * addlayer - triggered after a layer has been added.  The event object
	     *     will include a *layer* property that references the added layer.
	     * preremovelayer - triggered before a layer has been removed. The event
	     *     object will include a *layer* property that references the layer  
	     *     to be removed. When a listener returns "false" the removal will be 
	     *     aborted.
	     * removelayer - triggered after a layer has been removed.  The event
	     *     object will include a *layer* property that references the removed
	     *     layer.
	     * changelayer - triggered after a layer name change, order change,
	     *     opacity change, params change, visibility change (actual visibility,
	     *     not the layer's visibility property) or attribution change (due to
	     *     extent change). Listeners will receive an event object with *layer*
	     *     and *property* properties. The *layer* property will be a reference
	     *     to the changed layer. The *property* property will be a key to the
	     *     changed property (name, order, opacity, params, visibility or
	     *     attribution).
	     * movestart - triggered after the start of a drag, pan, or zoom. The event
	     *     object may include a *zoomChanged* property that tells whether the
	     *     zoom has changed.
	     * move - triggered after each drag, pan, or zoom
	     * moveend - triggered after a drag, pan, or zoom completes
	     * zoomstart - triggered when a zoom starts. Listeners receive an object
	     *     with *center* and *zoom* properties, for the target center and zoom
	     *     level.
	     * zoomend - triggered after a zoom completes
	     * mouseover - triggered after mouseover the map
	     * mouseout - triggered after mouseout the map
	     * mousemove - triggered after mousemove the map
	     * changebaselayer - triggered after the base layer changes
	     * updatesize - triggered after the <updateSize> method was executed
	     */

	    /**
	     * Property: id
	     * {String} Unique identifier for the map
	     */
	    id: null,
	    
	    /**
	     * Property: fractionalZoom
	     * {Boolean} For a base layer that supports it, allow the map resolution
	     *     to be set to a value between one of the values in the resolutions
	     *     array.  Default is false.
	     *
	     * When fractionalZoom is set to true, it is possible to zoom to
	     *     an arbitrary extent.  This requires a base layer from a source
	     *     that supports requests for arbitrary extents (i.e. not cached
	     *     tiles on a regular lattice).  This means that fractionalZoom
	     *     will not work with commercial layers (Google, Yahoo, VE), layers
	     *     using TileCache, or any other pre-cached data sources.
	     *
	     * If you are using fractionalZoom, then you should also use
	     *     <getResolutionForZoom> instead of layer.resolutions[zoom] as the
	     *     former works for non-integer zoom levels.
	     */
	    fractionalZoom: false,
	    
	    /**
	     * APIProperty: events
	     * {<OpenLayers.Events>} An events object that handles all 
	     *                       events on the map
	     */
	    events: null,
	    
	    /**
	     * APIProperty: allOverlays
	     * {Boolean} Allow the map to function with "overlays" only.  Defaults to
	     *     false.  If true, the lowest layer in the draw order will act as
	     *     the base layer.  In addition, if set to true, all layers will
	     *     have isBaseLayer set to false when they are added to the map.
	     *
	     * Note:
	     * If you set map.allOverlays to true, then you *cannot* use
	     *     map.setBaseLayer or layer.setIsBaseLayer.  With allOverlays true,
	     *     the lowest layer in the draw layer is the base layer.  So, to change
	     *     the base layer, use <setLayerIndex> or <raiseLayer> to set the layer
	     *     index to 0.
	     */
	    allOverlays: false,

	    /**
	     * APIProperty: div
	     * {DOMElement|String} The element that contains the map (or an id for
	     *     that element).  If the <OpenLayers.Map> constructor is called
	     *     with two arguments, this should be provided as the first argument.
	     *     Alternatively, the map constructor can be called with the options
	     *     object as the only argument.  In this case (one argument), a
	     *     div property may or may not be provided.  If the div property
	     *     is not provided, the map can be rendered to a container later
	     *     using the <render> method.
	     *     
	     * Note:
	     * If you are calling <render> after map construction, do not use
	     *     <maxResolution>  auto.  Instead, divide your <maxExtent> by your
	     *     maximum expected dimension.
	     */
	    div: null,
	    
	    /**
	     * Property: dragging
	     * {Boolean} The map is currently being dragged.
	     */
	    dragging: false,

	    /**
	     * Property: size
	     * {<OpenLayers.Size>} Size of the main div (this.div)
	     */
	    size: null,
	    
	    /**
	     * Property: viewPortDiv
	     * {HTMLDivElement} The element that represents the map viewport
	     */
	    viewPortDiv: null,

	    /**
	     * Property: layerContainerOrigin
	     * {<OpenLayers.LonLat>} The lonlat at which the later container was
	     *                       re-initialized (on-zoom)
	     */
	    layerContainerOrigin: null,

	    /**
	     * Property: layerContainerDiv
	     * {HTMLDivElement} The element that contains the layers.
	     */
	    layerContainerDiv: null,

	    /**
	     * APIProperty: layers
	     * {Array(<OpenLayers.Layer>)} Ordered list of layers in the map
	     */
	    layers: null,

	    /**
	     * APIProperty: controls
	     * {Array(<OpenLayers.Control>)} List of controls associated with the map.
	     *
	     * If not provided in the map options at construction, the map will
	     *     by default be given the following controls if present in the build:
	     *  - <OpenLayers.Control.Navigation> or <OpenLayers.Control.TouchNavigation>
	     *  - <OpenLayers.Control.Zoom> or <OpenLayers.Control.PanZoom>
	     *  - <OpenLayers.Control.ArgParser>
	     *  - <OpenLayers.Control.Attribution>
	     */
	    controls: null,

	    /**
	     * Property: popups
	     * {Array(<OpenLayers.Popup>)} List of popups associated with the map
	     */
	    popups: null,

	    /**
	     * APIProperty: baseLayer
	     * {<OpenLayers.Layer>} The currently selected base layer.  This determines
	     * min/max zoom level, projection, etc.
	     */
	    baseLayer: null,
	    
	    /**
	     * Property: center
	     * {<OpenLayers.LonLat>} The current center of the map
	     */
	    center: null,

	    /**
	     * Property: resolution
	     * {Float} The resolution of the map.
	     */
	    resolution: null,

	    /**
	     * Property: zoom
	     * {Integer} The current zoom level of the map
	     */
	    zoom: 0,    

	    /**
	     * Property: panRatio
	     * {Float} The ratio of the current extent within
	     *         which panning will tween.
	     */
	    panRatio: 1.5,    

	    /**
	     * APIProperty: options
	     * {Object} The options object passed to the class constructor. Read-only.
	     */
	    options: null,

	  // Options

	    /**
	     * APIProperty: tileSize
	     * {<OpenLayers.Size>} Set in the map options to override the default tile
	     *                     size for this map.
	     */
	    tileSize: null,

	    /**
	     * APIProperty: projection
	     * {String} Set in the map options to specify the default projection 
	     *          for layers added to this map. When using a projection other than EPSG:4326
	     *          (CRS:84, Geographic) or EPSG:3857 (EPSG:900913, Web Mercator),
	     *          also set maxExtent, maxResolution or resolutions.  Default is "EPSG:4326".
	     *          Note that the projection of the map is usually determined
	     *          by that of the current baseLayer (see <baseLayer> and <getProjectionObject>).
	     */
	    projection: "EPSG:4326",    
	        
	    /**
	     * APIProperty: units
	     * {String} The map units.  Possible values are 'degrees' (or 'dd'), 'm', 
	     *     'ft', 'km', 'mi', 'inches'.  Normally taken from the projection.
	     *     Only required if both map and layers do not define a projection,
	     *     or if they define a projection which does not define units
	     */
	    units: null,

	    /**
	     * APIProperty: resolutions
	     * {Array(Float)} A list of map resolutions (map units per pixel) in 
	     *     descending order.  If this is not set in the layer constructor, it 
	     *     will be set based on other resolution related properties 
	     *     (maxExtent, maxResolution, maxScale, etc.).
	     */
	    resolutions: null,

	    /**
	     * APIProperty: maxResolution
	     * {Float} Required if you are not displaying the whole world on a tile
	     * with the size specified in <tileSize>.
	     */
	    maxResolution: null,

	    /**
	     * APIProperty: minResolution
	     * {Float}
	     */
	    minResolution: null,

	    /**
	     * APIProperty: maxScale
	     * {Float}
	     */
	    maxScale: null,

	    /**
	     * APIProperty: minScale
	     * {Float}
	     */
	    minScale: null,

	    /**
	     * APIProperty: maxExtent
	     * {<OpenLayers.Bounds>|Array} If provided as an array, the array
	     *     should consist of four values (left, bottom, right, top).
	     *     The maximum extent for the map.
	     *     Default depends on projection; if this is one of those defined in OpenLayers.Projection.defaults
	     *     (EPSG:4326 or web mercator), maxExtent will be set to the value defined there;
	     *     else, defaults to null.
	     *     To restrict user panning and zooming of the map, use <restrictedExtent> instead.
	     *     The value for <maxExtent> will change calculations for tile URLs.
	     */
	    maxExtent: null,
	    
	    /**
	     * APIProperty: minExtent
	     * {<OpenLayers.Bounds>|Array} If provided as an array, the array
	     *     should consist of four values (left, bottom, right, top).
	     *     The minimum extent for the map.  Defaults to null.
	     */
	    minExtent: null,
	    
	    /**
	     * APIProperty: restrictedExtent
	     * {<OpenLayers.Bounds>|Array} If provided as an array, the array
	     *     should consist of four values (left, bottom, right, top).
	     *     Limit map navigation to this extent where possible.
	     *     If a non-null restrictedExtent is set, panning will be restricted
	     *     to the given bounds.  In addition, zooming to a resolution that
	     *     displays more than the restricted extent will center the map
	     *     on the restricted extent.  If you wish to limit the zoom level
	     *     or resolution, use maxResolution.
	     */
	    restrictedExtent: null,

	    /**
	     * APIProperty: numZoomLevels
	     * {Integer} Number of zoom levels for the map.  Defaults to 16.  Set a
	     *           different value in the map options if needed.
	     */
	    numZoomLevels: 16,

	    /**
	     * APIProperty: theme
	     * {String} Relative path to a CSS file from which to load theme styles.
	     *          Specify null in the map options (e.g. {theme: null}) if you 
	     *          want to get cascading style declarations - by putting links to 
	     *          stylesheets or style declarations directly in your page.
	     */
	    theme: null,
	    
	    /** 
	     * APIProperty: displayProjection
	     * {<OpenLayers.Projection>} Requires proj4js support for projections other
	     *     than EPSG:4326 or EPSG:900913/EPSG:3857. Projection used by
	     *     several controls to display data to user. If this property is set,
	     *     it will be set on any control which has a null displayProjection
	     *     property at the time the control is added to the map. 
	     */
	    displayProjection: null,

	    /**
	     * APIProperty: tileManager
	     * {<OpenLayers.TileManager>|Object} By default, and if the build contains
	     * TileManager.js, the map will use the TileManager to queue image requests
	     * and to cache tile image elements. To create a map without a TileManager
	     * configure the map with tileManager: null. To create a TileManager with
	     * non-default options, supply the options instead or alternatively supply
	     * an instance of {<OpenLayers.TileManager>}.
	     */

	    /**
	     * APIProperty: fallThrough
	     * {Boolean} Should OpenLayers allow events on the map to fall through to
	     *           other elements on the page, or should it swallow them? (#457)
	     *           Default is to swallow.
	     */
	    fallThrough: false,

	    /**
	     * APIProperty: autoUpdateSize
	     * {Boolean} Should OpenLayers automatically update the size of the map
	     * when the resize event is fired. Default is true.
	     */
	    autoUpdateSize: true,
	    
	    /**
	     * APIProperty: eventListeners
	     * {Object} If set as an option at construction, the eventListeners
	     *     object will be registered with <OpenLayers.Events.on>.  Object
	     *     structure must be a listeners object as shown in the example for
	     *     the events.on method.
	     */
	    eventListeners: null,

	    /**
	     * Property: panTween
	     * {<OpenLayers.Tween>} Animated panning tween object, see panTo()
	     */
	    panTween: null,

	    /**
	     * APIProperty: panMethod
	     * {Function} The Easing function to be used for tweening.  Default is
	     * OpenLayers.Easing.Expo.easeOut. Setting this to 'null' turns off
	     * animated panning.
	     */
	    panMethod: OpenLayers.Easing.Expo.easeOut,
	    
	    /**
	     * Property: panDuration
	     * {Integer} The number of steps to be passed to the
	     * OpenLayers.Tween.start() method when the map is
	     * panned.
	     * Default is 50.
	     */
	    panDuration: 50,
	    
	    /**
	     * Property: zoomTween
	     * {<OpenLayers.Tween>} Animated zooming tween object, see zoomTo()
	     */
	    zoomTween: null,

	    /**
	     * APIProperty: zoomMethod
	     * {Function} The Easing function to be used for tweening.  Default is
	     * OpenLayers.Easing.Quad.easeOut. Setting this to 'null' turns off
	     * animated zooming.
	     */
	    zoomMethod: OpenLayers.Easing.Quad.easeOut,
	    
	    /**
	     * Property: zoomDuration
	     * {Integer} The number of steps to be passed to the
	     * OpenLayers.Tween.start() method when the map is zoomed.
	     * Default is 20.
	     */
	    zoomDuration: 20,
	    
	    /**
	     * Property: paddingForPopups
	     * {<OpenLayers.Bounds>} Outside margin of the popup. Used to prevent 
	     *     the popup from getting too close to the map border.
	     */
	    paddingForPopups : null,
	    
	    /**
	     * Property: layerContainerOriginPx
	     * {Object} Cached object representing the layer container origin (in pixels).
	     */
	    layerContainerOriginPx: null,
	    
	    /**
	     * Property: minPx
	     * {Object} An object with a 'x' and 'y' values that is the lower
	     *     left of maxExtent in viewport pixel space.
	     *     Used to verify in moveByPx that the new location we're moving to
	     *     is valid. It is also used in the getLonLatFromViewPortPx function
	     *     of Layer.
	     */
	    minPx: null,
	    
	    /**
	     * Property: maxPx
	     * {Object} An object with a 'x' and 'y' values that is the top
	     *     right of maxExtent in viewport pixel space.
	     *     Used to verify in moveByPx that the new location we're moving to
	     *     is valid.
	     */
	    maxPx: null,
	    
	    /**
	     * Constructor: OpenLayers.Map
	     * Constructor for a new OpenLayers.Map instance.  There are two possible
	     *     ways to call the map constructor.  See the examples below.
	     *
	     * Parameters:
	     * div - {DOMElement|String}  The element or id of an element in your page
	     *     that will contain the map.  May be omitted if the <div> option is
	     *     provided or if you intend to call the <render> method later.
	     * options - {Object} Optional object with properties to tag onto the map.
	     *
	     * Valid options (in addition to the listed API properties):
	     * center - {<OpenLayers.LonLat>|Array} The default initial center of the map.
	     *     If provided as array, the first value is the x coordinate,
	     *     and the 2nd value is the y coordinate.
	     *     Only specify if <layers> is provided.
	     *     Note that if an ArgParser/Permalink control is present,
	     *     and the querystring contains coordinates, center will be set
	     *     by that, and this option will be ignored.
	     * zoom - {Number} The initial zoom level for the map. Only specify if
	     *     <layers> is provided.
	     *     Note that if an ArgParser/Permalink control is present,
	     *     and the querystring contains a zoom level, zoom will be set
	     *     by that, and this option will be ignored.
	     * 
	     * Examples:
	     * (code)
	     * // create a map with default options in an element with the id "map1"
	     * var map = new OpenLayers.Map("map1");
	     *
	     * // create a map with non-default options in an element with id "map2"
	     * var options = {
	     *     projection: "EPSG:3857",
	     *     maxExtent: new OpenLayers.Bounds(-200000, -200000, 200000, 200000),
	     *     center: new OpenLayers.LonLat(-12356463.476333, 5621521.4854095)
	     * };
	     * var map = new OpenLayers.Map("map2", options);
	     *
	     * // map with non-default options - same as above but with a single argument,
	     * // a restricted extent, and using arrays for bounds and center
	     * var map = new OpenLayers.Map({
	     *     div: "map_id",
	     *     projection: "EPSG:3857",
	     *     maxExtent: [-18924313.432222, -15538711.094146, 18924313.432222, 15538711.094146],
	     *     restrictedExtent: [-13358338.893333, -9608371.5085962, 13358338.893333, 9608371.5085962],
	     *     center: [-12356463.476333, 5621521.4854095]
	     * });
	     *
	     * // create a map without a reference to a container - call render later
	     * var map = new OpenLayers.Map({
	     *     projection: "EPSG:3857",
	     *     maxExtent: new OpenLayers.Bounds(-200000, -200000, 200000, 200000)
	     * });
	     * (end)
	     */    
	    initialize: function (div, options) {
	        
	        // If only one argument is provided, check if it is an object.
	        var isDOMElement = OpenLayers.Util.isElement(div);
	        if(arguments.length === 1 && typeof div === "object" && !isDOMElement) {
	            options = div;
	            div = options && options.div;
	        }

	        // Simple-type defaults are set in class definition. 
	        //  Now set complex-type defaults 
	        this.tileSize = new OpenLayers.Size(OpenLayers.Map.TILE_WIDTH,
	                                            OpenLayers.Map.TILE_HEIGHT);
	        
	        this.paddingForPopups = new OpenLayers.Bounds(15, 15, 15, 15);

	        this.theme = OpenLayers._getScriptLocation() + 
	                             'theme/default/style.css'; 

	        // backup original options
	        this.options = OpenLayers.Util.extend({}, options);

	        // now override default options 
	        OpenLayers.Util.extend(this, options);
	        
	        var projCode = this.projection instanceof OpenLayers.Projection ?
	            this.projection.projCode : this.projection;
	        OpenLayers.Util.applyDefaults(this, OpenLayers.Projection.defaults[projCode]);
	        
	        // allow extents and center to be arrays
	        if (this.maxExtent && !(this.maxExtent instanceof OpenLayers.Bounds)) {
	            this.maxExtent = new OpenLayers.Bounds(this.maxExtent);
	        }
	        if (this.minExtent && !(this.minExtent instanceof OpenLayers.Bounds)) {
	            this.minExtent = new OpenLayers.Bounds(this.minExtent);
	        }
	        if (this.restrictedExtent && !(this.restrictedExtent instanceof OpenLayers.Bounds)) {
	            this.restrictedExtent = new OpenLayers.Bounds(this.restrictedExtent);
	        }
	        if (this.center && !(this.center instanceof OpenLayers.LonLat)) {
	            this.center = new OpenLayers.LonLat(this.center);
	        }

	        // initialize layers array
	        this.layers = [];

	        this.id = OpenLayers.Util.createUniqueID("OpenLayers.Map_");

	        this.div = OpenLayers.Util.getElement(div);
	        if(!this.div) {
	            this.div = document.createElement("div");
	            this.div.style.height = "1px";
	            this.div.style.width = "1px";
	        }
	        
	        OpenLayers.Element.addClass(this.div, 'olMap');

	        // the viewPortDiv is the outermost div we modify
	        var id = this.id + "_OpenLayers_ViewPort";
	        this.viewPortDiv = OpenLayers.Util.createDiv(id, null, null, null,
	                                                     "relative", null,
	                                                     "hidden");
	        this.viewPortDiv.style.width = "100%";
	        this.viewPortDiv.style.height = "100%";
	        this.viewPortDiv.className = "olMapViewport";
	        this.div.appendChild(this.viewPortDiv);

	        this.events = new OpenLayers.Events(
	            this, this.viewPortDiv, null, this.fallThrough, 
	            {includeXY: true}
	        );
	        
	        if (OpenLayers.TileManager && this.tileManager !== null) {
	            if (!(this.tileManager instanceof OpenLayers.TileManager)) {
	                this.tileManager = new OpenLayers.TileManager(this.tileManager);
	            }
	            this.tileManager.addMap(this);
	        }

	        // the layerContainerDiv is the one that holds all the layers
	        id = this.id + "_OpenLayers_Container";
	        this.layerContainerDiv = OpenLayers.Util.createDiv(id);
	        this.layerContainerDiv.style.zIndex=this.Z_INDEX_BASE['Popup']-1;
	        this.layerContainerOriginPx = {x: 0, y: 0};
	        this.applyTransform();
	        
	        this.viewPortDiv.appendChild(this.layerContainerDiv);

	        this.updateSize();
	        if(this.eventListeners instanceof Object) {
	            this.events.on(this.eventListeners);
	        }

	        if (this.autoUpdateSize === true) {
	            // updateSize on catching the window's resize
	            // Note that this is ok, as updateSize() does nothing if the 
	            // map's size has not actually changed.
	            this.updateSizeDestroy = OpenLayers.Function.bind(this.updateSize, 
	                this);
	            OpenLayers.Event.observe(window, 'resize',
	                            this.updateSizeDestroy);
	        }
	        
	        // only append link stylesheet if the theme property is set
	        if(this.theme) {
	            // check existing links for equivalent url
	            var addNode = true;
	            var nodes = document.getElementsByTagName('link');
	            for(var i=0, len=nodes.length; i<len; ++i) {
	                if(OpenLayers.Util.isEquivalentUrl(nodes.item(i).href,
	                                                   this.theme)) {
	                    addNode = false;
	                    break;
	                }
	            }
	            // only add a new node if one with an equivalent url hasn't already
	            // been added
	            if(addNode) {
	                var cssNode = document.createElement('link');
	                cssNode.setAttribute('rel', 'stylesheet');
	                cssNode.setAttribute('type', 'text/css');
	                cssNode.setAttribute('href', this.theme);
	                document.getElementsByTagName('head')[0].appendChild(cssNode);
	            }
	        }
	        
	        if (this.controls == null) { // default controls
	            this.controls = [];
	            if (OpenLayers.Control != null) { // running full or lite?
	                // Navigation or TouchNavigation depending on what is in build
	                if (OpenLayers.Control.Navigation) {
	                    this.controls.push(new OpenLayers.Control.Navigation());
	                } else if (OpenLayers.Control.TouchNavigation) {
	                    this.controls.push(new OpenLayers.Control.TouchNavigation());
	                }
	                if (OpenLayers.Control.Zoom) {
	                    this.controls.push(new OpenLayers.Control.Zoom());
	                } else if (OpenLayers.Control.PanZoom) {
	                    this.controls.push(new OpenLayers.Control.PanZoom());
	                }

	                if (OpenLayers.Control.ArgParser) {
	                    this.controls.push(new OpenLayers.Control.ArgParser());
	                }
	                if (OpenLayers.Control.Attribution) {
	                    this.controls.push(new OpenLayers.Control.Attribution());
	                }
	            }
	        }

	        for(var i=0, len=this.controls.length; i<len; i++) {
	            this.addControlToMap(this.controls[i]);
	        }

	        this.popups = [];

	        this.unloadDestroy = OpenLayers.Function.bind(this.destroy, this);
	        

	        // always call map.destroy()
	        OpenLayers.Event.observe(window, 'unload', this.unloadDestroy);
	        
	        // add any initial layers
	        if (options && options.layers) {
	            /** 
	             * If you have set options.center, the map center property will be
	             * set at this point.  However, since setCenter has not been called,
	             * addLayers gets confused.  So we delete the map center in this 
	             * case.  Because the check below uses options.center, it will
	             * be properly set below.
	             */
	            delete this.center;
	            delete this.zoom;
	            this.addLayers(options.layers);
	            // set center (and optionally zoom)
	            if (options.center && !this.getCenter()) {
	                // zoom can be undefined here
	                this.setCenter(options.center, options.zoom);
	            }
	        }

	        if (this.panMethod) {
	            this.panTween = new OpenLayers.Tween(this.panMethod);
	        }
	        if (this.zoomMethod && this.applyTransform.transform) {
	            this.zoomTween = new OpenLayers.Tween(this.zoomMethod);
	        }
	    },

	    /** 
	     * APIMethod: getViewport
	     * Get the DOMElement representing the view port.
	     *
	     * Returns:
	     * {DOMElement}
	     */
	    getViewport: function() {
	        return this.viewPortDiv;
	    },
	    
	    /**
	     * APIMethod: render
	     * Render the map to a specified container.
	     * 
	     * Parameters:
	     * div - {String|DOMElement} The container that the map should be rendered
	     *     to. If different than the current container, the map viewport
	     *     will be moved from the current to the new container.
	     */
	    render: function(div) {
	        this.div = OpenLayers.Util.getElement(div);
	        OpenLayers.Element.addClass(this.div, 'olMap');
	        this.viewPortDiv.parentNode.removeChild(this.viewPortDiv);
	        this.div.appendChild(this.viewPortDiv);
	        this.updateSize();
	    },

	    /**
	     * Method: unloadDestroy
	     * Function that is called to destroy the map on page unload. stored here
	     *     so that if map is manually destroyed, we can unregister this.
	     */
	    unloadDestroy: null,
	    
	    /**
	     * Method: updateSizeDestroy
	     * When the map is destroyed, we need to stop listening to updateSize
	     *    events: this method stores the function we need to unregister in 
	     *    non-IE browsers.
	     */
	    updateSizeDestroy: null,

	    /**
	     * APIMethod: destroy
	     * Destroy this map.
	     *    Note that if you are using an application which removes a container
	     *    of the map from the DOM, you need to ensure that you destroy the
	     *    map *before* this happens; otherwise, the page unload handler
	     *    will fail because the DOM elements that map.destroy() wants
	     *    to clean up will be gone. (See 
	     *    http://trac.osgeo.org/openlayers/ticket/2277 for more information).
	     *    This will apply to GeoExt and also to other applications which
	     *    modify the DOM of the container of the OpenLayers Map.
	     */
	    destroy:function() {
	        // if unloadDestroy is null, we've already been destroyed
	        if (!this.unloadDestroy) {
	            return false;
	        }
	        
	        // make sure panning doesn't continue after destruction
	        if(this.panTween) {
	            this.panTween.stop();
	            this.panTween = null;
	        }
	        // make sure zooming doesn't continue after destruction
	        if(this.zoomTween) {
	            this.zoomTween.stop();
	            this.zoomTween = null;
	        }

	        // map has been destroyed. dont do it again!
	        OpenLayers.Event.stopObserving(window, 'unload', this.unloadDestroy);
	        this.unloadDestroy = null;

	        if (this.updateSizeDestroy) {
	            OpenLayers.Event.stopObserving(window, 'resize', 
	                                           this.updateSizeDestroy);
	        }
	        
	        this.paddingForPopups = null;    

	        if (this.controls != null) {
	            for (var i = this.controls.length - 1; i>=0; --i) {
	                this.controls[i].destroy();
	            } 
	            this.controls = null;
	        }
	        if (this.layers != null) {
	            for (var i = this.layers.length - 1; i>=0; --i) {
	                //pass 'false' to destroy so that map wont try to set a new 
	                // baselayer after each baselayer is removed
	                this.layers[i].destroy(false);
	            } 
	            this.layers = null;
	        }
	        if (this.viewPortDiv && this.viewPortDiv.parentNode) {
	            this.viewPortDiv.parentNode.removeChild(this.viewPortDiv);
	        }
	        this.viewPortDiv = null;
	        
	        if (this.tileManager) {
	            this.tileManager.removeMap(this);
	            this.tileManager = null;
	        }

	        if(this.eventListeners) {
	            this.events.un(this.eventListeners);
	            this.eventListeners = null;
	        }
	        this.events.destroy();
	        this.events = null;

	        this.options = null;
	    },

	    /**
	     * APIMethod: setOptions
	     * Change the map options
	     *
	     * Parameters:
	     * options - {Object} Hashtable of options to tag to the map
	     */
	    setOptions: function(options) {
	        var updatePxExtent = this.minPx &&
	            options.restrictedExtent != this.restrictedExtent;
	        OpenLayers.Util.extend(this, options);
	        // force recalculation of minPx and maxPx
	        updatePxExtent && this.moveTo(this.getCachedCenter(), this.zoom, {
	            forceZoomChange: true
	        });
	    },

	    /**
	     * APIMethod: getTileSize
	     * Get the tile size for the map
	     *
	     * Returns:
	     * {<OpenLayers.Size>}
	     */
	     getTileSize: function() {
	         return this.tileSize;
	     },


	    /**
	     * APIMethod: getBy
	     * Get a list of objects given a property and a match item.
	     *
	     * Parameters:
	     * array - {String} A property on the map whose value is an array.
	     * property - {String} A property on each item of the given array.
	     * match - {String | Object} A string to match.  Can also be a regular
	     *     expression literal or object.  In addition, it can be any object
	     *     with a method named test.  For reqular expressions or other, if
	     *     match.test(map[array][i][property]) evaluates to true, the item will
	     *     be included in the array returned.  If no items are found, an empty
	     *     array is returned.
	     *
	     * Returns:
	     * {Array} An array of items where the given property matches the given
	     *     criteria.
	     */
	    getBy: function(array, property, match) {
	        var test = (typeof match.test == "function");
	        var found = OpenLayers.Array.filter(this[array], function(item) {
	            return item[property] == match || (test && match.test(item[property]));
	        });
	        return found;
	    },

	    /**
	     * APIMethod: getLayersBy
	     * Get a list of layers with properties matching the given criteria.
	     *
	     * Parameters:
	     * property - {String} A layer property to be matched.
	     * match - {String | Object} A string to match.  Can also be a regular
	     *     expression literal or object.  In addition, it can be any object
	     *     with a method named test.  For reqular expressions or other, if
	     *     match.test(layer[property]) evaluates to true, the layer will be
	     *     included in the array returned.  If no layers are found, an empty
	     *     array is returned.
	     *
	     * Returns:
	     * {Array(<OpenLayers.Layer>)} A list of layers matching the given criteria.
	     *     An empty array is returned if no matches are found.
	     */
	    getLayersBy: function(property, match) {
	        return this.getBy("layers", property, match);
	    },

	    /**
	     * APIMethod: getLayersByName
	     * Get a list of layers with names matching the given name.
	     *
	     * Parameters:
	     * match - {String | Object} A layer name.  The name can also be a regular
	     *     expression literal or object.  In addition, it can be any object
	     *     with a method named test.  For reqular expressions or other, if
	     *     name.test(layer.name) evaluates to true, the layer will be included
	     *     in the list of layers returned.  If no layers are found, an empty
	     *     array is returned.
	     *
	     * Returns:
	     * {Array(<OpenLayers.Layer>)} A list of layers matching the given name.
	     *     An empty array is returned if no matches are found.
	     */
	    getLayersByName: function(match) {
	        return this.getLayersBy("name", match);
	    },

	    /**
	     * APIMethod: getLayersByClass
	     * Get a list of layers of a given class (CLASS_NAME).
	     *
	     * Parameters:
	     * match - {String | Object} A layer class name.  The match can also be a
	     *     regular expression literal or object.  In addition, it can be any
	     *     object with a method named test.  For reqular expressions or other,
	     *     if type.test(layer.CLASS_NAME) evaluates to true, the layer will
	     *     be included in the list of layers returned.  If no layers are
	     *     found, an empty array is returned.
	     *
	     * Returns:
	     * {Array(<OpenLayers.Layer>)} A list of layers matching the given class.
	     *     An empty array is returned if no matches are found.
	     */
	    getLayersByClass: function(match) {
	        return this.getLayersBy("CLASS_NAME", match);
	    },

	    /**
	     * APIMethod: getControlsBy
	     * Get a list of controls with properties matching the given criteria.
	     *
	     * Parameters:
	     * property - {String} A control property to be matched.
	     * match - {String | Object} A string to match.  Can also be a regular
	     *     expression literal or object.  In addition, it can be any object
	     *     with a method named test.  For reqular expressions or other, if
	     *     match.test(layer[property]) evaluates to true, the layer will be
	     *     included in the array returned.  If no layers are found, an empty
	     *     array is returned.
	     *
	     * Returns:
	     * {Array(<OpenLayers.Control>)} A list of controls matching the given
	     *     criteria.  An empty array is returned if no matches are found.
	     */
	    getControlsBy: function(property, match) {
	        return this.getBy("controls", property, match);
	    },

	    /**
	     * APIMethod: getControlsByClass
	     * Get a list of controls of a given class (CLASS_NAME).
	     *
	     * Parameters:
	     * match - {String | Object} A control class name.  The match can also be a
	     *     regular expression literal or object.  In addition, it can be any
	     *     object with a method named test.  For reqular expressions or other,
	     *     if type.test(control.CLASS_NAME) evaluates to true, the control will
	     *     be included in the list of controls returned.  If no controls are
	     *     found, an empty array is returned.
	     *
	     * Returns:
	     * {Array(<OpenLayers.Control>)} A list of controls matching the given class.
	     *     An empty array is returned if no matches are found.
	     */
	    getControlsByClass: function(match) {
	        return this.getControlsBy("CLASS_NAME", match);
	    },

	  /********************************************************/
	  /*                                                      */
	  /*                  Layer Functions                     */
	  /*                                                      */
	  /*     The following functions deal with adding and     */
	  /*        removing Layers to and from the Map           */
	  /*                                                      */
	  /********************************************************/         

	    /**
	     * APIMethod: getLayer
	     * Get a layer based on its id
	     *
	     * Parameters:
	     * id - {String} A layer id
	     *
	     * Returns:
	     * {<OpenLayers.Layer>} The Layer with the corresponding id from the map's 
	     *                      layer collection, or null if not found.
	     */
	    getLayer: function(id) {
	        var foundLayer = null;
	        for (var i=0, len=this.layers.length; i<len; i++) {
	            var layer = this.layers[i];
	            if (layer.id == id) {
	                foundLayer = layer;
	                break;
	            }
	        }
	        return foundLayer;
	    },

	    /**
	    * Method: setLayerZIndex
	    * 
	    * Parameters:
	    * layer - {<OpenLayers.Layer>} 
	    * zIdx - {int} 
	    */    
	    setLayerZIndex: function (layer, zIdx) {
	        layer.setZIndex(
	            this.Z_INDEX_BASE[layer.isBaseLayer ? 'BaseLayer' : 'Overlay']
	            + zIdx * 5 );
	    },

	    /**
	     * Method: resetLayersZIndex
	     * Reset each layer's z-index based on layer's array index
	     */
	    resetLayersZIndex: function() {
	        for (var i=0, len=this.layers.length; i<len; i++) {
	            var layer = this.layers[i];
	            this.setLayerZIndex(layer, i);
	        }
	    },

	    /**
	    * APIMethod: addLayer
	    *
	    * Parameters:
	    * layer - {<OpenLayers.Layer>} 
	    *
	    * Returns:
	    * {Boolean} True if the layer has been added to the map.
	    */    
	    addLayer: function (layer) {
	        for(var i = 0, len = this.layers.length; i < len; i++) {
	            if (this.layers[i] == layer) {
	                return false;
	            }
	        }
	        if (this.events.triggerEvent("preaddlayer", {layer: layer}) === false) {
	            return false;
	        }
	        if(this.allOverlays) {
	            layer.isBaseLayer = false;
	        }
	        
	        layer.div.className = "olLayerDiv";
	        layer.div.style.overflow = "";
	        this.setLayerZIndex(layer, this.layers.length);

	        if (layer.isFixed) {
	            this.viewPortDiv.appendChild(layer.div);
	        } else {
	            this.layerContainerDiv.appendChild(layer.div);
	        }
	        this.layers.push(layer);
	        layer.setMap(this);

	        if (layer.isBaseLayer || (this.allOverlays && !this.baseLayer))  {
	            if (this.baseLayer == null) {
	                // set the first baselaye we add as the baselayer
	                this.setBaseLayer(layer);
	            } else {
	                layer.setVisibility(false);
	            }
	        } else {
	            layer.redraw();
	        }

	        this.events.triggerEvent("addlayer", {layer: layer});
	        layer.events.triggerEvent("added", {map: this, layer: layer});
	        layer.afterAdd();

	        return true;
	    },

	    /**
	    * APIMethod: addLayers 
	    *
	    * Parameters:
	    * layers - {Array(<OpenLayers.Layer>)} 
	    */    
	    addLayers: function (layers) {
	        for (var i=0, len=layers.length; i<len; i++) {
	            this.addLayer(layers[i]);
	        }
	    },

	    /** 
	     * APIMethod: removeLayer
	     * Removes a layer from the map by removing its visual element (the 
	     *   layer.div property), then removing it from the map's internal list 
	     *   of layers, setting the layer's map property to null. 
	     * 
	     *   a "removelayer" event is triggered.
	     * 
	     *   very worthy of mention is that simply removing a layer from a map
	     *   will not cause the removal of any popups which may have been created
	     *   by the layer. this is due to the fact that it was decided at some
	     *   point that popups would not belong to layers. thus there is no way 
	     *   for us to know here to which layer the popup belongs.
	     *    
	     *     A simple solution to this is simply to call destroy() on the layer.
	     *     the default OpenLayers.Layer class's destroy() function
	     *     automatically takes care to remove itself from whatever map it has
	     *     been attached to. 
	     * 
	     *     The correct solution is for the layer itself to register an 
	     *     event-handler on "removelayer" and when it is called, if it 
	     *     recognizes itself as the layer being removed, then it cycles through
	     *     its own personal list of popups, removing them from the map.
	     * 
	     * Parameters:
	     * layer - {<OpenLayers.Layer>} 
	     * setNewBaseLayer - {Boolean} Default is true
	     */
	    removeLayer: function(layer, setNewBaseLayer) {
	        if (this.events.triggerEvent("preremovelayer", {layer: layer}) === false) {
	            return;
	        }
	        if (setNewBaseLayer == null) {
	            setNewBaseLayer = true;
	        }

	        if (layer.isFixed) {
	            this.viewPortDiv.removeChild(layer.div);
	        } else {
	            this.layerContainerDiv.removeChild(layer.div);
	        }
	        OpenLayers.Util.removeItem(this.layers, layer);
	        layer.removeMap(this);
	        layer.map = null;

	        // if we removed the base layer, need to set a new one
	        if(this.baseLayer == layer) {
	            this.baseLayer = null;
	            if(setNewBaseLayer) {
	                for(var i=0, len=this.layers.length; i<len; i++) {
	                    var iLayer = this.layers[i];
	                    if (iLayer.isBaseLayer || this.allOverlays) {
	                        this.setBaseLayer(iLayer);
	                        break;
	                    }
	                }
	            }
	        }

	        this.resetLayersZIndex();

	        this.events.triggerEvent("removelayer", {layer: layer});
	        layer.events.triggerEvent("removed", {map: this, layer: layer});
	    },

	    /**
	     * APIMethod: getNumLayers
	     * 
	     * Returns:
	     * {Int} The number of layers attached to the map.
	     */
	    getNumLayers: function () {
	        return this.layers.length;
	    },

	    /** 
	     * APIMethod: getLayerIndex
	     *
	     * Parameters:
	     * layer - {<OpenLayers.Layer>}
	     *
	     * Returns:
	     * {Integer} The current (zero-based) index of the given layer in the map's
	     *           layer stack. Returns -1 if the layer isn't on the map.
	     */
	    getLayerIndex: function (layer) {
	        return OpenLayers.Util.indexOf(this.layers, layer);
	    },
	    
	    /** 
	     * APIMethod: setLayerIndex
	     * Move the given layer to the specified (zero-based) index in the layer
	     *     list, changing its z-index in the map display. Use
	     *     map.getLayerIndex() to find out the current index of a layer. Note
	     *     that this cannot (or at least should not) be effectively used to
	     *     raise base layers above overlays.
	     *
	     * Parameters:
	     * layer - {<OpenLayers.Layer>} 
	     * idx - {int} 
	     */
	    setLayerIndex: function (layer, idx) {
	        var base = this.getLayerIndex(layer);
	        if (idx < 0) {
	            idx = 0;
	        } else if (idx > this.layers.length) {
	            idx = this.layers.length;
	        }
	        if (base != idx) {
	            this.layers.splice(base, 1);
	            this.layers.splice(idx, 0, layer);
	            for (var i=0, len=this.layers.length; i<len; i++) {
	                this.setLayerZIndex(this.layers[i], i);
	            }
	            this.events.triggerEvent("changelayer", {
	                layer: layer, property: "order"
	            });
	            if(this.allOverlays) {
	                if(idx === 0) {
	                    this.setBaseLayer(layer);
	                } else if(this.baseLayer !== this.layers[0]) {
	                    this.setBaseLayer(this.layers[0]);
	                }
	            }
	        }
	    },

	    /** 
	     * APIMethod: raiseLayer
	     * Change the index of the given layer by delta. If delta is positive, 
	     *     the layer is moved up the map's layer stack; if delta is negative,
	     *     the layer is moved down.  Again, note that this cannot (or at least
	     *     should not) be effectively used to raise base layers above overlays.
	     *
	     * Parameters:
	     * layer - {<OpenLayers.Layer>} 
	     * delta - {int} 
	     */
	    raiseLayer: function (layer, delta) {
	        var idx = this.getLayerIndex(layer) + delta;
	        this.setLayerIndex(layer, idx);
	    },
	    
	    /** 
	     * APIMethod: setBaseLayer
	     * Allows user to specify one of the currently-loaded layers as the Map's
	     *     new base layer.
	     * 
	     * Parameters:
	     * newBaseLayer - {<OpenLayers.Layer>}
	     */
	    setBaseLayer: function(newBaseLayer) {
	        
	        if (newBaseLayer != this.baseLayer) {
	          
	            // ensure newBaseLayer is already loaded
	            if (OpenLayers.Util.indexOf(this.layers, newBaseLayer) != -1) {

	                // preserve center and scale when changing base layers
	                var center = this.getCachedCenter();
	                var oldResolution = this.getResolution();
	                var newResolution = OpenLayers.Util.getResolutionFromScale(
	                    this.getScale(), newBaseLayer.units
	                );

	                // make the old base layer invisible 
	                if (this.baseLayer != null && !this.allOverlays) {
	                    this.baseLayer.setVisibility(false);
	                }

	                // set new baselayer
	                this.baseLayer = newBaseLayer;
	                
	                if(!this.allOverlays || this.baseLayer.visibility) {
	                    this.baseLayer.setVisibility(true);
	                    // Layer may previously have been visible but not in range.
	                    // In this case we need to redraw it to make it visible.
	                    if (this.baseLayer.inRange === false) {
	                        this.baseLayer.redraw();
	                    }
	                }

	                // recenter the map
	                if (center != null) {
	                    // new zoom level derived from old scale
	                    var newZoom = this.getZoomForResolution(
	                        newResolution || this.resolution, true
	                    );
	                    // zoom and force zoom change
	                    this.setCenter(center, newZoom, false, oldResolution != newResolution);
	                }

	                this.events.triggerEvent("changebaselayer", {
	                    layer: this.baseLayer
	                });
	            }        
	        }
	    },


	  /********************************************************/
	  /*                                                      */
	  /*                 Control Functions                    */
	  /*                                                      */
	  /*     The following functions deal with adding and     */
	  /*        removing Controls to and from the Map         */
	  /*                                                      */
	  /********************************************************/         

	    /**
	     * APIMethod: addControl
	     * Add the passed over control to the map. Optionally 
	     *     position the control at the given pixel.
	     * 
	     * Parameters:
	     * control - {<OpenLayers.Control>}
	     * px - {<OpenLayers.Pixel>}
	     */    
	    addControl: function (control, px) {
	        this.controls.push(control);
	        this.addControlToMap(control, px);
	    },
	    
	    /**
	     * APIMethod: addControls
	     * Add all of the passed over controls to the map. 
	     *     You can pass over an optional second array
	     *     with pixel-objects to position the controls.
	     *     The indices of the two arrays should match and
	     *     you can add null as pixel for those controls 
	     *     you want to be autopositioned.   
	     *     
	     * Parameters:
	     * controls - {Array(<OpenLayers.Control>)}
	     * pixels - {Array(<OpenLayers.Pixel>)}
	     */    
	    addControls: function (controls, pixels) {
	        var pxs = (arguments.length === 1) ? [] : pixels;
	        for (var i=0, len=controls.length; i<len; i++) {
	            var ctrl = controls[i];
	            var px = (pxs[i]) ? pxs[i] : null;
	            this.addControl( ctrl, px );
	        }
	    },

	    /**
	     * Method: addControlToMap
	     * 
	     * Parameters:
	     * 
	     * control - {<OpenLayers.Control>}
	     * px - {<OpenLayers.Pixel>}
	     */    
	    addControlToMap: function (control, px) {
	        // If a control doesn't have a div at this point, it belongs in the
	        // viewport.
	        control.outsideViewport = (control.div != null);
	        
	        // If the map has a displayProjection, and the control doesn't, set 
	        // the display projection.
	        if (this.displayProjection && !control.displayProjection) {
	            control.displayProjection = this.displayProjection;
	        }    
	        
	        control.setMap(this);
	        var div = control.draw(px);
	        if (div) {
	            if(!control.outsideViewport) {
	                div.style.zIndex = this.Z_INDEX_BASE['Control'] +
	                                    this.controls.length;
	                this.viewPortDiv.appendChild( div );
	            }
	        }
	        if(control.autoActivate) {
	            control.activate();
	        }
	    },
	    
	    /**
	     * APIMethod: getControl
	     * 
	     * Parameters:
	     * id - {String} ID of the control to return.
	     * 
	     * Returns:
	     * {<OpenLayers.Control>} The control from the map's list of controls 
	     *                        which has a matching 'id'. If none found, 
	     *                        returns null.
	     */    
	    getControl: function (id) {
	        var returnControl = null;
	        for(var i=0, len=this.controls.length; i<len; i++) {
	            var control = this.controls[i];
	            if (control.id == id) {
	                returnControl = control;
	                break;
	            }
	        }
	        return returnControl;
	    },
	    
	    /** 
	     * APIMethod: removeControl
	     * Remove a control from the map. Removes the control both from the map 
	     *     object's internal array of controls, as well as from the map's 
	     *     viewPort (assuming the control was not added outsideViewport)
	     * 
	     * Parameters:
	     * control - {<OpenLayers.Control>} The control to remove.
	     */    
	    removeControl: function (control) {
	        //make sure control is non-null and actually part of our map
	        if ( (control) && (control == this.getControl(control.id)) ) {
	            if (control.div && (control.div.parentNode == this.viewPortDiv)) {
	                this.viewPortDiv.removeChild(control.div);
	            }
	            OpenLayers.Util.removeItem(this.controls, control);
	        }
	    },

	  /********************************************************/
	  /*                                                      */
	  /*                  Popup Functions                     */
	  /*                                                      */
	  /*     The following functions deal with adding and     */
	  /*        removing Popups to and from the Map           */
	  /*                                                      */
	  /********************************************************/         

	    /** 
	     * APIMethod: addPopup
	     * 
	     * Parameters:
	     * popup - {<OpenLayers.Popup>}
	     * exclusive - {Boolean} If true, closes all other popups first
	     */
	    addPopup: function(popup, exclusive) {

	        if (exclusive) {
	            //remove all other popups from screen
	            for (var i = this.popups.length - 1; i >= 0; --i) {
	                this.removePopup(this.popups[i]);
	            }
	        }

	        popup.map = this;
	        this.popups.push(popup);
	        var popupDiv = popup.draw();
	        if (popupDiv) {
	            popupDiv.style.zIndex = this.Z_INDEX_BASE['Popup'] +
	                                    this.popups.length;
	            this.layerContainerDiv.appendChild(popupDiv);
	        }
	    },
	    
	    /** 
	    * APIMethod: removePopup
	    * 
	    * Parameters:
	    * popup - {<OpenLayers.Popup>}
	    */
	    removePopup: function(popup) {
	        OpenLayers.Util.removeItem(this.popups, popup);
	        if (popup.div) {
	            try { this.layerContainerDiv.removeChild(popup.div); }
	            catch (e) { } // Popups sometimes apparently get disconnected
	                      // from the layerContainerDiv, and cause complaints.
	        }
	        popup.map = null;
	    },

	  /********************************************************/
	  /*                                                      */
	  /*              Container Div Functions                 */
	  /*                                                      */
	  /*   The following functions deal with the access to    */
	  /*    and maintenance of the size of the container div  */
	  /*                                                      */
	  /********************************************************/     

	    /**
	     * APIMethod: getSize
	     * 
	     * Returns:
	     * {<OpenLayers.Size>} An <OpenLayers.Size> object that represents the 
	     *                     size, in pixels, of the div into which OpenLayers 
	     *                     has been loaded. 
	     *                     Note - A clone() of this locally cached variable is
	     *                     returned, so as not to allow users to modify it.
	     */
	    getSize: function () {
	        var size = null;
	        if (this.size != null) {
	            size = this.size.clone();
	        }
	        return size;
	    },

	    /**
	     * APIMethod: updateSize
	     * This function should be called by any external code which dynamically
	     *     changes the size of the map div (because mozilla wont let us catch 
	     *     the "onresize" for an element)
	     */
	    updateSize: function() {
	        // the div might have moved on the page, also
	        var newSize = this.getCurrentSize();
	        if (newSize && !isNaN(newSize.h) && !isNaN(newSize.w)) {
	            this.events.clearMouseCache();
	            var oldSize = this.getSize();
	            if (oldSize == null) {
	                this.size = oldSize = newSize;
	            }
	            if (!newSize.equals(oldSize)) {
	                
	                // store the new size
	                this.size = newSize;
	    
	                //notify layers of mapresize
	                for(var i=0, len=this.layers.length; i<len; i++) {
	                    this.layers[i].onMapResize();                
	                }
	    
	                var center = this.getCachedCenter();
	    
	                if (this.baseLayer != null && center != null) {
	                    var zoom = this.getZoom();
	                    this.zoom = null;
	                    this.setCenter(center, zoom);
	                }
	    
	            }
	        }
	        this.events.triggerEvent("updatesize");
	    },
	    
	    /**
	     * Method: getCurrentSize
	     * 
	     * Returns:
	     * {<OpenLayers.Size>} A new <OpenLayers.Size> object with the dimensions 
	     *                     of the map div
	     */
	    getCurrentSize: function() {

	        var size = new OpenLayers.Size(this.div.clientWidth, 
	                                       this.div.clientHeight);

	        if (size.w == 0 && size.h == 0 || isNaN(size.w) && isNaN(size.h)) {
	            size.w = this.div.offsetWidth;
	            size.h = this.div.offsetHeight;
	        }
	        if (size.w == 0 && size.h == 0 || isNaN(size.w) && isNaN(size.h)) {
	            size.w = parseInt(this.div.style.width);
	            size.h = parseInt(this.div.style.height);
	        }
	        return size;
	    },

	    /** 
	     * Method: calculateBounds
	     * 
	     * Parameters:
	     * center - {<OpenLayers.LonLat>} Default is this.getCenter()
	     * resolution - {float} Default is this.getResolution() 
	     * 
	     * Returns:
	     * {<OpenLayers.Bounds>} A bounds based on resolution, center, and 
	     *                       current mapsize.
	     */
	    calculateBounds: function(center, resolution) {

	        var extent = null;
	        
	        if (center == null) {
	            center = this.getCachedCenter();
	        }                
	        if (resolution == null) {
	            resolution = this.getResolution();
	        }
	    
	        if ((center != null) && (resolution != null)) {
	            var halfWDeg = (this.size.w * resolution) / 2;
	            var halfHDeg = (this.size.h * resolution) / 2;
	        
	            extent = new OpenLayers.Bounds(center.lon - halfWDeg,
	                                           center.lat - halfHDeg,
	                                           center.lon + halfWDeg,
	                                           center.lat + halfHDeg);
	        }

	        return extent;
	    },


	  /********************************************************/
	  /*                                                      */
	  /*            Zoom, Center, Pan Functions               */
	  /*                                                      */
	  /*    The following functions handle the validation,    */
	  /*   getting and setting of the Zoom Level and Center   */
	  /*       as well as the panning of the Map              */
	  /*                                                      */
	  /********************************************************/
	    /**
	     * APIMethod: getCenter
	     * 
	     * Returns:
	     * {<OpenLayers.LonLat>}
	     */
	    getCenter: function () {
	        var center = null;
	        var cachedCenter = this.getCachedCenter();
	        if (cachedCenter) {
	            center = cachedCenter.clone();
	        }
	        return center;
	    },

	    /**
	     * Method: getCachedCenter
	     *
	     * Returns:
	     * {<OpenLayers.LonLat>}
	     */
	    getCachedCenter: function() {
	        if (!this.center && this.size) {
	            this.center = this.getLonLatFromViewPortPx({
	                x: this.size.w / 2,
	                y: this.size.h / 2
	            });
	        }
	        return this.center;
	    },

	    /**
	     * APIMethod: getZoom
	     * 
	     * Returns:
	     * {Integer}
	     */
	    getZoom: function () {
	        return this.zoom;
	    },
	    
	    /** 
	     * APIMethod: pan
	     * Allows user to pan by a value of screen pixels
	     * 
	     * Parameters:
	     * dx - {Integer}
	     * dy - {Integer}
	     * options - {Object} Options to configure panning:
	     *  - *animate* {Boolean} Use panTo instead of setCenter. Default is true.
	     *  - *dragging* {Boolean} Call setCenter with dragging true.  Default is
	     *    false.
	     */
	    pan: function(dx, dy, options) {
	        options = OpenLayers.Util.applyDefaults(options, {
	            animate: true,
	            dragging: false
	        });
	        if (options.dragging) {
	            if (dx != 0 || dy != 0) {
	                this.moveByPx(dx, dy);
	            }
	        } else {
	            // getCenter
	            var centerPx = this.getViewPortPxFromLonLat(this.getCachedCenter());

	            // adjust
	            var newCenterPx = centerPx.add(dx, dy);

	            if (this.dragging || !newCenterPx.equals(centerPx)) {
	                var newCenterLonLat = this.getLonLatFromViewPortPx(newCenterPx);
	                if (options.animate) {
	                    this.panTo(newCenterLonLat);
	                } else {
	                    this.moveTo(newCenterLonLat);
	                    if(this.dragging) {
	                        this.dragging = false;
	                        this.events.triggerEvent("moveend");
	                    }
	                }    
	            }
	        }        

	   },
	   
	   /** 
	     * APIMethod: panTo
	     * Allows user to pan to a new lonlat.
	     * If the new lonlat is in the current extent the map will slide smoothly
	     * 
	     * Parameters:
	     * lonlat - {<OpenLayers.LonLat>}
	     */
	    panTo: function(lonlat) {
	        if (this.panTween && this.getExtent().scale(this.panRatio).containsLonLat(lonlat)) {
	            var center = this.getCachedCenter();

	            // center will not change, don't do nothing
	            if (lonlat.equals(center)) {
	                return;
	            }

	            var from = this.getPixelFromLonLat(center);
	            var to = this.getPixelFromLonLat(lonlat);
	            var vector = { x: to.x - from.x, y: to.y - from.y };
	            var last = { x: 0, y: 0 };

	            this.panTween.start( { x: 0, y: 0 }, vector, this.panDuration, {
	                callbacks: {
	                    eachStep: OpenLayers.Function.bind(function(px) {
	                        var x = px.x - last.x,
	                            y = px.y - last.y;
	                        this.moveByPx(x, y);
	                        last.x = Math.round(px.x);
	                        last.y = Math.round(px.y);
	                    }, this),
	                    done: OpenLayers.Function.bind(function(px) {
	                        this.moveTo(lonlat);
	                        this.dragging = false;
	                        this.events.triggerEvent("moveend");
	                    }, this)
	                }
	            });
	        } else {
	            this.setCenter(lonlat);
	        }
	    },

	    /**
	     * APIMethod: setCenter
	     * Set the map center (and optionally, the zoom level).
	     * 
	     * Parameters:
	     * lonlat - {<OpenLayers.LonLat>|Array} The new center location.
	     *     If provided as array, the first value is the x coordinate,
	     *     and the 2nd value is the y coordinate.
	     * zoom - {Integer} Optional zoom level.
	     * dragging - {Boolean} Specifies whether or not to trigger 
	     *                      movestart/end events
	     * forceZoomChange - {Boolean} Specifies whether or not to trigger zoom 
	     *                             change events (needed on baseLayer change)
	     *
	     * TBD: reconsider forceZoomChange in 3.0
	     */
	    setCenter: function(lonlat, zoom, dragging, forceZoomChange) {
	        if (this.panTween) {
	            this.panTween.stop();
	        }
	        if (this.zoomTween) {
	            this.zoomTween.stop();
	        }            
	        this.moveTo(lonlat, zoom, {
	            'dragging': dragging,
	            'forceZoomChange': forceZoomChange
	        });
	    },
	    
	    /** 
	     * Method: moveByPx
	     * Drag the map by pixels.
	     *
	     * Parameters:
	     * dx - {Number}
	     * dy - {Number}
	     */
	    moveByPx: function(dx, dy) {
	        var hw = this.size.w / 2;
	        var hh = this.size.h / 2;
	        var x = hw + dx;
	        var y = hh + dy;
	        var wrapDateLine = this.baseLayer.wrapDateLine;
	        var xRestriction = 0;
	        var yRestriction = 0;
	        if (this.restrictedExtent) {
	            xRestriction = hw;
	            yRestriction = hh;
	            // wrapping the date line makes no sense for restricted extents
	            wrapDateLine = false;
	        }
	        dx = wrapDateLine ||
	                    x <= this.maxPx.x - xRestriction &&
	                    x >= this.minPx.x + xRestriction ? Math.round(dx) : 0;
	        dy = y <= this.maxPx.y - yRestriction &&
	                    y >= this.minPx.y + yRestriction ? Math.round(dy) : 0;
	        if (dx || dy) {
	            if (!this.dragging) {
	                this.dragging = true;
	                this.events.triggerEvent("movestart");
	            }
	            this.center = null;
	            if (dx) {
	                this.layerContainerOriginPx.x -= dx;
	                this.minPx.x -= dx;
	                this.maxPx.x -= dx;
	            }
	            if (dy) {
	                this.layerContainerOriginPx.y -= dy;
	                this.minPx.y -= dy;
	                this.maxPx.y -= dy;
	            }
	            this.applyTransform();
	            var layer, i, len;
	            for (i=0, len=this.layers.length; i<len; ++i) {
	                layer = this.layers[i];
	                if (layer.visibility &&
	                    (layer === this.baseLayer || layer.inRange)) {
	                    layer.moveByPx(dx, dy);
	                    layer.events.triggerEvent("move");
	                }
	            }
	            this.events.triggerEvent("move");
	        }
	    },
	    
	    /**
	     * Method: adjustZoom
	     *
	     * Parameters:
	     * zoom - {Number} The zoom level to adjust
	     *
	     * Returns:
	     * {Integer} Adjusted zoom level that shows a map not wider than its
	     * <baseLayer>'s maxExtent.
	     */
	    adjustZoom: function(zoom) {
	        if (this.baseLayer && this.baseLayer.wrapDateLine) {
	            var resolution, resolutions = this.baseLayer.resolutions,
	                maxResolution = this.getMaxExtent().getWidth() / this.size.w;
	            if (this.getResolutionForZoom(zoom) > maxResolution) {
	                if (this.fractionalZoom) {
	                    zoom = this.getZoomForResolution(maxResolution);
	                } else {
	                    for (var i=zoom|0, ii=resolutions.length; i<ii; ++i) {
	                        if (resolutions[i] <= maxResolution) {
	                            zoom = i;
	                            break;
	                        }
	                    }
	                } 
	            }
	        }
	        return zoom;
	    },
	    
	    /**
	     * APIMethod: getMinZoom
	     * Returns the minimum zoom level for the current map view. If the base
	     * layer is configured with <wrapDateLine> set to true, this will be the
	     * first zoom level that shows no more than one world width in the current
	     * map viewport. Components that rely on this value (e.g. zoom sliders)
	     * should also listen to the map's "updatesize" event and call this method
	     * in the "updatesize" listener.
	     *
	     * Returns:
	     * {Number} Minimum zoom level that shows a map not wider than its
	     * <baseLayer>'s maxExtent. This is an Integer value, unless the map is
	     * configured with <fractionalZoom> set to true.
	     */
	    getMinZoom: function() {
	        return this.adjustZoom(0);
	    },

	    /**
	     * Method: moveTo
	     *
	     * Parameters:
	     * lonlat - {<OpenLayers.LonLat>}
	     * zoom - {Integer}
	     * options - {Object}
	     */
	    moveTo: function(lonlat, zoom, options) {
	        if (lonlat != null && !(lonlat instanceof OpenLayers.LonLat)) {
	            lonlat = new OpenLayers.LonLat(lonlat);
	        }
	        if (!options) { 
	            options = {};
	        }
	        if (zoom != null) {
	            zoom = parseFloat(zoom);
	            if (!this.fractionalZoom) {
	                zoom = Math.round(zoom);
	            }
	        }
	        var requestedZoom = zoom;
	        zoom = this.adjustZoom(zoom);
	        if (zoom !== requestedZoom) {
	            // zoom was adjusted, so keep old lonlat to avoid panning
	            lonlat = this.getCenter();
	        }
	        // dragging is false by default
	        var dragging = options.dragging || this.dragging;
	        // forceZoomChange is false by default
	        var forceZoomChange = options.forceZoomChange;

	        if (!this.getCachedCenter() && !this.isValidLonLat(lonlat)) {
	            lonlat = this.maxExtent.getCenterLonLat();
	            this.center = lonlat.clone();
	        }

	        if(this.restrictedExtent != null) {
	            // In 3.0, decide if we want to change interpretation of maxExtent.
	            if(lonlat == null) { 
	                lonlat = this.center; 
	            }
	            if(zoom == null) { 
	                zoom = this.getZoom(); 
	            }
	            var resolution = this.getResolutionForZoom(zoom);
	            var extent = this.calculateBounds(lonlat, resolution); 
	            if(!this.restrictedExtent.containsBounds(extent)) {
	                var maxCenter = this.restrictedExtent.getCenterLonLat(); 
	                if(extent.getWidth() > this.restrictedExtent.getWidth()) { 
	                    lonlat = new OpenLayers.LonLat(maxCenter.lon, lonlat.lat); 
	                } else if(extent.left < this.restrictedExtent.left) {
	                    lonlat = lonlat.add(this.restrictedExtent.left -
	                                        extent.left, 0); 
	                } else if(extent.right > this.restrictedExtent.right) { 
	                    lonlat = lonlat.add(this.restrictedExtent.right -
	                                        extent.right, 0); 
	                } 
	                if(extent.getHeight() > this.restrictedExtent.getHeight()) { 
	                    lonlat = new OpenLayers.LonLat(lonlat.lon, maxCenter.lat); 
	                } else if(extent.bottom < this.restrictedExtent.bottom) { 
	                    lonlat = lonlat.add(0, this.restrictedExtent.bottom -
	                                        extent.bottom); 
	                } 
	                else if(extent.top > this.restrictedExtent.top) { 
	                    lonlat = lonlat.add(0, this.restrictedExtent.top -
	                                        extent.top); 
	                } 
	            }
	        }
	        
	        var zoomChanged = forceZoomChange || (
	                            (this.isValidZoomLevel(zoom)) && 
	                            (zoom != this.getZoom()) );

	        var centerChanged = (this.isValidLonLat(lonlat)) && 
	                            (!lonlat.equals(this.center));

	        // if neither center nor zoom will change, no need to do anything
	        if (zoomChanged || centerChanged || dragging) {
	            dragging || this.events.triggerEvent("movestart", {
	                zoomChanged: zoomChanged
	            });

	            if (centerChanged) {
	                if (!zoomChanged && this.center) { 
	                    // if zoom hasn't changed, just slide layerContainer
	                    //  (must be done before setting this.center to new value)
	                    this.centerLayerContainer(lonlat);
	                }
	                this.center = lonlat.clone();
	            }

	            var res = zoomChanged ?
	                this.getResolutionForZoom(zoom) : this.getResolution();
	            // (re)set the layerContainerDiv's location
	            if (zoomChanged || this.layerContainerOrigin == null) {
	                this.layerContainerOrigin = this.getCachedCenter();
	                this.layerContainerOriginPx.x = 0;
	                this.layerContainerOriginPx.y = 0;
	                this.applyTransform();
	                var maxExtent = this.getMaxExtent({restricted: true});
	                var maxExtentCenter = maxExtent.getCenterLonLat();
	                var lonDelta = this.center.lon - maxExtentCenter.lon;
	                var latDelta = maxExtentCenter.lat - this.center.lat;
	                var extentWidth = Math.round(maxExtent.getWidth() / res);
	                var extentHeight = Math.round(maxExtent.getHeight() / res);
	                this.minPx = {
	                    x: (this.size.w - extentWidth) / 2 - lonDelta / res,
	                    y: (this.size.h - extentHeight) / 2 - latDelta / res
	                };
	                this.maxPx = {
	                    x: this.minPx.x + Math.round(maxExtent.getWidth() / res),
	                    y: this.minPx.y + Math.round(maxExtent.getHeight() / res)
	                };
	            }

	            if (zoomChanged) {
	                this.zoom = zoom;
	                this.resolution = res;
	            }    
	            
	            var bounds = this.getExtent();
	            
	            //send the move call to the baselayer and all the overlays    

	            if(this.baseLayer.visibility) {
	                this.baseLayer.moveTo(bounds, zoomChanged, options.dragging);
	                options.dragging || this.baseLayer.events.triggerEvent(
	                    "moveend", {zoomChanged: zoomChanged}
	                );
	            }
	            
	            bounds = this.baseLayer.getExtent();
	            
	            for (var i=this.layers.length-1; i>=0; --i) {
	                var layer = this.layers[i];
	                if (layer !== this.baseLayer && !layer.isBaseLayer) {
	                    var inRange = layer.calculateInRange();
	                    if (layer.inRange != inRange) {
	                        // the inRange property has changed. If the layer is
	                        // no longer in range, we turn it off right away. If
	                        // the layer is no longer out of range, the moveTo
	                        // call below will turn on the layer.
	                        layer.inRange = inRange;
	                        if (!inRange) {
	                            layer.display(false);
	                        }
	                        this.events.triggerEvent("changelayer", {
	                            layer: layer, property: "visibility"
	                        });
	                    }
	                    if (inRange && layer.visibility) {
	                        layer.moveTo(bounds, zoomChanged, options.dragging);
	                        options.dragging || layer.events.triggerEvent(
	                            "moveend", {zoomChanged: zoomChanged}
	                        );
	                    }
	                }                
	            }
	            
	            this.events.triggerEvent("move");
	            dragging || this.events.triggerEvent("moveend");

	            if (zoomChanged) {
	                //redraw popups
	                for (var i=0, len=this.popups.length; i<len; i++) {
	                    this.popups[i].updatePosition();
	                }
	                this.events.triggerEvent("zoomend");
	            }
	        }
	    },

	    /** 
	     * Method: centerLayerContainer
	     * This function takes care to recenter the layerContainerDiv.
	     * 
	     * Parameters:
	     * lonlat - {<OpenLayers.LonLat>}
	     */
	    centerLayerContainer: function (lonlat) {
	        var originPx = this.getViewPortPxFromLonLat(this.layerContainerOrigin);
	        var newPx = this.getViewPortPxFromLonLat(lonlat);

	        if ((originPx != null) && (newPx != null)) {
	            var oldLeft = this.layerContainerOriginPx.x;
	            var oldTop = this.layerContainerOriginPx.y;
	            var newLeft = Math.round(originPx.x - newPx.x);
	            var newTop = Math.round(originPx.y - newPx.y);
	            this.applyTransform(
	                (this.layerContainerOriginPx.x = newLeft),
	                (this.layerContainerOriginPx.y = newTop));
	            var dx = oldLeft - newLeft;
	            var dy = oldTop - newTop;
	            this.minPx.x -= dx;
	            this.maxPx.x -= dx;
	            this.minPx.y -= dy;
	            this.maxPx.y -= dy;
	        }        
	    },

	    /**
	     * Method: isValidZoomLevel
	     * 
	     * Parameters:
	     * zoomLevel - {Integer}
	     * 
	     * Returns:
	     * {Boolean} Whether or not the zoom level passed in is non-null and 
	     *           within the min/max range of zoom levels.
	     */
	    isValidZoomLevel: function(zoomLevel) {
	        return ( (zoomLevel != null) &&
	                 (zoomLevel >= 0) && 
	                 (zoomLevel < this.getNumZoomLevels()) );
	    },
	    
	    /**
	     * Method: isValidLonLat
	     * 
	     * Parameters:
	     * lonlat - {<OpenLayers.LonLat>}
	     * 
	     * Returns:
	     * {Boolean} Whether or not the lonlat passed in is non-null and within
	     *           the maxExtent bounds
	     */
	    isValidLonLat: function(lonlat) {
	        var valid = false;
	        if (lonlat != null) {
	            var maxExtent = this.getMaxExtent();
	            var worldBounds = this.baseLayer.wrapDateLine && maxExtent;
	            valid = maxExtent.containsLonLat(lonlat, {worldBounds: worldBounds});
	        }
	        return valid;
	    },

	  /********************************************************/
	  /*                                                      */
	  /*                 Layer Options                        */
	  /*                                                      */
	  /*    Accessor functions to Layer Options parameters    */
	  /*                                                      */
	  /********************************************************/
	    
	    /**
	     * APIMethod: getProjection
	     * This method returns a string representing the projection. In 
	     *     the case of projection support, this will be the srsCode which
	     *     is loaded -- otherwise it will simply be the string value that
	     *     was passed to the projection at startup.
	     *
	     * FIXME: In 3.0, we will remove getProjectionObject, and instead
	     *     return a Projection object from this function. 
	     * 
	     * Returns:
	     * {String} The Projection string from the base layer or null. 
	     */
	    getProjection: function() {
	        var projection = this.getProjectionObject();
	        return projection ? projection.getCode() : null;
	    },
	    
	    /**
	     * APIMethod: getProjectionObject
	     * Returns the projection obect from the baselayer.
	     *
	     * Returns:
	     * {<OpenLayers.Projection>} The Projection of the base layer.
	     */
	    getProjectionObject: function() {
	        var projection = null;
	        if (this.baseLayer != null) {
	            projection = this.baseLayer.projection;
	        }
	        return projection;
	    },
	    
	    /**
	     * APIMethod: getMaxResolution
	     * 
	     * Returns:
	     * {String} The Map's Maximum Resolution
	     */
	    getMaxResolution: function() {
	        var maxResolution = null;
	        if (this.baseLayer != null) {
	            maxResolution = this.baseLayer.maxResolution;
	        }
	        return maxResolution;
	    },
	        
	    /**
	     * APIMethod: getMaxExtent
	     *
	     * Parameters:
	     * options - {Object} 
	     * 
	     * Allowed Options:
	     * restricted - {Boolean} If true, returns restricted extent (if it is 
	     *     available.)
	     *
	     * Returns:
	     * {<OpenLayers.Bounds>} The maxExtent property as set on the current 
	     *     baselayer, unless the 'restricted' option is set, in which case
	     *     the 'restrictedExtent' option from the map is returned (if it
	     *     is set).
	     */
	    getMaxExtent: function (options) {
	        var maxExtent = null;
	        if(options && options.restricted && this.restrictedExtent){
	            maxExtent = this.restrictedExtent;
	        } else if (this.baseLayer != null) {
	            maxExtent = this.baseLayer.maxExtent;
	        }        
	        return maxExtent;
	    },
	    
	    /**
	     * APIMethod: getNumZoomLevels
	     * 
	     * Returns:
	     * {Integer} The total number of zoom levels that can be displayed by the 
	     *           current baseLayer.
	     */
	    getNumZoomLevels: function() {
	        var numZoomLevels = null;
	        if (this.baseLayer != null) {
	            numZoomLevels = this.baseLayer.numZoomLevels;
	        }
	        return numZoomLevels;
	    },

	  /********************************************************/
	  /*                                                      */
	  /*                 Baselayer Functions                  */
	  /*                                                      */
	  /*    The following functions, all publicly exposed     */
	  /*       in the API?, are all merely wrappers to the    */
	  /*       the same calls on whatever layer is set as     */
	  /*                the current base layer                */
	  /*                                                      */
	  /********************************************************/

	    /**
	     * APIMethod: getExtent
	     * 
	     * Returns:
	     * {<OpenLayers.Bounds>} A Bounds object which represents the lon/lat 
	     *                       bounds of the current viewPort. 
	     *                       If no baselayer is set, returns null.
	     */
	    getExtent: function () {
	        var extent = null;
	        if (this.baseLayer != null) {
	            extent = this.baseLayer.getExtent();
	        }
	        return extent;
	    },

	    /**
	     * APIMethod: getResolution
	     * 
	     * Returns:
	     * {Float} The current resolution of the map. 
	     *         If no baselayer is set, returns null.
	     */
	    getResolution: function () {
	        var resolution = null;
	        if (this.baseLayer != null) {
	            resolution = this.baseLayer.getResolution();
	        } else if(this.allOverlays === true && this.layers.length > 0) {
	            // while adding the 1st layer to the map in allOverlays mode,
	            // this.baseLayer is not set yet when we need the resolution
	            // for calculateInRange.
	            resolution = this.layers[0].getResolution();
	        }
	        return resolution;
	    },

	    /**
	     * APIMethod: getUnits
	     * 
	     * Returns:
	     * {Float} The current units of the map. 
	     *         If no baselayer is set, returns null.
	     */
	    getUnits: function () {
	        var units = null;
	        if (this.baseLayer != null) {
	            units = this.baseLayer.units;
	        }
	        return units;
	    },

	     /**
	      * APIMethod: getScale
	      * 
	      * Returns:
	      * {Float} The current scale denominator of the map. 
	      *         If no baselayer is set, returns null.
	      */
	    getScale: function () {
	        var scale = null;
	        if (this.baseLayer != null) {
	            var res = this.getResolution();
	            var units = this.baseLayer.units;
	            scale = OpenLayers.Util.getScaleFromResolution(res, units);
	        }
	        return scale;
	    },


	    /**
	     * APIMethod: getZoomForExtent
	     * 
	     * Parameters: 
	     * bounds - {<OpenLayers.Bounds>}
	     * closest - {Boolean} Find the zoom level that most closely fits the 
	     *     specified bounds. Note that this may result in a zoom that does 
	     *     not exactly contain the entire extent.
	     *     Default is false.
	     * 
	     * Returns:
	     * {Integer} A suitable zoom level for the specified bounds.
	     *           If no baselayer is set, returns null.
	     */
	    getZoomForExtent: function (bounds, closest) {
	        var zoom = null;
	        if (this.baseLayer != null) {
	            zoom = this.baseLayer.getZoomForExtent(bounds, closest);
	        }
	        return zoom;
	    },

	    /**
	     * APIMethod: getResolutionForZoom
	     * 
	     * Parameters:
	     * zoom - {Float}
	     * 
	     * Returns:
	     * {Float} A suitable resolution for the specified zoom.  If no baselayer
	     *     is set, returns null.
	     */
	    getResolutionForZoom: function(zoom) {
	        var resolution = null;
	        if(this.baseLayer) {
	            resolution = this.baseLayer.getResolutionForZoom(zoom);
	        }
	        return resolution;
	    },

	    /**
	     * APIMethod: getZoomForResolution
	     * 
	     * Parameters:
	     * resolution - {Float}
	     * closest - {Boolean} Find the zoom level that corresponds to the absolute 
	     *     closest resolution, which may result in a zoom whose corresponding
	     *     resolution is actually smaller than we would have desired (if this
	     *     is being called from a getZoomForExtent() call, then this means that
	     *     the returned zoom index might not actually contain the entire 
	     *     extent specified... but it'll be close).
	     *     Default is false.
	     * 
	     * Returns:
	     * {Integer} A suitable zoom level for the specified resolution.
	     *           If no baselayer is set, returns null.
	     */
	    getZoomForResolution: function(resolution, closest) {
	        var zoom = null;
	        if (this.baseLayer != null) {
	            zoom = this.baseLayer.getZoomForResolution(resolution, closest);
	        }
	        return zoom;
	    },

	  /********************************************************/
	  /*                                                      */
	  /*                  Zooming Functions                   */
	  /*                                                      */
	  /*    The following functions, all publicly exposed     */
	  /*       in the API, are all merely wrappers to the     */
	  /*               the setCenter() function               */
	  /*                                                      */
	  /********************************************************/
	  
	    /** 
	     * APIMethod: zoomTo
	     * Zoom to a specific zoom level. Zooming will be animated unless the map
	     * is configured with {zoomMethod: null}. To zoom without animation, use
	     * <setCenter> without a lonlat argument.
	     * 
	     * Parameters:
	     * zoom - {Integer}
	     */
	    zoomTo: function(zoom, xy) {
	        // non-API arguments:
	        // xy - {<OpenLayers.Pixel>} optional zoom origin
	        
	        var map = this;
	        if (map.isValidZoomLevel(zoom)) {
	            if (map.baseLayer.wrapDateLine) {
	                zoom = map.adjustZoom(zoom);
	            }
	            var center = xy ?
	                map.getZoomTargetCenter(xy, map.getResolutionForZoom(zoom)) :
	                map.getCenter();
	            if (center) {
	                map.events.triggerEvent('zoomstart', {
	                    center: center,
	                    zoom: zoom
	                });
	            }
	            if (map.zoomTween) {
	                map.zoomTween.stop();
	                var currentRes = map.getResolution(),
	                    targetRes = map.getResolutionForZoom(zoom),
	                    start = {scale: 1},
	                    end = {scale: currentRes / targetRes};
	                if (!xy) {
	                    var size = map.getSize();
	                    xy = {x: size.w / 2, y: size.h / 2};
	                }
	                map.zoomTween.start(start, end, map.zoomDuration, {
	                    minFrameRate: 50, // don't spend much time zooming
	                    callbacks: {
	                        eachStep: function(data) {
	                            var containerOrigin = map.layerContainerOriginPx,
	                                scale = data.scale,
	                                dx = ((scale - 1) * (containerOrigin.x - xy.x)) | 0,
	                                dy = ((scale - 1) * (containerOrigin.y - xy.y)) | 0;
	                            map.applyTransform(containerOrigin.x + dx, containerOrigin.y + dy, scale);
	                        },
	                        done: function(data) {
	                            map.applyTransform();
	                            var resolution = map.getResolution() / data.scale,
	                                newZoom = map.getZoomForResolution(resolution, true),
	                                newCenter = data.scale === 1 ? center :
	                                        map.getZoomTargetCenter(xy, resolution);
	                            map.moveTo(newCenter, newZoom);
	                        }
	                    }
	                });
	            } else {
	                map.setCenter(center, zoom);
	            }
	        }
	    },
	        
	    /**
	     * APIMethod: zoomIn
	     * 
	     */
	    zoomIn: function() {
	        if (this.zoomTween) {
	            this.zoomTween.stop();
	        }
	        this.zoomTo(this.getZoom() + 1);
	    },
	    
	    /**
	     * APIMethod: zoomOut
	     * 
	     */
	    zoomOut: function() {
	        if (this.zoomTween) {
	            this.zoomTween.stop();
	        }
	        this.zoomTo(this.getZoom() - 1);
	    },

	    /**
	     * APIMethod: zoomToExtent
	     * Zoom to the passed in bounds, recenter
	     * 
	     * Parameters:
	     * bounds - {<OpenLayers.Bounds>|Array} If provided as an array, the array
	     *     should consist of four values (left, bottom, right, top).
	     * closest - {Boolean} Find the zoom level that most closely fits the 
	     *     specified bounds. Note that this may result in a zoom that does 
	     *     not exactly contain the entire extent.
	     *     Default is false.
	     * 
	     */
	    zoomToExtent: function(bounds, closest) {
	        if (!(bounds instanceof OpenLayers.Bounds)) {
	            bounds = new OpenLayers.Bounds(bounds);
	        }
	        var center = bounds.getCenterLonLat();
	        if (this.baseLayer.wrapDateLine) {
	            var maxExtent = this.getMaxExtent();

	            //fix straddling bounds (in the case of a bbox that straddles the 
	            // dateline, it's left and right boundaries will appear backwards. 
	            // we fix this by allowing a right value that is greater than the
	            // max value at the dateline -- this allows us to pass a valid 
	            // bounds to calculate zoom)
	            //
	            bounds = bounds.clone();
	            while (bounds.right < bounds.left) {
	                bounds.right += maxExtent.getWidth();
	            }
	            //if the bounds was straddling (see above), then the center point 
	            // we got from it was wrong. So we take our new bounds and ask it
	            // for the center.
	            //
	            center = bounds.getCenterLonLat().wrapDateLine(maxExtent);
	        }
	        this.setCenter(center, this.getZoomForExtent(bounds, closest));
	    },

	    /** 
	     * APIMethod: zoomToMaxExtent
	     * Zoom to the full extent and recenter.
	     *
	     * Parameters:
	     * options - {Object}
	     * 
	     * Allowed Options:
	     * restricted - {Boolean} True to zoom to restricted extent if it is 
	     *     set. Defaults to true.
	     */
	    zoomToMaxExtent: function(options) {
	        //restricted is true by default
	        var restricted = (options) ? options.restricted : true;

	        var maxExtent = this.getMaxExtent({
	            'restricted': restricted 
	        });
	        this.zoomToExtent(maxExtent);
	    },

	    /** 
	     * APIMethod: zoomToScale
	     * Zoom to a specified scale 
	     * 
	     * Parameters:
	     * scale - {float}
	     * closest - {Boolean} Find the zoom level that most closely fits the 
	     *     specified scale. Note that this may result in a zoom that does 
	     *     not exactly contain the entire extent.
	     *     Default is false.
	     * 
	     */
	    zoomToScale: function(scale, closest) {
	        var res = OpenLayers.Util.getResolutionFromScale(scale, 
	                                                         this.baseLayer.units);

	        var halfWDeg = (this.size.w * res) / 2;
	        var halfHDeg = (this.size.h * res) / 2;
	        var center = this.getCachedCenter();

	        var extent = new OpenLayers.Bounds(center.lon - halfWDeg,
	                                           center.lat - halfHDeg,
	                                           center.lon + halfWDeg,
	                                           center.lat + halfHDeg);
	        this.zoomToExtent(extent, closest);
	    },
	    
	  /********************************************************/
	  /*                                                      */
	  /*             Translation Functions                    */
	  /*                                                      */
	  /*      The following functions translate between       */
	  /*           LonLat, LayerPx, and ViewPortPx            */
	  /*                                                      */
	  /********************************************************/
	      
	  //
	  // TRANSLATION: LonLat <-> ViewPortPx
	  //

	    /**
	     * Method: getLonLatFromViewPortPx
	     * 
	     * Parameters:
	     * viewPortPx - {<OpenLayers.Pixel>|Object} An OpenLayers.Pixel or
	     *                                          an object with a 'x'
	     *                                          and 'y' properties.
	     * 
	     * Returns:
	     * {<OpenLayers.LonLat>} An OpenLayers.LonLat which is the passed-in view 
	     *                       port <OpenLayers.Pixel>, translated into lon/lat
	     *                       by the current base layer.
	     */
	    getLonLatFromViewPortPx: function (viewPortPx) {
	        var lonlat = null; 
	        if (this.baseLayer != null) {
	            lonlat = this.baseLayer.getLonLatFromViewPortPx(viewPortPx);
	        }
	        return lonlat;
	    },

	    /**
	     * APIMethod: getViewPortPxFromLonLat
	     * 
	     * Parameters:
	     * lonlat - {<OpenLayers.LonLat>}
	     * 
	     * Returns:
	     * {<OpenLayers.Pixel>} An OpenLayers.Pixel which is the passed-in 
	     *                      <OpenLayers.LonLat>, translated into view port 
	     *                      pixels by the current base layer.
	     */
	    getViewPortPxFromLonLat: function (lonlat) {
	        var px = null; 
	        if (this.baseLayer != null) {
	            px = this.baseLayer.getViewPortPxFromLonLat(lonlat);
	        }
	        return px;
	    },

	    /**
	     * Method: getZoomTargetCenter
	     *
	     * Parameters:
	     * xy - {<OpenLayers.Pixel>} The zoom origin pixel location on the screen
	     * resolution - {Float} The resolution we want to get the center for
	     *
	     * Returns:
	     * {<OpenLayers.LonLat>} The location of the map center after the
	     *     transformation described by the origin xy and the target resolution.
	     */
	    getZoomTargetCenter: function (xy, resolution) {
	        var lonlat = null,
	            size = this.getSize(),
	            deltaX  = size.w/2 - xy.x,
	            deltaY  = xy.y - size.h/2,
	            zoomPoint = this.getLonLatFromPixel(xy);
	        if (zoomPoint) {
	            lonlat = new OpenLayers.LonLat(
	                zoomPoint.lon + deltaX * resolution,
	                zoomPoint.lat + deltaY * resolution
	            );
	        }
	        return lonlat;
	    },
	        
	  //
	  // CONVENIENCE TRANSLATION FUNCTIONS FOR API
	  //

	    /**
	     * APIMethod: getLonLatFromPixel
	     * 
	     * Parameters:
	     * px - {<OpenLayers.Pixel>|Object} An OpenLayers.Pixel or an object with
	     *                                  a 'x' and 'y' properties.
	     *
	     * Returns:
	     * {<OpenLayers.LonLat>} An OpenLayers.LonLat corresponding to the given
	     *                       OpenLayers.Pixel, translated into lon/lat by the 
	     *                       current base layer
	     */
	    getLonLatFromPixel: function (px) {
	        return this.getLonLatFromViewPortPx(px);
	    },

	    /**
	     * APIMethod: getPixelFromLonLat
	     * Returns a pixel location given a map location.  The map location is
	     *     translated to an integer pixel location (in viewport pixel
	     *     coordinates) by the current base layer.
	     * 
	     * Parameters:
	     * lonlat - {<OpenLayers.LonLat>} A map location.
	     * 
	     * Returns: 
	     * {<OpenLayers.Pixel>} An OpenLayers.Pixel corresponding to the 
	     *     <OpenLayers.LonLat> translated into view port pixels by the current
	     *     base layer.
	     */
	    getPixelFromLonLat: function (lonlat) {
	        var px = this.getViewPortPxFromLonLat(lonlat);
	        px.x = Math.round(px.x);
	        px.y = Math.round(px.y);
	        return px;
	    },
	    
	    /**
	     * Method: getGeodesicPixelSize
	     * 
	     * Parameters:
	     * px - {<OpenLayers.Pixel>} The pixel to get the geodesic length for. If
	     *     not provided, the center pixel of the map viewport will be used.
	     * 
	     * Returns:
	     * {<OpenLayers.Size>} The geodesic size of the pixel in kilometers.
	     */
	    getGeodesicPixelSize: function(px) {
	        var lonlat = px ? this.getLonLatFromPixel(px) : (
	            this.getCachedCenter() || new OpenLayers.LonLat(0, 0));
	        var res = this.getResolution();
	        var left = lonlat.add(-res / 2, 0);
	        var right = lonlat.add(res / 2, 0);
	        var bottom = lonlat.add(0, -res / 2);
	        var top = lonlat.add(0, res / 2);
	        var dest = new OpenLayers.Projection("EPSG:4326");
	        var source = this.getProjectionObject() || dest;
	        if(!source.equals(dest)) {
	            left.transform(source, dest);
	            right.transform(source, dest);
	            bottom.transform(source, dest);
	            top.transform(source, dest);
	        }
	        
	        return new OpenLayers.Size(
	            OpenLayers.Util.distVincenty(left, right),
	            OpenLayers.Util.distVincenty(bottom, top)
	        );
	    },



	  //
	  // TRANSLATION: ViewPortPx <-> LayerPx
	  //

	    /**
	     * APIMethod: getViewPortPxFromLayerPx
	     * 
	     * Parameters:
	     * layerPx - {<OpenLayers.Pixel>}
	     * 
	     * Returns:
	     * {<OpenLayers.Pixel>} Layer Pixel translated into ViewPort Pixel 
	     *                      coordinates
	     */
	    getViewPortPxFromLayerPx:function(layerPx) {
	        var viewPortPx = null;
	        if (layerPx != null) {
	            var dX = this.layerContainerOriginPx.x;
	            var dY = this.layerContainerOriginPx.y;
	            viewPortPx = layerPx.add(dX, dY);            
	        }
	        return viewPortPx;
	    },
	    
	    /**
	     * APIMethod: getLayerPxFromViewPortPx
	     * 
	     * Parameters:
	     * viewPortPx - {<OpenLayers.Pixel>}
	     * 
	     * Returns:
	     * {<OpenLayers.Pixel>} ViewPort Pixel translated into Layer Pixel 
	     *                      coordinates
	     */
	    getLayerPxFromViewPortPx:function(viewPortPx) {
	        var layerPx = null;
	        if (viewPortPx != null) {
	            var dX = -this.layerContainerOriginPx.x;
	            var dY = -this.layerContainerOriginPx.y;
	            layerPx = viewPortPx.add(dX, dY);
	            if (isNaN(layerPx.x) || isNaN(layerPx.y)) {
	                layerPx = null;
	            }
	        }
	        return layerPx;
	    },
	    
	  //
	  // TRANSLATION: LonLat <-> LayerPx
	  //

	    /**
	     * Method: getLonLatFromLayerPx
	     * 
	     * Parameters:
	     * px - {<OpenLayers.Pixel>}
	     *
	     * Returns:
	     * {<OpenLayers.LonLat>}
	     */
	    getLonLatFromLayerPx: function (px) {
	       //adjust for displacement of layerContainerDiv
	       px = this.getViewPortPxFromLayerPx(px);
	       return this.getLonLatFromViewPortPx(px);         
	    },
	    
	    /**
	     * APIMethod: getLayerPxFromLonLat
	     * 
	     * Parameters:
	     * lonlat - {<OpenLayers.LonLat>} lonlat
	     *
	     * Returns:
	     * {<OpenLayers.Pixel>} An OpenLayers.Pixel which is the passed-in 
	     *                      <OpenLayers.LonLat>, translated into layer pixels 
	     *                      by the current base layer
	     */
	    getLayerPxFromLonLat: function (lonlat) {
	       //adjust for displacement of layerContainerDiv
	       var px = this.getPixelFromLonLat(lonlat);
	       return this.getLayerPxFromViewPortPx(px);         
	    },

	    /**
	     * Method: applyTransform
	     * Applies the given transform to the <layerContainerDiv>. This method has
	     * a 2-stage fallback from translate3d/scale3d via translate/scale to plain
	     * style.left/style.top, in which case no scaling is supported.
	     *
	     * Parameters:
	     * x - {Number} x parameter for the translation. Defaults to the x value of
	     *     the map's <layerContainerOriginPx>
	     * y - {Number} y parameter for the translation. Defaults to the y value of
	     *     the map's <layerContainerOriginPx>
	     * scale - {Number} scale. Defaults to 1 if not provided.
	     */
	     applyTransform: function(x, y, scale) {
	         scale = scale || 1;
	         var origin = this.layerContainerOriginPx,
	             needTransform = scale !== 1;
	         x = x || origin.x;
	         y = y || origin.y;
	            
	         var style = this.layerContainerDiv.style,
	             transform = this.applyTransform.transform,
	             template = this.applyTransform.template;
	        
	         if (transform === undefined) {
	             transform = OpenLayers.Util.vendorPrefix.style('transform');
	             this.applyTransform.transform = transform;
	             if (transform) {
	                 // Try translate3d, but only if the viewPortDiv has a transform
	                 // defined in a stylesheet
	                 var computedStyle = OpenLayers.Element.getStyle(this.viewPortDiv,
	                     OpenLayers.Util.vendorPrefix.css('transform'));
	                 if (!computedStyle || computedStyle !== 'none') {
	                     template = ['translate3d(', ',0) ', 'scale3d(', ',1)'];
	                     style[transform] = [template[0], '0,0', template[1]].join('');
	                 }
	                 // If no transform is defined in the stylesheet or translate3d
	                 // does not stick, use translate and scale
	                 if (!template || !~style[transform].indexOf(template[0])) {
	                     template = ['translate(', ') ', 'scale(', ')'];
	                 }
	                 this.applyTransform.template = template;
	             }
	         }
	         
	         // If we do 3d transforms, we always want to use them. If we do 2d
	         // transforms, we only use them when we need to.
	         if (transform !== null && (template[0] === 'translate3d(' || needTransform === true)) {
	             // Our 2d transforms are combined with style.left and style.top, so
	             // adjust x and y values and set the origin as left and top
	             if (needTransform === true && template[0] === 'translate(') {
	                 x -= origin.x;
	                 y -= origin.y;
	                 style.left = origin.x + 'px';
	                 style.top = origin.y + 'px';
	             }
	             style[transform] = [
	                 template[0], x, 'px,', y, 'px', template[1],
	                 template[2], scale, ',', scale, template[3]
	             ].join('');
	         } else {
	             style.left = x + 'px';
	             style.top = y + 'px';
	             // We previously might have had needTransform, so remove transform
	             if (transform !== null) {
	                 style[transform] = '';
	             }
	         }
	     },
	    
	    CLASS_NAME: "OpenLayers.Map"
	});

	/**
	 * Constant: TILE_WIDTH
	 * {Integer} 256 Default tile width (unless otherwise specified)
	 */
	OpenLayers.Map.TILE_WIDTH = 256;
	/**
	 * Constant: TILE_HEIGHT
	 * {Integer} 256 Default tile height (unless otherwise specified)
	 */
	OpenLayers.Map.TILE_HEIGHT = 256;
	/* ======================================================================
	    OpenLayers/Layer.js
	   ====================================================================== */

	/* Copyright (c) 2006-2015 by OpenLayers Contributors (see authors.txt for
	 * full list of contributors). Published under the 2-clause BSD license.
	 * See license.txt in the OpenLayers distribution or repository for the
	 * full text of the license. */


	/**
	 * @requires OpenLayers/BaseTypes/Class.js
	 * @requires OpenLayers/Map.js
	 * @requires OpenLayers/Projection.js
	 */

	/**
	 * Class: OpenLayers.Layer
	 */
	OpenLayers.Layer = OpenLayers.Class({

	    /**
	     * APIProperty: id
	     * {String}
	     */
	    id: null,

	    /** 
	     * APIProperty: name
	     * {String}
	     */
	    name: null,

	    /** 
	     * APIProperty: div
	     * {DOMElement}
	     */
	    div: null,

	    /**
	     * APIProperty: opacity
	     * {Float} The layer's opacity. Float number between 0.0 and 1.0. Default
	     * is 1.
	     */
	    opacity: 1,

	    /**
	     * APIProperty: alwaysInRange
	     * {Boolean} If a layer's display should not be scale-based, this should 
	     *     be set to true. This will cause the layer, as an overlay, to always 
	     *     be 'active', by always returning true from the calculateInRange() 
	     *     function. 
	     * 
	     *     If not explicitly specified for a layer, its value will be 
	     *     determined on startup in initResolutions() based on whether or not 
	     *     any scale-specific properties have been set as options on the 
	     *     layer. If no scale-specific options have been set on the layer, we 
	     *     assume that it should always be in range.
	     * 
	     *     See #987 for more info.
	     */
	    alwaysInRange: null,   

	    /**
	     * Constant: RESOLUTION_PROPERTIES
	     * {Array} The properties that are used for calculating resolutions
	     *     information.
	     */
	    RESOLUTION_PROPERTIES: [
	        'scales', 'resolutions',
	        'maxScale', 'minScale',
	        'maxResolution', 'minResolution',
	        'numZoomLevels', 'maxZoomLevel'
	    ],

	    /**
	     * APIProperty: events
	     * {<OpenLayers.Events>}
	     *
	     * Register a listener for a particular event with the following syntax:
	     * (code)
	     * layer.events.register(type, obj, listener);
	     * (end)
	     *
	     * Listeners will be called with a reference to an event object.  The
	     *     properties of this event depends on exactly what happened.
	     *
	     * All event objects have at least the following properties:
	     * object - {Object} A reference to layer.events.object.
	     * element - {DOMElement} A reference to layer.events.element.
	     *
	     * Supported map event types:
	     * loadstart - Triggered when layer loading starts.  When using a Vector 
	     *     layer with a Fixed or BBOX strategy, the event object includes 
	     *     a *filter* property holding the OpenLayers.Filter used when 
	     *     calling read on the protocol.
	     * loadend - Triggered when layer loading ends.  When using a Vector layer
	     *     with a Fixed or BBOX strategy, the event object includes a 
	     *     *response* property holding an OpenLayers.Protocol.Response object.
	     * visibilitychanged - Triggered when the layer's visibility property is
	     *     changed, e.g. by turning the layer on or off in the layer switcher.
	     *     Note that the actual visibility of the layer can also change if it
	     *     gets out of range (see <calculateInRange>). If you also want to catch
	     *     these cases, register for the map's 'changelayer' event instead.
	     * move - Triggered when layer moves (triggered with every mousemove
	     *     during a drag).
	     * moveend - Triggered when layer is done moving, object passed as
	     *     argument has a zoomChanged boolean property which tells that the
	     *     zoom has changed.
	     * added - Triggered after the layer is added to a map.  Listeners will
	     *     receive an object with a *map* property referencing the map and a
	     *     *layer* property referencing the layer.
	     * removed - Triggered after the layer is removed from the map.  Listeners
	     *     will receive an object with a *map* property referencing the map and
	     *     a *layer* property referencing the layer.
	     */
	    events: null,

	    /**
	     * APIProperty: map
	     * {<OpenLayers.Map>} This variable is set when the layer is added to 
	     *     the map, via the accessor function setMap().
	     */
	    map: null,
	    
	    /**
	     * APIProperty: isBaseLayer
	     * {Boolean} Whether or not the layer is a base layer. This should be set 
	     *     individually by all subclasses. Default is false
	     */
	    isBaseLayer: false,
	 
	    /**
	     * Property: alpha
	     * {Boolean} The layer's images have an alpha channel.  Default is false.
	     */
	    alpha: false,

	    /** 
	     * APIProperty: displayInLayerSwitcher
	     * {Boolean} Display the layer's name in the layer switcher.  Default is
	     *     true.
	     */
	    displayInLayerSwitcher: true,

	    /**
	     * APIProperty: visibility
	     * {Boolean} The layer should be displayed in the map.  Default is true.
	     */
	    visibility: true,

	    /**
	     * APIProperty: attribution
	     * {<Object>} or {<String>} Attribution information, displayed when an
	     *     <OpenLayers.Control.Attribution> has been added to the map.
	     *
	     *     An object is required to store the full attribution information
	     *     from a WMS capabilities response. Example attribution object:
	     *     {title:"",href:"",logo:{format:"",width:10,height:10,href:""}}
	     */
	    attribution: null,

	    /** 
	     * Property: inRange
	     * {Boolean} The current map resolution is within the layer's min/max 
	     *     range. This is set in <OpenLayers.Map.setCenter> whenever the zoom 
	     *     changes.
	     */
	    inRange: false,
	    
	    /**
	     * Propery: imageSize
	     * {<OpenLayers.Size>} For layers with a gutter, the image is larger than 
	     *     the tile by twice the gutter in each dimension.
	     */
	    imageSize: null,
	    
	  // OPTIONS

	    /** 
	     * Property: options
	     * {Object} An optional object whose properties will be set on the layer.
	     *     Any of the layer properties can be set as a property of the options
	     *     object and sent to the constructor when the layer is created.
	     */
	    options: null,

	    /**
	     * APIProperty: eventListeners
	     * {Object} If set as an option at construction, the eventListeners
	     *     object will be registered with <OpenLayers.Events.on>.  Object
	     *     structure must be a listeners object as shown in the example for
	     *     the events.on method.
	     */
	    eventListeners: null,

	    /**
	     * APIProperty: gutter
	     * {Integer} Determines the width (in pixels) of the gutter around image
	     *     tiles to ignore.  By setting this property to a non-zero value,
	     *     images will be requested that are wider and taller than the tile
	     *     size by a value of 2 x gutter.  This allows artifacts of rendering
	     *     at tile edges to be ignored.  Set a gutter value that is equal to
	     *     half the size of the widest symbol that needs to be displayed.
	     *     Defaults to zero.  Non-tiled layers always have zero gutter.
	     */ 
	    gutter: 0, 

	    /**
	     * APIProperty: projection
	     * {<OpenLayers.Projection>} or {<String>} Specifies the projection of the layer.
	     *     Can be set in the layer options. If not specified in the layer options,
	     *     it is set to the default projection specified in the map,
	     *     when the layer is added to the map.
	     *     Projection along with default maxExtent and resolutions
	     *     are set automatically with commercial baselayers in EPSG:3857,
	     *     such as Google, Bing and OpenStreetMap, and do not need to be specified.
	     *     Otherwise, if specifying projection, also set maxExtent,
	     *     maxResolution or resolutions as appropriate.
	     *     When using vector layers with strategies, layer projection should be set
	     *     to the projection of the source data if that is different from the map default.
	     * 
	     *     Can be either a string or an <OpenLayers.Projection> object;
	     *     if a string is passed, will be converted to an object when
	     *     the layer is added to the map.
	     * 
	     */
	    projection: null,    
	    
	    /**
	     * APIProperty: units
	     * {String} The layer map units.  Defaults to null.  Possible values
	     *     are 'degrees' (or 'dd'), 'm', 'ft', 'km', 'mi', 'inches'.
	     *     Normally taken from the projection.
	     *     Only required if both map and layers do not define a projection,
	     *     or if they define a projection which does not define units.
	     */
	    units: null,

	    /**
	     * APIProperty: scales
	     * {Array}  An array of map scales in descending order.  The values in the
	     *     array correspond to the map scale denominator.  Note that these
	     *     values only make sense if the display (monitor) resolution of the
	     *     client is correctly guessed by whomever is configuring the
	     *     application.  In addition, the units property must also be set.
	     *     Use <resolutions> instead wherever possible.
	     */
	    scales: null,

	    /**
	     * APIProperty: resolutions
	     * {Array} A list of map resolutions (map units per pixel) in descending
	     *     order.  If this is not set in the layer constructor, it will be set
	     *     based on other resolution related properties (maxExtent,
	     *     maxResolution, maxScale, etc.).
	     */
	    resolutions: null,
	    
	    /**
	     * APIProperty: maxExtent
	     * {<OpenLayers.Bounds>|Array} If provided as an array, the array
	     *     should consist of four values (left, bottom, right, top).
	     *     The maximum extent for the layer.  Defaults to null.
	     * 
	     *     The center of these bounds will not stray outside
	     *     of the viewport extent during panning.  In addition, if
	     *     <displayOutsideMaxExtent> is set to false, data will not be
	     *     requested that falls completely outside of these bounds.
	     */
	    maxExtent: null,
	    
	    /**
	     * APIProperty: minExtent
	     * {<OpenLayers.Bounds>|Array} If provided as an array, the array
	     *     should consist of four values (left, bottom, right, top).
	     *     The minimum extent for the layer.  Defaults to null.
	     */
	    minExtent: null,
	    
	    /**
	     * APIProperty: maxResolution
	     * {Float} Default max is 360 deg / 256 px, which corresponds to
	     *     zoom level 0 on gmaps.  Specify a different value in the layer 
	     *     options if you are not using the default <OpenLayers.Map.tileSize>
	     *     and displaying the whole world.
	     */
	    maxResolution: null,

	    /**
	     * APIProperty: minResolution
	     * {Float}
	     */
	    minResolution: null,

	    /**
	     * APIProperty: numZoomLevels
	     * {Integer}
	     */
	    numZoomLevels: null,
	    
	    /**
	     * APIProperty: minScale
	     * {Float}
	     */
	    minScale: null,
	    
	    /**
	     * APIProperty: maxScale
	     * {Float}
	     */
	    maxScale: null,

	    /**
	     * APIProperty: displayOutsideMaxExtent
	     * {Boolean} Request map tiles that are completely outside of the max 
	     *     extent for this layer. Defaults to false.
	     */
	    displayOutsideMaxExtent: false,

	    /**
	     * APIProperty: wrapDateLine
	     * {Boolean} Wraps the world at the international dateline, so the map can
	     * be panned infinitely in longitudinal direction. Only use this on the
	     * base layer, and only if the layer's maxExtent equals the world bounds.
	     * #487 for more info.   
	     */
	    wrapDateLine: false,
	    
	    /**
	     * Property: metadata
	     * {Object} This object can be used to store additional information on a
	     *     layer object.
	     */
	    metadata: null,
	    
	    /**
	     * Constructor: OpenLayers.Layer
	     *
	     * Parameters:
	     * name - {String} The layer name
	     * options - {Object} Hashtable of extra options to tag onto the layer
	     */
	    initialize: function(name, options) {

	        this.metadata = {};
	        
	        options = OpenLayers.Util.extend({}, options);
	        // make sure we respect alwaysInRange if set on the prototype
	        if (this.alwaysInRange != null) {
	            options.alwaysInRange = this.alwaysInRange;
	        }
	        this.addOptions(options);

	        this.name = name;
	        
	        if (this.id == null) {

	            this.id = OpenLayers.Util.createUniqueID(this.CLASS_NAME + "_");

	            this.div = OpenLayers.Util.createDiv(this.id);
	            this.div.style.width = "100%";
	            this.div.style.height = "100%";
	            this.div.dir = "ltr";

	            this.events = new OpenLayers.Events(this, this.div);
	            if(this.eventListeners instanceof Object) {
	                this.events.on(this.eventListeners);
	            }

	        }
	    },
	    
	    /**
	     * Method: destroy
	     * Destroy is a destructor: this is to alleviate cyclic references which
	     *     the Javascript garbage cleaner can not take care of on its own.
	     *
	     * Parameters:
	     * setNewBaseLayer - {Boolean} Set a new base layer when this layer has
	     *     been destroyed.  Default is true.
	     */
	    destroy: function(setNewBaseLayer) {
	        if (setNewBaseLayer == null) {
	            setNewBaseLayer = true;
	        }
	        if (this.map != null) {
	            this.map.removeLayer(this, setNewBaseLayer);
	        }
	        this.projection = null;
	        this.map = null;
	        this.name = null;
	        this.div = null;
	        this.options = null;

	        if (this.events) {
	            if(this.eventListeners) {
	                this.events.un(this.eventListeners);
	            }
	            this.events.destroy();
	        }
	        this.eventListeners = null;
	        this.events = null;
	    },
	    
	   /**
	    * Method: clone
	    *
	    * Parameters:
	    * obj - {<OpenLayers.Layer>} The layer to be cloned
	    *
	    * Returns:
	    * {<OpenLayers.Layer>} An exact clone of this <OpenLayers.Layer>
	    */
	    clone: function (obj) {
	        
	        if (obj == null) {
	            obj = new OpenLayers.Layer(this.name, this.getOptions());
	        }
	        
	        // catch any randomly tagged-on properties
	        OpenLayers.Util.applyDefaults(obj, this);
	        
	        // a cloned layer should never have its map property set
	        //  because it has not been added to a map yet. 
	        obj.map = null;
	        
	        return obj;
	    },
	    
	    /**
	     * Method: getOptions
	     * Extracts an object from the layer with the properties that were set as
	     *     options, but updates them with the values currently set on the
	     *     instance.
	     * 
	     * Returns:
	     * {Object} the <options> of the layer, representing the current state.
	     */
	    getOptions: function() {
	        var options = {};
	        for(var o in this.options) {
	            options[o] = this[o];
	        }
	        return options;
	    },
	    
	    /** 
	     * APIMethod: setName
	     * Sets the new layer name for this layer.  Can trigger a changelayer event
	     *     on the map.
	     *
	     * Parameters:
	     * newName - {String} The new name.
	     */
	    setName: function(newName) {
	        if (newName != this.name) {
	            this.name = newName;
	            if (this.map != null) {
	                this.map.events.triggerEvent("changelayer", {
	                    layer: this,
	                    property: "name"
	                });
	            }
	        }
	    },    
	    
	   /**
	    * APIMethod: addOptions
	    * 
	    * Parameters:
	    * newOptions - {Object}
	    * reinitialize - {Boolean} If set to true, and if resolution options of the
	    *     current baseLayer were changed, the map will be recentered to make
	    *     sure that it is displayed with a valid resolution, and a
	    *     changebaselayer event will be triggered.
	    */
	    addOptions: function (newOptions, reinitialize) {

	        if (this.options == null) {
	            this.options = {};
	        }
	        
	        if (newOptions) {
	            // make sure this.projection references a projection object
	            if(typeof newOptions.projection == "string") {
	                newOptions.projection = new OpenLayers.Projection(newOptions.projection);
	            }
	            if (newOptions.projection) {
	                // get maxResolution, units and maxExtent from projection defaults if
	                // they are not defined already
	                OpenLayers.Util.applyDefaults(newOptions,
	                    OpenLayers.Projection.defaults[newOptions.projection.getCode()]);
	            }
	            // allow array for extents
	            if (newOptions.maxExtent && !(newOptions.maxExtent instanceof OpenLayers.Bounds)) {
	                newOptions.maxExtent = new OpenLayers.Bounds(newOptions.maxExtent);
	            }
	            if (newOptions.minExtent && !(newOptions.minExtent instanceof OpenLayers.Bounds)) {
	                newOptions.minExtent = new OpenLayers.Bounds(newOptions.minExtent);
	            }
	        }

	        // update our copy for clone
	        OpenLayers.Util.extend(this.options, newOptions);

	        // add new options to this
	        OpenLayers.Util.extend(this, newOptions);
	        
	        // get the units from the projection, if we have a projection
	        // and it it has units
	        if(this.projection && this.projection.getUnits()) {
	            this.units = this.projection.getUnits();
	        }

	        // re-initialize resolutions if necessary, i.e. if any of the
	        // properties of the "properties" array defined below is set
	        // in the new options
	        if(this.map) {
	            // store current resolution so we can try to restore it later
	            var resolution = this.map.getResolution();
	            var properties = this.RESOLUTION_PROPERTIES.concat(
	                ["projection", "units", "minExtent", "maxExtent"]
	            );
	            for(var o in newOptions) {
	                if(newOptions.hasOwnProperty(o) &&
	                   OpenLayers.Util.indexOf(properties, o) >= 0) {

	                    this.initResolutions();
	                    if (reinitialize && this.map.baseLayer === this) {
	                        // update map position, and restore previous resolution
	                        this.map.setCenter(this.map.getCenter(),
	                            this.map.getZoomForResolution(resolution),
	                            false, true
	                        );
	                        // trigger a changebaselayer event to make sure that
	                        // all controls (especially
	                        // OpenLayers.Control.PanZoomBar) get notified of the
	                        // new options
	                        this.map.events.triggerEvent("changebaselayer", {
	                            layer: this
	                        });
	                    }
	                    break;
	                }
	            }
	        }
	    },

	    /**
	     * APIMethod: onMapResize
	     * This function can be implemented by subclasses
	     */
	    onMapResize: function() {
	        //this function can be implemented by subclasses  
	    },

	    /**
	     * APIMethod: redraw
	     * Redraws the layer.  Returns true if the layer was redrawn, false if not.
	     *
	     * Returns:
	     * {Boolean} The layer was redrawn.
	     */
	    redraw: function() {
	        var redrawn = false;
	        if (this.map) {

	            // min/max Range may have changed
	            this.inRange = this.calculateInRange();

	            // map's center might not yet be set
	            var extent = this.getExtent();

	            if (extent && this.inRange && this.visibility) {
	                var zoomChanged = true;
	                this.moveTo(extent, zoomChanged, false);
	                this.events.triggerEvent("moveend",
	                    {"zoomChanged": zoomChanged});
	                redrawn = true;
	            }
	        }
	        return redrawn;
	    },

	    /**
	     * Method: moveTo
	     * 
	     * Parameters:
	     * bounds - {<OpenLayers.Bounds>}
	     * zoomChanged - {Boolean} Tells when zoom has changed, as layers have to
	     *     do some init work in that case.
	     * dragging - {Boolean}
	     */
	    moveTo:function(bounds, zoomChanged, dragging) {
	        var display = this.visibility;
	        if (!this.isBaseLayer) {
	            display = display && this.inRange;
	        }
	        this.display(display);
	    },

	    /**
	     * Method: moveByPx
	     * Move the layer based on pixel vector. To be implemented by subclasses.
	     *
	     * Parameters:
	     * dx - {Number} The x coord of the displacement vector.
	     * dy - {Number} The y coord of the displacement vector.
	     */
	    moveByPx: function(dx, dy) {
	    },

	    /**
	     * Method: setMap
	     * Set the map property for the layer. This is done through an accessor
	     *     so that subclasses can override this and take special action once 
	     *     they have their map variable set. 
	     * 
	     *     Here we take care to bring over any of the necessary default 
	     *     properties from the map. 
	     * 
	     * Parameters:
	     * map - {<OpenLayers.Map>}
	     */
	    setMap: function(map) {
	        if (this.map == null) {
	        
	            this.map = map;
	            
	            // grab some essential layer data from the map if it hasn't already
	            //  been set
	            this.maxExtent = this.maxExtent || this.map.maxExtent;
	            this.minExtent = this.minExtent || this.map.minExtent;

	            this.projection = this.projection || this.map.projection;
	            if (typeof this.projection == "string") {
	                this.projection = new OpenLayers.Projection(this.projection);
	            }

	            // Check the projection to see if we can get units -- if not, refer
	            // to properties.
	            if (this.projection && this.projection.getUnits()) {
	                this.units = this.projection.getUnits();
	            }
	            else {
	                this.units = this.units || this.map.units;
	            }
	            
	            this.initResolutions();
	            
	            if (!this.isBaseLayer) {
	                this.inRange = this.calculateInRange();
	                var show = ((this.visibility) && (this.inRange));
	                this.div.style.display = show ? "" : "none";
	            }
	            
	            // deal with gutters
	            this.setTileSize();
	        }
	    },
	    
	    /**
	     * Method: afterAdd
	     * Called at the end of the map.addLayer sequence.  At this point, the map
	     *     will have a base layer.  To be overridden by subclasses.
	     */
	    afterAdd: function() {
	    },
	    
	    /**
	     * APIMethod: removeMap
	     * Just as setMap() allows each layer the possibility to take a 
	     *     personalized action on being added to the map, removeMap() allows
	     *     each layer to take a personalized action on being removed from it. 
	     *     For now, this will be mostly unused, except for the EventPane layer,
	     *     which needs this hook so that it can remove the special invisible
	     *     pane. 
	     * 
	     * Parameters:
	     * map - {<OpenLayers.Map>}
	     */
	    removeMap: function(map) {
	        //to be overridden by subclasses
	    },
	    
	    /**
	     * APIMethod: getImageSize
	     *
	     * Parameters:
	     * bounds - {<OpenLayers.Bounds>} optional tile bounds, can be used
	     *     by subclasses that have to deal with different tile sizes at the
	     *     layer extent edges (e.g. Zoomify)
	     * 
	     * Returns:
	     * {<OpenLayers.Size>} The size that the image should be, taking into 
	     *     account gutters.
	     */ 
	    getImageSize: function(bounds) { 
	        return (this.imageSize || this.tileSize); 
	    },    
	  
	    /**
	     * APIMethod: setTileSize
	     * Set the tile size based on the map size.  This also sets layer.imageSize
	     *     or use by Tile.Image.
	     * 
	     * Parameters:
	     * size - {<OpenLayers.Size>}
	     */
	    setTileSize: function(size) {
	        var tileSize = (size) ? size :
	                                ((this.tileSize) ? this.tileSize :
	                                                   this.map.getTileSize());
	        this.tileSize = tileSize;
	        if(this.gutter) {
	          // layers with gutters need non-null tile sizes
	          //if(tileSize == null) {
	          //    OpenLayers.console.error("Error in layer.setMap() for " +
	          //                              this.name + ": layers with " +
	          //                              "gutters need non-null tile sizes");
	          //}
	            this.imageSize = new OpenLayers.Size(tileSize.w + (2*this.gutter), 
	                                                 tileSize.h + (2*this.gutter)); 
	        }
	    },

	    /**
	     * APIMethod: getVisibility
	     * 
	     * Returns:
	     * {Boolean} The layer should be displayed (if in range).
	     */
	    getVisibility: function() {
	        return this.visibility;
	    },

	    /** 
	     * APIMethod: setVisibility
	     * Set the visibility flag for the layer and hide/show & redraw 
	     *     accordingly. Fire event unless otherwise specified
	     * 
	     * Note that visibility is no longer simply whether or not the layer's
	     *     style.display is set to "block". Now we store a 'visibility' state 
	     *     property on the layer class, this allows us to remember whether or 
	     *     not we *desire* for a layer to be visible. In the case where the 
	     *     map's resolution is out of the layer's range, this desire may be 
	     *     subverted.
	     * 
	     * Parameters:
	     * visibility - {Boolean} Whether or not to display the layer (if in range)
	     */
	    setVisibility: function(visibility) {
	        if (visibility != this.visibility) {
	            this.visibility = visibility;
	            this.display(visibility);
	            this.redraw();
	            if (this.map != null) {
	                this.map.events.triggerEvent("changelayer", {
	                    layer: this,
	                    property: "visibility"
	                });
	            }
	            this.events.triggerEvent("visibilitychanged");
	        }
	    },

	    /** 
	     * APIMethod: display
	     * Hide or show the Layer. This is designed to be used internally, and 
	     *     is not generally the way to enable or disable the layer. For that,
	     *     use the setVisibility function instead..
	     * 
	     * Parameters:
	     * display - {Boolean}
	     */
	    display: function(display) {
	        if (display != (this.div.style.display != "none")) {
	            this.div.style.display = (display && this.calculateInRange()) ? "block" : "none";
	        }
	    },

	    /**
	     * APIMethod: calculateInRange
	     * 
	     * Returns:
	     * {Boolean} The layer is displayable at the current map's current
	     *     resolution. Note that if 'alwaysInRange' is true for the layer, 
	     *     this function will always return true.
	     */
	    calculateInRange: function() {
	        var inRange = false;

	        if (this.alwaysInRange) {
	            inRange = true;
	        } else {
	            if (this.map) {
	                var resolution = this.map.getResolution();
	                inRange = ( (resolution >= this.minResolution) &&
	                            (resolution <= this.maxResolution) );
	            }
	        }
	        return inRange;
	    },

	    /** 
	     * APIMethod: setIsBaseLayer
	     * 
	     * Parameters:
	     * isBaseLayer - {Boolean}
	     */
	    setIsBaseLayer: function(isBaseLayer) {
	        if (isBaseLayer != this.isBaseLayer) {
	            this.isBaseLayer = isBaseLayer;
	            if (this.map != null) {
	                this.map.events.triggerEvent("changebaselayer", {
	                    layer: this
	                });
	            }
	        }
	    },

	  /********************************************************/
	  /*                                                      */
	  /*                 Baselayer Functions                  */
	  /*                                                      */
	  /********************************************************/
	  
	    /** 
	     * Method: initResolutions
	     * This method's responsibility is to set up the 'resolutions' array 
	     *     for the layer -- this array is what the layer will use to interface
	     *     between the zoom levels of the map and the resolution display 
	     *     of the layer.
	     * 
	     * The user has several options that determine how the array is set up.
	     *  
	     * For a detailed explanation, see the following wiki from the 
	     *     openlayers.org homepage:
	     *     http://trac.openlayers.org/wiki/SettingZoomLevels
	     */
	    initResolutions: function() {

	        // ok we want resolutions, here's our strategy:
	        //
	        // 1. if resolutions are defined in the layer config, use them
	        // 2. else, if scales are defined in the layer config then derive
	        //    resolutions from these scales
	        // 3. else, attempt to calculate resolutions from maxResolution,
	        //    minResolution, numZoomLevels, maxZoomLevel set in the
	        //    layer config
	        // 4. if we still don't have resolutions, and if resolutions
	        //    are defined in the same, use them
	        // 5. else, if scales are defined in the map then derive
	        //    resolutions from these scales
	        // 6. else, attempt to calculate resolutions from maxResolution,
	        //    minResolution, numZoomLevels, maxZoomLevel set in the
	        //    map
	        // 7. hope for the best!

	        var i, len, p;
	        var props = {}, alwaysInRange = true;

	        // get resolution data from layer config
	        // (we also set alwaysInRange in the layer as appropriate)
	        for(i=0, len=this.RESOLUTION_PROPERTIES.length; i<len; i++) {
	            p = this.RESOLUTION_PROPERTIES[i];
	            props[p] = this.options[p];
	            if(alwaysInRange && this.options[p]) {
	                alwaysInRange = false;
	            }
	        }
	        if(this.options.alwaysInRange == null) {
	            this.alwaysInRange = alwaysInRange;
	        }

	        // if we don't have resolutions then attempt to derive them from scales
	        if(props.resolutions == null) {
	            props.resolutions = this.resolutionsFromScales(props.scales);
	        }

	        // if we still don't have resolutions then attempt to calculate them
	        if(props.resolutions == null) {
	            props.resolutions = this.calculateResolutions(props);
	        }

	        // if we couldn't calculate resolutions then we look at we have
	        // in the map
	        if(props.resolutions == null) {
	            for(i=0, len=this.RESOLUTION_PROPERTIES.length; i<len; i++) {
	                p = this.RESOLUTION_PROPERTIES[i];
	                props[p] = this.options[p] != null ?
	                    this.options[p] : this.map[p];
	            }
	            if(props.resolutions == null) {
	                props.resolutions = this.resolutionsFromScales(props.scales);
	            }
	            if(props.resolutions == null) {
	                props.resolutions = this.calculateResolutions(props);
	            }
	        }

	        // ok, we new need to set properties in the instance

	        // get maxResolution from the config if it's defined there
	        var maxResolution;
	        if(this.options.maxResolution &&
	           this.options.maxResolution !== "auto") {
	            maxResolution = this.options.maxResolution;
	        }
	        if(this.options.minScale) {
	            maxResolution = OpenLayers.Util.getResolutionFromScale(
	                this.options.minScale, this.units);
	        }

	        // get minResolution from the config if it's defined there
	        var minResolution;
	        if(this.options.minResolution &&
	           this.options.minResolution !== "auto") {
	            minResolution = this.options.minResolution;
	        }
	        if(this.options.maxScale) {
	            minResolution = OpenLayers.Util.getResolutionFromScale(
	                this.options.maxScale, this.units);
	        }

	        if(props.resolutions) {

	            //sort resolutions array descendingly
	            props.resolutions.sort(function(a, b) {
	                return (b - a);
	            });

	            // if we still don't have a maxResolution get it from the
	            // resolutions array
	            if(!maxResolution) {
	                maxResolution = props.resolutions[0];
	            }

	            // if we still don't have a minResolution get it from the
	            // resolutions array
	            if(!minResolution) {
	                var lastIdx = props.resolutions.length - 1;
	                minResolution = props.resolutions[lastIdx];
	            }
	        }

	        this.resolutions = props.resolutions;
	        if(this.resolutions) {
	            len = this.resolutions.length;
	            this.scales = new Array(len);
	            for(i=0; i<len; i++) {
	                this.scales[i] = OpenLayers.Util.getScaleFromResolution(
	                    this.resolutions[i], this.units);
	            }
	            this.numZoomLevels = len;
	        }
	        this.minResolution = minResolution;
	        if(minResolution) {
	            this.maxScale = OpenLayers.Util.getScaleFromResolution(
	                minResolution, this.units);
	        }
	        this.maxResolution = maxResolution;
	        if(maxResolution) {
	            this.minScale = OpenLayers.Util.getScaleFromResolution(
	                maxResolution, this.units);
	        }
	    },

	    /**
	     * Method: resolutionsFromScales
	     * Derive resolutions from scales.
	     *
	     * Parameters:
	     * scales - {Array(Number)} Scales
	     *
	     * Returns
	     * {Array(Number)} Resolutions
	     */
	    resolutionsFromScales: function(scales) {
	        if(scales == null) {
	            return;
	        }
	        var resolutions, i, len;
	        len = scales.length;
	        resolutions = new Array(len);
	        for(i=0; i<len; i++) {
	            resolutions[i] = OpenLayers.Util.getResolutionFromScale(
	                scales[i], this.units);
	        }
	        return resolutions;
	    },

	    /**
	     * Method: calculateResolutions
	     * Calculate resolutions based on the provided properties.
	     *
	     * Parameters:
	     * props - {Object} Properties
	     *
	     * Returns:
	     * {Array({Number})} Array of resolutions.
	     */
	    calculateResolutions: function(props) {

	        var viewSize, wRes, hRes;

	        // determine maxResolution
	        var maxResolution = props.maxResolution;
	        if(props.minScale != null) {
	            maxResolution =
	                OpenLayers.Util.getResolutionFromScale(props.minScale,
	                                                       this.units);
	        } else if(maxResolution == "auto" && this.maxExtent != null) {
	            viewSize = this.map.getSize();
	            wRes = this.maxExtent.getWidth() / viewSize.w;
	            hRes = this.maxExtent.getHeight() / viewSize.h;
	            maxResolution = Math.max(wRes, hRes);
	        }

	        // determine minResolution
	        var minResolution = props.minResolution;
	        if(props.maxScale != null) {
	            minResolution =
	                OpenLayers.Util.getResolutionFromScale(props.maxScale,
	                                                       this.units);
	        } else if(props.minResolution == "auto" && this.minExtent != null) {
	            viewSize = this.map.getSize();
	            wRes = this.minExtent.getWidth() / viewSize.w;
	            hRes = this.minExtent.getHeight()/ viewSize.h;
	            minResolution = Math.max(wRes, hRes);
	        }

	        if(typeof maxResolution !== "number" &&
	           typeof minResolution !== "number" &&
	           this.maxExtent != null) {
	            // maxResolution for default grid sets assumes that at zoom
	            // level zero, the whole world fits on one tile.
	            var tileSize = this.map.getTileSize();
	            maxResolution = Math.max(
	                this.maxExtent.getWidth() / tileSize.w,
	                this.maxExtent.getHeight() / tileSize.h
	            );
	        }

	        // determine numZoomLevels
	        var maxZoomLevel = props.maxZoomLevel;
	        var numZoomLevels = props.numZoomLevels;
	        if(typeof minResolution === "number" &&
	           typeof maxResolution === "number" && numZoomLevels === undefined) {
	            var ratio = maxResolution / minResolution;
	            numZoomLevels = Math.floor(Math.log(ratio) / Math.log(2)) + 1;
	        } else if(numZoomLevels === undefined && maxZoomLevel != null) {
	            numZoomLevels = maxZoomLevel + 1;
	        }

	        // are we able to calculate resolutions?
	        if(typeof numZoomLevels !== "number" || numZoomLevels <= 0 ||
	           (typeof maxResolution !== "number" &&
	                typeof minResolution !== "number")) {
	            return;
	        }

	        // now we have numZoomLevels and at least one of maxResolution
	        // or minResolution, we can populate the resolutions array

	        var resolutions = new Array(numZoomLevels);
	        var base = 2;
	        if(typeof minResolution == "number" &&
	           typeof maxResolution == "number") {
	            // if maxResolution and minResolution are set, we calculate
	            // the base for exponential scaling that starts at
	            // maxResolution and ends at minResolution in numZoomLevels
	            // steps.
	            base = Math.pow(
	                    (maxResolution / minResolution),
	                (1 / (numZoomLevels - 1))
	            );
	        }

	        var i;
	        if(typeof maxResolution === "number") {
	            for(i=0; i<numZoomLevels; i++) {
	                resolutions[i] = maxResolution / Math.pow(base, i);
	            }
	        } else {
	            for(i=0; i<numZoomLevels; i++) {
	                resolutions[numZoomLevels - 1 - i] =
	                    minResolution * Math.pow(base, i);
	            }
	        }

	        return resolutions;
	    },

	    /**
	     * APIMethod: getResolution
	     * 
	     * Returns:
	     * {Float} The currently selected resolution of the map, taken from the
	     *     resolutions array, indexed by current zoom level.
	     */
	    getResolution: function() {
	        var zoom = this.map.getZoom();
	        return this.getResolutionForZoom(zoom);
	    },

	    /** 
	     * APIMethod: getExtent
	     * 
	     * Returns:
	     * {<OpenLayers.Bounds>} A Bounds object which represents the lon/lat 
	     *     bounds of the current viewPort.
	     */
	    getExtent: function() {
	        // just use stock map calculateBounds function -- passing no arguments
	        //  means it will user map's current center & resolution
	        //
	        return this.map.calculateBounds();
	    },

	    /**
	     * APIMethod: getZoomForExtent
	     * 
	     * Parameters:
	     * extent - {<OpenLayers.Bounds>}
	     * closest - {Boolean} Find the zoom level that most closely fits the 
	     *     specified bounds. Note that this may result in a zoom that does 
	     *     not exactly contain the entire extent.
	     *     Default is false.
	     *
	     * Returns:
	     * {Integer} The index of the zoomLevel (entry in the resolutions array) 
	     *     for the passed-in extent. We do this by calculating the ideal 
	     *     resolution for the given extent (based on the map size) and then 
	     *     calling getZoomForResolution(), passing along the 'closest'
	     *     parameter.
	     */
	    getZoomForExtent: function(extent, closest) {
	        var viewSize = this.map.getSize();
	        var idealResolution = Math.max( extent.getWidth()  / viewSize.w,
	                                        extent.getHeight() / viewSize.h );

	        return this.getZoomForResolution(idealResolution, closest);
	    },
	    
	    /** 
	     * Method: getDataExtent
	     * Calculates the max extent which includes all of the data for the layer.
	     *     This function is to be implemented by subclasses.
	     * 
	     * Returns:
	     * {<OpenLayers.Bounds>}
	     */
	    getDataExtent: function () {
	        //to be implemented by subclasses
	    },

	    /**
	     * APIMethod: getResolutionForZoom
	     * 
	     * Parameters:
	     * zoom - {Float}
	     * 
	     * Returns:
	     * {Float} A suitable resolution for the specified zoom.
	     */
	    getResolutionForZoom: function(zoom) {
	        zoom = Math.max(0, Math.min(zoom, this.resolutions.length - 1));
	        var resolution;
	        if(this.map.fractionalZoom) {
	            var low = Math.floor(zoom);
	            var high = Math.ceil(zoom);
	            resolution = this.resolutions[low] -
	                ((zoom-low) * (this.resolutions[low]-this.resolutions[high]));
	        } else {
	            resolution = this.resolutions[Math.round(zoom)];
	        }
	        return resolution;
	    },

	    /**
	     * APIMethod: getZoomForResolution
	     * 
	     * Parameters:
	     * resolution - {Float}
	     * closest - {Boolean} Find the zoom level that corresponds to the absolute 
	     *     closest resolution, which may result in a zoom whose corresponding
	     *     resolution is actually smaller than we would have desired (if this
	     *     is being called from a getZoomForExtent() call, then this means that
	     *     the returned zoom index might not actually contain the entire 
	     *     extent specified... but it'll be close).
	     *     Default is false.
	     * 
	     * Returns:
	     * {Integer} The index of the zoomLevel (entry in the resolutions array) 
	     *     that corresponds to the best fit resolution given the passed in 
	     *     value and the 'closest' specification.
	     */
	    getZoomForResolution: function(resolution, closest) {
	        var zoom, i, len;
	        if(this.map.fractionalZoom) {
	            var lowZoom = 0;
	            var highZoom = this.resolutions.length - 1;
	            var highRes = this.resolutions[lowZoom];
	            var lowRes = this.resolutions[highZoom];
	            var res;
	            for(i=0, len=this.resolutions.length; i<len; ++i) {
	                res = this.resolutions[i];
	                if(res >= resolution) {
	                    highRes = res;
	                    lowZoom = i;
	                }
	                if(res <= resolution) {
	                    lowRes = res;
	                    highZoom = i;
	                    break;
	                }
	            }
	            var dRes = highRes - lowRes;
	            if(dRes > 0) {
	                zoom = lowZoom + ((highRes - resolution) / dRes);
	            } else {
	                zoom = lowZoom;
	            }
	        } else {
	            var diff;
	            var minDiff = Number.POSITIVE_INFINITY;
	            for(i=0, len=this.resolutions.length; i<len; i++) {            
	                if (closest) {
	                    diff = Math.abs(this.resolutions[i] - resolution);
	                    if (diff > minDiff) {
	                        break;
	                    }
	                    minDiff = diff;
	                } else {
	                    if (this.resolutions[i] < resolution) {
	                        break;
	                    }
	                }
	            }
	            zoom = Math.max(0, i-1);
	        }
	        return zoom;
	    },
	    
	    /**
	     * APIMethod: getLonLatFromViewPortPx
	     * 
	     * Parameters:
	     * viewPortPx - {<OpenLayers.Pixel>|Object} An OpenLayers.Pixel or
	     *                                          an object with a 'x'
	     *                                          and 'y' properties.
	     *
	     * Returns:
	     * {<OpenLayers.LonLat>} An OpenLayers.LonLat which is the passed-in 
	     *     view port <OpenLayers.Pixel>, translated into lon/lat by the layer.
	     */
	    getLonLatFromViewPortPx: function (viewPortPx) {
	        var lonlat = null;
	        var map = this.map;
	        if (viewPortPx != null && map.minPx) {
	            var res = map.getResolution();
	            var maxExtent = map.getMaxExtent({restricted: true});
	            var lon = (viewPortPx.x - map.minPx.x) * res + maxExtent.left;
	            var lat = (map.minPx.y - viewPortPx.y) * res + maxExtent.top;
	            lonlat = new OpenLayers.LonLat(lon, lat);

	            if (this.wrapDateLine) {
	                lonlat = lonlat.wrapDateLine(this.maxExtent);
	            }
	        }
	        return lonlat;
	    },

	    /**
	     * APIMethod: getViewPortPxFromLonLat
	     * Returns a pixel location given a map location.  This method will return
	     *     fractional pixel values.
	     * 
	     * Parameters:
	     * lonlat - {<OpenLayers.LonLat>|Object} An OpenLayers.LonLat or
	     *                                       an object with a 'lon'
	     *                                       and 'lat' properties.
	     *
	     * Returns: 
	     * {<OpenLayers.Pixel>} An <OpenLayers.Pixel> which is the passed-in 
	     *     lonlat translated into view port pixels.
	     */
	    getViewPortPxFromLonLat: function (lonlat, resolution) {
	        var px = null; 
	        if (lonlat != null) {
	            resolution = resolution || this.map.getResolution();
	            var extent = this.map.calculateBounds(null, resolution);
	            px = new OpenLayers.Pixel(
	                (1/resolution * (lonlat.lon - extent.left)),
	                (1/resolution * (extent.top - lonlat.lat))
	            );    
	        }
	        return px;
	    },
	    
	    /**
	     * APIMethod: setOpacity
	     * Sets the opacity for the entire layer (all images)
	     * 
	     * Parameters:
	     * opacity - {Float}
	     */
	    setOpacity: function(opacity) {
	        if (opacity != this.opacity) {
	            this.opacity = opacity;
	            var childNodes = this.div.childNodes;
	            for(var i = 0, len = childNodes.length; i < len; ++i) {
	                var element = childNodes[i].firstChild || childNodes[i];
	                var lastChild = childNodes[i].lastChild;
	                //TODO de-uglify this
	                if (lastChild && lastChild.nodeName.toLowerCase() === "iframe") {
	                    element = lastChild.parentNode;
	                }
	                OpenLayers.Util.modifyDOMElement(element, null, null, null, 
	                                                 null, null, null, opacity);
	            }
	            if (this.map != null) {
	                this.map.events.triggerEvent("changelayer", {
	                    layer: this,
	                    property: "opacity"
	                });
	            }
	        }
	    },

	    /**
	     * Method: getZIndex
	     * 
	     * Returns: 
	     * {Integer} the z-index of this layer
	     */    
	    getZIndex: function () {
	        return this.div.style.zIndex;
	    },

	    /**
	     * Method: setZIndex
	     * 
	     * Parameters: 
	     * zIndex - {Integer}
	     */    
	    setZIndex: function (zIndex) {
	        this.div.style.zIndex = zIndex;
	    },

	    /**
	     * Method: adjustBounds
	     * This function will take a bounds, and if wrapDateLine option is set
	     *     on the layer, it will return a bounds which is wrapped around the 
	     *     world. We do not wrap for bounds which *cross* the 
	     *     maxExtent.left/right, only bounds which are entirely to the left 
	     *     or entirely to the right.
	     * 
	     * Parameters:
	     * bounds - {<OpenLayers.Bounds>}
	     */
	    adjustBounds: function (bounds) {

	        if (this.gutter) {
	            // Adjust the extent of a bounds in map units by the 
	            // layer's gutter in pixels.
	            var mapGutter = this.gutter * this.map.getResolution();
	            bounds = new OpenLayers.Bounds(bounds.left - mapGutter,
	                                           bounds.bottom - mapGutter,
	                                           bounds.right + mapGutter,
	                                           bounds.top + mapGutter);
	        }

	        if (this.wrapDateLine) {
	            // wrap around the date line, within the limits of rounding error
	            var wrappingOptions = { 
	                'rightTolerance':this.getResolution(),
	                'leftTolerance':this.getResolution()
	            };    
	            bounds = bounds.wrapDateLine(this.maxExtent, wrappingOptions);
	                              
	        }
	        return bounds;
	    },

	    CLASS_NAME: "OpenLayers.Layer"
	});
	/* ======================================================================
	    OpenLayers/Layer/HTTPRequest.js
	   ====================================================================== */

	/* Copyright (c) 2006-2015 by OpenLayers Contributors (see authors.txt for
	 * full list of contributors). Published under the 2-clause BSD license.
	 * See license.txt in the OpenLayers distribution or repository for the
	 * full text of the license. */


	/**
	 * @requires OpenLayers/Layer.js
	 */

	/**
	 * Class: OpenLayers.Layer.HTTPRequest
	 * 
	 * Inherits from: 
	 *  - <OpenLayers.Layer>
	 */
	OpenLayers.Layer.HTTPRequest = OpenLayers.Class(OpenLayers.Layer, {

	    /**
	     * APIProperty: events
	     * {<OpenLayers.Events>}
	     *
	     * Supported event types (in addition to those from <OpenLayers.Layer.events>):
	     * refresh - Triggered when a redraw is forced, to re-fetch data from the
	     *     server.
	     */

	    /** 
	     * Constant: URL_HASH_FACTOR
	     * {Float} Used to hash URL param strings for multi-WMS server selection.
	     *         Set to the Golden Ratio per Knuth's recommendation.
	     */
	    URL_HASH_FACTOR: (Math.sqrt(5) - 1) / 2,

	    /** 
	     * Property: url
	     * {Array(String) or String} This is either an array of url strings or 
	     *                           a single url string. 
	     */
	    url: null,

	    /** 
	     * Property: params
	     * {Object} Hashtable of key/value parameters
	     */
	    params: null,
	    
	    /** 
	     * APIProperty: reproject
	     * *Deprecated*. See http://docs.openlayers.org/library/spherical_mercator.html
	     * for information on the replacement for this functionality. 
	     * {Boolean} Whether layer should reproject itself based on base layer 
	     *           locations. This allows reprojection onto commercial layers. 
	     *           Default is false: Most layers can't reproject, but layers 
	     *           which can create non-square geographic pixels can, like WMS.
	     *           
	     */
	    reproject: false,

	    /**
	     * Constructor: OpenLayers.Layer.HTTPRequest
	     * 
	     * Parameters:
	     * name - {String}
	     * url - {Array(String) or String}
	     * params - {Object}
	     * options - {Object} Hashtable of extra options to tag onto the layer
	     */
	    initialize: function(name, url, params, options) {
	        OpenLayers.Layer.prototype.initialize.apply(this, [name, options]);
	        this.url = url;
	        if (!this.params) {
	            this.params = OpenLayers.Util.extend({}, params);
	        }
	    },

	    /**
	     * APIMethod: destroy
	     */
	    destroy: function() {
	        this.url = null;
	        this.params = null;
	        OpenLayers.Layer.prototype.destroy.apply(this, arguments); 
	    },
	    
	    /**
	     * APIMethod: clone
	     * 
	     * Parameters:
	     * obj - {Object}
	     * 
	     * Returns:
	     * {<OpenLayers.Layer.HTTPRequest>} An exact clone of this 
	     *                                  <OpenLayers.Layer.HTTPRequest>
	     */
	    clone: function (obj) {
	        
	        if (obj == null) {
	            obj = new OpenLayers.Layer.HTTPRequest(this.name,
	                                                   this.url,
	                                                   this.params,
	                                                   this.getOptions());
	        }
	        
	        //get all additions from superclasses
	        obj = OpenLayers.Layer.prototype.clone.apply(this, [obj]);

	        // copy/set any non-init, non-simple values here
	        
	        return obj;
	    },

	    /** 
	     * APIMethod: setUrl
	     * 
	     * Parameters:
	     * newUrl - {String}
	     */
	    setUrl: function(newUrl) {
	        this.url = newUrl;
	    },

	    /**
	     * APIMethod: mergeNewParams
	     * 
	     * Parameters:
	     * newParams - {Object}
	     *
	     * Returns:
	     * redrawn: {Boolean} whether the layer was actually redrawn.
	     */
	    mergeNewParams:function(newParams) {
	        this.params = OpenLayers.Util.extend(this.params, newParams);
	        var ret = this.redraw();
	        if(this.map != null) {
	            this.map.events.triggerEvent("changelayer", {
	                layer: this,
	                property: "params"
	            });
	        }
	        return ret;
	    },

	    /**
	     * APIMethod: redraw
	     * Redraws the layer.  Returns true if the layer was redrawn, false if not.
	     *
	     * Parameters:
	     * force - {Boolean} Force redraw by adding random parameter.
	     *
	     * Returns:
	     * {Boolean} The layer was redrawn.
	     */
	    redraw: function(force) { 
	        if (force) {
	            this.events.triggerEvent('refresh');
	            return this.mergeNewParams({"_olSalt": Math.random()});
	        } else {
	            return OpenLayers.Layer.prototype.redraw.apply(this, []);
	        }
	    },
	    
	    /**
	     * Method: selectUrl
	     * selectUrl() implements the standard floating-point multiplicative
	     *     hash function described by Knuth, and hashes the contents of the 
	     *     given param string into a float between 0 and 1. This float is then
	     *     scaled to the size of the provided urls array, and used to select
	     *     a URL.
	     *
	     * Parameters:
	     * paramString - {String}
	     * urls - {Array(String)}
	     * 
	     * Returns:
	     * {String} An entry from the urls array, deterministically selected based
	     *          on the paramString.
	     */
	    selectUrl: function(paramString, urls) {
	        var product = 1;
	        for (var i=0, len=paramString.length; i<len; i++) { 
	            product *= paramString.charCodeAt(i) * this.URL_HASH_FACTOR; 
	            product -= Math.floor(product); 
	        }
	        return urls[Math.floor(product * urls.length)];
	    },

	    /** 
	     * Method: getFullRequestString
	     * Combine url with layer's params and these newParams. 
	     *   
	     *    does checking on the serverPath variable, allowing for cases when it 
	     *     is supplied with trailing ? or &, as well as cases where not. 
	     *
	     *    return in formatted string like this:
	     *        "server?key1=value1&key2=value2&key3=value3"
	     * 
	     * WARNING: The altUrl parameter is deprecated and will be removed in 3.0.
	     *
	     * Parameters:
	     * newParams - {Object}
	     * altUrl - {String} Use this as the url instead of the layer's url
	     *   
	     * Returns: 
	     * {String}
	     */
	    getFullRequestString:function(newParams, altUrl) {

	        // if not altUrl passed in, use layer's url
	        var url = altUrl || this.url;
	        
	        // create a new params hashtable with all the layer params and the 
	        // new params together. then convert to string
	        var allParams = OpenLayers.Util.extend({}, this.params);
	        allParams = OpenLayers.Util.extend(allParams, newParams);
	        var paramsString = OpenLayers.Util.getParameterString(allParams);
	        
	        // if url is not a string, it should be an array of strings, 
	        // in which case we will deterministically select one of them in 
	        // order to evenly distribute requests to different urls.
	        //
	        if (OpenLayers.Util.isArray(url)) {
	            url = this.selectUrl(paramsString, url);
	        }   
	 
	        // ignore parameters that are already in the url search string
	        var urlParams = 
	            OpenLayers.Util.upperCaseObject(OpenLayers.Util.getParameters(url));
	        for(var key in allParams) {
	            if(key.toUpperCase() in urlParams) {
	                delete allParams[key];
	            }
	        }
	        paramsString = OpenLayers.Util.getParameterString(allParams);
	        
	        return OpenLayers.Util.urlAppend(url, paramsString);
	    },

	    CLASS_NAME: "OpenLayers.Layer.HTTPRequest"
	});
	/* ======================================================================
	    OpenLayers/Tile.js
	   ====================================================================== */

	/* Copyright (c) 2006-2015 by OpenLayers Contributors (see authors.txt for
	 * full list of contributors). Published under the 2-clause BSD license.
	 * See license.txt in the OpenLayers distribution or repository for the
	 * full text of the license. */


	/**
	 * @requires OpenLayers/BaseTypes/Class.js
	 * @requires OpenLayers/Util.js
	 */

	/**
	 * Class: OpenLayers.Tile 
	 * This is a class designed to designate a single tile, however
	 *     it is explicitly designed to do relatively little. Tiles store 
	 *     information about themselves -- such as the URL that they are related
	 *     to, and their size - but do not add themselves to the layer div 
	 *     automatically, for example. Create a new tile with the 
	 *     <OpenLayers.Tile> constructor, or a subclass. 
	 * 
	 * TBD 3.0 - remove reference to url in above paragraph
	 * 
	 */
	OpenLayers.Tile = OpenLayers.Class({
	    
	    /**
	     * APIProperty: events
	     * {<OpenLayers.Events>} An events object that handles all 
	     *     events on the tile.
	     *
	     * Register a listener for a particular event with the following syntax:
	     * (code)
	     * tile.events.register(type, obj, listener);
	     * (end)
	     *
	     * Supported event types:
	     * beforedraw - Triggered before the tile is drawn. Used to defer
	     *     drawing to an animation queue. To defer drawing, listeners need
	     *     to return false, which will abort drawing. The queue handler needs
	     *     to call <draw>(true) to actually draw the tile.
	     * loadstart - Triggered when tile loading starts.
	     * loadend - Triggered when tile loading ends.
	     * loaderror - Triggered before the loadend event (i.e. when the tile is
	     *     still hidden) if the tile could not be loaded.
	     * reload - Triggered when an already loading tile is reloaded.
	     * unload - Triggered before a tile is unloaded.
	     */
	    events: null,

	    /**
	     * APIProperty: eventListeners
	     * {Object} If set as an option at construction, the eventListeners
	     *     object will be registered with <OpenLayers.Events.on>.  Object
	     *     structure must be a listeners object as shown in the example for
	     *     the events.on method.
	     *
	     * This options can be set in the ``tileOptions`` option from
	     * <OpenLayers.Layer.Grid>. For example, to be notified of the
	     * ``loadend`` event of each tiles:
	     * (code)
	     * new OpenLayers.Layer.OSM('osm', 'http://tile.openstreetmap.org/${z}/${x}/${y}.png', {
	     *     tileOptions: {
	     *         eventListeners: {
	     *             'loadend': function(evt) {
	     *                 // do something on loadend
	     *             }
	     *         }
	     *     }
	     * });
	     * (end)
	     */
	    eventListeners: null,

	    /**
	     * Property: id 
	     * {String} null
	     */
	    id: null,
	    
	    /** 
	     * Property: layer 
	     * {<OpenLayers.Layer>} layer the tile is attached to 
	     */
	    layer: null,
	    
	    /**
	     * Property: url
	     * {String} url of the request.
	     *
	     * TBD 3.0 
	     * Deprecated. The base tile class does not need an url. This should be 
	     * handled in subclasses. Does not belong here.
	     */
	    url: null,

	    /** 
	     * APIProperty: bounds 
	     * {<OpenLayers.Bounds>} null
	     */
	    bounds: null,
	    
	    /** 
	     * Property: size 
	     * {<OpenLayers.Size>} null
	     */
	    size: null,
	    
	    /** 
	     * Property: position 
	     * {<OpenLayers.Pixel>} Top Left pixel of the tile
	     */    
	    position: null,
	    
	    /**
	     * Property: isLoading
	     * {Boolean} Is the tile loading?
	     */
	    isLoading: false,
	    
	    /** TBD 3.0 -- remove 'url' from the list of parameters to the constructor.
	     *             there is no need for the base tile class to have a url.
	     */

	    /** 
	     * Constructor: OpenLayers.Tile
	     * Constructor for a new <OpenLayers.Tile> instance.
	     * 
	     * Parameters:
	     * layer - {<OpenLayers.Layer>} layer that the tile will go in.
	     * position - {<OpenLayers.Pixel>}
	     * bounds - {<OpenLayers.Bounds>}
	     * url - {<String>}
	     * size - {<OpenLayers.Size>}
	     * options - {Object}
	     */   
	    initialize: function(layer, position, bounds, url, size, options) {
	        this.layer = layer;
	        this.position = position.clone();
	        this.setBounds(bounds);
	        this.url = url;
	        if (size) {
	            this.size = size.clone();
	        }

	        //give the tile a unique id based on its BBOX.
	        this.id = OpenLayers.Util.createUniqueID("Tile_");

	        OpenLayers.Util.extend(this, options);

	        this.events = new OpenLayers.Events(this);
	        if (this.eventListeners instanceof Object) {
	            this.events.on(this.eventListeners);
	        }
	    },

	    /**
	     * Method: unload
	     * Call immediately before destroying if you are listening to tile
	     * events, so that counters are properly handled if tile is still
	     * loading at destroy-time. Will only fire an event if the tile is
	     * still loading.
	     */
	    unload: function() {
	       if (this.isLoading) { 
	           this.isLoading = false; 
	           this.events.triggerEvent("unload"); 
	       }
	    },
	    
	    /** 
	     * APIMethod: destroy
	     * Nullify references to prevent circular references and memory leaks.
	     */
	    destroy:function() {
	        this.layer  = null;
	        this.bounds = null;
	        this.size = null;
	        this.position = null;
	        
	        if (this.eventListeners) {
	            this.events.un(this.eventListeners);
	        }
	        this.events.destroy();
	        this.eventListeners = null;
	        this.events = null;
	    },
	    
	    /**
	     * Method: draw
	     * Clear whatever is currently in the tile, then return whether or not 
	     *     it should actually be re-drawn. This is an example implementation
	     *     that can be overridden by subclasses. The minimum thing to do here
	     *     is to call <clear> and return the result from <shouldDraw>.
	     *
	     * Parameters:
	     * force - {Boolean} If true, the tile will not be cleared and no beforedraw
	     *     event will be fired. This is used for drawing tiles asynchronously
	     *     after drawing has been cancelled by returning false from a beforedraw
	     *     listener.
	     * 
	     * Returns:
	     * {Boolean} Whether or not the tile should actually be drawn. Returns null
	     *     if a beforedraw listener returned false.
	     */
	    draw: function(force) {
	        if (!force) {
	            //clear tile's contents and mark as not drawn
	            this.clear();
	        }
	        var draw = this.shouldDraw();
	        if (draw && !force && this.events.triggerEvent("beforedraw") === false) {
	            draw = null;
	        }
	        return draw;
	    },
	    
	    /**
	     * Method: shouldDraw
	     * Return whether or not the tile should actually be (re-)drawn. The only
	     * case where we *wouldn't* want to draw the tile is if the tile is outside
	     * its layer's maxExtent
	     * 
	     * Returns:
	     * {Boolean} Whether or not the tile should actually be drawn.
	     */
	    shouldDraw: function() {        
	        var withinMaxExtent = false,
	            maxExtent = this.layer.maxExtent;
	        if (maxExtent) {
	            var map = this.layer.map;
	            var worldBounds = map.baseLayer.wrapDateLine && map.getMaxExtent();
	            if (this.bounds.intersectsBounds(maxExtent, {inclusive: false, worldBounds: worldBounds})) {
	                withinMaxExtent = true;
	            }
	        }
	        
	        return withinMaxExtent || this.layer.displayOutsideMaxExtent;
	    },
	    
	    /**
	     * Method: setBounds
	     * Sets the bounds on this instance
	     *
	     * Parameters:
	     * bounds {<OpenLayers.Bounds>}
	     */
	    setBounds: function(bounds) {
	        bounds = bounds.clone();
	        if (this.layer.map.baseLayer.wrapDateLine) {
	            var worldExtent = this.layer.map.getMaxExtent(),
	                tolerance = this.layer.map.getResolution();
	            bounds = bounds.wrapDateLine(worldExtent, {
	                leftTolerance: tolerance,
	                rightTolerance: tolerance
	            });
	        }
	        this.bounds = bounds;
	    },
	    
	    /** 
	     * Method: moveTo
	     * Reposition the tile.
	     *
	     * Parameters:
	     * bounds - {<OpenLayers.Bounds>}
	     * position - {<OpenLayers.Pixel>}
	     * redraw - {Boolean} Call draw method on tile after moving.
	     *     Default is true
	     */
	    moveTo: function (bounds, position, redraw) {
	        if (redraw == null) {
	            redraw = true;
	        }

	        this.setBounds(bounds);
	        this.position = position.clone();
	        if (redraw) {
	            this.draw();
	        }
	    },

	    /** 
	     * Method: clear
	     * Clear the tile of any bounds/position-related data so that it can 
	     *     be reused in a new location.
	     */
	    clear: function(draw) {
	        // to be extended by subclasses
	    },
	    
	    CLASS_NAME: "OpenLayers.Tile"
	});
	/* ======================================================================
	    OpenLayers/Tile/Image.js
	   ====================================================================== */

	/* Copyright (c) 2006-2015 by OpenLayers Contributors (see authors.txt for
	 * full list of contributors). Published under the 2-clause BSD license.
	 * See license.txt in the OpenLayers distribution or repository for the
	 * full text of the license. */


	/**
	 * @requires OpenLayers/Tile.js
	 * @requires OpenLayers/Animation.js
	 * @requires OpenLayers/Util.js
	 */

	/**
	 * Class: OpenLayers.Tile.Image
	 * Instances of OpenLayers.Tile.Image are used to manage the image tiles
	 * used by various layers.  Create a new image tile with the
	 * <OpenLayers.Tile.Image> constructor.
	 *
	 * Inherits from:
	 *  - <OpenLayers.Tile>
	 */
	OpenLayers.Tile.Image = OpenLayers.Class(OpenLayers.Tile, {

	    /**
	     * APIProperty: events
	     * {<OpenLayers.Events>} An events object that handles all 
	     *     events on the tile.
	     *
	     * Register a listener for a particular event with the following syntax:
	     * (code)
	     * tile.events.register(type, obj, listener);
	     * (end)
	     *
	     * Supported event types (in addition to the <OpenLayers.Tile> events):
	     * beforeload - Triggered before an image is prepared for loading, when the
	     *     url for the image is known already. Listeners may call <setImage> on
	     *     the tile instance. If they do so, that image will be used and no new
	     *     one will be created.
	     */

	    /** 
	     * APIProperty: url
	     * {String} The URL of the image being requested. No default. Filled in by
	     * layer.getURL() function. May be modified by loadstart listeners.
	     */
	    url: null,
	    
	    /** 
	     * Property: imgDiv
	     * {HTMLImageElement} The image for this tile.
	     */
	    imgDiv: null,
	    
	    /**
	     * Property: frame
	     * {DOMElement} The image element is appended to the frame.  Any gutter on
	     * the image will be hidden behind the frame. If no gutter is set,
	     * this will be null.
	     */ 
	    frame: null, 

	    /** 
	     * Property: imageReloadAttempts
	     * {Integer} Attempts to load the image.
	     */
	    imageReloadAttempts: null,
	    
	    /**
	     * Property: layerAlphaHack
	     * {Boolean} True if the png alpha hack needs to be applied on the layer's div.
	     */
	    layerAlphaHack: null,
	    
	    /**
	     * Property: asyncRequestId
	     * {Integer} ID of an request to see if request is still valid. This is a
	     * number which increments by 1 for each asynchronous request.
	     */
	    asyncRequestId: null,
	    
	    /**
	     * APIProperty: maxGetUrlLength
	     * {Number} If set, requests that would result in GET urls with more
	     * characters than the number provided will be made using form-encoded
	     * HTTP POST. It is good practice to avoid urls that are longer than 2048
	     * characters.
	     *
	     * Caution:
	     * Older versions of Gecko based browsers (e.g. Firefox < 3.5) and most
	     * Opera versions do not fully support this option. On all browsers,
	     * transition effects are not supported if POST requests are used.
	     */
	    maxGetUrlLength: null,

	    /**
	     * Property: canvasContext
	     * {CanvasRenderingContext2D} A canvas context associated with
	     * the tile image.
	     */
	    canvasContext: null,
	    
	    /**
	     * APIProperty: crossOriginKeyword
	     * The value of the crossorigin keyword to use when loading images. This is
	     * only relevant when using <getCanvasContext> for tiles from remote
	     * origins and should be set to either 'anonymous' or 'use-credentials'
	     * for servers that send Access-Control-Allow-Origin headers with their
	     * tiles.
	     */
	    crossOriginKeyword: null,

	    /** TBD 3.0 - reorder the parameters to the init function to remove 
	     *             URL. the getUrl() function on the layer gets called on 
	     *             each draw(), so no need to specify it here.
	     */

	    /** 
	     * Constructor: OpenLayers.Tile.Image
	     * Constructor for a new <OpenLayers.Tile.Image> instance.
	     * 
	     * Parameters:
	     * layer - {<OpenLayers.Layer>} layer that the tile will go in.
	     * position - {<OpenLayers.Pixel>}
	     * bounds - {<OpenLayers.Bounds>}
	     * url - {<String>} Deprecated. Remove me in 3.0.
	     * size - {<OpenLayers.Size>}
	     * options - {Object}
	     */   
	    initialize: function(layer, position, bounds, url, size, options) {
	        OpenLayers.Tile.prototype.initialize.apply(this, arguments);

	        this.url = url; //deprecated remove me
	        
	        this.layerAlphaHack = this.layer.alpha && OpenLayers.Util.alphaHack();

	        if (this.maxGetUrlLength != null || this.layer.gutter || this.layerAlphaHack) {
	            // only create frame if it's needed
	            this.frame = document.createElement("div");
	            this.frame.style.position = "absolute";
	            this.frame.style.overflow = "hidden";
	        }
	        if (this.maxGetUrlLength != null) {
	            OpenLayers.Util.extend(this, OpenLayers.Tile.Image.IFrame);
	        }
	    },
	    
	    /** 
	     * APIMethod: destroy
	     * nullify references to prevent circular references and memory leaks
	     */
	    destroy: function() {
	        if (this.imgDiv)  {
	            this.clear();
	            this.imgDiv = null;
	            this.frame = null;
	        }
	        // don't handle async requests any more
	        this.asyncRequestId = null;
	        OpenLayers.Tile.prototype.destroy.apply(this, arguments);
	    },
	    
	    /**
	     * Method: draw
	     * Check that a tile should be drawn, and draw it.
	     * 
	     * Returns:
	     * {Boolean} Was a tile drawn? Or null if a beforedraw listener returned
	     *     false.
	     */
	    draw: function() {
	        var shouldDraw = OpenLayers.Tile.prototype.draw.apply(this, arguments);
	        if (shouldDraw) {
	            // The layer's reproject option is deprecated.
	            if (this.layer != this.layer.map.baseLayer && this.layer.reproject) {
	                // getBoundsFromBaseLayer is defined in deprecated.js.
	                this.bounds = this.getBoundsFromBaseLayer(this.position);
	            }
	            if (this.isLoading) {
	                //if we're already loading, send 'reload' instead of 'loadstart'.
	                this._loadEvent = "reload";
	            } else {
	                this.isLoading = true;
	                this._loadEvent = "loadstart";
	            }
	            this.renderTile();
	            this.positionTile();
	        } else if (shouldDraw === false) {
	            this.unload();
	        }
	        return shouldDraw;
	    },
	    
	    /**
	     * Method: renderTile
	     * Internal function to actually initialize the image tile,
	     *     position it correctly, and set its url.
	     */
	    renderTile: function() {
	        if (this.layer.async) {
	            // Asynchronous image requests call the asynchronous getURL method
	            // on the layer to fetch an image that covers 'this.bounds'.
	            var id = this.asyncRequestId = (this.asyncRequestId || 0) + 1;
	            this.layer.getURLasync(this.bounds, function(url) {
	                if (id == this.asyncRequestId) {
	                    this.url = url;
	                    this.initImage();
	                }
	            }, this);
	        } else {
	            // synchronous image requests get the url immediately.
	            this.url = this.layer.getURL(this.bounds);
	            this.initImage();
	        }
	    },

	    /**
	     * Method: positionTile
	     * Using the properties currenty set on the layer, position the tile correctly.
	     * This method is used both by the async and non-async versions of the Tile.Image
	     * code.
	     */
	    positionTile: function() {
	        var style = this.getTile().style,
	            size = this.frame ? this.size :
	                this.layer.getImageSize(this.bounds),
	            ratio = 1;
	        if (this.layer instanceof OpenLayers.Layer.Grid) {
	            ratio = this.layer.getServerResolution() / this.layer.map.getResolution();
	        }
	        style.left = this.position.x + "px";
	        style.top = this.position.y + "px";
	        style.width = Math.round(ratio * size.w) + "px";
	        style.height = Math.round(ratio * size.h) + "px";
	    },

	    /** 
	     * Method: clear
	     * Remove the tile from the DOM, clear it of any image related data so that
	     * it can be reused in a new location.
	     */
	    clear: function() {
	        OpenLayers.Tile.prototype.clear.apply(this, arguments);
	        var img = this.imgDiv;
	        if (img) {
	            var tile = this.getTile();
	            if (tile.parentNode === this.layer.div) {
	                this.layer.div.removeChild(tile);
	            }
	            this.setImgSrc();
	            if (this.layerAlphaHack === true) {
	                img.style.filter = "";
	            }
	            OpenLayers.Element.removeClass(img, "olImageLoadError");
	        }
	        this.canvasContext = null;
	    },
	    
	    /**
	     * Method: getImage
	     * Returns or creates and returns the tile image.
	     */
	    getImage: function() {
	        if (!this.imgDiv) {
	            this.imgDiv = OpenLayers.Tile.Image.IMAGE.cloneNode(false);

	            var style = this.imgDiv.style;
	            if (this.frame) {
	                var left = 0, top = 0;
	                if (this.layer.gutter) {
	                    left = this.layer.gutter / this.layer.tileSize.w * 100;
	                    top = this.layer.gutter / this.layer.tileSize.h * 100;
	                }
	                style.left = -left + "%";
	                style.top = -top + "%";
	                style.width = (2 * left + 100) + "%";
	                style.height = (2 * top + 100) + "%";
	            }
	            style.visibility = "hidden";
	            style.opacity = 0;
	            if (this.layer.opacity < 1) {
	                style.filter = 'alpha(opacity=' +
	                               (this.layer.opacity * 100) +
	                               ')';
	            }
	            style.position = "absolute";
	            if (this.layerAlphaHack) {
	                // move the image out of sight
	                style.paddingTop = style.height;
	                style.height = "0";
	                style.width = "100%";
	            }
	            if (this.frame) {
	                this.frame.appendChild(this.imgDiv);
	            }
	        }

	        return this.imgDiv;
	    },
	    
	    /**
	     * APIMethod: setImage
	     * Sets the image element for this tile. This method should only be called
	     * from beforeload listeners.
	     *
	     * Parameters
	     * img - {HTMLImageElement} The image to use for this tile.
	     */
	    setImage: function(img) {
	        this.imgDiv = img;
	    },

	    /**
	     * Method: initImage
	     * Creates the content for the frame on the tile.
	     */
	    initImage: function() {
	        if (!this.url && !this.imgDiv) {
	            // fast path out - if there is no tile url and no previous image
	            this.isLoading = false;
	            return;
	        }
	        this.events.triggerEvent('beforeload');
	        this.layer.div.appendChild(this.getTile());
	        this.events.triggerEvent(this._loadEvent);
	        var img = this.getImage();
	        var src = img.getAttribute('src') || '';
	        if (this.url && OpenLayers.Util.isEquivalentUrl(src, this.url)) {
	            this._loadTimeout = window.setTimeout(
	                OpenLayers.Function.bind(this.onImageLoad, this), 0
	            );
	        } else {
	            this.stopLoading();
	            if (this.crossOriginKeyword) {
	                img.removeAttribute("crossorigin");
	            }
	            OpenLayers.Event.observe(img, "load",
	                OpenLayers.Function.bind(this.onImageLoad, this)
	            );
	            OpenLayers.Event.observe(img, "error",
	                OpenLayers.Function.bind(this.onImageError, this)
	            );
	            this.imageReloadAttempts = 0;
	            this.setImgSrc(this.url);
	        }
	    },
	    
	    /**
	     * Method: setImgSrc
	     * Sets the source for the tile image
	     *
	     * Parameters:
	     * url - {String} or undefined to hide the image
	     */
	    setImgSrc: function(url) {
	        var img = this.imgDiv;
	        if (url) {
	            img.style.visibility = 'hidden';
	            img.style.opacity = 0;
	            // don't set crossOrigin if the url is a data URL
	            if (this.crossOriginKeyword) {
	                if (url.substr(0, 5) !== 'data:') {
	                    img.setAttribute("crossorigin", this.crossOriginKeyword);
	                } else {
	                    img.removeAttribute("crossorigin");
	                }
	            }
	            img.src = url;
	        } else {
	            // Remove reference to the image, and leave it to the browser's
	            // caching and garbage collection.
	            this.stopLoading();
	            this.imgDiv = null;
	            if (img.parentNode) {
	                img.parentNode.removeChild(img);
	            }
	        }
	    },
	    
	    /**
	     * Method: getTile
	     * Get the tile's markup.
	     *
	     * Returns:
	     * {DOMElement} The tile's markup
	     */
	    getTile: function() {
	        return this.frame ? this.frame : this.getImage();
	    },

	    /**
	     * Method: createBackBuffer
	     * Create a backbuffer for this tile. A backbuffer isn't exactly a clone
	     * of the tile's markup, because we want to avoid the reloading of the
	     * image. So we clone the frame, and steal the image from the tile.
	     *
	     * Returns:
	     * {DOMElement} The markup, or undefined if the tile has no image
	     * or if it's currently loading.
	     */
	    createBackBuffer: function() {
	        if (!this.imgDiv || this.isLoading) {
	            return;
	        }
	        var backBuffer;
	        if (this.frame) {
	            backBuffer = this.frame.cloneNode(false);
	            backBuffer.appendChild(this.imgDiv);
	        } else {
	            backBuffer = this.imgDiv;
	        }
	        this.imgDiv = null;
	        return backBuffer;
	    },

	    /**
	     * Method: onImageLoad
	     * Handler for the image onload event
	     */
	    onImageLoad: function() {
	        var img = this.imgDiv;
	        this.stopLoading();
	        img.style.visibility = 'inherit';
	        img.style.opacity = this.layer.opacity;
	        this.isLoading = false;
	        this.canvasContext = null;
	        this.events.triggerEvent("loadend");

	        if (this.layerAlphaHack === true) {
	            img.style.filter =
	                "progid:DXImageTransform.Microsoft.AlphaImageLoader(src='" +
	                img.src + "', sizingMethod='scale')";
	        }
	    },
	    
	    /**
	     * Method: onImageError
	     * Handler for the image onerror event
	     */
	    onImageError: function() {
	        var img = this.imgDiv;
	        if (img.src != null) {
	            this.imageReloadAttempts++;
	            if (this.imageReloadAttempts <= OpenLayers.IMAGE_RELOAD_ATTEMPTS) {
	                this.setImgSrc(this.layer.getURL(this.bounds));
	            } else {
	                OpenLayers.Element.addClass(img, "olImageLoadError");
	                this.events.triggerEvent("loaderror");
	                this.onImageLoad();
	            }
	        }
	    },
	    
	    /**
	     * Method: stopLoading
	     * Stops a loading sequence so <onImageLoad> won't be executed.
	     */
	    stopLoading: function() {
	        OpenLayers.Event.stopObservingElement(this.imgDiv);
	        window.clearTimeout(this._loadTimeout);
	        delete this._loadTimeout;
	    },

	    /**
	     * APIMethod: getCanvasContext
	     * Returns a canvas context associated with the tile image (with
	     * the image drawn on it).
	     * Returns undefined if the browser does not support canvas, if
	     * the tile has no image or if it's currently loading.
	     *
	     * The function returns a canvas context instance but the
	     * underlying canvas is still available in the 'canvas' property:
	     * (code)
	     * var context = tile.getCanvasContext();
	     * if (context) {
	     *     var data = context.canvas.toDataURL('image/jpeg');
	     * }
	     * (end)
	     *
	     * Returns:
	     * {Boolean}
	     */
	    getCanvasContext: function() {
	        if (OpenLayers.CANVAS_SUPPORTED && this.imgDiv && !this.isLoading) {
	            if (!this.canvasContext) {
	                var canvas = document.createElement("canvas");
	                canvas.width = this.size.w;
	                canvas.height = this.size.h;
	                this.canvasContext = canvas.getContext("2d");
	                this.canvasContext.drawImage(this.imgDiv, 0, 0);
	            }
	            return this.canvasContext;
	        }
	    },

	    CLASS_NAME: "OpenLayers.Tile.Image"

	});

	/** 
	 * Constant: OpenLayers.Tile.Image.IMAGE
	 * {HTMLImageElement} The image for a tile.
	 */
	OpenLayers.Tile.Image.IMAGE = (function() {
	    var img = new Image();
	    img.className = "olTileImage";
	    // avoid image gallery menu in IE6
	    img.galleryImg = "no";
	    return img;
	}());

	/* ======================================================================
	    OpenLayers/Layer/Grid.js
	   ====================================================================== */

	/* Copyright (c) 2006-2015 by OpenLayers Contributors (see authors.txt for
	 * full list of contributors). Published under the 2-clause BSD license.
	 * See license.txt in the OpenLayers distribution or repository for the
	 * full text of the license. */


	/**
	 * @requires OpenLayers/Layer/HTTPRequest.js
	 * @requires OpenLayers/Tile/Image.js
	 */

	/**
	 * Class: OpenLayers.Layer.Grid
	 * Base class for layers that use a lattice of tiles.  Create a new grid
	 * layer with the <OpenLayers.Layer.Grid> constructor.
	 *
	 * Inherits from:
	 *  - <OpenLayers.Layer.HTTPRequest>
	 */
	OpenLayers.Layer.Grid = OpenLayers.Class(OpenLayers.Layer.HTTPRequest, {
	    
	    /**
	     * APIProperty: tileSize
	     * {<OpenLayers.Size>}
	     */
	    tileSize: null,

	    /**
	     * Property: tileOriginCorner
	     * {String} If the <tileOrigin> property is not provided, the tile origin 
	     *     will be derived from the layer's <maxExtent>.  The corner of the 
	     *     <maxExtent> used is determined by this property.  Acceptable values
	     *     are "tl" (top left), "tr" (top right), "bl" (bottom left), and "br"
	     *     (bottom right).  Default is "bl".
	     */
	    tileOriginCorner: "bl",
	    
	    /**
	     * APIProperty: tileOrigin
	     * {<OpenLayers.LonLat>} Optional origin for aligning the grid of tiles.
	     *     If provided, requests for tiles at all resolutions will be aligned
	     *     with this location (no tiles shall overlap this location).  If
	     *     not provided, the grid of tiles will be aligned with the layer's
	     *     <maxExtent>.  Default is ``null``.
	     */
	    tileOrigin: null,
	    
	    /** APIProperty: tileOptions
	     *  {Object} optional configuration options for <OpenLayers.Tile> instances
	     *  created by this Layer, if supported by the tile class.
	     */
	    tileOptions: null,

	    /**
	     * APIProperty: tileClass
	     * {<OpenLayers.Tile>} The tile class to use for this layer.
	     *     Defaults is OpenLayers.Tile.Image.
	     */
	    tileClass: OpenLayers.Tile.Image,
	    
	    /**
	     * Property: grid
	     * {Array(Array(<OpenLayers.Tile>))} This is an array of rows, each row is 
	     *     an array of tiles.
	     */
	    grid: null,

	    /**
	     * APIProperty: singleTile
	     * {Boolean} Moves the layer into single-tile mode, meaning that one tile 
	     *     will be loaded. The tile's size will be determined by the 'ratio'
	     *     property. When the tile is dragged such that it does not cover the 
	     *     entire viewport, it is reloaded.
	     */
	    singleTile: false,

	    /** APIProperty: ratio
	     *  {Float} Used only when in single-tile mode, this specifies the 
	     *          ratio of the size of the single tile to the size of the map.
	     *          Default value is 1.5.
	     */
	    ratio: 1.5,

	    /**
	     * APIProperty: buffer
	     * {Integer} Used only when in gridded mode, this specifies the number of 
	     *           extra rows and columns of tiles on each side which will
	     *           surround the minimum grid tiles to cover the map.
	     *           For very slow loading layers, a larger value may increase
	     *           performance somewhat when dragging, but will increase bandwidth
	     *           use significantly. 
	     */
	    buffer: 0,

	    /**
	     * APIProperty: transitionEffect
	     * {String} The transition effect to use when the map is zoomed.
	     * Two possible values:
	     *
	     * "resize" - Existing tiles are resized on zoom to provide a visual
	     *     effect of the zoom having taken place immediately.  As the
	     *     new tiles become available, they are drawn on top of the
	     *     resized tiles (this is the default setting).
	     * "map-resize" - Existing tiles are resized on zoom and placed below the
	     *     base layer.  New tiles for the base layer will cover existing tiles.
	     *     This setting is recommended when having an overlay duplicated during
	     *     the transition is undesirable (e.g. street labels or big transparent
	     *     fills). 
	     * null - No transition effect.
	     *
	     * Using "resize" on non-opaque layers can cause undesired visual
	     * effects.  Set transitionEffect to null in this case.
	     */
	    transitionEffect: "resize",

	    /**
	     * APIProperty: numLoadingTiles
	     * {Integer} How many tiles are still loading?
	     */
	    numLoadingTiles: 0,

	    /**
	     * Property: serverResolutions
	     * {Array(Number}} This property is documented in subclasses as
	     *     an API property.
	     */
	    serverResolutions: null,

	    /**
	     * Property: loading
	     * {Boolean} Indicates if tiles are being loaded.
	     */
	    loading: false,
	    
	    /**
	     * Property: backBuffer
	     * {DOMElement} The back buffer.
	     */
	    backBuffer: null,

	    /**
	     * Property: gridResolution
	     * {Number} The resolution of the current grid. Used for backbuffer and
	     *     client zoom. This property is updated every time the grid is
	     *     initialized.
	     */
	    gridResolution: null,

	    /**
	     * Property: backBufferResolution
	     * {Number} The resolution of the current back buffer. This property is
	     *     updated each time a back buffer is created.
	     */
	    backBufferResolution: null,

	    /**
	     * Property: backBufferLonLat
	     * {Object} The top-left corner of the current back buffer. Includes lon
	     *     and lat properties. This object is updated each time a back buffer
	     *     is created.
	     */
	    backBufferLonLat: null,

	    /**
	     * Property: backBufferTimerId
	     * {Number} The id of the back buffer timer. This timer is used to
	     *     delay the removal of the back buffer, thereby preventing
	     *     flash effects caused by tile animation.
	     */
	    backBufferTimerId: null,

	    /**
	     * APIProperty: removeBackBufferDelay
	     * {Number} Delay for removing the backbuffer when all tiles have finished
	     *     loading. Can be set to 0 when no css opacity transitions for the
	     *     olTileImage class are used. Default is 0 for <singleTile> layers,
	     *     2500 for tiled layers. See <className> for more information on
	     *     tile animation.
	     */
	    removeBackBufferDelay: null,

	    /**
	     * APIProperty: className
	     * {String} Name of the class added to the layer div. If not set in the
	     *     options passed to the constructor then className defaults to
	     *     "olLayerGridSingleTile" for single tile layers (see <singleTile>),
	     *     and "olLayerGrid" for non single tile layers.
	     *
	     * Note:
	     *
	     * The displaying of tiles is not animated by default for single tile
	     *     layers - OpenLayers' default theme (style.css) includes this:
	     * (code)
	     * .olLayerGrid .olTileImage {
	     *     -webkit-transition: opacity 0.2s linear;
	     *     -moz-transition: opacity 0.2s linear;
	     *     -o-transition: opacity 0.2s linear;
	     *     transition: opacity 0.2s linear;
	     *  }
	     * (end)
	     * To animate tile displaying for any grid layer the following
	     *     CSS rule can be used:
	     * (code)
	     * .olTileImage {
	     *     -webkit-transition: opacity 0.2s linear;
	     *     -moz-transition: opacity 0.2s linear;
	     *     -o-transition: opacity 0.2s linear;
	     *     transition: opacity 0.2s linear;
	     * }
	     * (end)
	     * In that case, to avoid flash effects, <removeBackBufferDelay>
	     *     should not be zero.
	     */
	    className: null,
	    
	    /**
	     * Register a listener for a particular event with the following syntax:
	     * (code)
	     * layer.events.register(type, obj, listener);
	     * (end)
	     *
	     * Listeners will be called with a reference to an event object.  The
	     *     properties of this event depends on exactly what happened.
	     *
	     * All event objects have at least the following properties:
	     * object - {Object} A reference to layer.events.object.
	     * element - {DOMElement} A reference to layer.events.element.
	     *
	     * Supported event types:
	     * addtile - Triggered when a tile is added to this layer. Listeners receive
	     *     an object as first argument, which has a tile property that
	     *     references the tile that has been added.
	     * tileloadstart - Triggered when a tile starts loading. Listeners receive
	     *     an object as first argument, which has a tile property that
	     *     references the tile that starts loading.
	     * tileloaded - Triggered when each new tile is
	     *     loaded, as a means of progress update to listeners.
	     *     listeners can access 'numLoadingTiles' if they wish to keep
	     *     track of the loading progress. Listeners are called with an object
	     *     with a 'tile' property as first argument, making the loaded tile
	     *     available to the listener, and an 'aborted' property, which will be
	     *     true when loading was aborted and no tile data is available.
	     * tileerror - Triggered before the tileloaded event (i.e. when the tile is
	     *     still hidden) if a tile failed to load. Listeners receive an object
	     *     as first argument, which has a tile property that references the
	     *     tile that could not be loaded.
	     * retile - Triggered when the layer recreates its tile grid.
	     */

	    /**
	     * Property: gridLayout
	     * {Object} Object containing properties tilelon, tilelat, startcol,
	     * startrow
	     */
	    gridLayout: null,
	    
	    /**
	     * Property: rowSign
	     * {Number} 1 for grids starting at the top, -1 for grids starting at the
	     * bottom. This is used for several grid index and offset calculations.
	     */
	    rowSign: null,

	    /**
	     * Property: transitionendEvents
	     * {Array} Event names for transitionend
	     */
	    transitionendEvents: [
	        'transitionend', 'webkitTransitionEnd', 'otransitionend',
	        'oTransitionEnd'
	    ],

	    /**
	     * Constructor: OpenLayers.Layer.Grid
	     * Create a new grid layer
	     *
	     * Parameters:
	     * name - {String}
	     * url - {String}
	     * params - {Object}
	     * options - {Object} Hashtable of extra options to tag onto the layer
	     */
	    initialize: function(name, url, params, options) {
	        OpenLayers.Layer.HTTPRequest.prototype.initialize.apply(this, 
	                                                                arguments);
	        this.grid = [];
	        this._removeBackBuffer = OpenLayers.Function.bind(this.removeBackBuffer, this);

	        this.initProperties();

	        this.rowSign = this.tileOriginCorner.substr(0, 1) === "t" ? 1 : -1;
	    },

	    /**
	     * Method: initProperties
	     * Set any properties that depend on the value of singleTile.
	     * Currently sets removeBackBufferDelay and className
	     */
	    initProperties: function() {
	        if (this.options.removeBackBufferDelay === undefined) {
	            this.removeBackBufferDelay = this.singleTile ? 0 : 2500;
	        }

	        if (this.options.className === undefined) {
	            this.className = this.singleTile ? 'olLayerGridSingleTile' :
	                                               'olLayerGrid';
	        }
	    },

	    /**
	     * Method: setMap
	     *
	     * Parameters:
	     * map - {<OpenLayers.Map>} The map.
	     */
	    setMap: function(map) {
	        OpenLayers.Layer.HTTPRequest.prototype.setMap.call(this, map);
	        OpenLayers.Element.addClass(this.div, this.className);
	    },

	    /**
	     * Method: removeMap
	     * Called when the layer is removed from the map.
	     *
	     * Parameters:
	     * map - {<OpenLayers.Map>} The map.
	     */
	    removeMap: function(map) {
	        this.removeBackBuffer();
	    },

	    /**
	     * APIMethod: destroy
	     * Deconstruct the layer and clear the grid.
	     */
	    destroy: function() {
	        this.removeBackBuffer();
	        this.clearGrid();

	        this.grid = null;
	        this.tileSize = null;
	        OpenLayers.Layer.HTTPRequest.prototype.destroy.apply(this, arguments); 
	    },

	    /**
	     * APIMethod: mergeNewParams
	     * Refetches tiles with new params merged, keeping a backbuffer. Each
	     * loading new tile will have a css class of '.olTileReplacing'. If a
	     * stylesheet applies a 'display: none' style to that class, any fade-in
	     * transition will not apply, and backbuffers for each tile will be removed
	     * as soon as the tile is loaded.
	     * 
	     * Parameters:
	     * newParams - {Object}
	     *
	     * Returns:
	     * redrawn: {Boolean} whether the layer was actually redrawn.
	     */

	    /**
	     * Method: clearGrid
	     * Go through and remove all tiles from the grid, calling
	     *    destroy() on each of them to kill circular references
	     */
	    clearGrid:function() {
	        if (this.grid) {
	            for(var iRow=0, len=this.grid.length; iRow<len; iRow++) {
	                var row = this.grid[iRow];
	                for(var iCol=0, clen=row.length; iCol<clen; iCol++) {
	                    var tile = row[iCol];
	                    this.destroyTile(tile);
	                }
	            }
	            this.grid = [];
	            this.gridResolution = null;
	            this.gridLayout = null;
	        }
	    },

	   /**
	    * APIMethod: addOptions
	    * 
	    * Parameters:
	    * newOptions - {Object}
	    * reinitialize - {Boolean} If set to true, and if resolution options of the
	    *     current baseLayer were changed, the map will be recentered to make
	    *     sure that it is displayed with a valid resolution, and a
	    *     changebaselayer event will be triggered.
	    */
	    addOptions: function (newOptions, reinitialize) {
	        var singleTileChanged = newOptions.singleTile !== undefined && 
	            newOptions.singleTile !== this.singleTile;
	        OpenLayers.Layer.HTTPRequest.prototype.addOptions.apply(this, arguments);
	        if (this.map && singleTileChanged) {
	            this.initProperties();
	            this.clearGrid();
	            this.tileSize = this.options.tileSize;
	            this.setTileSize();
	            if (this.visibility) {
	                this.moveTo(null, true);
	            }
	        }
	    },
	    
	    /**
	     * APIMethod: clone
	     * Create a clone of this layer
	     *
	     * Parameters:
	     * obj - {Object} Is this ever used?
	     * 
	     * Returns:
	     * {<OpenLayers.Layer.Grid>} An exact clone of this OpenLayers.Layer.Grid
	     */
	    clone: function (obj) {
	        
	        if (obj == null) {
	            obj = new OpenLayers.Layer.Grid(this.name,
	                                            this.url,
	                                            this.params,
	                                            this.getOptions());
	        }

	        //get all additions from superclasses
	        obj = OpenLayers.Layer.HTTPRequest.prototype.clone.apply(this, [obj]);

	        // copy/set any non-init, non-simple values here
	        if (this.tileSize != null) {
	            obj.tileSize = this.tileSize.clone();
	        }
	        
	        // we do not want to copy reference to grid, so we make a new array
	        obj.grid = [];
	        obj.gridResolution = null;
	        // same for backbuffer
	        obj.backBuffer = null;
	        obj.backBufferTimerId = null;
	        obj.loading = false;
	        obj.numLoadingTiles = 0;

	        return obj;
	    },    

	    /**
	     * Method: moveTo
	     * This function is called whenever the map is moved. All the moving
	     * of actual 'tiles' is done by the map, but moveTo's role is to accept
	     * a bounds and make sure the data that that bounds requires is pre-loaded.
	     *
	     * Parameters:
	     * bounds - {<OpenLayers.Bounds>}
	     * zoomChanged - {Boolean}
	     * dragging - {Boolean}
	     */
	    moveTo:function(bounds, zoomChanged, dragging) {

	        OpenLayers.Layer.HTTPRequest.prototype.moveTo.apply(this, arguments);

	        bounds = bounds || this.map.getExtent();

	        if (bounds != null) {
	             
	            // if grid is empty or zoom has changed, we *must* re-tile
	            var forceReTile = !this.grid.length || zoomChanged;
	            
	            // total bounds of the tiles
	            var tilesBounds = this.getTilesBounds();            

	            // the new map resolution
	            var resolution = this.map.getResolution();

	            // the server-supported resolution for the new map resolution
	            var serverResolution = this.getServerResolution(resolution);

	            if (this.singleTile) {
	                
	                // We want to redraw whenever even the slightest part of the 
	                //  current bounds is not contained by our tile.
	                //  (thus, we do not specify partial -- its default is false)

	                if ( forceReTile ||
	                     (!dragging && !tilesBounds.containsBounds(bounds))) {

	                    // In single tile mode with no transition effect, we insert
	                    // a non-scaled backbuffer when the layer is moved. But if
	                    // a zoom occurs right after a move, i.e. before the new
	                    // image is received, we need to remove the backbuffer, or
	                    // an ill-positioned image will be visible during the zoom
	                    // transition.

	                    if(zoomChanged && this.transitionEffect !== 'resize') {
	                        this.removeBackBuffer();
	                    }

	                    if(!zoomChanged || this.transitionEffect === 'resize') {
	                        this.applyBackBuffer(resolution);
	                    }

	                    this.initSingleTile(bounds);
	                }
	            } else {

	                // if the bounds have changed such that they are not even 
	                // *partially* contained by our tiles (e.g. when user has 
	                // programmatically panned to the other side of the earth on
	                // zoom level 18), then moveGriddedTiles could potentially have
	                // to run through thousands of cycles, so we want to reTile
	                // instead (thus, partial true).  
	                forceReTile = forceReTile ||
	                    !tilesBounds.intersectsBounds(bounds, {
	                        worldBounds: this.map.baseLayer.wrapDateLine &&
	                            this.map.getMaxExtent()
	                    });

	                if(forceReTile) {
	                    if(zoomChanged && (this.transitionEffect === 'resize' ||
	                                          this.gridResolution === resolution)) {
	                        this.applyBackBuffer(resolution);
	                    }
	                    this.initGriddedTiles(bounds);
	                } else {
	                    this.moveGriddedTiles();
	                }
	            }
	        }
	    },

	    /**
	     * Method: getTileData
	     * Given a map location, retrieve a tile and the pixel offset within that
	     *     tile corresponding to the location.  If there is not an existing 
	     *     tile in the grid that covers the given location, null will be 
	     *     returned.
	     *
	     * Parameters:
	     * loc - {<OpenLayers.LonLat>} map location
	     *
	     * Returns:
	     * {Object} Object with the following properties: tile ({<OpenLayers.Tile>}),
	     *     i ({Number} x-pixel offset from top left), and j ({Integer} y-pixel
	     *     offset from top left).
	     */
	    getTileData: function(loc) {
	        var data = null,
	            x = loc.lon,
	            y = loc.lat,
	            numRows = this.grid.length;

	        if (this.map && numRows) {
	            var res = this.map.getResolution(),
	                tileWidth = this.tileSize.w,
	                tileHeight = this.tileSize.h,
	                bounds = this.grid[0][0].bounds,
	                left = bounds.left,
	                top = bounds.top;

	            if (x < left) {
	                // deal with multiple worlds
	                if (this.map.baseLayer.wrapDateLine) {
	                    var worldWidth = this.map.getMaxExtent().getWidth();
	                    var worldsAway = Math.ceil((left - x) / worldWidth);
	                    x += worldWidth * worldsAway;
	                }
	            }
	            // tile distance to location (fractional number of tiles);
	            var dtx = (x - left) / (res * tileWidth);
	            var dty = (top - y) / (res * tileHeight);
	            // index of tile in grid
	            var col = Math.floor(dtx);
	            var row = Math.floor(dty);
	            if (row >= 0 && row < numRows) {
	                var tile = this.grid[row][col];
	                if (tile) {
	                    data = {
	                        tile: tile,
	                        // pixel index within tile
	                        i: Math.floor((dtx - col) * tileWidth),
	                        j: Math.floor((dty - row) * tileHeight)
	                    };                    
	                }
	            }
	        }
	        return data;
	    },
	    
	    /**
	     * Method: destroyTile
	     *
	     * Parameters:
	     * tile - {<OpenLayers.Tile>}
	     */
	    destroyTile: function(tile) {
	        this.removeTileMonitoringHooks(tile);
	        tile.destroy();
	    },

	    /**
	     * Method: getServerResolution
	     * Return the closest server-supported resolution.
	     *
	     * Parameters:
	     * resolution - {Number} The base resolution. If undefined the
	     *     map resolution is used.
	     *
	     * Returns:
	     * {Number} The closest server resolution value.
	     */
	    getServerResolution: function(resolution) {
	        var distance = Number.POSITIVE_INFINITY;
	        resolution = resolution || this.map.getResolution();
	        if(this.serverResolutions &&
	           OpenLayers.Util.indexOf(this.serverResolutions, resolution) === -1) {
	            var i, newDistance, newResolution, serverResolution;
	            for(i=this.serverResolutions.length-1; i>= 0; i--) {
	                newResolution = this.serverResolutions[i];
	                newDistance = Math.abs(newResolution - resolution);
	                if (newDistance > distance) {
	                    break;
	                }
	                distance = newDistance;
	                serverResolution = newResolution;
	            }
	            resolution = serverResolution;
	        }
	        return resolution;
	    },

	    /**
	     * Method: getServerZoom
	     * Return the zoom value corresponding to the best matching server
	     * resolution, taking into account <serverResolutions> and <zoomOffset>.
	     *
	     * Returns:
	     * {Number} The closest server supported zoom. This is not the map zoom
	     *     level, but an index of the server's resolutions array.
	     */
	    getServerZoom: function() {
	        var resolution = this.getServerResolution();
	        return this.serverResolutions ?
	            OpenLayers.Util.indexOf(this.serverResolutions, resolution) :
	            this.map.getZoomForResolution(resolution) + (this.zoomOffset || 0);
	    },

	    /**
	     * Method: applyBackBuffer
	     * Create, insert, scale and position a back buffer for the layer.
	     *
	     * Parameters:
	     * resolution - {Number} The resolution to transition to.
	     */
	    applyBackBuffer: function(resolution) {
	        if(this.backBufferTimerId !== null) {
	            this.removeBackBuffer();
	        }
	        var backBuffer = this.backBuffer;
	        if(!backBuffer) {
	            backBuffer = this.createBackBuffer();
	            if(!backBuffer) {
	                return;
	            }
	            if (resolution === this.gridResolution) {
	                this.div.insertBefore(backBuffer, this.div.firstChild);
	            } else {
	                this.map.baseLayer.div.parentNode.insertBefore(backBuffer, this.map.baseLayer.div);
	            }
	            this.backBuffer = backBuffer;

	            // set some information in the instance for subsequent
	            // calls to applyBackBuffer where the same back buffer
	            // is reused
	            var topLeftTileBounds = this.grid[0][0].bounds;
	            this.backBufferLonLat = {
	                lon: topLeftTileBounds.left,
	                lat: topLeftTileBounds.top
	            };
	            this.backBufferResolution = this.gridResolution;
	        }
	        
	        var ratio = this.backBufferResolution / resolution;

	        // scale the tiles inside the back buffer
	        var tiles = backBuffer.childNodes, tile;
	        for (var i=tiles.length-1; i>=0; --i) {
	            tile = tiles[i];
	            tile.style.top = ((ratio * tile._i * backBuffer._th) | 0) + 'px';
	            tile.style.left = ((ratio * tile._j * backBuffer._tw) | 0) + 'px';
	            tile.style.width = Math.round(ratio * tile._w) + 'px';
	            tile.style.height = Math.round(ratio * tile._h) + 'px';
	        }

	        // and position it (based on the grid's top-left corner)
	        var position = this.getViewPortPxFromLonLat(
	                this.backBufferLonLat, resolution);
	        var leftOffset = this.map.layerContainerOriginPx.x;
	        var topOffset = this.map.layerContainerOriginPx.y;
	        backBuffer.style.left = Math.round(position.x - leftOffset) + 'px';
	        backBuffer.style.top = Math.round(position.y - topOffset) + 'px';
	    },

	    /**
	     * Method: createBackBuffer
	     * Create a back buffer.
	     *
	     * Returns:
	     * {DOMElement} The DOM element for the back buffer, undefined if the
	     * grid isn't initialized yet.
	     */
	    createBackBuffer: function() {
	        var backBuffer;
	        if(this.grid.length > 0) {
	            backBuffer = document.createElement('div');
	            backBuffer.id = this.div.id + '_bb';
	            backBuffer.className = 'olBackBuffer';
	            backBuffer.style.position = 'absolute';
	            var map = this.map;
	            backBuffer.style.zIndex = this.transitionEffect === 'resize' ?
	                    this.getZIndex() - 1 :
	                    // 'map-resize':
	                    map.Z_INDEX_BASE.BaseLayer -
	                            (map.getNumLayers() - map.getLayerIndex(this));
	            for(var i=0, lenI=this.grid.length; i<lenI; i++) {
	                for(var j=0, lenJ=this.grid[i].length; j<lenJ; j++) {
	                    var tile = this.grid[i][j],
	                        markup = this.grid[i][j].createBackBuffer();
	                    if (markup) {
	                        markup._i = i;
	                        markup._j = j;
	                        markup._w = this.singleTile ?
	                                this.getImageSize(tile.bounds).w : tile.size.w;
	                        markup._h = tile.size.h;
	                        markup.id = tile.id + '_bb';
	                        backBuffer.appendChild(markup);
	                    }
	                }
	            }
	            backBuffer._tw = this.tileSize.w;
	            backBuffer._th = this.tileSize.h;
	        }
	        return backBuffer;
	    },

	    /**
	     * Method: removeBackBuffer
	     * Remove back buffer from DOM.
	     */
	    removeBackBuffer: function() {
	        if (this._transitionElement) {
	            for (var i=this.transitionendEvents.length-1; i>=0; --i) {
	                OpenLayers.Event.stopObserving(this._transitionElement,
	                    this.transitionendEvents[i], this._removeBackBuffer);
	            }
	            delete this._transitionElement;
	        }
	        if(this.backBuffer) {
	            if (this.backBuffer.parentNode) {
	                this.backBuffer.parentNode.removeChild(this.backBuffer);
	            }
	            this.backBuffer = null;
	            this.backBufferResolution = null;
	            if(this.backBufferTimerId !== null) {
	                window.clearTimeout(this.backBufferTimerId);
	                this.backBufferTimerId = null;
	            }
	        }
	    },

	    /**
	     * Method: moveByPx
	     * Move the layer based on pixel vector.
	     *
	     * Parameters:
	     * dx - {Number}
	     * dy - {Number}
	     */
	    moveByPx: function(dx, dy) {
	        if (!this.singleTile) {
	            this.moveGriddedTiles();
	        }
	    },

	    /**
	     * APIMethod: setTileSize
	     * Check if we are in singleTile mode and if so, set the size as a ratio
	     *     of the map size (as specified by the layer's 'ratio' property).
	     * 
	     * Parameters:
	     * size - {<OpenLayers.Size>}
	     */
	    setTileSize: function(size) { 
	        if (this.singleTile) {
	            size = this.map.getSize();
	            size.h = parseInt(size.h * this.ratio, 10);
	            size.w = parseInt(size.w * this.ratio, 10);
	        } 
	        OpenLayers.Layer.HTTPRequest.prototype.setTileSize.apply(this, [size]);
	    },

	    /**
	     * APIMethod: getTilesBounds
	     * Return the bounds of the tile grid.
	     *
	     * Returns:
	     * {<OpenLayers.Bounds>} A Bounds object representing the bounds of all the
	     *     currently loaded tiles (including those partially or not at all seen 
	     *     onscreen).
	     */
	    getTilesBounds: function() {    
	        var bounds = null; 
	        
	        var length = this.grid.length;
	        if (length) {
	            var bottomLeftTileBounds = this.grid[length - 1][0].bounds,
	                width = this.grid[0].length * bottomLeftTileBounds.getWidth(),
	                height = this.grid.length * bottomLeftTileBounds.getHeight();
	            
	            bounds = new OpenLayers.Bounds(bottomLeftTileBounds.left, 
	                                           bottomLeftTileBounds.bottom,
	                                           bottomLeftTileBounds.left + width, 
	                                           bottomLeftTileBounds.bottom + height);
	        }   
	        return bounds;
	    },

	    /**
	     * Method: initSingleTile
	     * 
	     * Parameters: 
	     * bounds - {<OpenLayers.Bounds>}
	     */
	    initSingleTile: function(bounds) {
	        this.events.triggerEvent("retile");

	        //determine new tile bounds
	        var center = bounds.getCenterLonLat();
	        var tileWidth = bounds.getWidth() * this.ratio;
	        var tileHeight = bounds.getHeight() * this.ratio;
	                                       
	        var tileBounds = 
	            new OpenLayers.Bounds(center.lon - (tileWidth/2),
	                                  center.lat - (tileHeight/2),
	                                  center.lon + (tileWidth/2),
	                                  center.lat + (tileHeight/2));

	        // store the resolution of the grid
	        this.gridResolution = this.getServerResolution();
	  
	        // same logic as OpenLayers.Tile#shouldDraw
	        var maxExtent = this.maxExtent;
	        if (maxExtent && (!this.displayOutsideMaxExtent ||
	                (this.map.baseLayer.wrapDateLine &&
	                this.maxExtent.equals(this.map.getMaxExtent())))) {
	            tileBounds.left = Math.max(tileBounds.left, maxExtent.left);
	            tileBounds.right = Math.min(tileBounds.right, maxExtent.right);
	        }

	        var px = this.map.getLayerPxFromLonLat({
	            lon: tileBounds.left,
	            lat: tileBounds.top
	        });

	        if (!this.grid.length) {
	            this.grid[0] = [];
	        }

	        var tile = this.grid[0][0];
	        if (!tile) {
	            tile = this.addTile(tileBounds, px);

	            this.addTileMonitoringHooks(tile);
	            tile.draw();
	            this.grid[0][0] = tile;
	        } else {
	            tile.moveTo(tileBounds, px);
	        }           
	        
	        //remove all but our single tile
	        this.removeExcessTiles(1,1);
	    },

	    /** 
	     * Method: calculateGridLayout
	     * Generate parameters for the grid layout.
	     *
	     * Parameters:
	     * bounds - {<OpenLayers.Bound>|Object} OpenLayers.Bounds or an
	     *     object with a 'left' and 'top' properties.
	     * origin - {<OpenLayers.LonLat>|Object} OpenLayers.LonLat or an
	     *     object with a 'lon' and 'lat' properties.
	     * resolution - {Number}
	     *
	     * Returns:
	     * {Object} Object containing properties tilelon, tilelat, startcol,
	     * startrow
	     */
	    calculateGridLayout: function(bounds, origin, resolution) {
	        var tilelon = resolution * this.tileSize.w;
	        var tilelat = resolution * this.tileSize.h;
	        
	        var offsetlon = bounds.left - origin.lon;
	        var tilecol = Math.floor(offsetlon/tilelon) - this.buffer;
	        
	        var rowSign = this.rowSign;

	        var offsetlat = rowSign * (origin.lat - bounds.top + tilelat);  
	        var tilerow = Math[~rowSign ? 'floor' : 'ceil'](offsetlat/tilelat) - this.buffer * rowSign;
	        
	        return { 
	          tilelon: tilelon, tilelat: tilelat,
	          startcol: tilecol, startrow: tilerow
	        };

	    },

	    getImageSize: function(bounds) {
	        var tileSize = OpenLayers.Layer.HTTPRequest.prototype.getImageSize.apply(this, arguments);
	        if (this.singleTile) {
	            tileSize = new OpenLayers.Size(
	                Math.round(bounds.getWidth() / this.gridResolution),
	                tileSize.h
	            );
	        }
	        return tileSize;
	    },

	    /**
	     * Method: getTileOrigin
	     * Determine the origin for aligning the grid of tiles.  If a <tileOrigin>
	     *     property is supplied, that will be returned.  Otherwise, the origin
	     *     will be derived from the layer's <maxExtent> property.  In this case,
	     *     the tile origin will be the corner of the <maxExtent> given by the 
	     *     <tileOriginCorner> property.
	     *
	     * Returns:
	     * {<OpenLayers.LonLat>} The tile origin.
	     */
	    getTileOrigin: function() {
	        var origin = this.tileOrigin;
	        if (!origin) {
	            var extent = this.getMaxExtent();
	            var edges = ({
	                "tl": ["left", "top"],
	                "tr": ["right", "top"],
	                "bl": ["left", "bottom"],
	                "br": ["right", "bottom"]
	            })[this.tileOriginCorner];
	            origin = new OpenLayers.LonLat(extent[edges[0]], extent[edges[1]]);
	        }
	        return origin;
	    },

	    /**
	     * Method: getTileBoundsForGridIndex
	     *
	     * Parameters:
	     * row - {Number} The row of the grid
	     * col - {Number} The column of the grid
	     *
	     * Returns:
	     * {<OpenLayers.Bounds>} The bounds for the tile at (row, col)
	     */
	    getTileBoundsForGridIndex: function(row, col) {
	        var origin = this.getTileOrigin();
	        var tileLayout = this.gridLayout;
	        var tilelon = tileLayout.tilelon;
	        var tilelat = tileLayout.tilelat;
	        var startcol = tileLayout.startcol;
	        var startrow = tileLayout.startrow;
	        var rowSign = this.rowSign;
	        return new OpenLayers.Bounds(
	            origin.lon + (startcol + col) * tilelon,
	            origin.lat - (startrow + row * rowSign) * tilelat * rowSign,
	            origin.lon + (startcol + col + 1) * tilelon,
	            origin.lat - (startrow + (row - 1) * rowSign) * tilelat * rowSign
	        );
	    },

	    /**
	     * Method: initGriddedTiles
	     * 
	     * Parameters:
	     * bounds - {<OpenLayers.Bounds>}
	     */
	    initGriddedTiles:function(bounds) {
	        this.events.triggerEvent("retile");

	        // work out mininum number of rows and columns; this is the number of
	        // tiles required to cover the viewport plus at least one for panning

	        var viewSize = this.map.getSize();
	        
	        var origin = this.getTileOrigin();
	        var resolution = this.map.getResolution(),
	            serverResolution = this.getServerResolution(),
	            ratio = resolution / serverResolution,
	            tileSize = {
	                w: this.tileSize.w / ratio,
	                h: this.tileSize.h / ratio
	            };

	        var minRows = Math.ceil(viewSize.h/tileSize.h) + 
	                      2 * this.buffer + 1;
	        var minCols = Math.ceil(viewSize.w/tileSize.w) +
	                      2 * this.buffer + 1;

	        var tileLayout = this.calculateGridLayout(bounds, origin, serverResolution);
	        this.gridLayout = tileLayout;
	        
	        var tilelon = tileLayout.tilelon;
	        var tilelat = tileLayout.tilelat;
	        
	        var layerContainerDivLeft = this.map.layerContainerOriginPx.x;
	        var layerContainerDivTop = this.map.layerContainerOriginPx.y;

	        var tileBounds = this.getTileBoundsForGridIndex(0, 0);
	        var startPx = this.map.getViewPortPxFromLonLat(
	            new OpenLayers.LonLat(tileBounds.left, tileBounds.top)
	        );
	        startPx.x = Math.round(startPx.x) - layerContainerDivLeft;
	        startPx.y = Math.round(startPx.y) - layerContainerDivTop;

	        var tileData = [], center = this.map.getCenter();

	        var rowidx = 0;
	        do {
	            var row = this.grid[rowidx];
	            if (!row) {
	                row = [];
	                this.grid.push(row);
	            }
	            
	            var colidx = 0;
	            do {
	                tileBounds = this.getTileBoundsForGridIndex(rowidx, colidx);
	                var px = startPx.clone();
	                px.x = px.x + colidx * Math.round(tileSize.w);
	                px.y = px.y + rowidx * Math.round(tileSize.h);
	                var tile = row[colidx];
	                if (!tile) {
	                    tile = this.addTile(tileBounds, px);
	                    this.addTileMonitoringHooks(tile);
	                    row.push(tile);
	                } else {
	                    tile.moveTo(tileBounds, px, false);
	                }
	                var tileCenter = tileBounds.getCenterLonLat();
	                tileData.push({
	                    tile: tile,
	                    distance: Math.pow(tileCenter.lon - center.lon, 2) +
	                        Math.pow(tileCenter.lat - center.lat, 2)
	                });
	     
	                colidx += 1;
	            } while ((tileBounds.right <= bounds.right + tilelon * this.buffer)
	                     || colidx < minCols);
	             
	            rowidx += 1;
	        } while((tileBounds.bottom >= bounds.bottom - tilelat * this.buffer)
	                || rowidx < minRows);
	        
	        //shave off excess rows and columns
	        this.removeExcessTiles(rowidx, colidx);

	        var resolution = this.getServerResolution();
	        // store the resolution of the grid
	        this.gridResolution = resolution;

	        //now actually draw the tiles
	        tileData.sort(function(a, b) {
	            return a.distance - b.distance; 
	        });
	        for (var i=0, ii=tileData.length; i<ii; ++i) {
	            tileData[i].tile.draw();
	        }
	    },

	    /**
	     * Method: getMaxExtent
	     * Get this layer's maximum extent. (Implemented as a getter for
	     *     potential specific implementations in sub-classes.)
	     *
	     * Returns:
	     * {<OpenLayers.Bounds>}
	     */
	    getMaxExtent: function() {
	        return this.maxExtent;
	    },

	    /**
	     * APIMethod: addTile
	     * Create a tile, initialize it, and add it to the layer div. 
	     *
	     * Parameters
	     * bounds - {<OpenLayers.Bounds>}
	     * position - {<OpenLayers.Pixel>}
	     *
	     * Returns:
	     * {<OpenLayers.Tile>} The added OpenLayers.Tile
	     */
	    addTile: function(bounds, position) {
	        var tile = new this.tileClass(
	            this, position, bounds, null, this.tileSize, this.tileOptions
	        );
	        this.events.triggerEvent("addtile", {tile: tile});
	        return tile;
	    },
	    
	    /** 
	     * Method: addTileMonitoringHooks
	     * This function takes a tile as input and adds the appropriate hooks to 
	     *     the tile so that the layer can keep track of the loading tiles.
	     * 
	     * Parameters: 
	     * tile - {<OpenLayers.Tile>}
	     */
	    addTileMonitoringHooks: function(tile) {
	        
	        var replacingCls = 'olTileReplacing';

	        tile.onLoadStart = function() {
	            //if that was first tile then trigger a 'loadstart' on the layer
	            if (this.loading === false) {
	                this.loading = true;
	                this.events.triggerEvent("loadstart");
	            }
	            this.events.triggerEvent("tileloadstart", {tile: tile});
	            this.numLoadingTiles++;
	            if (!this.singleTile && this.backBuffer && this.gridResolution === this.backBufferResolution) {
	                OpenLayers.Element.addClass(tile.getTile(), replacingCls);
	            }
	        };
	      
	        tile.onLoadEnd = function(evt) {
	            this.numLoadingTiles--;
	            var aborted = evt.type === 'unload';
	            this.events.triggerEvent("tileloaded", {
	                tile: tile,
	                aborted: aborted
	            });
	            if (!this.singleTile && !aborted && this.backBuffer && this.gridResolution === this.backBufferResolution) {
	                var tileDiv = tile.getTile();
	                if (OpenLayers.Element.getStyle(tileDiv, 'display') === 'none') {
	                    var bufferTile = document.getElementById(tile.id + '_bb');
	                    if (bufferTile) {
	                        bufferTile.parentNode.removeChild(bufferTile);
	                    }
	                }
	                OpenLayers.Element.removeClass(tileDiv, replacingCls);
	            }
	            //if that was the last tile, then trigger a 'loadend' on the layer
	            if (this.numLoadingTiles === 0) {
	                if (this.backBuffer) {
	                    if (this.backBuffer.childNodes.length === 0) {
	                        // no tiles transitioning, remove immediately
	                        this.removeBackBuffer();
	                    } else {
	                        // wait until transition has ended or delay has passed
	                        this._transitionElement = aborted ?
	                            this.div.lastChild : tile.imgDiv;
	                        var transitionendEvents = this.transitionendEvents;
	                        for (var i=transitionendEvents.length-1; i>=0; --i) {
	                            OpenLayers.Event.observe(this._transitionElement,
	                                transitionendEvents[i],
	                                this._removeBackBuffer);
	                        }
	                        // the removal of the back buffer is delayed to prevent
	                        // flash effects due to the animation of tile displaying
	                        this.backBufferTimerId = window.setTimeout(
	                            this._removeBackBuffer, this.removeBackBufferDelay
	                        );
	                    }
	                }
	                this.loading = false;
	                this.events.triggerEvent("loadend");
	            }
	        };
	        
	        tile.onLoadError = function() {
	            this.events.triggerEvent("tileerror", {tile: tile});
	        };
	        
	        tile.events.on({
	            "loadstart": tile.onLoadStart,
	            "loadend": tile.onLoadEnd,
	            "unload": tile.onLoadEnd,
	            "loaderror": tile.onLoadError,
	            scope: this
	        });
	    },

	    /** 
	     * Method: removeTileMonitoringHooks
	     * This function takes a tile as input and removes the tile hooks 
	     *     that were added in addTileMonitoringHooks()
	     * 
	     * Parameters: 
	     * tile - {<OpenLayers.Tile>}
	     */
	    removeTileMonitoringHooks: function(tile) {
	        tile.unload();
	        tile.events.un({
	            "loadstart": tile.onLoadStart,
	            "loadend": tile.onLoadEnd,
	            "unload": tile.onLoadEnd,
	            "loaderror": tile.onLoadError,
	            scope: this
	        });
	    },
	    
	    /**
	     * Method: moveGriddedTiles
	     */
	    moveGriddedTiles: function() {
	        var buffer = this.buffer + 1;
	        while(true) {
	            var tlTile = this.grid[0][0];
	            var tlViewPort = {
	                x: tlTile.position.x +
	                    this.map.layerContainerOriginPx.x,
	                y: tlTile.position.y +
	                    this.map.layerContainerOriginPx.y
	            };
	            var ratio = this.getServerResolution() / this.map.getResolution();
	            var tileSize = {
	                w: Math.round(this.tileSize.w * ratio),
	                h: Math.round(this.tileSize.h * ratio)
	            };
	            if (tlViewPort.x > -tileSize.w * (buffer - 1)) {
	                this.shiftColumn(true, tileSize);
	            } else if (tlViewPort.x < -tileSize.w * buffer) {
	                this.shiftColumn(false, tileSize);
	            } else if (tlViewPort.y > -tileSize.h * (buffer - 1)) {
	                this.shiftRow(true, tileSize);
	            } else if (tlViewPort.y < -tileSize.h * buffer) {
	                this.shiftRow(false, tileSize);
	            } else {
	                break;
	            }
	        }
	    },

	    /**
	     * Method: shiftRow
	     * Shifty grid work
	     *
	     * Parameters:
	     * prepend - {Boolean} if true, prepend to beginning.
	     *                          if false, then append to end
	     * tileSize - {Object} rendered tile size; object with w and h properties
	     */
	    shiftRow: function(prepend, tileSize) {
	        var grid = this.grid;
	        var rowIndex = prepend ? 0 : (grid.length - 1);
	        var sign = prepend ? -1 : 1;
	        var rowSign = this.rowSign;
	        var tileLayout = this.gridLayout;
	        tileLayout.startrow += sign * rowSign;

	        var modelRow = grid[rowIndex];
	        var row = grid[prepend ? 'pop' : 'shift']();
	        for (var i=0, len=row.length; i<len; i++) {
	            var tile = row[i];
	            var position = modelRow[i].position.clone();
	            position.y += tileSize.h * sign;
	            tile.moveTo(this.getTileBoundsForGridIndex(rowIndex, i), position);
	        }
	        grid[prepend ? 'unshift' : 'push'](row);
	    },

	    /**
	     * Method: shiftColumn
	     * Shift grid work in the other dimension
	     *
	     * Parameters:
	     * prepend - {Boolean} if true, prepend to beginning.
	     *                          if false, then append to end
	     * tileSize - {Object} rendered tile size; object with w and h properties
	     */
	    shiftColumn: function(prepend, tileSize) {
	        var grid = this.grid;
	        var colIndex = prepend ? 0 : (grid[0].length - 1);
	        var sign = prepend ? -1 : 1;
	        var tileLayout = this.gridLayout;
	        tileLayout.startcol += sign;

	        for (var i=0, len=grid.length; i<len; i++) {
	            var row = grid[i];
	            var position = row[colIndex].position.clone();
	            var tile = row[prepend ? 'pop' : 'shift']();            
	            position.x += tileSize.w * sign;
	            tile.moveTo(this.getTileBoundsForGridIndex(i, colIndex), position);
	            row[prepend ? 'unshift' : 'push'](tile);
	        }
	    },

	    /**
	     * Method: removeExcessTiles
	     * When the size of the map or the buffer changes, we may need to
	     *     remove some excess rows and columns.
	     * 
	     * Parameters:
	     * rows - {Integer} Maximum number of rows we want our grid to have.
	     * columns - {Integer} Maximum number of columns we want our grid to have.
	     */
	    removeExcessTiles: function(rows, columns) {
	        var i, l;
	        
	        // remove extra rows
	        while (this.grid.length > rows) {
	            var row = this.grid.pop();
	            for (i=0, l=row.length; i<l; i++) {
	                var tile = row[i];
	                this.destroyTile(tile);
	            }
	        }
	        
	        // remove extra columns
	        for (i=0, l=this.grid.length; i<l; i++) {
	            while (this.grid[i].length > columns) {
	                var row = this.grid[i];
	                var tile = row.pop();
	                this.destroyTile(tile);
	            }
	        }
	    },

	    /**
	     * Method: onMapResize
	     * For singleTile layers, this will set a new tile size according to the
	     * dimensions of the map pane.
	     */
	    onMapResize: function() {
	        if (this.singleTile) {
	            this.clearGrid();
	            this.setTileSize();
	        }
	    },
	    
	    /**
	     * APIMethod: getTileBounds
	     * Returns The tile bounds for a layer given a pixel location.
	     *
	     * Parameters:
	     * viewPortPx - {<OpenLayers.Pixel>} The location in the viewport.
	     *
	     * Returns:
	     * {<OpenLayers.Bounds>} Bounds of the tile at the given pixel location.
	     */
	    getTileBounds: function(viewPortPx) {
	        var maxExtent = this.maxExtent;
	        var resolution = this.getResolution();
	        var tileMapWidth = resolution * this.tileSize.w;
	        var tileMapHeight = resolution * this.tileSize.h;
	        var mapPoint = this.getLonLatFromViewPortPx(viewPortPx);
	        var tileLeft = maxExtent.left + (tileMapWidth *
	                                         Math.floor((mapPoint.lon -
	                                                     maxExtent.left) /
	                                                    tileMapWidth));
	        var tileBottom = maxExtent.bottom + (tileMapHeight *
	                                             Math.floor((mapPoint.lat -
	                                                         maxExtent.bottom) /
	                                                        tileMapHeight));
	        return new OpenLayers.Bounds(tileLeft, tileBottom,
	                                     tileLeft + tileMapWidth,
	                                     tileBottom + tileMapHeight);
	    },

	    CLASS_NAME: "OpenLayers.Layer.Grid"
	});
	/* ======================================================================
	    OpenLayers/TileManager.js
	   ====================================================================== */

	/* Copyright (c) 2006-2015 by OpenLayers Contributors (see authors.txt for
	 * full list of contributors). Published under the 2-clause BSD license.
	 * See license.txt in the OpenLayers distribution or repository for the
	 * full text of the license. */


	/**
	 * @requires OpenLayers/Util.js
	 * @requires OpenLayers/BaseTypes.js
	 * @requires OpenLayers/BaseTypes/Element.js
	 * @requires OpenLayers/Layer/Grid.js
	 * @requires OpenLayers/Tile/Image.js
	 */

	/**
	 * Class: OpenLayers.TileManager
	 * Provides queueing of image requests and caching of image elements.
	 *
	 * Queueing avoids unnecessary image requests while changing zoom levels
	 * quickly, and helps improve dragging performance on mobile devices that show
	 * a lag in dragging when loading of new images starts. <zoomDelay> and
	 * <moveDelay> are the configuration options to control this behavior.
	 *
	 * Caching avoids setting the src on image elements for images that have already
	 * been used. Several maps can share a TileManager instance, in which case each
	 * map gets its own tile queue, but all maps share the same tile cache.
	 */
	OpenLayers.TileManager = OpenLayers.Class({
	    
	    /**
	     * APIProperty: cacheSize
	     * {Number} Number of image elements to keep referenced in this instance's
	     * cache for fast reuse. Default is 256.
	     */
	    cacheSize: 256,

	    /**
	     * APIProperty: tilesPerFrame
	     * {Number} Number of queued tiles to load per frame (see <frameDelay>).
	     *     Default is 2.
	     */
	    tilesPerFrame: 2,

	    /**
	     * APIProperty: frameDelay
	     * {Number} Delay between tile loading frames (see <tilesPerFrame>) in
	     *     milliseconds. Default is 16.
	     */
	    frameDelay: 16,

	    /**
	     * APIProperty: moveDelay
	     * {Number} Delay in milliseconds after a map's move event before loading
	     * tiles. Default is 100.
	     */
	    moveDelay: 100,
	    
	    /**
	     * APIProperty: zoomDelay
	     * {Number} Delay in milliseconds after a map's zoomend event before loading
	     * tiles. Default is 200.
	     */
	    zoomDelay: 200,
	    
	    /**
	     * Property: maps
	     * {Array(<OpenLayers.Map>)} The maps to manage tiles on.
	     */
	    maps: null,
	    
	    /**
	     * Property: tileQueueId
	     * {Object} The ids of the <drawTilesFromQueue> loop, keyed by map id.
	     */
	    tileQueueId: null,

	    /**
	     * Property: tileQueue
	     * {Object(Array(<OpenLayers.Tile>))} Tiles queued for drawing, keyed by
	     * map id.
	     */
	    tileQueue: null,
	    
	    /**
	     * Property: tileCache
	     * {Object} Cached image elements, keyed by URL.
	     */
	    tileCache: null,
	    
	    /**
	     * Property: tileCacheIndex
	     * {Array(String)} URLs of cached tiles. First entry is the least recently
	     *    used.
	     */
	    tileCacheIndex: null,    
	    
	    /** 
	     * Constructor: OpenLayers.TileManager
	     * Constructor for a new <OpenLayers.TileManager> instance.
	     * 
	     * Parameters:
	     * options - {Object} Configuration for this instance.
	     */   
	    initialize: function(options) {
	        OpenLayers.Util.extend(this, options);
	        this.maps = [];
	        this.tileQueueId = {};
	        this.tileQueue = {};
	        this.tileCache = {};
	        this.tileCacheIndex = [];
	    },
	    
	    /**
	     * Method: addMap
	     * Binds this instance to a map
	     *
	     * Parameters:
	     * map - {<OpenLayers.Map>}
	     */
	    addMap: function(map) {
	        if (this._destroyed || !OpenLayers.Layer.Grid) {
	            return;
	        }
	        this.maps.push(map);
	        this.tileQueue[map.id] = [];
	        for (var i=0, ii=map.layers.length; i<ii; ++i) {
	            this.addLayer({layer: map.layers[i]});
	        }
	        map.events.on({
	            move: this.move,
	            zoomend: this.zoomEnd,
	            changelayer: this.changeLayer,
	            addlayer: this.addLayer,
	            preremovelayer: this.removeLayer,
	            scope: this
	        });
	    },
	    
	    /**
	     * Method: removeMap
	     * Unbinds this instance from a map
	     *
	     * Parameters:
	     * map - {<OpenLayers.Map>}
	     */
	    removeMap: function(map) {
	        if (this._destroyed || !OpenLayers.Layer.Grid) {
	            return;
	        }
	        window.clearTimeout(this.tileQueueId[map.id]);
	        if (map.layers) {
	            for (var i=0, ii=map.layers.length; i<ii; ++i) {
	                this.removeLayer({layer: map.layers[i]});
	            }
	        }
	        if (map.events) {
	            map.events.un({
	                move: this.move,
	                zoomend: this.zoomEnd,
	                changelayer: this.changeLayer,
	                addlayer: this.addLayer,
	                preremovelayer: this.removeLayer,
	                scope: this
	            });
	        }
	        delete this.tileQueue[map.id];
	        delete this.tileQueueId[map.id];
	        OpenLayers.Util.removeItem(this.maps, map);
	    },
	    
	    /**
	     * Method: move
	     * Handles the map's move event
	     *
	     * Parameters:
	     * evt - {Object} Listener argument
	     */
	    move: function(evt) {
	        this.updateTimeout(evt.object, this.moveDelay, true);
	    },
	    
	    /**
	     * Method: zoomEnd
	     * Handles the map's zoomEnd event
	     *
	     * Parameters:
	     * evt - {Object} Listener argument
	     */
	    zoomEnd: function(evt) {
	        this.updateTimeout(evt.object, this.zoomDelay);
	    },
	    
	    /**
	     * Method: changeLayer
	     * Handles the map's changeLayer event
	     *
	     * Parameters:
	     * evt - {Object} Listener argument
	     */
	    changeLayer: function(evt) {
	        if (evt.property === 'visibility' || evt.property === 'params') {
	            this.updateTimeout(evt.object, 0);
	        }
	    },
	    
	    /**
	     * Method: addLayer
	     * Handles the map's addlayer event
	     *
	     * Parameters:
	     * evt - {Object} The listener argument
	     */
	    addLayer: function(evt) {
	        var layer = evt.layer;
	        if (layer instanceof OpenLayers.Layer.Grid) {
	            layer.events.on({
	                addtile: this.addTile,
	                refresh: this.handleLayerRefresh,
	                retile: this.clearTileQueue,
	                scope: this
	            });
	            var i, j, tile;
	            for (i=layer.grid.length-1; i>=0; --i) {
	                for (j=layer.grid[i].length-1; j>=0; --j) {
	                    tile = layer.grid[i][j];
	                    this.addTile({tile: tile});
	                    if (tile.url && !tile.imgDiv) {
	                        this.manageTileCache({object: tile});
	                    }
	                }
	            }
	        }
	    },
	    
	    /**
	     * Method: removeLayer
	     * Handles the map's preremovelayer event
	     *
	     * Parameters:
	     * evt - {Object} The listener argument
	     */
	    removeLayer: function(evt) {
	        var layer = evt.layer;
	        if (layer instanceof OpenLayers.Layer.Grid) {
	            this.clearTileQueue({object: layer});
	            if (layer.events) {
	                layer.events.un({
	                    addtile: this.addTile,
	                    refresh: this.handleLayerRefresh,
	                    retile: this.clearTileQueue,
	                    scope: this
	                });
	            }
	            if (layer.grid) {
	                var i, j, tile;
	                for (i=layer.grid.length-1; i>=0; --i) {
	                    for (j=layer.grid[i].length-1; j>=0; --j) {
	                        tile = layer.grid[i][j];
	                        this.unloadTile({object: tile});
	                    }
	                }
	            }
	        }
	    },

	    /**
	     * Method: handleLayerRefresh
	     * Clears the cache when a redraw is forced on a layer
	     *
	     * Parameters:
	     * evt - {Object} The listener argument
	     */
	    handleLayerRefresh: function(evt) {
	        var layer = evt.object;
	        if (layer.grid) {
	            var i, j, tile;
	            for (i=layer.grid.length-1; i>=0; --i) {
	                for (j=layer.grid[i].length-1; j>=0; --j) {
	                    tile = layer.grid[i][j];
	                    OpenLayers.Util.removeItem(this.tileCacheIndex, tile.url);
	                    delete this.tileCache[tile.url];
	                }
	            }
	        }
	    },
	    
	    /**
	     * Method: updateTimeout
	     * Applies the <moveDelay> or <zoomDelay> to the <drawTilesFromQueue> loop,
	     * and schedules more queue processing after <frameDelay> if there are still
	     * tiles in the queue.
	     *
	     * Parameters:
	     * map - {<OpenLayers.Map>} The map to update the timeout for
	     * delay - {Number} The delay to apply
	     * nice - {Boolean} If true, the timeout function will only be created if
	     *     the tilequeue is not empty. This is used by the move handler to
	     *     avoid impacts on dragging performance. For other events, the tile
	     *     queue may not be populated yet, so we need to set the timer
	     *     regardless of the queue size.
	     */
	    updateTimeout: function(map, delay, nice) {
	        window.clearTimeout(this.tileQueueId[map.id]);
	        var tileQueue = this.tileQueue[map.id];
	        if (!nice || tileQueue.length) {
	            this.tileQueueId[map.id] = window.setTimeout(
	                OpenLayers.Function.bind(function() {
	                    this.drawTilesFromQueue(map);
	                    if (tileQueue.length) {
	                        this.updateTimeout(map, this.frameDelay);
	                    }
	                }, this), delay
	            );
	        }
	    },
	    
	    /**
	     * Method: addTile
	     * Listener for the layer's addtile event
	     *
	     * Parameters:
	     * evt - {Object} The listener argument
	     */
	    addTile: function(evt) {
	        if (evt.tile instanceof OpenLayers.Tile.Image) {
	          if (!evt.tile.layer.singleTile) {
	            evt.tile.events.on({
	                beforedraw: this.queueTileDraw,
	                beforeload: this.manageTileCache,
	                loadend: this.addToCache,
	                unload: this.unloadTile,
	                scope: this
	            });        
	          }
	        } else {
	            // Layer has the wrong tile type, so don't handle it any longer
	            this.removeLayer({layer: evt.tile.layer});
	        }
	    },
	    
	    /**
	     * Method: unloadTile
	     * Listener for the tile's unload event
	     *
	     * Parameters:
	     * evt - {Object} The listener argument
	     */
	    unloadTile: function(evt) {
	        var tile = evt.object;
	        tile.events.un({
	            beforedraw: this.queueTileDraw,
	            beforeload: this.manageTileCache,
	            loadend: this.addToCache,
	            unload: this.unloadTile,
	            scope: this
	        });
	        OpenLayers.Util.removeItem(this.tileQueue[tile.layer.map.id], tile);
	    },
	    
	    /**
	     * Method: queueTileDraw
	     * Adds a tile to the queue that will draw it.
	     *
	     * Parameters:
	     * evt - {Object} Listener argument of the tile's beforedraw event
	     */
	    queueTileDraw: function(evt) {
	        var tile = evt.object;
	        var queued = false;
	        var layer = tile.layer;
	        var url = layer.getURL(tile.bounds);
	        var img = this.tileCache[url];
	        if (img && img.className !== 'olTileImage') {
	            // cached image no longer valid, e.g. because we're olTileReplacing
	            delete this.tileCache[url];
	            OpenLayers.Util.removeItem(this.tileCacheIndex, url);
	            img = null;
	        }
	        // queue only if image with same url not cached already
	        if (layer.url && (layer.async || !img)) {
	            // add to queue only if not in queue already
	            var tileQueue = this.tileQueue[layer.map.id];
	            if (!~OpenLayers.Util.indexOf(tileQueue, tile)) {
	                tileQueue.push(tile);
	            }
	            queued = true;
	        }
	        return !queued;
	    },
	    
	    /**
	     * Method: drawTilesFromQueue
	     * Draws tiles from the tileQueue, and unqueues the tiles
	     */
	    drawTilesFromQueue: function(map) {
	        var tileQueue = this.tileQueue[map.id];
	        var limit = this.tilesPerFrame;
	        var animating = map.zoomTween && map.zoomTween.playing;
	        while (!animating && tileQueue.length && limit) {
	            tileQueue.shift().draw(true);
	            --limit;
	        }
	    },
	    
	    /**
	     * Method: manageTileCache
	     * Adds, updates, removes and fetches cache entries.
	     *
	     * Parameters:
	     * evt - {Object} Listener argument of the tile's beforeload event
	     */
	    manageTileCache: function(evt) {
	        var tile = evt.object;
	        var img = this.tileCache[tile.url];
	        if (img) {
	          // if image is on its layer's backbuffer, remove it from backbuffer
	          if (img.parentNode &&
	                  OpenLayers.Element.hasClass(img.parentNode, 'olBackBuffer')) {
	              img.parentNode.removeChild(img);
	              img.id = null;
	          }
	          // only use image from cache if it is not on a layer already
	          if (!img.parentNode) {
	              img.style.visibility = 'hidden';
	              img.style.opacity = 0;
	              tile.setImage(img);
	              // LRU - move tile to the end of the array to mark it as the most
	              // recently used
	              OpenLayers.Util.removeItem(this.tileCacheIndex, tile.url);
	              this.tileCacheIndex.push(tile.url);
	          }
	        }
	    },
	    
	    /**
	     * Method: addToCache
	     *
	     * Parameters:
	     * evt - {Object} Listener argument for the tile's loadend event
	     */
	    addToCache: function(evt) {
	        var tile = evt.object;
	        if (!this.tileCache[tile.url]) {
	            if (!OpenLayers.Element.hasClass(tile.imgDiv, 'olImageLoadError')) {
	                if (this.tileCacheIndex.length >= this.cacheSize) {
	                    delete this.tileCache[this.tileCacheIndex[0]];
	                    this.tileCacheIndex.shift();
	                }
	                this.tileCache[tile.url] = tile.imgDiv;
	                this.tileCacheIndex.push(tile.url);
	            }
	        }
	    },

	    /**
	     * Method: clearTileQueue
	     * Clears the tile queue from tiles of a specific layer
	     *
	     * Parameters:
	     * evt - {Object} Listener argument of the layer's retile event
	     */
	    clearTileQueue: function(evt) {
	        var layer = evt.object;
	        var tileQueue = this.tileQueue[layer.map.id];
	        for (var i=tileQueue.length-1; i>=0; --i) {
	            if (tileQueue[i].layer === layer) {
	                tileQueue.splice(i, 1);
	            }
	        }
	    },
	    
	    /**
	     * Method: destroy
	     */
	    destroy: function() {
	        for (var i=this.maps.length-1; i>=0; --i) {
	            this.removeMap(this.maps[i]);
	        }
	        this.maps = null;
	        this.tileQueue = null;
	        this.tileQueueId = null;
	        this.tileCache = null;
	        this.tileCacheIndex = null;
	        this._destroyed = true;
	    }

	});
	/* ======================================================================
	    OpenLayers/Renderer.js
	   ====================================================================== */

	/* Copyright (c) 2006-2015 by OpenLayers Contributors (see authors.txt for
	 * full list of contributors). Published under the 2-clause BSD license.
	 * See license.txt in the OpenLayers distribution or repository for the
	 * full text of the license. */

	/**
	 * @requires OpenLayers/BaseTypes/Class.js
	 */

	/**
	 * Class: OpenLayers.Renderer 
	 * This is the base class for all renderers.
	 *
	 * This is based on a merger code written by Paul Spencer and Bertil Chapuis.
	 * It is largely composed of virtual functions that are to be implemented
	 * in technology-specific subclasses, but there is some generic code too.
	 * 
	 * The functions that *are* implemented here merely deal with the maintenance
	 *  of the size and extent variables, as well as the cached 'resolution' 
	 *  value. 
	 * 
	 * A note to the user that all subclasses should use getResolution() instead
	 *  of directly accessing this.resolution in order to correctly use the 
	 *  cacheing system.
	 *
	 */
	OpenLayers.Renderer = OpenLayers.Class({

	    /** 
	     * Property: container
	     * {DOMElement} 
	     */
	    container: null,
	    
	    /**
	     * Property: root
	     * {DOMElement}
	     */
	    root: null,

	    /** 
	     * Property: extent
	     * {<OpenLayers.Bounds>}
	     */
	    extent: null,

	    /**
	     * Property: locked
	     * {Boolean} If the renderer is currently in a state where many things
	     *     are changing, the 'locked' property is set to true. This means 
	     *     that renderers can expect at least one more drawFeature event to be
	     *     called with the 'locked' property set to 'true': In some renderers,
	     *     this might make sense to use as a 'only update local information'
	     *     flag. 
	     */  
	    locked: false,
	    
	    /** 
	     * Property: size
	     * {<OpenLayers.Size>} 
	     */
	    size: null,
	    
	    /**
	     * Property: resolution
	     * {Float} cache of current map resolution
	     */
	    resolution: null,
	    
	    /**
	     * Property: map  
	     * {<OpenLayers.Map>} Reference to the map -- this is set in Vector's setMap()
	     */
	    map: null,
	    
	    /**
	     * Property: featureDx
	     * {Number} Feature offset in x direction. Will be calculated for and
	     * applied to the current feature while rendering (see
	     * <calculateFeatureDx>).
	     */
	    featureDx: 0,
	    
	    /**
	     * Constructor: OpenLayers.Renderer 
	     *
	     * Parameters:
	     * containerID - {<String>} 
	     * options - {Object} options for this renderer. See sublcasses for
	     *     supported options.
	     */
	    initialize: function(containerID, options) {
	        this.container = OpenLayers.Util.getElement(containerID);
	        OpenLayers.Util.extend(this, options);
	    },
	    
	    /**
	     * APIMethod: destroy
	     */
	    destroy: function() {
	        this.container = null;
	        this.extent = null;
	        this.size =  null;
	        this.resolution = null;
	        this.map = null;
	    },

	    /**
	     * APIMethod: supported
	     * This should be overridden by specific subclasses
	     * 
	     * Returns:
	     * {Boolean} Whether or not the browser supports the renderer class
	     */
	    supported: function() {
	        return false;
	    },    
	    
	    /**
	     * Method: setExtent
	     * Set the visible part of the layer.
	     *
	     * Resolution has probably changed, so we nullify the resolution 
	     * cache (this.resolution) -- this way it will be re-computed when 
	     * next it is needed.
	     * We nullify the resolution cache (this.resolution) if resolutionChanged
	     * is set to true - this way it will be re-computed on the next
	     * getResolution() request.
	     *
	     * Parameters:
	     * extent - {<OpenLayers.Bounds>}
	     * resolutionChanged - {Boolean}
	     *
	     * Returns:
	     * {Boolean} true to notify the layer that the new extent does not exceed
	     *     the coordinate range, and the features will not need to be redrawn.
	     *     False otherwise.
	     */
	    setExtent: function(extent, resolutionChanged) {
	        this.extent = extent.clone();
	        if (this.map.baseLayer && this.map.baseLayer.wrapDateLine) {
	            var ratio = extent.getWidth() / this.map.getExtent().getWidth(),
	                extent = extent.scale(1 / ratio);
	            this.extent = extent.wrapDateLine(this.map.getMaxExtent()).scale(ratio);
	        }
	        if (resolutionChanged) {
	            this.resolution = null;
	        }
	        return true;
	    },
	    
	    /**
	     * Method: setSize
	     * Sets the size of the drawing surface.
	     * 
	     * Resolution has probably changed, so we nullify the resolution 
	     * cache (this.resolution) -- this way it will be re-computed when 
	     * next it is needed.
	     *
	     * Parameters:
	     * size - {<OpenLayers.Size>} 
	     */
	    setSize: function(size) {
	        this.size = size.clone();
	        this.resolution = null;
	    },
	    
	    /** 
	     * Method: getResolution
	     * Uses cached copy of resolution if available to minimize computing
	     * 
	     * Returns:
	     * {Float} The current map's resolution
	     */
	    getResolution: function() {
	        this.resolution = this.resolution || this.map.getResolution();
	        return this.resolution;
	    },
	    
	    /**
	     * Method: drawFeature
	     * Draw the feature.  The optional style argument can be used
	     * to override the feature's own style.  This method should only
	     * be called from layer.drawFeature().
	     *
	     * Parameters:
	     * feature - {<OpenLayers.Feature.Vector>} 
	     * style - {<Object>}
	     * 
	     * Returns:
	     * {Boolean} true if the feature has been drawn completely, false if not,
	     *     undefined if the feature had no geometry
	     */
	    drawFeature: function(feature, style) {
	        if(style == null) {
	            style = feature.style;
	        }
	        if (feature.geometry) {
	            var bounds = feature.geometry.getBounds();
	            if(bounds) {
	                var worldBounds;
	                if (this.map.baseLayer && this.map.baseLayer.wrapDateLine) {
	                    worldBounds = this.map.getMaxExtent();
	                }
	                if (!bounds.intersectsBounds(this.extent, {worldBounds: worldBounds})) {
	                    style = {display: "none"};
	                } else {
	                    this.calculateFeatureDx(bounds, worldBounds);
	                }
	                var rendered = this.drawGeometry(feature.geometry, style, feature.id);
	                if(style.display != "none" && style.label && rendered !== false) {

	                    var location = feature.geometry.getCentroid(); 
	                    if(style.labelXOffset || style.labelYOffset) {
	                        var xOffset = isNaN(style.labelXOffset) ? 0 : style.labelXOffset;
	                        var yOffset = isNaN(style.labelYOffset) ? 0 : style.labelYOffset;
	                        var res = this.getResolution();
	                        location.move(xOffset*res, yOffset*res);
	                    }
	                    this.drawText(feature.id, style, location);
	                } else {
	                    this.removeText(feature.id);
	                }
	                return rendered;
	            }
	        }
	    },

	    /**
	     * Method: calculateFeatureDx
	     * {Number} Calculates the feature offset in x direction. Looking at the
	     * center of the feature bounds and the renderer extent, we calculate how
	     * many world widths the two are away from each other. This distance is
	     * used to shift the feature as close as possible to the center of the
	     * current enderer extent, which ensures that the feature is visible in the
	     * current viewport.
	     *
	     * Parameters:
	     * bounds - {<OpenLayers.Bounds>} Bounds of the feature
	     * worldBounds - {<OpenLayers.Bounds>} Bounds of the world
	     */
	    calculateFeatureDx: function(bounds, worldBounds) {
	        this.featureDx = 0;
	        if (worldBounds) {
	            var worldWidth = worldBounds.getWidth(),
	                rendererCenterX = (this.extent.left + this.extent.right) / 2,
	                featureCenterX = (bounds.left + bounds.right) / 2,
	                worldsAway = Math.round((featureCenterX - rendererCenterX) / worldWidth);
	            this.featureDx = worldsAway * worldWidth;
	        }
	    },

	    /** 
	     * Method: drawGeometry
	     * 
	     * Draw a geometry.  This should only be called from the renderer itself.
	     * Use layer.drawFeature() from outside the renderer.
	     * virtual function
	     *
	     * Parameters:
	     * geometry - {<OpenLayers.Geometry>} 
	     * style - {Object} 
	     * featureId - {<String>} 
	     */
	    drawGeometry: function(geometry, style, featureId) {},
	        
	    /**
	     * Method: drawText
	     * Function for drawing text labels.
	     * This method is only called by the renderer itself.
	     * 
	     * Parameters: 
	     * featureId - {String}
	     * style -
	     * location - {<OpenLayers.Geometry.Point>}
	     */
	    drawText: function(featureId, style, location) {},

	    /**
	     * Method: removeText
	     * Function for removing text labels.
	     * This method is only called by the renderer itself.
	     * 
	     * Parameters: 
	     * featureId - {String}
	     */
	    removeText: function(featureId) {},
	    
	    /**
	     * Method: clear
	     * Clear all vectors from the renderer.
	     * virtual function.
	     */    
	    clear: function() {},

	    /**
	     * Method: getFeatureIdFromEvent
	     * Returns a feature id from an event on the renderer.  
	     * How this happens is specific to the renderer.  This should be
	     * called from layer.getFeatureFromEvent().
	     * Virtual function.
	     * 
	     * Parameters:
	     * evt - {<OpenLayers.Event>} 
	     *
	     * Returns:
	     * {String} A feature id or undefined.
	     */
	    getFeatureIdFromEvent: function(evt) {},
	    
	    /**
	     * Method: eraseFeatures 
	     * This is called by the layer to erase features
	     * 
	     * Parameters:
	     * features - {Array(<OpenLayers.Feature.Vector>)} 
	     */
	    eraseFeatures: function(features) {
	        if(!(OpenLayers.Util.isArray(features))) {
	            features = [features];
	        }
	        for(var i=0, len=features.length; i<len; ++i) {
	            var feature = features[i];
	            this.eraseGeometry(feature.geometry, feature.id);
	            this.removeText(feature.id);
	        }
	    },
	    
	    /**
	     * Method: eraseGeometry
	     * Remove a geometry from the renderer (by id).
	     * virtual function.
	     * 
	     * Parameters:
	     * geometry - {<OpenLayers.Geometry>} 
	     * featureId - {String}
	     */
	    eraseGeometry: function(geometry, featureId) {},
	    
	    /**
	     * Method: moveRoot
	     * moves this renderer's root to a (different) renderer.
	     * To be implemented by subclasses that require a common renderer root for
	     * feature selection.
	     * 
	     * Parameters:
	     * renderer - {<OpenLayers.Renderer>} target renderer for the moved root
	     */
	    moveRoot: function(renderer) {},

	    /**
	     * Method: getRenderLayerId
	     * Gets the layer that this renderer's output appears on. If moveRoot was
	     * used, this will be different from the id of the layer containing the
	     * features rendered by this renderer.
	     * 
	     * Returns:
	     * {String} the id of the output layer.
	     */
	    getRenderLayerId: function() {
	        return this.container.id;
	    },
	    
	    /**
	     * Method: applyDefaultSymbolizer
	     * 
	     * Parameters:
	     * symbolizer - {Object}
	     * 
	     * Returns:
	     * {Object}
	     */
	    applyDefaultSymbolizer: function(symbolizer) {
	        var result = OpenLayers.Util.extend({},
	            OpenLayers.Renderer.defaultSymbolizer);
	        if(symbolizer.stroke === false) {
	            delete result.strokeWidth;
	            delete result.strokeColor;
	        }
	        if(symbolizer.fill === false) {
	            delete result.fillColor;
	        }
	        OpenLayers.Util.extend(result, symbolizer);
	        return result;
	    },

	    CLASS_NAME: "OpenLayers.Renderer"
	});

	/**
	 * Constant: OpenLayers.Renderer.defaultSymbolizer
	 * {Object} Properties from this symbolizer will be applied to symbolizers
	 *     with missing properties. This can also be used to set a global
	 *     symbolizer default in OpenLayers. To be SLD 1.x compliant, add the
	 *     following code before rendering any vector features:
	 * (code)
	 * OpenLayers.Renderer.defaultSymbolizer = {
	 *     fillColor: "#808080",
	 *     fillOpacity: 1,
	 *     strokeColor: "#000000",
	 *     strokeOpacity: 1,
	 *     strokeWidth: 1,
	 *     pointRadius: 3,
	 *     graphicName: "square"
	 * };
	 * (end)
	 */
	OpenLayers.Renderer.defaultSymbolizer = {
	    fillColor: "#000000",
	    strokeColor: "#000000",
	    strokeWidth: 2,
	    fillOpacity: 1,
	    strokeOpacity: 1,
	    pointRadius: 0,
	    labelAlign: 'cm'
	};
	    


	/**
	 * Constant: OpenLayers.Renderer.symbol
	 * Coordinate arrays for well known (named) symbols.
	 */
	OpenLayers.Renderer.symbol = {
	    "star": [350,75, 379,161, 469,161, 397,215, 423,301, 350,250, 277,301,
	            303,215, 231,161, 321,161, 350,75],
	    "cross": [4,0, 6,0, 6,4, 10,4, 10,6, 6,6, 6,10, 4,10, 4,6, 0,6, 0,4, 4,4,
	            4,0],
	    "x": [0,0, 25,0, 50,35, 75,0, 100,0, 65,50, 100,100, 75,100, 50,65, 25,100, 0,100, 35,50, 0,0],
	    "square": [0,0, 0,1, 1,1, 1,0, 0,0],
	    "triangle": [0,10, 10,10, 5,0, 0,10]
	};
	/* ======================================================================
	    OpenLayers/Renderer/Canvas.js
	   ====================================================================== */

	/* Copyright (c) 2006-2015 by OpenLayers Contributors (see authors.txt for
	 * full list of contributors). Published under the 2-clause BSD license.
	 * See license.txt in the OpenLayers distribution or repository for the
	 * full text of the license. */

	/**
	 * @requires OpenLayers/Renderer.js
	 */

	/**
	 * Class: OpenLayers.Renderer.Canvas 
	 * A renderer based on the 2D 'canvas' drawing element.
	 * 
	 * Inherits:
	 *  - <OpenLayers.Renderer>
	 */
	OpenLayers.Renderer.Canvas = OpenLayers.Class(OpenLayers.Renderer, {
	    
	    /**
	     * APIProperty: hitDetection
	     * {Boolean} Allow for hit detection of features.  Default is true.
	     */
	    hitDetection: true,
	    
	    /**
	     * Property: hitOverflow
	     * {Number} The method for converting feature identifiers to color values
	     *     supports 16777215 sequential values.  Two features cannot be 
	     *     predictably detected if their identifiers differ by more than this
	     *     value.  The hitOverflow allows for bigger numbers (but the 
	     *     difference in values is still limited).
	     */
	    hitOverflow: 0,

	    /**
	     * Property: canvas
	     * {Canvas} The canvas context object.
	     */
	    canvas: null, 
	    
	    /**
	     * Property: features
	     * {Object} Internal object of feature/style pairs for use in redrawing the layer.
	     */
	    features: null,
	    
	    /**
	     * Property: pendingRedraw
	     * {Boolean} The renderer needs a redraw call to render features added while
	     *     the renderer was locked.
	     */
	    pendingRedraw: false,
	    
	    /**
	     * Property: cachedSymbolBounds
	     * {Object} Internal cache of calculated symbol extents.
	     */
	    cachedSymbolBounds: {},
	    
	    /**
	     * Constructor: OpenLayers.Renderer.Canvas
	     *
	     * Parameters:
	     * containerID - {<String>}
	     * options - {Object} Optional properties to be set on the renderer.
	     */
	    initialize: function(containerID, options) {
	        OpenLayers.Renderer.prototype.initialize.apply(this, arguments);
	        this.root = document.createElement("canvas");
	        this.container.appendChild(this.root);
	        this.canvas = this.root.getContext("2d");
	        this._clearRectId = OpenLayers.Util.createUniqueID();
	        this.features = {};
	        if (this.hitDetection) {
	            this.hitCanvas = document.createElement("canvas");
	            this.hitContext = this.hitCanvas.getContext("2d");
	        }
	    },
	    
	    /**
	     * Method: setExtent
	     * Set the visible part of the layer.
	     *
	     * Parameters:
	     * extent - {<OpenLayers.Bounds>}
	     * resolutionChanged - {Boolean}
	     *
	     * Returns:
	     * {Boolean} true to notify the layer that the new extent does not exceed
	     *     the coordinate range, and the features will not need to be redrawn.
	     *     False otherwise.
	     */
	    setExtent: function() {
	        OpenLayers.Renderer.prototype.setExtent.apply(this, arguments);
	        // always redraw features
	        return false;
	    },
	    
	    /** 
	     * Method: eraseGeometry
	     * Erase a geometry from the renderer. Because the Canvas renderer has
	     *     'memory' of the features that it has drawn, we have to remove the
	     *     feature so it doesn't redraw.   
	     * 
	     * Parameters:
	     * geometry - {<OpenLayers.Geometry>}
	     * featureId - {String}
	     */
	    eraseGeometry: function(geometry, featureId) {
	        this.eraseFeatures(this.features[featureId][0]);
	    },

	    /**
	     * APIMethod: supported
	     * 
	     * Returns:
	     * {Boolean} Whether or not the browser supports the renderer class
	     */
	    supported: function() {
	        return OpenLayers.CANVAS_SUPPORTED;
	    },    
	    
	    /**
	     * Method: setSize
	     * Sets the size of the drawing surface.
	     *
	     * Once the size is updated, redraw the canvas.
	     *
	     * Parameters:
	     * size - {<OpenLayers.Size>} 
	     */
	    setSize: function(size) {
	        this.size = size.clone();
	        var root = this.root;
	        root.style.width = size.w + "px";
	        root.style.height = size.h + "px";
	        root.width = size.w;
	        root.height = size.h;
	        this.resolution = null;
	        if (this.hitDetection) {
	            var hitCanvas = this.hitCanvas;
	            hitCanvas.style.width = size.w + "px";
	            hitCanvas.style.height = size.h + "px";
	            hitCanvas.width = size.w;
	            hitCanvas.height = size.h;
	        }
	    },
	    
	    /**
	     * Method: drawFeature
	     * Draw the feature. Stores the feature in the features list,
	     * then redraws the layer. 
	     *
	     * Parameters:
	     * feature - {<OpenLayers.Feature.Vector>} 
	     * style - {<Object>} 
	     *
	     * Returns:
	     * {Boolean} The feature has been drawn completely.  If the feature has no
	     *     geometry, undefined will be returned.  If the feature is not rendered
	     *     for other reasons, false will be returned.
	     */
	    drawFeature: function(feature, style) {
	        var rendered;
	        if (feature.geometry) {
	            style = this.applyDefaultSymbolizer(style || feature.style);
	            // don't render if display none or feature outside extent
	            var bounds = feature.geometry.getBounds();

	            var worldBounds;
	            if (this.map.baseLayer && this.map.baseLayer.wrapDateLine) {
	                worldBounds = this.map.getMaxExtent();
	            }

	            var intersects = bounds && bounds.intersectsBounds(this.extent, {worldBounds: worldBounds});

	            rendered = (style.display !== "none") && !!bounds && intersects;
	            if (rendered) {
	                // keep track of what we have rendered for redraw
	                this.features[feature.id] = [feature, style];
	            }
	            else {
	                // remove from features tracked for redraw
	                delete(this.features[feature.id]);
	            }
	            this.pendingRedraw = true;
	        }
	        if (this.pendingRedraw && !this.locked) {
	            this.redraw();
	            this.pendingRedraw = false;
	        }
	        return rendered;
	    },

	    /** 
	     * Method: drawGeometry
	     * Used when looping (in redraw) over the features; draws
	     * the canvas. 
	     *
	     * Parameters:
	     * geometry - {<OpenLayers.Geometry>} 
	     * style - {Object} 
	     */
	    drawGeometry: function(geometry, style, featureId) {
	        var className = geometry.CLASS_NAME;
	        if ((className == "OpenLayers.Geometry.Collection") ||
	            (className == "OpenLayers.Geometry.MultiPoint") ||
	            (className == "OpenLayers.Geometry.MultiLineString") ||
	            (className == "OpenLayers.Geometry.MultiPolygon")) {
	            var worldBounds = (this.map.baseLayer && this.map.baseLayer.wrapDateLine) && this.map.getMaxExtent();
	            for (var i = 0; i < geometry.components.length; i++) {
	                this.calculateFeatureDx(geometry.components[i].getBounds(), worldBounds);
	                this.drawGeometry(geometry.components[i], style, featureId);
	            }
	            return;
	        }
	        switch (geometry.CLASS_NAME) {
	            case "OpenLayers.Geometry.Point":
	                this.drawPoint(geometry, style, featureId);
	                break;
	            case "OpenLayers.Geometry.LineString":
	                this.drawLineString(geometry, style, featureId);
	                break;
	            case "OpenLayers.Geometry.LinearRing":
	                this.drawLinearRing(geometry, style, featureId);
	                break;
	            case "OpenLayers.Geometry.Polygon":
	                this.drawPolygon(geometry, style, featureId);
	                break;
	            default:
	                break;
	        }
	    },

	    /**
	     * Method: drawExternalGraphic
	     * Called to draw External graphics. 
	     * 
	     * Parameters: 
	     * geometry - {<OpenLayers.Geometry>}
	     * style    - {Object}
	     * featureId - {String}
	     */ 
	    drawExternalGraphic: function(geometry, style, featureId) {
	        var img = new Image();

	        var title = style.title || style.graphicTitle;        
	        if (title) {
	            img.title = title;           
	        }

	        var width = style.graphicWidth || style.graphicHeight;
	        var height = style.graphicHeight || style.graphicWidth;
	        width = width ? width : style.pointRadius * 2;
	        height = height ? height : style.pointRadius * 2;
	        var xOffset = (style.graphicXOffset != undefined) ?
	           style.graphicXOffset : -(0.5 * width);
	        var yOffset = (style.graphicYOffset != undefined) ?
	           style.graphicYOffset : -(0.5 * height);
	        var _clearRectId = this._clearRectId;

	        var opacity = style.graphicOpacity || style.fillOpacity;
	        
	        var onLoad = function() {
	            if(!this.features[featureId] ||
	                                     _clearRectId !== this._clearRectId) {
	                return;
	            }
	            var pt = this.getLocalXY(geometry);
	            var p0 = pt[0];
	            var p1 = pt[1];
	            if(!isNaN(p0) && !isNaN(p1)) {
	                var x = (p0 + xOffset) | 0;
	                var y = (p1 + yOffset) | 0;
	                var canvas = this.canvas;
	                canvas.globalAlpha = opacity;
	                var factor = OpenLayers.Renderer.Canvas.drawImageScaleFactor ||
	                    (OpenLayers.Renderer.Canvas.drawImageScaleFactor =
	                        /android 2.1/.test(navigator.userAgent.toLowerCase()) ?
	                            // 320 is the screen width of the G1 phone, for
	                            // which drawImage works out of the box.
	                            320 / window.screen.width : 1
	                    );
	                canvas.drawImage(
	                    img, x*factor, y*factor, width*factor, height*factor
	                );
	                if (this.hitDetection) {
	                    this.setHitContextStyle("fill", featureId);
	                    this.hitContext.fillRect(x, y, width, height);
	                }
	            }
	        };
	        img.onload = OpenLayers.Function.bind(onLoad, this);
	        img.src = style.externalGraphic;
	        if (img.complete) {
	            img.onload();
	            img.onload = null;
	        }
	    },

	    /**
	     * Method: drawNamedSymbol
	     * Called to draw Well Known Graphic Symbol Name. 
	     * This method is only called by the renderer itself.
	     * 
	     * Parameters: 
	     * geometry - {<OpenLayers.Geometry>}
	     * style    - {Object}
	     * featureId - {String}
	     */ 
	    drawNamedSymbol: function(geometry, style, featureId) {
	        var x, y, cx, cy, i, symbolBounds, scaling, angle;
	        var unscaledStrokeWidth;
	        var deg2rad = Math.PI / 180.0;
	        
	        var symbol = OpenLayers.Renderer.symbol[style.graphicName];
	         
	        if (!symbol) {
	            throw new Error(style.graphicName + ' is not a valid symbol name');
	        }
	        
	        if (!symbol.length || symbol.length < 2) return;
	        
	        var pt = this.getLocalXY(geometry);
	        var p0 = pt[0];
	        var p1 = pt[1];
	       
	        if (isNaN(p0) || isNaN(p1)) return;
	        
	        // Use rounded line caps
	        this.canvas.lineCap = "round";
	        this.canvas.lineJoin = "round";
	        
	        if (this.hitDetection) {
	            this.hitContext.lineCap = "round";
	            this.hitContext.lineJoin = "round";
	        }
	        
	        // Scale and rotate symbols, using precalculated bounds whenever possible.
	        if (style.graphicName in this.cachedSymbolBounds) {
	            symbolBounds = this.cachedSymbolBounds[style.graphicName];
	        } else {
	            symbolBounds = new OpenLayers.Bounds();
	            for(i = 0; i < symbol.length; i+=2) {
	                symbolBounds.extend(new OpenLayers.LonLat(symbol[i], symbol[i+1]));
	            }
	            this.cachedSymbolBounds[style.graphicName] = symbolBounds;
	        }
	        
	        // Push symbol scaling, translation and rotation onto the transformation stack in reverse order.
	        // Don't forget to apply all canvas transformations to the hitContext canvas as well(!)
	        this.canvas.save();
	        if (this.hitDetection) { this.hitContext.save(); }
	        
	        // Step 3: place symbol at the desired location
	        this.canvas.translate(p0,p1);
	        if (this.hitDetection) { this.hitContext.translate(p0,p1); }
	        
	        // Step 2a. rotate the symbol if necessary
	        angle = deg2rad * style.rotation; // will be NaN when style.rotation is undefined.
	        if (!isNaN(angle)) {
	            this.canvas.rotate(angle);
	            if (this.hitDetection) { this.hitContext.rotate(angle); }
	        }
	                
	        // // Step 2: scale symbol such that pointRadius equals half the maximum symbol dimension.
	        scaling = 2.0 * style.pointRadius / Math.max(symbolBounds.getWidth(), symbolBounds.getHeight());
	        this.canvas.scale(scaling,scaling);
	        if (this.hitDetection) { this.hitContext.scale(scaling,scaling); }
	        
	        // Step 1: center the symbol at the origin        
	        cx = symbolBounds.getCenterLonLat().lon;
	        cy = symbolBounds.getCenterLonLat().lat;
	        this.canvas.translate(-cx,-cy);
	        if (this.hitDetection) { this.hitContext.translate(-cx,-cy); }        

	        // Don't forget to scale stroke widths, because they are affected by canvas scale transformations as well(!)
	        // Alternative: scale symbol coordinates manually, so stroke width scaling is not needed anymore.
	        unscaledStrokeWidth = style.strokeWidth;
	        style.strokeWidth = unscaledStrokeWidth / scaling;
	            
	        if (style.fill !== false) {
	            this.setCanvasStyle("fill", style);
	            this.canvas.beginPath();
	            for (i=0; i<symbol.length; i=i+2) {
	                x = symbol[i];
	                y = symbol[i+1];
	                if (i == 0) this.canvas.moveTo(x,y);
	                this.canvas.lineTo(x,y);
	            }
	            this.canvas.closePath();
	            this.canvas.fill();

	            if (this.hitDetection) {
	                this.setHitContextStyle("fill", featureId, style);
	                this.hitContext.beginPath();
	                for (i=0; i<symbol.length; i=i+2) {
	                    x = symbol[i];
	                    y = symbol[i+1];
	                    if (i == 0) this.canvas.moveTo(x,y);
	                    this.hitContext.lineTo(x,y);
	                }
	                this.hitContext.closePath();
	                this.hitContext.fill();
	            }
	        }  
	        
	        if (style.stroke !== false) {
	            this.setCanvasStyle("stroke", style);
	            this.canvas.beginPath();
	            for (i=0; i<symbol.length; i=i+2) {
	                x = symbol[i];
	                y = symbol[i+1];
	                if (i == 0) this.canvas.moveTo(x,y);
	                this.canvas.lineTo(x,y);
	            }
	            this.canvas.closePath();
	            this.canvas.stroke();
	            
	            
	            if (this.hitDetection) {
	                this.setHitContextStyle("stroke", featureId, style, scaling);
	                this.hitContext.beginPath();
	                for (i=0; i<symbol.length; i=i+2) {
	                    x = symbol[i];
	                    y = symbol[i+1];
	                    if (i == 0) this.hitContext.moveTo(x,y);
	                    this.hitContext.lineTo(x,y);
	                }
	                this.hitContext.closePath();
	                this.hitContext.stroke();
	            }
	            
	        }
	        
	        style.strokeWidth = unscaledStrokeWidth;
	        this.canvas.restore();
	        if (this.hitDetection) { this.hitContext.restore(); }
	        this.setCanvasStyle("reset");  
	    },

	    /**
	     * Method: setCanvasStyle
	     * Prepare the canvas for drawing by setting various global settings.
	     *
	     * Parameters:
	     * type - {String} one of 'stroke', 'fill', or 'reset'
	     * style - {Object} Symbolizer hash
	     */
	    setCanvasStyle: function(type, style) {
	        if (type === "fill") {     
	            this.canvas.globalAlpha = style['fillOpacity'];
	            this.canvas.fillStyle = style['fillColor'];
	        } else if (type === "stroke") {  
	            this.canvas.globalAlpha = style['strokeOpacity'];
	            this.canvas.strokeStyle = style['strokeColor'];
	            this.canvas.lineWidth = style['strokeWidth'];
	        } else {
	            this.canvas.globalAlpha = 0;
	            this.canvas.lineWidth = 1;
	        }
	    },
	    
	    /**
	     * Method: featureIdToHex
	     * Convert a feature ID string into an RGB hex string.
	     *
	     * Parameters:
	     * featureId - {String} Feature id
	     *
	     * Returns:
	     * {String} RGB hex string.
	     */
	    featureIdToHex: function(featureId) {
	        var id = Number(featureId.split("_").pop()) + 1; // zero for no feature
	        if (id >= 16777216) {
	            this.hitOverflow = id - 16777215;
	            id = id % 16777216 + 1;
	        }
	        var hex = "000000" + id.toString(16);
	        var len = hex.length;
	        hex = "#" + hex.substring(len-6, len);
	        return hex;
	    },
	    
	    /**
	     * Method: setHitContextStyle
	     * Prepare the hit canvas for drawing by setting various global settings.
	     *
	     * Parameters:
	     * type - {String} one of 'stroke', 'fill', or 'reset'
	     * featureId - {String} The feature id.
	     * symbolizer - {<OpenLayers.Symbolizer>} The symbolizer.
	     */
	    setHitContextStyle: function(type, featureId, symbolizer, strokeScaling) {
	        var hex = this.featureIdToHex(featureId);
	        if (type == "fill") {
	            this.hitContext.globalAlpha = 1.0;
	            this.hitContext.fillStyle = hex;
	        } else if (type == "stroke") {  
	            this.hitContext.globalAlpha = 1.0;
	            this.hitContext.strokeStyle = hex;
	            // bump up stroke width to deal with antialiasing. If strokeScaling is defined, we're rendering a symbol 
	            // on a transformed canvas, so the antialias width bump has to scale as well.
	            if (typeof strokeScaling === "undefined") {
	                this.hitContext.lineWidth = symbolizer.strokeWidth + 2;
	            } else {
	                if (!isNaN(strokeScaling)) { this.hitContext.lineWidth = symbolizer.strokeWidth + 2.0 / strokeScaling; }
	            }
	        } else {
	            this.hitContext.globalAlpha = 0;
	            this.hitContext.lineWidth = 1;
	        }
	    },

	    /**
	     * Method: drawPoint
	     * This method is only called by the renderer itself.
	     * 
	     * Parameters: 
	     * geometry - {<OpenLayers.Geometry>}
	     * style    - {Object}
	     * featureId - {String}
	     */ 
	    drawPoint: function(geometry, style, featureId) {
	        if(style.graphic !== false) {
	            if(style.externalGraphic) {
	                this.drawExternalGraphic(geometry, style, featureId);
	            } else if (style.graphicName && (style.graphicName != "circle")) {
	                this.drawNamedSymbol(geometry, style, featureId);
	            } else {
	                var pt = this.getLocalXY(geometry);
	                var p0 = pt[0];
	                var p1 = pt[1];
	                if(!isNaN(p0) && !isNaN(p1)) {
	                    var twoPi = Math.PI*2;
	                    var radius = style.pointRadius;
	                    if(style.fill !== false) {
	                        this.setCanvasStyle("fill", style);
	                        this.canvas.beginPath();
	                        this.canvas.arc(p0, p1, radius, 0, twoPi, true);
	                        this.canvas.fill();
	                        if (this.hitDetection) {
	                            this.setHitContextStyle("fill", featureId, style);
	                            this.hitContext.beginPath();
	                            this.hitContext.arc(p0, p1, radius, 0, twoPi, true);
	                            this.hitContext.fill();
	                        }
	                    }

	                    if(style.stroke !== false) {
	                        this.setCanvasStyle("stroke", style);
	                        this.canvas.beginPath();
	                        this.canvas.arc(p0, p1, radius, 0, twoPi, true);
	                        this.canvas.stroke();
	                        if (this.hitDetection) {
	                            this.setHitContextStyle("stroke", featureId, style);
	                            this.hitContext.beginPath();
	                            this.hitContext.arc(p0, p1, radius, 0, twoPi, true);
	                            this.hitContext.stroke();
	                        }
	                        this.setCanvasStyle("reset");
	                    }
	                }
	            }
	        }
	    },
	    
	    /**
	     * Method: drawLineString
	     * This method is only called by the renderer itself.
	     * 
	     * Parameters: 
	     * geometry - {<OpenLayers.Geometry>}
	     * style    - {Object}
	     * featureId - {String}
	     */ 
	    drawLineString: function(geometry, style, featureId) {
	        style = OpenLayers.Util.applyDefaults({fill: false}, style);
	        this.drawLinearRing(geometry, style, featureId);
	    },    
	    
	    /**
	     * Method: drawLinearRing
	     * This method is only called by the renderer itself.
	     * 
	     * Parameters: 
	     * geometry - {<OpenLayers.Geometry>}
	     * style    - {Object}
	     * featureId - {String}
	     */ 
	    drawLinearRing: function(geometry, style, featureId) {
	        if (style.fill !== false) {
	            this.setCanvasStyle("fill", style);
	            this.renderPath(this.canvas, geometry, style, featureId, "fill");
	            if (this.hitDetection) {
	                this.setHitContextStyle("fill", featureId, style);
	                this.renderPath(this.hitContext, geometry, style, featureId, "fill");
	            }
	        }
	        if (style.stroke !== false) {
	            this.setCanvasStyle("stroke", style);
	            this.renderPath(this.canvas, geometry, style, featureId, "stroke");
	            if (this.hitDetection) {
	                this.setHitContextStyle("stroke", featureId, style);
	                this.renderPath(this.hitContext, geometry, style, featureId, "stroke");
	            }
	        }
	        this.setCanvasStyle("reset");
	    },
	    
	    /**
	     * Method: renderPath
	     * Render a path with stroke and optional fill.
	     */
	    renderPath: function(context, geometry, style, featureId, type) {
	        var components = geometry.components;
	        var len = components.length;
	        context.beginPath();
	        var start = this.getLocalXY(components[0]);
	        var x = start[0];
	        var y = start[1];
	        if (!isNaN(x) && !isNaN(y)) {
	            context.moveTo(start[0], start[1]);
	            for (var i=1; i<len; ++i) {
	                var pt = this.getLocalXY(components[i]);
	                context.lineTo(pt[0], pt[1]);
	            }
	            if (type === "fill") {
	                context.fill();
	            } else {
	                context.stroke();
	            }
	        }
	    },
	    
	    /**
	     * Method: drawPolygon
	     * This method is only called by the renderer itself.
	     * 
	     * Parameters: 
	     * geometry - {<OpenLayers.Geometry>}
	     * style    - {Object}
	     * featureId - {String}
	     */ 
	    drawPolygon: function(geometry, style, featureId) {
	        var components = geometry.components;
	        var len = components.length;
	        this.drawLinearRing(components[0], style, featureId);
	        // erase inner rings
	        for (var i=1; i<len; ++i) {
	            /** 
	             * Note that this is overly aggressive.  Here we punch holes through 
	             * all previously rendered features on the same canvas.  A better 
	             * solution for polygons with interior rings would be to draw the 
	             * polygon on a sketch canvas first.  We could erase all holes 
	             * there and then copy the drawing to the layer canvas. 
	             * TODO: http://trac.osgeo.org/openlayers/ticket/3130 
	             */
	            this.canvas.globalCompositeOperation = "destination-out";
	            if (this.hitDetection) {
	                this.hitContext.globalCompositeOperation = "destination-out";
	            }
	            this.drawLinearRing(
	                components[i], 
	                OpenLayers.Util.applyDefaults({stroke: false, fillOpacity: 1.0}, style),
	                featureId
	            );
	            this.canvas.globalCompositeOperation = "source-over";
	            if (this.hitDetection) {
	                this.hitContext.globalCompositeOperation = "source-over";
	            }
	            this.drawLinearRing(
	                components[i], 
	                OpenLayers.Util.applyDefaults({fill: false}, style),
	                featureId
	            );
	        }
	    },
	    
	    /**
	     * Method: drawText
	     * This method is only called by the renderer itself.
	     *
	     * Parameters:
	     * location - {<OpenLayers.Point>}
	     * style    - {Object}
	     */
	    drawText: function(location, style) {
	        var pt = this.getLocalXY(location);

	        this.setCanvasStyle("reset");
	        this.canvas.fillStyle = style.fontColor;
	        this.canvas.globalAlpha = style.fontOpacity || 1.0;
	        var fontStyle = [style.fontStyle ? style.fontStyle : "normal",
	                         "normal", // "font-variant" not supported
	                         style.fontWeight ? style.fontWeight : "normal",
	                         style.fontSize ? style.fontSize : "1em",
	                         style.fontFamily ? style.fontFamily : "sans-serif"].join(" ");
	        var labelRows = style.label.split('\n');
	        var numRows = labelRows.length;
	        if (this.canvas.fillText) {
	            // HTML5
	            this.canvas.font = fontStyle;
	            this.canvas.textAlign =
	                OpenLayers.Renderer.Canvas.LABEL_ALIGN[style.labelAlign[0]] ||
	                "center";
	            this.canvas.textBaseline =
	                OpenLayers.Renderer.Canvas.LABEL_ALIGN[style.labelAlign[1]] ||
	                "middle";
	            var vfactor =
	                OpenLayers.Renderer.Canvas.LABEL_FACTOR[style.labelAlign[1]];
	            if (vfactor == null) {
	                vfactor = -.5;
	            }
	            var lineHeight =
	                this.canvas.measureText('Mg').height ||
	                this.canvas.measureText('xx').width;
	            pt[1] += lineHeight*vfactor*(numRows-1);
	            for (var i = 0; i < numRows; i++) {
	                if (style.labelOutlineWidth) {
	                    this.canvas.save();
	                    this.canvas.globalAlpha = style.labelOutlineOpacity || style.fontOpacity || 1.0;
	                    this.canvas.strokeStyle = style.labelOutlineColor;
	                    this.canvas.lineWidth = style.labelOutlineWidth;
	                    this.canvas.strokeText(labelRows[i], pt[0], pt[1] + (lineHeight*i) + 1);
	                    this.canvas.restore();
	                }
	                this.canvas.fillText(labelRows[i], pt[0], pt[1] + (lineHeight*i));
	            }
	        } else if (this.canvas.mozDrawText) {
	            // Mozilla pre-Gecko1.9.1 (<FF3.1)
	            this.canvas.mozTextStyle = fontStyle;
	            // No built-in text alignment, so we measure and adjust the position
	            var hfactor =
	                OpenLayers.Renderer.Canvas.LABEL_FACTOR[style.labelAlign[0]];
	            if (hfactor == null) {
	                hfactor = -.5;
	            }
	            var vfactor =
	                OpenLayers.Renderer.Canvas.LABEL_FACTOR[style.labelAlign[1]];
	            if (vfactor == null) {
	                vfactor = -.5;
	            }
	            var lineHeight = this.canvas.mozMeasureText('xx');
	            pt[1] += lineHeight*(1 + (vfactor*numRows));
	            for (var i = 0; i < numRows; i++) {
	                var x = pt[0] + (hfactor*this.canvas.mozMeasureText(labelRows[i]));
	                var y = pt[1] + (i*lineHeight);
	                this.canvas.translate(x, y);
	                this.canvas.mozDrawText(labelRows[i]);
	                this.canvas.translate(-x, -y);
	            }
	        }
	        this.setCanvasStyle("reset");
	    },
	    
	    /**
	     * Method: getLocalXY
	     * transform geographic xy into pixel xy
	     *
	     * Parameters: 
	     * point - {<OpenLayers.Geometry.Point>}
	     */
	    getLocalXY: function(point) {
	        var resolution = this.getResolution();
	        var extent = this.extent;
	        var x = ((point.x - this.featureDx) / resolution + (-extent.left / resolution));
	        var y = ((extent.top / resolution) - point.y / resolution);
	        return [x, y];
	    },

	    /**
	     * Method: clear
	     * Clear all vectors from the renderer.
	     */    
	    clear: function() {
	        this.clearCanvas();
	        this.features = {};
	    },

	    /**
	     * Method: clearCanvas
	     * Clear the canvas element of the renderer.
	     */    
	    clearCanvas: function() {
	        var height = this.root.height;
	        var width = this.root.width;
	        this.canvas.clearRect(0, 0, width, height);
	        this._clearRectId = OpenLayers.Util.createUniqueID();
	        if (this.hitDetection) {
	            this.hitContext.clearRect(0, 0, width, height);
	        }
	    },

	    /**
	     * Method: getFeatureIdFromEvent
	     * Returns a feature id from an event on the renderer.  
	     * 
	     * Parameters:
	     * evt - {<OpenLayers.Event>} 
	     *
	     * Returns:
	     * {<OpenLayers.Feature.Vector} A feature or undefined.  This method returns a 
	     *     feature instead of a feature id to avoid an unnecessary lookup on the
	     *     layer.
	     */
	    getFeatureIdFromEvent: function(evt) {
	        var featureId, feature;
	        
	        if (this.hitDetection && this.root.style.display !== "none") {
	            // this dragging check should go in the feature handler
	            if (!this.map.dragging) {
	                var xy = evt.xy;
	                var x = xy.x | 0;
	                var y = xy.y | 0;
	                var data = this.hitContext.getImageData(x, y, 1, 1).data;
	                if (data[3] === 255) { // antialiased
	                    var id = data[2] + (256 * (data[1] + (256 * data[0])));
	                    if (id) {
	                        featureId = "OpenLayers_Feature_Vector_" + (id - 1 + this.hitOverflow);
	                        try {
	                            feature = this.features[featureId][0];
	                        } catch(err) {
	                            // Because of antialiasing on the canvas, when the hit location is at a point where the edge of
	                            // one symbol intersects the interior of another symbol, a wrong hit color (and therefore id) results.
	                            // todo: set Antialiasing = 'off' on the hitContext as soon as browsers allow it.
	                        }
	                    }
	                }
	            }
	        }
	        return feature;
	    },
	    
	    /**
	     * Method: eraseFeatures 
	     * This is called by the layer to erase features; removes the feature from
	     *     the list, then redraws the layer.
	     * 
	     * Parameters:
	     * features - {Array(<OpenLayers.Feature.Vector>)} 
	     */
	    eraseFeatures: function(features) {
	        if(!(OpenLayers.Util.isArray(features))) {
	            features = [features];
	        }
	        for(var i=0; i<features.length; ++i) {
	            delete this.features[features[i].id];
	        }
	        this.redraw();
	    },

	    /**
	     * Method: redraw
	     * The real 'meat' of the function: any time things have changed,
	     *     redraw() can be called to loop over all the data and (you guessed
	     *     it) redraw it.  Unlike Elements-based Renderers, we can't interact
	     *     with things once they're drawn, to remove them, for example, so
	     *     instead we have to just clear everything and draw from scratch.
	     */
	    redraw: function() {
	        if (!this.locked) {
	            this.clearCanvas();
	            var labelMap = [];
	            var feature, geometry, style;
	            var worldBounds = (this.map.baseLayer && this.map.baseLayer.wrapDateLine) && this.map.getMaxExtent();
	            for (var id in this.features) {
	                if (!this.features.hasOwnProperty(id)) { continue; }
	                feature = this.features[id][0];
	                geometry = feature.geometry;
	                this.calculateFeatureDx(geometry.getBounds(), worldBounds);
	                style = this.features[id][1];
	                this.drawGeometry(geometry, style, feature.id);
	                if(style.label) {
	                    labelMap.push([feature, style]);
	                }
	            }
	            var item;
	            for (var i=0, len=labelMap.length; i<len; ++i) {
	                item = labelMap[i];
	                this.drawText(item[0].geometry.getCentroid(), item[1]);
	            }
	        }    
	    },

	    CLASS_NAME: "OpenLayers.Renderer.Canvas"
	});

	/**
	 * Constant: OpenLayers.Renderer.Canvas.LABEL_ALIGN
	 * {Object}
	 */
	OpenLayers.Renderer.Canvas.LABEL_ALIGN = {
	    "l": "left",
	    "r": "right",
	    "t": "top",
	    "b": "bottom"
	};

	/**
	 * Constant: OpenLayers.Renderer.Canvas.LABEL_FACTOR
	 * {Object}
	 */
	OpenLayers.Renderer.Canvas.LABEL_FACTOR = {
	    "l": 0,
	    "r": -1,
	    "t": 0,
	    "b": -1
	};

	/**
	 * Constant: OpenLayers.Renderer.Canvas.drawImageScaleFactor
	 * {Number} Scale factor to apply to the canvas drawImage arguments. This
	 *     is always 1 except for Android 2.1 devices, to work around
	 *     http://code.google.com/p/android/issues/detail?id=5141.
	 */
	OpenLayers.Renderer.Canvas.drawImageScaleFactor = null;
	/* ======================================================================
	    OpenLayers/Renderer/Elements.js
	   ====================================================================== */

	/* Copyright (c) 2006-2015 by OpenLayers Contributors (see authors.txt for
	 * full list of contributors). Published under the 2-clause BSD license.
	 * See license.txt in the OpenLayers distribution or repository for the
	 * full text of the license. */

	/**
	 * @requires OpenLayers/Renderer.js
	 */

	/**
	 * Class: OpenLayers.ElementsIndexer
	 * This class takes care of figuring out which order elements should be
	 *     placed in the DOM based on given indexing methods. 
	 */
	OpenLayers.ElementsIndexer = OpenLayers.Class({
	   
	    /**
	     * Property: maxZIndex
	     * {Integer} This is the largest-most z-index value for a node
	     *     contained within the indexer.
	     */
	    maxZIndex: null,
	    
	    /**
	     * Property: order
	     * {Array<String>} This is an array of node id's stored in the
	     *     order that they should show up on screen. Id's higher up in the
	     *     array (higher array index) represent nodes with higher z-indeces.
	     */
	    order: null, 
	    
	    /**
	     * Property: indices
	     * {Object} This is a hash that maps node ids to their z-index value
	     *     stored in the indexer. This is done to make finding a nodes z-index 
	     *     value O(1).
	     */
	    indices: null,
	    
	    /**
	     * Property: compare
	     * {Function} This is the function used to determine placement of
	     *     of a new node within the indexer. If null, this defaults to to
	     *     the Z_ORDER_DRAWING_ORDER comparison method.
	     */
	    compare: null,
	    
	    /**
	     * APIMethod: initialize
	     * Create a new indexer with 
	     * 
	     * Parameters:
	     * yOrdering - {Boolean} Whether to use y-ordering.
	     */
	    initialize: function(yOrdering) {

	        this.compare = yOrdering ? 
	            OpenLayers.ElementsIndexer.IndexingMethods.Z_ORDER_Y_ORDER :
	            OpenLayers.ElementsIndexer.IndexingMethods.Z_ORDER_DRAWING_ORDER;

	        this.clear();
	    },
	    
	    /**
	     * APIMethod: insert
	     * Insert a new node into the indexer. In order to find the correct 
	     *     positioning for the node to be inserted, this method uses a binary 
	     *     search. This makes inserting O(log(n)). 
	     * 
	     * Parameters:
	     * newNode - {DOMElement} The new node to be inserted.
	     * 
	     * Returns
	     * {DOMElement} the node before which we should insert our newNode, or
	     *     null if newNode can just be appended.
	     */
	    insert: function(newNode) {
	        // If the node is known to the indexer, remove it so we can
	        // recalculate where it should go.
	        if (this.exists(newNode)) {
	            this.remove(newNode);
	        }
	        
	        var nodeId = newNode.id;
	        
	        this.determineZIndex(newNode);       

	        var leftIndex = -1;
	        var rightIndex = this.order.length;
	        var middle;

	        while (rightIndex - leftIndex > 1) {
	            middle = parseInt((leftIndex + rightIndex) / 2);
	            
	            var placement = this.compare(this, newNode,
	                OpenLayers.Util.getElement(this.order[middle]));
	            
	            if (placement > 0) {
	                leftIndex = middle;
	            } else {
	                rightIndex = middle;
	            } 
	        }
	        
	        this.order.splice(rightIndex, 0, nodeId);
	        this.indices[nodeId] = this.getZIndex(newNode);
	        
	        // If the new node should be before another in the index
	        // order, return the node before which we have to insert the new one;
	        // else, return null to indicate that the new node can be appended.
	        return this.getNextElement(rightIndex);
	    },
	    
	    /**
	     * APIMethod: remove
	     * 
	     * Parameters:
	     * node - {DOMElement} The node to be removed.
	     */
	    remove: function(node) {
	        var nodeId = node.id;
	        var arrayIndex = OpenLayers.Util.indexOf(this.order, nodeId);
	        if (arrayIndex >= 0) {
	            // Remove it from the order array, as well as deleting the node
	            // from the indeces hash.
	            this.order.splice(arrayIndex, 1);
	            delete this.indices[nodeId];
	            
	            // Reset the maxium z-index based on the last item in the 
	            // order array.
	            if (this.order.length > 0) {
	                var lastId = this.order[this.order.length - 1];
	                this.maxZIndex = this.indices[lastId];
	            } else {
	                this.maxZIndex = 0;
	            }
	        }
	    },
	    
	    /**
	     * APIMethod: clear
	     */
	    clear: function() {
	        this.order = [];
	        this.indices = {};
	        this.maxZIndex = 0;
	    },
	    
	    /**
	     * APIMethod: exists
	     *
	     * Parameters:
	     * node - {DOMElement} The node to test for existence.
	     *
	     * Returns:
	     * {Boolean} Whether or not the node exists in the indexer?
	     */
	    exists: function(node) {
	        return (this.indices[node.id] != null);
	    },

	    /**
	     * APIMethod: getZIndex
	     * Get the z-index value for the current node from the node data itself.
	     * 
	     * Parameters:
	     * node - {DOMElement} The node whose z-index to get.
	     * 
	     * Returns:
	     * {Integer} The z-index value for the specified node (from the node 
	     *     data itself).
	     */
	    getZIndex: function(node) {
	        return node._style.graphicZIndex;  
	    },
	    
	    /**
	     * Method: determineZIndex
	     * Determine the z-index for the current node if there isn't one, 
	     *     and set the maximum value if we've found a new maximum.
	     * 
	     * Parameters:
	     * node - {DOMElement} 
	     */
	    determineZIndex: function(node) {
	        var zIndex = node._style.graphicZIndex;
	        
	        // Everything must have a zIndex. If none is specified,
	        // this means the user *must* (hint: assumption) want this
	        // node to succomb to drawing order. To enforce drawing order
	        // over all indexing methods, we'll create a new z-index that's
	        // greater than any currently in the indexer.
	        if (zIndex == null) {
	            zIndex = this.maxZIndex;
	            node._style.graphicZIndex = zIndex; 
	        } else if (zIndex > this.maxZIndex) {
	            this.maxZIndex = zIndex;
	        }
	    },

	    /**
	     * APIMethod: getNextElement
	     * Get the next element in the order stack.
	     * 
	     * Parameters:
	     * index - {Integer} The index of the current node in this.order.
	     * 
	     * Returns:
	     * {DOMElement} the node following the index passed in, or
	     *     null.
	     */
	    getNextElement: function(index) {
	        for (var nextIndex = index + 1, nextElement = undefined;
	            (nextIndex < this.order.length) && (nextElement == undefined);
	            nextIndex++) {
	            nextElement = OpenLayers.Util.getElement(this.order[nextIndex]);
	        }
	        
	        return nextElement || null;
	    },
	    
	    CLASS_NAME: "OpenLayers.ElementsIndexer"
	});

	/**
	 * Namespace: OpenLayers.ElementsIndexer.IndexingMethods
	 * These are the compare methods for figuring out where a new node should be 
	 *     placed within the indexer. These methods are very similar to general 
	 *     sorting methods in that they return -1, 0, and 1 to specify the 
	 *     direction in which new nodes fall in the ordering.
	 */
	OpenLayers.ElementsIndexer.IndexingMethods = {
	    
	    /**
	     * Method: Z_ORDER
	     * This compare method is used by other comparison methods.
	     *     It can be used individually for ordering, but is not recommended,
	     *     because it doesn't subscribe to drawing order.
	     * 
	     * Parameters:
	     * indexer - {<OpenLayers.ElementsIndexer>}
	     * newNode - {DOMElement}
	     * nextNode - {DOMElement}
	     * 
	     * Returns:
	     * {Integer}
	     */
	    Z_ORDER: function(indexer, newNode, nextNode) {
	        var newZIndex = indexer.getZIndex(newNode);

	        var returnVal = 0;
	        if (nextNode) {
	            var nextZIndex = indexer.getZIndex(nextNode);
	            returnVal = newZIndex - nextZIndex; 
	        }
	        
	        return returnVal;
	    },

	    /**
	     * APIMethod: Z_ORDER_DRAWING_ORDER
	     * This method orders nodes by their z-index, but does so in a way
	     *     that, if there are other nodes with the same z-index, the newest 
	     *     drawn will be the front most within that z-index. This is the 
	     *     default indexing method.
	     * 
	     * Parameters:
	     * indexer - {<OpenLayers.ElementsIndexer>}
	     * newNode - {DOMElement}
	     * nextNode - {DOMElement}
	     * 
	     * Returns:
	     * {Integer}
	     */
	    Z_ORDER_DRAWING_ORDER: function(indexer, newNode, nextNode) {
	        var returnVal = OpenLayers.ElementsIndexer.IndexingMethods.Z_ORDER(
	            indexer, 
	            newNode, 
	            nextNode
	        );
	        
	        // Make Z_ORDER subscribe to drawing order by pushing it above
	        // all of the other nodes with the same z-index.
	        if (nextNode && returnVal == 0) {
	            returnVal = 1;
	        }
	        
	        return returnVal;
	    },

	    /**
	     * APIMethod: Z_ORDER_Y_ORDER
	     * This one should really be called Z_ORDER_Y_ORDER_DRAWING_ORDER, as it
	     *     best describes which ordering methods have precedence (though, the 
	     *     name would be too long). This method orders nodes by their z-index, 
	     *     but does so in a way that, if there are other nodes with the same 
	     *     z-index, the nodes with the lower y position will be "closer" than 
	     *     those with a higher y position. If two nodes have the exact same y 
	     *     position, however, then this method will revert to using drawing  
	     *     order to decide placement.
	     * 
	     * Parameters:
	     * indexer - {<OpenLayers.ElementsIndexer>}
	     * newNode - {DOMElement}
	     * nextNode - {DOMElement}
	     * 
	     * Returns:
	     * {Integer}
	     */
	    Z_ORDER_Y_ORDER: function(indexer, newNode, nextNode) {
	        var returnVal = OpenLayers.ElementsIndexer.IndexingMethods.Z_ORDER(
	            indexer, 
	            newNode, 
	            nextNode
	        );
	        
	        if (nextNode && returnVal === 0) {            
	            var result = nextNode._boundsBottom - newNode._boundsBottom;
	            returnVal = (result === 0) ? 1 : result;
	        }
	        
	        return returnVal;       
	    }
	};

	/**
	 * Class: OpenLayers.Renderer.Elements
	 * This is another virtual class in that it should never be instantiated by 
	 *  itself as a Renderer. It exists because there is *tons* of shared 
	 *  functionality between different vector libraries which use nodes/elements
	 *  as a base for rendering vectors. 
	 * 
	 * The highlevel bits of code that are implemented here are the adding and 
	 *  removing of geometries, which is essentially the same for any 
	 *  element-based renderer. The details of creating each node and drawing the
	 *  paths are of course different, but the machinery is the same. 
	 * 
	 * Inherits:
	 *  - <OpenLayers.Renderer>
	 */
	OpenLayers.Renderer.Elements = OpenLayers.Class(OpenLayers.Renderer, {

	    /**
	     * Property: rendererRoot
	     * {DOMElement}
	     */
	    rendererRoot: null,
	    
	    /**
	     * Property: root
	     * {DOMElement}
	     */
	    root: null,
	    
	    /**
	     * Property: vectorRoot
	     * {DOMElement}
	     */
	    vectorRoot: null,

	    /**
	     * Property: textRoot
	     * {DOMElement}
	     */
	    textRoot: null,

	    /**
	     * Property: xmlns
	     * {String}
	     */    
	    xmlns: null,
	    
	    /**
	     * Property: xOffset
	     * {Number} Offset to apply to the renderer viewport translation in x
	     * direction. If the renderer extent's center is on the right of the
	     * dateline (i.e. exceeds the world bounds), we shift the viewport to the
	     * left by one world width. This avoids that features disappear from the
	     * map viewport. Because our dateline handling logic in other places
	     * ensures that extents crossing the dateline always have a center
	     * exceeding the world bounds on the left, we need this offset to make sure
	     * that the same is true for the renderer extent in pixel space as well.
	     */
	    xOffset: 0,
	    
	    /**
	     * Property: rightOfDateLine
	     * {Boolean} Keeps track of the location of the map extent relative to the
	     * date line. The <setExtent> method compares this value (which is the one
	     * from the previous <setExtent> call) with the current position of the map
	     * extent relative to the date line and updates the xOffset when the extent
	     * has moved from one side of the date line to the other.
	     */
	    
	    /**
	     * Property: Indexer
	     * {<OpenLayers.ElementIndexer>} An instance of OpenLayers.ElementsIndexer 
	     *     created upon initialization if the zIndexing or yOrdering options
	     *     passed to this renderer's constructor are set to true.
	     */
	    indexer: null, 
	    
	    /**
	     * Constant: BACKGROUND_ID_SUFFIX
	     * {String}
	     */
	    BACKGROUND_ID_SUFFIX: "_background",
	    
	    /**
	     * Constant: LABEL_ID_SUFFIX
	     * {String}
	     */
	    LABEL_ID_SUFFIX: "_label",
	    
	    /**
	     * Constant: LABEL_OUTLINE_SUFFIX
	     * {String}
	     */
	    LABEL_OUTLINE_SUFFIX: "_outline",

	    /**
	     * Constructor: OpenLayers.Renderer.Elements
	     * 
	     * Parameters:
	     * containerID - {String}
	     * options - {Object} options for this renderer. 
	     *
	     * Supported options are:
	     *     yOrdering - {Boolean} Whether to use y-ordering
	     *     zIndexing - {Boolean} Whether to use z-indexing. Will be ignored
	     *         if yOrdering is set to true.
	     */
	    initialize: function(containerID, options) {
	        OpenLayers.Renderer.prototype.initialize.apply(this, arguments);

	        this.rendererRoot = this.createRenderRoot();
	        this.root = this.createRoot("_root");
	        this.vectorRoot = this.createRoot("_vroot");
	        this.textRoot = this.createRoot("_troot");
	        
	        this.root.appendChild(this.vectorRoot);
	        this.root.appendChild(this.textRoot);
	        
	        this.rendererRoot.appendChild(this.root);
	        this.container.appendChild(this.rendererRoot);
	        
	        if(options && (options.zIndexing || options.yOrdering)) {
	            this.indexer = new OpenLayers.ElementsIndexer(options.yOrdering);
	        }
	    },
	    
	    /**
	     * Method: destroy
	     */
	    destroy: function() {

	        this.clear(); 

	        this.rendererRoot = null;
	        this.root = null;
	        this.xmlns = null;

	        OpenLayers.Renderer.prototype.destroy.apply(this, arguments);
	    },
	    
	    /**
	     * Method: clear
	     * Remove all the elements from the root
	     */    
	    clear: function() {
	        var child;
	        var root = this.vectorRoot;
	        if (root) {
	            while (child = root.firstChild) {
	                root.removeChild(child);
	            }
	        }
	        root = this.textRoot;
	        if (root) {
	            while (child = root.firstChild) {
	                root.removeChild(child);
	            }
	        }
	        if (this.indexer) {
	            this.indexer.clear();
	        }
	    },
	    
	    /**
	     * Method: setExtent
	     * Set the visible part of the layer.
	     *
	     * Parameters:
	     * extent - {<OpenLayers.Bounds>}
	     * resolutionChanged - {Boolean}
	     *
	     * Returns:
	     * {Boolean} true to notify the layer that the new extent does not exceed
	     *     the coordinate range, and the features will not need to be redrawn.
	     *     False otherwise.
	     */
	    setExtent: function(extent, resolutionChanged) {
	        var coordSysUnchanged = OpenLayers.Renderer.prototype.setExtent.apply(this, arguments);
	        var resolution = this.getResolution();
	        if (this.map.baseLayer && this.map.baseLayer.wrapDateLine) {
	            var rightOfDateLine,
	                ratio = extent.getWidth() / this.map.getExtent().getWidth(),
	                extent = extent.scale(1 / ratio),
	                world = this.map.getMaxExtent();
	            if (world.right > extent.left && world.right < extent.right) {
	                rightOfDateLine = true;
	            } else if (world.left > extent.left && world.left < extent.right) {
	                rightOfDateLine = false;
	            }
	            if (rightOfDateLine !== this.rightOfDateLine || resolutionChanged) {
	                coordSysUnchanged = false;
	                this.xOffset = rightOfDateLine === true ?
	                    world.getWidth() / resolution : 0;
	            }
	            this.rightOfDateLine = rightOfDateLine;
	        }
	        return coordSysUnchanged;
	    },

	    /** 
	     * Method: getNodeType
	     * This function is in charge of asking the specific renderer which type
	     *     of node to create for the given geometry and style. All geometries
	     *     in an Elements-based renderer consist of one node and some
	     *     attributes. We have the nodeFactory() function which creates a node
	     *     for us, but it takes a 'type' as input, and that is precisely what
	     *     this function tells us.  
	     *  
	     * Parameters:
	     * geometry - {<OpenLayers.Geometry>}
	     * style - {Object}
	     * 
	     * Returns:
	     * {String} The corresponding node type for the specified geometry
	     */
	    getNodeType: function(geometry, style) { },

	    /** 
	     * Method: drawGeometry 
	     * Draw the geometry, creating new nodes, setting paths, setting style,
	     *     setting featureId on the node.  This method should only be called
	     *     by the renderer itself.
	     *
	     * Parameters:
	     * geometry - {<OpenLayers.Geometry>}
	     * style - {Object}
	     * featureId - {String}
	     * 
	     * Returns:
	     * {Boolean} true if the geometry has been drawn completely; null if
	     *     incomplete; false otherwise
	     */
	    drawGeometry: function(geometry, style, featureId) {
	        var className = geometry.CLASS_NAME;
	        var rendered = true;
	        if ((className == "OpenLayers.Geometry.Collection") ||
	            (className == "OpenLayers.Geometry.MultiPoint") ||
	            (className == "OpenLayers.Geometry.MultiLineString") ||
	            (className == "OpenLayers.Geometry.MultiPolygon")) {
	            for (var i = 0, len=geometry.components.length; i<len; i++) {
	                rendered = this.drawGeometry(
	                    geometry.components[i], style, featureId) && rendered;
	            }
	            return rendered;
	        }

	        rendered = false;
	        var removeBackground = false;
	        if (style.display != "none") {
	            if (style.backgroundGraphic) {
	                this.redrawBackgroundNode(geometry.id, geometry, style,
	                    featureId);
	            } else {
	                removeBackground = true;
	            }
	            rendered = this.redrawNode(geometry.id, geometry, style,
	                featureId);
	        }
	        if (rendered == false) {
	            var node = document.getElementById(geometry.id);
	            if (node) {
	                if (node._style.backgroundGraphic) {
	                    removeBackground = true;
	                }
	                node.parentNode.removeChild(node);
	            }
	        }
	        if (removeBackground) {
	            var node = document.getElementById(
	                geometry.id + this.BACKGROUND_ID_SUFFIX);
	            if (node) {
	                node.parentNode.removeChild(node);
	            }
	        }
	        return rendered;
	    },
	    
	    /**
	     * Method: redrawNode
	     * 
	     * Parameters:
	     * id - {String}
	     * geometry - {<OpenLayers.Geometry>}
	     * style - {Object}
	     * featureId - {String}
	     * 
	     * Returns:
	     * {Boolean} true if the complete geometry could be drawn, null if parts of
	     *     the geometry could not be drawn, false otherwise
	     */
	    redrawNode: function(id, geometry, style, featureId) {
	        style = this.applyDefaultSymbolizer(style);
	        // Get the node if it's already on the map.
	        var node = this.nodeFactory(id, this.getNodeType(geometry, style));
	        
	        // Set the data for the node, then draw it.
	        node._featureId = featureId;
	        node._boundsBottom = geometry.getBounds().bottom;
	        node._geometryClass = geometry.CLASS_NAME;
	        node._style = style;

	        var drawResult = this.drawGeometryNode(node, geometry, style);
	        if(drawResult === false) {
	            return false;
	        }
	         
	        node = drawResult.node;
	        
	        // Insert the node into the indexer so it can show us where to
	        // place it. Note that this operation is O(log(n)). If there's a
	        // performance problem (when dragging, for instance) this is
	        // likely where it would be.
	        if (this.indexer) {
	            var insert = this.indexer.insert(node);
	            if (insert) {
	                this.vectorRoot.insertBefore(node, insert);
	            } else {
	                this.vectorRoot.appendChild(node);
	            }
	        } else {
	            // if there's no indexer, simply append the node to root,
	            // but only if the node is a new one
	            if (node.parentNode !== this.vectorRoot){ 
	                this.vectorRoot.appendChild(node);
	            }
	        }
	        
	        this.postDraw(node);
	        
	        return drawResult.complete;
	    },
	    
	    /**
	     * Method: redrawBackgroundNode
	     * Redraws the node using special 'background' style properties. Basically
	     *     just calls redrawNode(), but instead of directly using the 
	     *     'externalGraphic', 'graphicXOffset', 'graphicYOffset', and 
	     *     'graphicZIndex' properties directly from the specified 'style' 
	     *     parameter, we create a new style object and set those properties 
	     *     from the corresponding 'background'-prefixed properties from 
	     *     specified 'style' parameter.
	     * 
	     * Parameters:
	     * id - {String}
	     * geometry - {<OpenLayers.Geometry>}
	     * style - {Object}
	     * featureId - {String}
	     * 
	     * Returns:
	     * {Boolean} true if the complete geometry could be drawn, null if parts of
	     *     the geometry could not be drawn, false otherwise
	     */
	    redrawBackgroundNode: function(id, geometry, style, featureId) {
	        var backgroundStyle = OpenLayers.Util.extend({}, style);
	        
	        // Set regular style attributes to apply to the background styles.
	        backgroundStyle.externalGraphic = backgroundStyle.backgroundGraphic;
	        backgroundStyle.graphicXOffset = backgroundStyle.backgroundXOffset;
	        backgroundStyle.graphicYOffset = backgroundStyle.backgroundYOffset;
	        backgroundStyle.graphicZIndex = backgroundStyle.backgroundGraphicZIndex;
	        backgroundStyle.graphicWidth = backgroundStyle.backgroundWidth || backgroundStyle.graphicWidth;
	        backgroundStyle.graphicHeight = backgroundStyle.backgroundHeight || backgroundStyle.graphicHeight;
	        
	        // Erase background styles.
	        backgroundStyle.backgroundGraphic = null;
	        backgroundStyle.backgroundXOffset = null;
	        backgroundStyle.backgroundYOffset = null;
	        backgroundStyle.backgroundGraphicZIndex = null;
	        
	        return this.redrawNode(
	            id + this.BACKGROUND_ID_SUFFIX, 
	            geometry, 
	            backgroundStyle, 
	            null
	        );
	    },

	    /**
	     * Method: drawGeometryNode
	     * Given a node, draw a geometry on the specified layer.
	     *     node and geometry are required arguments, style is optional.
	     *     This method is only called by the render itself.
	     *
	     * Parameters:
	     * node - {DOMElement}
	     * geometry - {<OpenLayers.Geometry>}
	     * style - {Object}
	     * 
	     * Returns:
	     * {Object} a hash with properties "node" (the drawn node) and "complete"
	     *     (null if parts of the geometry could not be drawn, false if nothing
	     *     could be drawn)
	     */
	    drawGeometryNode: function(node, geometry, style) {
	        style = style || node._style;

	        var options = {
	            'isFilled': style.fill === undefined ?
	                true :
	                style.fill,
	            'isStroked': style.stroke === undefined ?
	                !!style.strokeWidth :
	                style.stroke
	        };
	        var drawn;
	        switch (geometry.CLASS_NAME) {
	            case "OpenLayers.Geometry.Point":
	                if(style.graphic === false) {
	                    options.isFilled = false;
	                    options.isStroked = false;
	                }
	                drawn = this.drawPoint(node, geometry);
	                break;
	            case "OpenLayers.Geometry.LineString":
	                options.isFilled = false;
	                drawn = this.drawLineString(node, geometry);
	                break;
	            case "OpenLayers.Geometry.LinearRing":
	                drawn = this.drawLinearRing(node, geometry);
	                break;
	            case "OpenLayers.Geometry.Polygon":
	                drawn = this.drawPolygon(node, geometry);
	                break;
	            case "OpenLayers.Geometry.Rectangle":
	                drawn = this.drawRectangle(node, geometry);
	                break;
	            default:
	                break;
	        }

	        node._options = options; 

	        //set style
	        //TBD simplify this
	        if (drawn != false) {
	            return {
	                node: this.setStyle(node, style, options, geometry),
	                complete: drawn
	            };
	        } else {
	            return false;
	        }
	    },
	    
	    /**
	     * Method: postDraw
	     * Things that have do be done after the geometry node is appended
	     *     to its parent node. To be overridden by subclasses.
	     * 
	     * Parameters:
	     * node - {DOMElement}
	     */
	    postDraw: function(node) {},
	    
	    /**
	     * Method: drawPoint
	     * Virtual function for drawing Point Geometry. 
	     *     Should be implemented by subclasses.
	     *     This method is only called by the renderer itself.
	     * 
	     * Parameters: 
	     * node - {DOMElement}
	     * geometry - {<OpenLayers.Geometry>}
	     * 
	     * Returns:
	     * {DOMElement} or false if the renderer could not draw the point
	     */ 
	    drawPoint: function(node, geometry) {},

	    /**
	     * Method: drawLineString
	     * Virtual function for drawing LineString Geometry. 
	     *     Should be implemented by subclasses.
	     *     This method is only called by the renderer itself.
	     * 
	     * Parameters: 
	     * node - {DOMElement}
	     * geometry - {<OpenLayers.Geometry>}
	     * 
	     * Returns:
	     * {DOMElement} or null if the renderer could not draw all components of
	     *     the linestring, or false if nothing could be drawn
	     */ 
	    drawLineString: function(node, geometry) {},

	    /**
	     * Method: drawLinearRing
	     * Virtual function for drawing LinearRing Geometry. 
	     *     Should be implemented by subclasses.
	     *     This method is only called by the renderer itself.
	     * 
	     * Parameters: 
	     * node - {DOMElement}
	     * geometry - {<OpenLayers.Geometry>}
	     * 
	     * Returns:
	     * {DOMElement} or null if the renderer could not draw all components
	     *     of the linear ring, or false if nothing could be drawn
	     */ 
	    drawLinearRing: function(node, geometry) {},

	    /**
	     * Method: drawPolygon
	     * Virtual function for drawing Polygon Geometry. 
	     *    Should be implemented by subclasses.
	     *    This method is only called by the renderer itself.
	     * 
	     * Parameters: 
	     * node - {DOMElement}
	     * geometry - {<OpenLayers.Geometry>}
	     * 
	     * Returns:
	     * {DOMElement} or null if the renderer could not draw all components
	     *     of the polygon, or false if nothing could be drawn
	     */ 
	    drawPolygon: function(node, geometry) {},

	    /**
	     * Method: drawRectangle
	     * Virtual function for drawing Rectangle Geometry. 
	     *     Should be implemented by subclasses.
	     *     This method is only called by the renderer itself.
	     * 
	     * Parameters: 
	     * node - {DOMElement}
	     * geometry - {<OpenLayers.Geometry>}
	     * 
	     * Returns:
	     * {DOMElement} or false if the renderer could not draw the rectangle
	     */ 
	    drawRectangle: function(node, geometry) {},

	    /**
	     * Method: drawCircle
	     * Virtual function for drawing Circle Geometry. 
	     *     Should be implemented by subclasses.
	     *     This method is only called by the renderer itself.
	     * 
	     * Parameters: 
	     * node - {DOMElement}
	     * geometry - {<OpenLayers.Geometry>}
	     * 
	     * Returns:
	     * {DOMElement} or false if the renderer could not draw the circle
	     */ 
	    drawCircle: function(node, geometry) {},

	    /**
	     * Method: removeText
	     * Removes a label
	     * 
	     * Parameters:
	     * featureId - {String}
	     */
	    removeText: function(featureId) {
	        var label = document.getElementById(featureId + this.LABEL_ID_SUFFIX);
	        if (label) {
	            this.textRoot.removeChild(label);
	        }
	        var outline = document.getElementById(featureId + this.LABEL_OUTLINE_SUFFIX);
	        if (outline) {
	            this.textRoot.removeChild(outline);
	        }
	    },

	    /**
	     * Method: getFeatureIdFromEvent
	     * 
	     * Parameters:
	     * evt - {Object} An <OpenLayers.Event> object
	     *
	     * Returns:
	     * {String} A feature id or undefined.
	     */
	    getFeatureIdFromEvent: function(evt) {
	        var target = evt.target;
	        var useElement = target && target.correspondingUseElement;
	        var node = useElement ? useElement : (target || evt.srcElement);
	        return node._featureId;
	    },

	    /** 
	     * Method: eraseGeometry
	     * Erase a geometry from the renderer. In the case of a multi-geometry, 
	     *     we cycle through and recurse on ourselves. Otherwise, we look for a 
	     *     node with the geometry.id, destroy its geometry, and remove it from
	     *     the DOM.
	     * 
	     * Parameters:
	     * geometry - {<OpenLayers.Geometry>}
	     * featureId - {String}
	     */
	    eraseGeometry: function(geometry, featureId) {
	        if ((geometry.CLASS_NAME == "OpenLayers.Geometry.MultiPoint") ||
	            (geometry.CLASS_NAME == "OpenLayers.Geometry.MultiLineString") ||
	            (geometry.CLASS_NAME == "OpenLayers.Geometry.MultiPolygon") ||
	            (geometry.CLASS_NAME == "OpenLayers.Geometry.Collection")) {
	            for (var i=0, len=geometry.components.length; i<len; i++) {
	                this.eraseGeometry(geometry.components[i], featureId);
	            }
	        } else {    
	            var element = OpenLayers.Util.getElement(geometry.id);
	            if (element && element.parentNode) {
	                if (element.geometry) {
	                    element.geometry.destroy();
	                    element.geometry = null;
	                }
	                element.parentNode.removeChild(element);

	                if (this.indexer) {
	                    this.indexer.remove(element);
	                }
	                
	                if (element._style.backgroundGraphic) {
	                    var backgroundId = geometry.id + this.BACKGROUND_ID_SUFFIX;
	                    var bElem = OpenLayers.Util.getElement(backgroundId);
	                    if (bElem && bElem.parentNode) {
	                        // No need to destroy the geometry since the element and the background
	                        // node share the same geometry.
	                        bElem.parentNode.removeChild(bElem);
	                    }
	                }
	            }
	        }
	    },

	    /** 
	     * Method: nodeFactory
	     * Create new node of the specified type, with the (optional) specified id.
	     * 
	     * If node already exists with same ID and a different type, we remove it
	     *     and then call ourselves again to recreate it.
	     * 
	     * Parameters:
	     * id - {String}
	     * type - {String} type Kind of node to draw.
	     * 
	     * Returns:
	     * {DOMElement} A new node of the given type and id.
	     */
	    nodeFactory: function(id, type) {
	        var node = OpenLayers.Util.getElement(id);
	        if (node) {
	            if (!this.nodeTypeCompare(node, type)) {
	                node.parentNode.removeChild(node);
	                node = this.nodeFactory(id, type);
	            }
	        } else {
	            node = this.createNode(type, id);
	        }
	        return node;
	    },
	    
	    /** 
	     * Method: nodeTypeCompare
	     * 
	     * Parameters:
	     * node - {DOMElement}
	     * type - {String} Kind of node
	     * 
	     * Returns:
	     * {Boolean} Whether or not the specified node is of the specified type
	     *     This function must be overridden by subclasses.
	     */
	    nodeTypeCompare: function(node, type) {},
	    
	    /** 
	     * Method: createNode
	     * 
	     * Parameters:
	     * type - {String} Kind of node to draw.
	     * id - {String} Id for node.
	     * 
	     * Returns:
	     * {DOMElement} A new node of the given type and id.
	     *     This function must be overridden by subclasses.
	     */
	    createNode: function(type, id) {},

	    /**
	     * Method: moveRoot
	     * moves this renderer's root to a different renderer.
	     * 
	     * Parameters:
	     * renderer - {<OpenLayers.Renderer>} target renderer for the moved root
	     */
	    moveRoot: function(renderer) {
	        var root = this.root;
	        if(renderer.root.parentNode == this.rendererRoot) {
	            root = renderer.root;
	        }
	        root.parentNode.removeChild(root);
	        renderer.rendererRoot.appendChild(root);
	    },
	    
	    /**
	     * Method: getRenderLayerId
	     * Gets the layer that this renderer's output appears on. If moveRoot was
	     * used, this will be different from the id of the layer containing the
	     * features rendered by this renderer.
	     * 
	     * Returns:
	     * {String} the id of the output layer.
	     */
	    getRenderLayerId: function() {
	        return this.root.parentNode.parentNode.id;
	    },
	    
	    /**
	     * Method: isComplexSymbol
	     * Determines if a symbol cannot be rendered using drawCircle
	     * 
	     * Parameters:
	     * graphicName - {String}
	     * 
	     * Returns
	     * {Boolean} true if the symbol is complex, false if not
	     */
	    isComplexSymbol: function(graphicName) {
	        return (graphicName != "circle") && !!graphicName;
	    },

	    CLASS_NAME: "OpenLayers.Renderer.Elements"
	});

	/* ======================================================================
	    OpenLayers/Renderer/SVG.js
	   ====================================================================== */

	/* Copyright (c) 2006-2015 by OpenLayers Contributors (see authors.txt for
	 * full list of contributors). Published under the 2-clause BSD license.
	 * See license.txt in the OpenLayers distribution or repository for the
	 * full text of the license. */

	/**
	 * @requires OpenLayers/Renderer/Elements.js
	 */

	/**
	 * Class: OpenLayers.Renderer.SVG
	 * 
	 * Inherits:
	 *  - <OpenLayers.Renderer.Elements>
	 */
	OpenLayers.Renderer.SVG = OpenLayers.Class(OpenLayers.Renderer.Elements, {

	    /** 
	     * Property: xmlns
	     * {String}
	     */
	    xmlns: "http://www.w3.org/2000/svg",
	    
	    /**
	     * Property: xlinkns
	     * {String}
	     */
	    xlinkns: "http://www.w3.org/1999/xlink",

	    /**
	     * Constant: MAX_PIXEL
	     * {Integer} Firefox has a limitation where values larger or smaller than  
	     *           about 15000 in an SVG document lock the browser up. This 
	     *           works around it.
	     */
	    MAX_PIXEL: 15000,

	    /**
	     * Property: translationParameters
	     * {Object} Hash with "x" and "y" properties
	     */
	    translationParameters: null,
	    
	    /**
	     * Property: symbolMetrics
	     * {Object} Cache for symbol metrics according to their svg coordinate
	     *     space. This is an object keyed by the symbol's id, and values are
	     *     an array of [width, centerX, centerY].
	     */
	    symbolMetrics: null,
	    
	    /**
	     * Constructor: OpenLayers.Renderer.SVG
	     * 
	     * Parameters:
	     * containerID - {String}
	     */
	    initialize: function(containerID) {
	        if (!this.supported()) { 
	            return; 
	        }
	        OpenLayers.Renderer.Elements.prototype.initialize.apply(this, 
	                                                                arguments);
	        this.translationParameters = {x: 0, y: 0};
	        
	        this.symbolMetrics = {};
	    },

	    /**
	     * APIMethod: supported
	     * 
	     * Returns:
	     * {Boolean} Whether or not the browser supports the SVG renderer
	     */
	    supported: function() {
	        var svgFeature = "http://www.w3.org/TR/SVG11/feature#";
	        return (document.implementation && 
	           (document.implementation.hasFeature("org.w3c.svg", "1.0") || 
	            document.implementation.hasFeature(svgFeature + "SVG", "1.1") || 
	            document.implementation.hasFeature(svgFeature + "BasicStructure", "1.1") ));
	    },    

	    /**
	     * Method: inValidRange
	     * See #669 for more information
	     *
	     * Parameters:
	     * x      - {Integer}
	     * y      - {Integer}
	     * xyOnly - {Boolean} whether or not to just check for x and y, which means
	     *     to not take the current translation parameters into account if true.
	     * 
	     * Returns:
	     * {Boolean} Whether or not the 'x' and 'y' coordinates are in the  
	     *           valid range.
	     */ 
	    inValidRange: function(x, y, xyOnly) {
	        var left = x + (xyOnly ? 0 : this.translationParameters.x);
	        var top = y + (xyOnly ? 0 : this.translationParameters.y);
	        return (left >= -this.MAX_PIXEL && left <= this.MAX_PIXEL &&
	                top >= -this.MAX_PIXEL && top <= this.MAX_PIXEL);
	    },

	    /**
	     * Method: setExtent
	     * 
	     * Parameters:
	     * extent - {<OpenLayers.Bounds>}
	     * resolutionChanged - {Boolean}
	     * 
	     * Returns:
	     * {Boolean} true to notify the layer that the new extent does not exceed
	     *     the coordinate range, and the features will not need to be redrawn.
	     *     False otherwise.
	     */
	    setExtent: function(extent, resolutionChanged) {
	        var coordSysUnchanged = OpenLayers.Renderer.Elements.prototype.setExtent.apply(this, arguments);
	        
	        var resolution = this.getResolution(),
	            left = -extent.left / resolution,
	            top = extent.top / resolution;

	        // If the resolution has changed, start over changing the corner, because
	        // the features will redraw.
	        if (resolutionChanged) {
	            this.left = left;
	            this.top = top;
	            // Set the viewbox
	            var extentString = "0 0 " + this.size.w + " " + this.size.h;

	            this.rendererRoot.setAttributeNS(null, "viewBox", extentString);
	            this.translate(this.xOffset, 0);
	            return true;
	        } else {
	            var inRange = this.translate(left - this.left + this.xOffset, top - this.top);
	            if (!inRange) {
	                // recenter the coordinate system
	                this.setExtent(extent, true);
	            }
	            return coordSysUnchanged && inRange;
	        }
	    },
	    
	    /**
	     * Method: translate
	     * Transforms the SVG coordinate system
	     * 
	     * Parameters:
	     * x - {Float}
	     * y - {Float}
	     * 
	     * Returns:
	     * {Boolean} true if the translation parameters are in the valid coordinates
	     *     range, false otherwise.
	     */
	    translate: function(x, y) {
	        if (!this.inValidRange(x, y, true)) {
	            return false;
	        } else {
	            var transformString = "";
	            if (x || y) {
	                transformString = "translate(" + x + "," + y + ")";
	            }
	            this.root.setAttributeNS(null, "transform", transformString);
	            this.translationParameters = {x: x, y: y};
	            return true;
	        }
	    },

	    /**
	     * Method: setSize
	     * Sets the size of the drawing surface.
	     * 
	     * Parameters:
	     * size - {<OpenLayers.Size>} The size of the drawing surface
	     */
	    setSize: function(size) {
	        OpenLayers.Renderer.prototype.setSize.apply(this, arguments);
	        
	        this.rendererRoot.setAttributeNS(null, "width", this.size.w);
	        this.rendererRoot.setAttributeNS(null, "height", this.size.h);
	    },

	    /** 
	     * Method: getNodeType 
	     * 
	     * Parameters:
	     * geometry - {<OpenLayers.Geometry>}
	     * style - {Object}
	     * 
	     * Returns:
	     * {String} The corresponding node type for the specified geometry
	     */
	    getNodeType: function(geometry, style) {
	        var nodeType = null;
	        switch (geometry.CLASS_NAME) {
	            case "OpenLayers.Geometry.Point":
	                if (style.externalGraphic) {
	                    nodeType = "image";
	                } else if (this.isComplexSymbol(style.graphicName)) {
	                    nodeType = "svg";
	                } else {
	                    nodeType = "circle";
	                }
	                break;
	            case "OpenLayers.Geometry.Rectangle":
	                nodeType = "rect";
	                break;
	            case "OpenLayers.Geometry.LineString":
	                nodeType = "polyline";
	                break;
	            case "OpenLayers.Geometry.LinearRing":
	                nodeType = "polygon";
	                break;
	            case "OpenLayers.Geometry.Polygon":
	            case "OpenLayers.Geometry.Curve":
	                nodeType = "path";
	                break;
	            default:
	                break;
	        }
	        return nodeType;
	    },

	    /** 
	     * Method: setStyle
	     * Use to set all the style attributes to a SVG node.
	     * 
	     * Takes care to adjust stroke width and point radius to be
	     * resolution-relative
	     *
	     * Parameters:
	     * node - {SVGDomElement} An SVG element to decorate
	     * style - {Object}
	     * options - {Object} Currently supported options include 
	     *                              'isFilled' {Boolean} and
	     *                              'isStroked' {Boolean}
	     */
	    setStyle: function(node, style, options) {
	        style = style  || node._style;
	        options = options || node._options;

	        var title = style.title || style.graphicTitle;
	        if (title) {
	            node.setAttributeNS(null, "title", title);
	            //Standards-conformant SVG
	            // Prevent duplicate nodes. See issue https://github.com/openlayers/ol2/issues/92 
	            var titleNode = node.getElementsByTagName("title");
	            if (titleNode.length > 0) {
	                titleNode[0].firstChild.textContent = title;
	            } else {
	                var label = this.nodeFactory(null, "title");
	                label.textContent = title;
	                node.appendChild(label);
	            }
	        }

	        var r = parseFloat(node.getAttributeNS(null, "r"));
	        var widthFactor = 1;
	        var pos;
	        if (node._geometryClass == "OpenLayers.Geometry.Point" && r) {
	            node.style.visibility = "";
	            if (style.graphic === false) {
	                node.style.visibility = "hidden";
	            } else if (style.externalGraphic) {
	                pos = this.getPosition(node);
	                if (style.graphicWidth && style.graphicHeight) {
	                  node.setAttributeNS(null, "preserveAspectRatio", "none");
	                }
	                var width = style.graphicWidth || style.graphicHeight;
	                var height = style.graphicHeight || style.graphicWidth;
	                width = width ? width : style.pointRadius*2;
	                height = height ? height : style.pointRadius*2;
	                var xOffset = (style.graphicXOffset != undefined) ?
	                    style.graphicXOffset : -(0.5 * width);
	                var yOffset = (style.graphicYOffset != undefined) ?
	                    style.graphicYOffset : -(0.5 * height);

	                var opacity = style.graphicOpacity || style.fillOpacity;
	                
	                node.setAttributeNS(null, "x", (pos.x + xOffset).toFixed());
	                node.setAttributeNS(null, "y", (pos.y + yOffset).toFixed());
	                node.setAttributeNS(null, "width", width);
	                node.setAttributeNS(null, "height", height);
	                node.setAttributeNS(this.xlinkns, "xlink:href", style.externalGraphic);
	                node.setAttributeNS(null, "style", "opacity: "+opacity);
	                node.onclick = OpenLayers.Event.preventDefault;
	            } else if (this.isComplexSymbol(style.graphicName)) {
	                // the symbol viewBox is three times as large as the symbol
	                var offset = style.pointRadius * 3;
	                var size = offset * 2;
	                var src = this.importSymbol(style.graphicName);
	                pos = this.getPosition(node);
	                widthFactor = this.symbolMetrics[src.id][0] * 3 / size;
	                
	                // remove the node from the dom before we modify it. This
	                // prevents various rendering issues in Safari and FF
	                var parent = node.parentNode;
	                var nextSibling = node.nextSibling;
	                if(parent) {
	                    parent.removeChild(node);
	                }
	                
	                // The more appropriate way to implement this would be use/defs,
	                // but due to various issues in several browsers, it is safer to
	                // copy the symbols instead of referencing them. 
	                // See e.g. ticket http://trac.osgeo.org/openlayers/ticket/2985 
	                // and this email thread
	                // http://osgeo-org.1803224.n2.nabble.com/Select-Control-Ctrl-click-on-Feature-with-a-graphicName-opens-new-browser-window-tc5846039.html
	                node.firstChild && node.removeChild(node.firstChild);
	                node.appendChild(src.firstChild.cloneNode(true));
	                node.setAttributeNS(null, "viewBox", src.getAttributeNS(null, "viewBox"));
	                
	                node.setAttributeNS(null, "width", size);
	                node.setAttributeNS(null, "height", size);
	                node.setAttributeNS(null, "x", pos.x - offset);
	                node.setAttributeNS(null, "y", pos.y - offset);
	                
	                // now that the node has all its new properties, insert it
	                // back into the dom where it was
	                if(nextSibling) {
	                    parent.insertBefore(node, nextSibling);
	                } else if(parent) {
	                    parent.appendChild(node);
	                }
	            } else {
	                node.setAttributeNS(null, "r", style.pointRadius);
	            }

	            var rotation = style.rotation;
	            
	            if ((rotation !== undefined || node._rotation !== undefined) && pos) {
	                node._rotation = rotation;
	                rotation |= 0;
	                if (node.nodeName !== "svg") { 
	                    node.setAttributeNS(null, "transform", 
	                        "rotate(" + rotation + " " + pos.x + " " + 
	                        pos.y + ")"); 
	                } else {
	                    var metrics = this.symbolMetrics[src.id];
	                    node.firstChild.setAttributeNS(null, "transform", "rotate(" 
	                        + rotation + " " 
	                        + metrics[1] + " "
	                        + metrics[2] + ")");
	                }
	            }
	        }
	        
	        if (options.isFilled) {
	            node.setAttributeNS(null, "fill", style.fillColor);
	            node.setAttributeNS(null, "fill-opacity", style.fillOpacity);
	        } else {
	            node.setAttributeNS(null, "fill", "none");
	        }

	        if (options.isStroked) {
	            node.setAttributeNS(null, "stroke", style.strokeColor);
	            node.setAttributeNS(null, "stroke-opacity", style.strokeOpacity);
	            node.setAttributeNS(null, "stroke-width", style.strokeWidth * widthFactor);
	            node.setAttributeNS(null, "stroke-linecap", style.strokeLinecap || "round");
	            // Hard-coded linejoin for now, to make it look the same as in VML.
	            // There is no strokeLinejoin property yet for symbolizers.
	            node.setAttributeNS(null, "stroke-linejoin", "round");
	            style.strokeDashstyle && node.setAttributeNS(null,
	                "stroke-dasharray", this.dashStyle(style, widthFactor));
	        } else {
	            node.setAttributeNS(null, "stroke", "none");
	        }
	        
	        if (style.pointerEvents) {
	            node.setAttributeNS(null, "pointer-events", style.pointerEvents);
	        }
	                
	        if (style.cursor != null) {
	            node.setAttributeNS(null, "cursor", style.cursor);
	        }
	        
	        return node;
	    },

	    /** 
	     * Method: dashStyle
	     * 
	     * Parameters:
	     * style - {Object}
	     * widthFactor - {Number}
	     * 
	     * Returns:
	     * {String} A SVG compliant 'stroke-dasharray' value
	     */
	    dashStyle: function(style, widthFactor) {
	        var w = style.strokeWidth * widthFactor;
	        var str = style.strokeDashstyle;
	        switch (str) {
	            case 'solid':
	                return 'none';
	            case 'dot':
	                return [1, 4 * w].join();
	            case 'dash':
	                return [4 * w, 4 * w].join();
	            case 'dashdot':
	                return [4 * w, 4 * w, 1, 4 * w].join();
	            case 'longdash':
	                return [8 * w, 4 * w].join();
	            case 'longdashdot':
	                return [8 * w, 4 * w, 1, 4 * w].join();
	            default:
	                return OpenLayers.String.trim(str).replace(/\s+/g, ",");
	        }
	    },
	    
	    /** 
	     * Method: createNode
	     * 
	     * Parameters:
	     * type - {String} Kind of node to draw
	     * id - {String} Id for node
	     * 
	     * Returns:
	     * {DOMElement} A new node of the given type and id
	     */
	    createNode: function(type, id) {
	        var node = document.createElementNS(this.xmlns, type);
	        if (id) {
	            node.setAttributeNS(null, "id", id);
	        }
	        return node;    
	    },
	    
	    /** 
	     * Method: nodeTypeCompare
	     * 
	     * Parameters:
	     * node - {SVGDomElement} An SVG element
	     * type - {String} Kind of node
	     * 
	     * Returns:
	     * {Boolean} Whether or not the specified node is of the specified type
	     */
	    nodeTypeCompare: function(node, type) {
	        return (type == node.nodeName);
	    },
	   
	    /**
	     * Method: createRenderRoot
	     * 
	     * Returns:
	     * {DOMElement} The specific render engine's root element
	     */
	    createRenderRoot: function() {
	        var svg = this.nodeFactory(this.container.id + "_svgRoot", "svg");
	        svg.style.display = "block";
	        return svg;
	    },

	    /**
	     * Method: createRoot
	     * 
	     * Parameters:
	     * suffix - {String} suffix to append to the id
	     * 
	     * Returns:
	     * {DOMElement}
	     */
	    createRoot: function(suffix) {
	        return this.nodeFactory(this.container.id + suffix, "g");
	    },

	    /**
	     * Method: createDefs
	     *
	     * Returns:
	     * {DOMElement} The element to which we'll add the symbol definitions
	     */
	    createDefs: function() {
	        var defs = this.nodeFactory(this.container.id + "_defs", "defs");
	        this.rendererRoot.appendChild(defs);
	        return defs;
	    },

	    /**************************************
	     *                                    *
	     *     GEOMETRY DRAWING FUNCTIONS     *
	     *                                    *
	     **************************************/

	    /**
	     * Method: drawPoint
	     * This method is only called by the renderer itself.
	     * 
	     * Parameters: 
	     * node - {DOMElement}
	     * geometry - {<OpenLayers.Geometry>}
	     * 
	     * Returns:
	     * {DOMElement} or false if the renderer could not draw the point
	     */ 
	    drawPoint: function(node, geometry) {
	        return this.drawCircle(node, geometry, 1);
	    },

	    /**
	     * Method: drawCircle
	     * This method is only called by the renderer itself.
	     * 
	     * Parameters: 
	     * node - {DOMElement}
	     * geometry - {<OpenLayers.Geometry>}
	     * radius - {Float}
	     * 
	     * Returns:
	     * {DOMElement} or false if the renderer could not draw the circle
	     */
	    drawCircle: function(node, geometry, radius) {
	        var resolution = this.getResolution();
	        var x = ((geometry.x - this.featureDx) / resolution + this.left);
	        var y = (this.top - geometry.y / resolution);

	        if (this.inValidRange(x, y)) { 
	            node.setAttributeNS(null, "cx", x);
	            node.setAttributeNS(null, "cy", y);
	            node.setAttributeNS(null, "r", radius);
	            return node;
	        } else {
	            return false;
	        }    
	            
	    },
	    
	    /**
	     * Method: drawLineString
	     * This method is only called by the renderer itself.
	     * 
	     * Parameters: 
	     * node - {DOMElement}
	     * geometry - {<OpenLayers.Geometry>}
	     * 
	     * Returns:
	     * {DOMElement} or null if the renderer could not draw all components of
	     *     the linestring, or false if nothing could be drawn
	     */ 
	    drawLineString: function(node, geometry) {
	        var componentsResult = this.getComponentsString(geometry.components);
	        if (componentsResult.path) {
	            node.setAttributeNS(null, "points", componentsResult.path);
	            return (componentsResult.complete ? node : null);  
	        } else {
	            return false;
	        }
	    },
	    
	    /**
	     * Method: drawLinearRing
	     * This method is only called by the renderer itself.
	     * 
	     * Parameters: 
	     * node - {DOMElement}
	     * geometry - {<OpenLayers.Geometry>}
	     * 
	     * Returns:
	     * {DOMElement} or null if the renderer could not draw all components
	     *     of the linear ring, or false if nothing could be drawn
	     */ 
	    drawLinearRing: function(node, geometry) {
	        var componentsResult = this.getComponentsString(geometry.components);
	        if (componentsResult.path) {
	            node.setAttributeNS(null, "points", componentsResult.path);
	            return (componentsResult.complete ? node : null);  
	        } else {
	            return false;
	        }
	    },
	    
	    /**
	     * Method: drawPolygon
	     * This method is only called by the renderer itself.
	     * 
	     * Parameters: 
	     * node - {DOMElement}
	     * geometry - {<OpenLayers.Geometry>}
	     * 
	     * Returns:
	     * {DOMElement} or null if the renderer could not draw all components
	     *     of the polygon, or false if nothing could be drawn
	     */ 
	    drawPolygon: function(node, geometry) {
	        var d = "";
	        var draw = true;
	        var complete = true;
	        var linearRingResult, path;
	        for (var j=0, len=geometry.components.length; j<len; j++) {
	            d += " M";
	            linearRingResult = this.getComponentsString(
	                geometry.components[j].components, " ");
	            path = linearRingResult.path;
	            if (path) {
	                d += " " + path;
	                complete = linearRingResult.complete && complete;
	            } else {
	                draw = false;
	            }
	        }
	        d += " z";
	        if (draw) {
	            node.setAttributeNS(null, "d", d);
	            node.setAttributeNS(null, "fill-rule", "evenodd");
	            return complete ? node : null;
	        } else {
	            return false;
	        }    
	    },
	    
	    /**
	     * Method: drawRectangle
	     * This method is only called by the renderer itself.
	     * 
	     * Parameters: 
	     * node - {DOMElement}
	     * geometry - {<OpenLayers.Geometry>}
	     * 
	     * Returns:
	     * {DOMElement} or false if the renderer could not draw the rectangle
	     */ 
	    drawRectangle: function(node, geometry) {
	        var resolution = this.getResolution();
	        var x = ((geometry.x - this.featureDx) / resolution + this.left);
	        var y = (this.top - geometry.y / resolution);

	        if (this.inValidRange(x, y)) { 
	            node.setAttributeNS(null, "x", x);
	            node.setAttributeNS(null, "y", y);
	            node.setAttributeNS(null, "width", geometry.width / resolution);
	            node.setAttributeNS(null, "height", geometry.height / resolution);
	            return node;
	        } else {
	            return false;
	        }
	    },
	    
	    /**
	     * Method: drawText
	     * This method is only called by the renderer itself.
	     *
	     * Parameters:
	     * featureId - {String}
	     * style -
	     * location - {<OpenLayers.Geometry.Point>}
	     */
	    drawText: function(featureId, style, location) {
	        var drawOutline = (!!style.labelOutlineWidth);
	        // First draw text in halo color and size and overlay the
	        // normal text afterwards
	        if (drawOutline) {
	            var outlineStyle = OpenLayers.Util.extend({}, style);
	            outlineStyle.fontColor = outlineStyle.labelOutlineColor;
	            outlineStyle.fontStrokeColor = outlineStyle.labelOutlineColor;
	            outlineStyle.fontStrokeWidth = style.labelOutlineWidth;
	            if (style.labelOutlineOpacity) {
	                outlineStyle.fontOpacity = style.labelOutlineOpacity;
	            }
	            delete outlineStyle.labelOutlineWidth;
	            this.drawText(featureId, outlineStyle, location);
	        }

	        var resolution = this.getResolution();

	        var x = ((location.x - this.featureDx) / resolution + this.left);
	        var y = (location.y / resolution - this.top);

	        var suffix = (drawOutline)?this.LABEL_OUTLINE_SUFFIX:this.LABEL_ID_SUFFIX;
	        var label = this.nodeFactory(featureId + suffix, "text");

	        label.setAttributeNS(null, "x", x);
	        label.setAttributeNS(null, "y", -y);

	        if (style.fontColor) {
	            label.setAttributeNS(null, "fill", style.fontColor);
	        }
	        if (style.fontStrokeColor) {
	            label.setAttributeNS(null, "stroke", style.fontStrokeColor);
	        }
	        if (style.fontStrokeWidth) {
	            label.setAttributeNS(null, "stroke-width", style.fontStrokeWidth);
	        }
	        if (style.fontOpacity) {
	            label.setAttributeNS(null, "opacity", style.fontOpacity);
	        }
	        if (style.fontFamily) {
	            label.setAttributeNS(null, "font-family", style.fontFamily);
	        }
	        if (style.fontSize) {
	            label.setAttributeNS(null, "font-size", style.fontSize);
	        }
	        if (style.fontWeight) {
	            label.setAttributeNS(null, "font-weight", style.fontWeight);
	        }
	        if (style.fontStyle) {
	            label.setAttributeNS(null, "font-style", style.fontStyle);
	        }
	        if (style.labelSelect === true) {
	            label.setAttributeNS(null, "pointer-events", "visible");
	            label._featureId = featureId;
	        } else {
	            label.setAttributeNS(null, "pointer-events", "none");
	        }
	        var align = style.labelAlign || OpenLayers.Renderer.defaultSymbolizer.labelAlign;
	        label.setAttributeNS(null, "text-anchor",
	            OpenLayers.Renderer.SVG.LABEL_ALIGN[align[0]] || "middle");

	        if (OpenLayers.IS_GECKO === true) {
	            label.setAttributeNS(null, "dominant-baseline",
	                OpenLayers.Renderer.SVG.LABEL_ALIGN[align[1]] || "central");
	        }

	        var labelRows = style.label.split('\n');
	        var numRows = labelRows.length;
	        while (label.childNodes.length > numRows) {
	            label.removeChild(label.lastChild);
	        }
	        for (var i = 0; i < numRows; i++) {
	            var tspan = this.nodeFactory(featureId + suffix + "_tspan_" + i, "tspan");
	            if (style.labelSelect === true) {
	                tspan._featureId = featureId;
	                tspan._geometry = location;
	                tspan._geometryClass = location.CLASS_NAME;
	            }
	            if (OpenLayers.IS_GECKO === false) {
	                tspan.setAttributeNS(null, "baseline-shift",
	                    OpenLayers.Renderer.SVG.LABEL_VSHIFT[align[1]] || "-35%");
	            }
	            tspan.setAttribute("x", x);
	            if (i == 0) {
	                var vfactor = OpenLayers.Renderer.SVG.LABEL_VFACTOR[align[1]];
	                if (vfactor == null) {
	                     vfactor = -.5;
	                }
	                tspan.setAttribute("dy", (vfactor*(numRows-1)) + "em");
	            } else {
	                tspan.setAttribute("dy", "1em");
	            }
	            tspan.textContent = (labelRows[i] === '') ? ' ' : labelRows[i];
	            if (!tspan.parentNode) {
	                label.appendChild(tspan);
	            }
	        }

	        if (!label.parentNode) {
	            this.textRoot.appendChild(label);
	        }
	    },
	    
	    /** 
	     * Method: getComponentString
	     * 
	     * Parameters:
	     * components - {Array(<OpenLayers.Geometry.Point>)} Array of points
	     * separator - {String} character between coordinate pairs. Defaults to ","
	     * 
	     * Returns:
	     * {Object} hash with properties "path" (the string created from the
	     *     components and "complete" (false if the renderer was unable to
	     *     draw all components)
	     */
	    getComponentsString: function(components, separator) {
	        var renderCmp = [];
	        var complete = true;
	        var len = components.length;
	        var strings = [];
	        var str, component;
	        for(var i=0; i<len; i++) {
	            component = components[i];
	            renderCmp.push(component);
	            str = this.getShortString(component);
	            if (str) {
	                strings.push(str);
	            } else {
	                // The current component is outside the valid range. Let's
	                // see if the previous or next component is inside the range.
	                // If so, add the coordinate of the intersection with the
	                // valid range bounds.
	                if (i > 0) {
	                    if (this.getShortString(components[i - 1])) {
	                        strings.push(this.clipLine(components[i],
	                            components[i-1]));
	                    }
	                }
	                if (i < len - 1) {
	                    if (this.getShortString(components[i + 1])) {
	                        strings.push(this.clipLine(components[i],
	                            components[i+1]));
	                    }
	                }
	                complete = false;
	            }
	        }

	        return {
	            path: strings.join(separator || ","),
	            complete: complete
	        };
	    },
	    
	    /**
	     * Method: clipLine
	     * Given two points (one inside the valid range, and one outside),
	     * clips the line betweeen the two points so that the new points are both
	     * inside the valid range.
	     * 
	     * Parameters:
	     * badComponent - {<OpenLayers.Geometry.Point>} original geometry of the
	     *     invalid point
	     * goodComponent - {<OpenLayers.Geometry.Point>} original geometry of the
	     *     valid point
	     * Returns
	     * {String} the SVG coordinate pair of the clipped point (like
	     *     getShortString), or an empty string if both passed componets are at
	     *     the same point.
	     */
	    clipLine: function(badComponent, goodComponent) {
	        if (goodComponent.equals(badComponent)) {
	            return "";
	        }
	        var resolution = this.getResolution();
	        var maxX = this.MAX_PIXEL - this.translationParameters.x;
	        var maxY = this.MAX_PIXEL - this.translationParameters.y;
	        var x1 = (goodComponent.x - this.featureDx) / resolution + this.left;
	        var y1 = this.top - goodComponent.y / resolution;
	        var x2 = (badComponent.x - this.featureDx) / resolution + this.left;
	        var y2 = this.top - badComponent.y / resolution;
	        var k;
	        if (x2 < -maxX || x2 > maxX) {
	            k = (y2 - y1) / (x2 - x1);
	            x2 = x2 < 0 ? -maxX : maxX;
	            y2 = y1 + (x2 - x1) * k;
	        }
	        if (y2 < -maxY || y2 > maxY) {
	            k = (x2 - x1) / (y2 - y1);
	            y2 = y2 < 0 ? -maxY : maxY;
	            x2 = x1 + (y2 - y1) * k;
	        }
	        return x2 + "," + y2;
	    },

	    /** 
	     * Method: getShortString
	     * 
	     * Parameters:
	     * point - {<OpenLayers.Geometry.Point>}
	     * 
	     * Returns:
	     * {String} or false if point is outside the valid range
	     */
	    getShortString: function(point) {
	        var resolution = this.getResolution();
	        var x = ((point.x - this.featureDx) / resolution + this.left);
	        var y = (this.top - point.y / resolution);

	        if (this.inValidRange(x, y)) { 
	            return x + "," + y;
	        } else {
	            return false;
	        }
	    },
	    
	    /**
	     * Method: getPosition
	     * Finds the position of an svg node.
	     * 
	     * Parameters:
	     * node - {DOMElement}
	     * 
	     * Returns:
	     * {Object} hash with x and y properties, representing the coordinates
	     *     within the svg coordinate system
	     */
	    getPosition: function(node) {
	        return({
	            x: parseFloat(node.getAttributeNS(null, "cx")),
	            y: parseFloat(node.getAttributeNS(null, "cy"))
	        });
	    },

	    /**
	     * Method: importSymbol
	     * add a new symbol definition from the rendererer's symbol hash
	     * 
	     * Parameters:
	     * graphicName - {String} name of the symbol to import
	     * 
	     * Returns:
	     * {DOMElement} - the imported symbol
	     */      
	    importSymbol: function (graphicName)  {
	        if (!this.defs) {
	            // create svg defs tag
	            this.defs = this.createDefs();
	        }
	        var id = this.container.id + "-" + graphicName;
	        
	        // check if symbol already exists in the defs
	        var existing = document.getElementById(id);
	        if (existing != null) {
	            return existing;
	        }
	        
	        var symbol = OpenLayers.Renderer.symbol[graphicName];
	        if (!symbol) {
	            throw new Error(graphicName + ' is not a valid symbol name');
	        }

	        var symbolNode = this.nodeFactory(id, "symbol");
	        var node = this.nodeFactory(null, "polygon");
	        symbolNode.appendChild(node);
	        var symbolExtent = new OpenLayers.Bounds(
	                                    Number.MAX_VALUE, Number.MAX_VALUE, 0, 0);

	        var points = [];
	        var x,y;
	        for (var i=0; i<symbol.length; i=i+2) {
	            x = symbol[i];
	            y = symbol[i+1];
	            symbolExtent.left = Math.min(symbolExtent.left, x);
	            symbolExtent.bottom = Math.min(symbolExtent.bottom, y);
	            symbolExtent.right = Math.max(symbolExtent.right, x);
	            symbolExtent.top = Math.max(symbolExtent.top, y);
	            points.push(x, ",", y);
	        }
	        
	        node.setAttributeNS(null, "points", points.join(" "));
	        
	        var width = symbolExtent.getWidth();
	        var height = symbolExtent.getHeight();
	        // create a viewBox three times as large as the symbol itself,
	        // to allow for strokeWidth being displayed correctly at the corners.
	        var viewBox = [symbolExtent.left - width,
	                        symbolExtent.bottom - height, width * 3, height * 3];
	        symbolNode.setAttributeNS(null, "viewBox", viewBox.join(" "));
	        this.symbolMetrics[id] = [
	            Math.max(width, height),
	            symbolExtent.getCenterLonLat().lon,
	            symbolExtent.getCenterLonLat().lat
	        ];
	        
	        this.defs.appendChild(symbolNode);
	        return symbolNode;
	    },
	    
	    /**
	     * Method: getFeatureIdFromEvent
	     * 
	     * Parameters:
	     * evt - {Object} An <OpenLayers.Event> object
	     *
	     * Returns:
	     * {String} A feature id or undefined.
	     */
	    getFeatureIdFromEvent: function(evt) {
	        var featureId = OpenLayers.Renderer.Elements.prototype.getFeatureIdFromEvent.apply(this, arguments);
	        if(!featureId) {
	            var target = evt.target;
	            featureId = target.parentNode && target != this.rendererRoot ?
	                target.parentNode._featureId : undefined;
	        }
	        return featureId;
	    },

	    CLASS_NAME: "OpenLayers.Renderer.SVG"
	});

	/**
	 * Constant: OpenLayers.Renderer.SVG.LABEL_ALIGN
	 * {Object}
	 */
	OpenLayers.Renderer.SVG.LABEL_ALIGN = {
	    "l": "start",
	    "r": "end",
	    "b": "bottom",
	    "t": "hanging"
	};

	/**
	 * Constant: OpenLayers.Renderer.SVG.LABEL_VSHIFT
	 * {Object}
	 */
	OpenLayers.Renderer.SVG.LABEL_VSHIFT = {
	    // according to
	    // http://www.w3.org/Graphics/SVG/Test/20061213/htmlObjectHarness/full-text-align-02-b.html
	    // a baseline-shift of -70% shifts the text exactly from the
	    // bottom to the top of the baseline, so -35% moves the text to
	    // the center of the baseline.
	    "t": "-70%",
	    "b": "0"    
	};

	/**
	 * Constant: OpenLayers.Renderer.SVG.LABEL_VFACTOR
	 * {Object}
	 */
	OpenLayers.Renderer.SVG.LABEL_VFACTOR = {
	    "t": 0,
	    "b": -1
	};

	/**
	 * Function: OpenLayers.Renderer.SVG.preventDefault
	 * *Deprecated*.  Use <OpenLayers.Event.preventDefault> method instead.
	 * Used to prevent default events (especially opening images in a new tab on
	 * ctrl-click) from being executed for externalGraphic symbols
	 */
	OpenLayers.Renderer.SVG.preventDefault = function(e) {
	    OpenLayers.Event.preventDefault(e);
	};
	/* ======================================================================
	    OpenLayers/Popup.js
	   ====================================================================== */

	/* Copyright (c) 2006-2015 by OpenLayers Contributors (see authors.txt for
	 * full list of contributors). Published under the 2-clause BSD license.
	 * See license.txt in the OpenLayers distribution or repository for the
	 * full text of the license. */

	/**
	 * @requires OpenLayers/BaseTypes/Class.js
	 */


	/**
	 * Class: OpenLayers.Popup
	 * A popup is a small div that can opened and closed on the map.
	 * Typically opened in response to clicking on a marker.  
	 * See <OpenLayers.Marker>.  Popup's don't require their own
	 * layer and are added the the map using the <OpenLayers.Map.addPopup>
	 * method.
	 *
	 * Example:
	 * (code)
	 * popup = new OpenLayers.Popup("chicken", 
	 *                    new OpenLayers.LonLat(5,40),
	 *                    new OpenLayers.Size(200,200),
	 *                    "example popup",
	 *                    true);
	 *       
	 * map.addPopup(popup);
	 * (end)
	 */
	OpenLayers.Popup = OpenLayers.Class({

	    /** 
	     * Property: events  
	     * {<OpenLayers.Events>} custom event manager 
	     */
	    events: null,
	    
	    /** Property: id
	     * {String} the unique identifier assigned to this popup.
	     */
	    id: "",

	    /** 
	     * Property: lonlat 
	     * {<OpenLayers.LonLat>} the position of this popup on the map
	     */
	    lonlat: null,

	    /** 
	     * Property: div 
	     * {DOMElement} the div that contains this popup.
	     */
	    div: null,

	    /** 
	     * Property: contentSize 
	     * {<OpenLayers.Size>} the width and height of the content.
	     */
	    contentSize: null,    

	    /** 
	     * Property: size 
	     * {<OpenLayers.Size>} the width and height of the popup.
	     */
	    size: null,    

	    /** 
	     * Property: contentHTML 
	     * {String} An HTML string for this popup to display.
	     */
	    contentHTML: null,
	    
	    /** 
	     * Property: backgroundColor 
	     * {String} the background color used by the popup.
	     */
	    backgroundColor: "",
	    
	    /** 
	     * Property: opacity 
	     * {float} the opacity of this popup (between 0.0 and 1.0)
	     */
	    opacity: "",

	    /** 
	     * Property: border 
	     * {String} the border size of the popup.  (eg 2px)
	     */
	    border: "",
	    
	    /** 
	     * Property: contentDiv 
	     * {DOMElement} a reference to the element that holds the content of
	     *              the div.
	     */
	    contentDiv: null,
	    
	    /** 
	     * Property: groupDiv 
	     * {DOMElement} First and only child of 'div'. The group Div contains the
	     *     'contentDiv' and the 'closeDiv'.
	     */
	    groupDiv: null,

	    /** 
	     * Property: closeDiv
	     * {DOMElement} the optional closer image
	     */
	    closeDiv: null,

	    /** 
	     * APIProperty: autoSize
	     * {Boolean} Resize the popup to auto-fit the contents.
	     *     Default is false.
	     */
	    autoSize: false,

	    /**
	     * APIProperty: minSize
	     * {<OpenLayers.Size>} Minimum size allowed for the popup's contents.
	     */
	    minSize: null,

	    /**
	     * APIProperty: maxSize
	     * {<OpenLayers.Size>} Maximum size allowed for the popup's contents.
	     */
	    maxSize: null,

	    /** 
	     * Property: displayClass
	     * {String} The CSS class of the popup.
	     */
	    displayClass: "olPopup",

	    /** 
	     * Property: contentDisplayClass
	     * {String} The CSS class of the popup content div.
	     */
	    contentDisplayClass: "olPopupContent",

	    /** 
	     * Property: padding 
	     * {int or <OpenLayers.Bounds>} An extra opportunity to specify internal 
	     *     padding of the content div inside the popup. This was originally
	     *     confused with the css padding as specified in style.css's 
	     *     'olPopupContent' class. We would like to get rid of this altogether,
	     *     except that it does come in handy for the framed and anchoredbubble
	     *     popups, who need to maintain yet another barrier between their 
	     *     content and the outer border of the popup itself. 
	     * 
	     *     Note that in order to not break API, we must continue to support 
	     *     this property being set as an integer. Really, though, we'd like to 
	     *     have this specified as a Bounds object so that user can specify
	     *     distinct left, top, right, bottom paddings. With the 3.0 release
	     *     we can make this only a bounds.
	     */
	    padding: 0,

	    /** 
	     * Property: disableFirefoxOverflowHack
	     * {Boolean} The hack for overflow in Firefox causes all elements 
	     *     to be re-drawn, which causes Flash elements to be 
	     *     re-initialized, which is troublesome.
	     *     With this property the hack can be disabled.
	     */
	    disableFirefoxOverflowHack: false,

	    /**
	     * Method: fixPadding
	     * To be removed in 3.0, this function merely helps us to deal with the 
	     *     case where the user may have set an integer value for padding, 
	     *     instead of an <OpenLayers.Bounds> object.
	     */
	    fixPadding: function() {
	        if (typeof this.padding == "number") {
	            this.padding = new OpenLayers.Bounds(
	                this.padding, this.padding, this.padding, this.padding
	            );
	        }
	    },

	    /**
	     * APIProperty: panMapIfOutOfView
	     * {Boolean} When drawn, pan map such that the entire popup is visible in
	     *     the current viewport (if necessary).
	     *     Default is false.
	     */
	    panMapIfOutOfView: false,
	    
	    /**
	     * APIProperty: keepInMap 
	     * {Boolean} If panMapIfOutOfView is false, and this property is true, 
	     *     contrain the popup such that it always fits in the available map
	     *     space. By default, this is not set on the base class. If you are
	     *     creating popups that are near map edges and not allowing pannning,
	     *     and especially if you have a popup which has a
	     *     fixedRelativePosition, setting this to false may be a smart thing to
	     *     do. Subclasses may want to override this setting.
	     *   
	     *     Default is false.
	     */
	    keepInMap: false,

	    /**
	     * APIProperty: closeOnMove
	     * {Boolean} When map pans, close the popup.
	     *     Default is false.
	     */
	    closeOnMove: false,
	    
	    /** 
	     * Property: map 
	     * {<OpenLayers.Map>} this gets set in Map.js when the popup is added to the map
	     */
	    map: null,

	    /** 
	    * Constructor: OpenLayers.Popup
	    * Create a popup.
	    * 
	    * Parameters: 
	    * id - {String} a unqiue identifier for this popup.  If null is passed
	    *               an identifier will be automatically generated. 
	    * lonlat - {<OpenLayers.LonLat>}  The position on the map the popup will
	    *                                 be shown.
	    * contentSize - {<OpenLayers.Size>} The size of the content.
	    * contentHTML - {String}          An HTML string to display inside the   
	    *                                 popup.
	    * closeBox - {Boolean}            Whether to display a close box inside
	    *                                 the popup.
	    * closeBoxCallback - {Function}   Function to be called on closeBox click.
	    */
	    initialize:function(id, lonlat, contentSize, contentHTML, closeBox, closeBoxCallback) {
	        if (id == null) {
	            id = OpenLayers.Util.createUniqueID(this.CLASS_NAME + "_");
	        }

	        this.id = id;
	        this.lonlat = lonlat;

	        this.contentSize = (contentSize != null) ? contentSize 
	                                  : new OpenLayers.Size(
	                                                   OpenLayers.Popup.WIDTH,
	                                                   OpenLayers.Popup.HEIGHT);
	        if (contentHTML != null) { 
	             this.contentHTML = contentHTML;
	        }
	        this.backgroundColor = OpenLayers.Popup.COLOR;
	        this.opacity = OpenLayers.Popup.OPACITY;
	        this.border = OpenLayers.Popup.BORDER;

	        this.div = OpenLayers.Util.createDiv(this.id, null, null, 
	                                             null, null, null, "hidden");
	        this.div.className = this.displayClass;
	        
	        var groupDivId = this.id + "_GroupDiv";
	        this.groupDiv = OpenLayers.Util.createDiv(groupDivId, null, null, 
	                                                    null, "relative", null,
	                                                    "hidden");

	        var id = this.div.id + "_contentDiv";
	        this.contentDiv = OpenLayers.Util.createDiv(id, null, this.contentSize.clone(), 
	                                                    null, "relative");
	        this.contentDiv.className = this.contentDisplayClass;
	        this.groupDiv.appendChild(this.contentDiv);
	        this.div.appendChild(this.groupDiv);

	        if (closeBox) {
	            this.addCloseBox(closeBoxCallback);
	        } 

	        this.registerEvents();
	    },

	    /** 
	     * Method: destroy
	     * nullify references to prevent circular references and memory leaks
	     */
	    destroy: function() {

	        this.id = null;
	        this.lonlat = null;
	        this.size = null;
	        this.contentHTML = null;
	        
	        this.backgroundColor = null;
	        this.opacity = null;
	        this.border = null;
	        
	        if (this.closeOnMove && this.map) {
	            this.map.events.unregister("movestart", this, this.hide);
	        }

	        this.events.destroy();
	        this.events = null;
	        
	        if (this.closeDiv) {
	            OpenLayers.Event.stopObservingElement(this.closeDiv); 
	            this.groupDiv.removeChild(this.closeDiv);
	        }
	        this.closeDiv = null;
	        
	        this.div.removeChild(this.groupDiv);
	        this.groupDiv = null;

	        if (this.map != null) {
	            this.map.removePopup(this);
	        }
	        this.map = null;
	        this.div = null;
	        
	        this.autoSize = null;
	        this.minSize = null;
	        this.maxSize = null;
	        this.padding = null;
	        this.panMapIfOutOfView = null;
	    },

	    /** 
	    * Method: draw
	    * Constructs the elements that make up the popup.
	    *
	    * Parameters:
	    * px - {<OpenLayers.Pixel>} the position the popup in pixels.
	    * 
	    * Returns:
	    * {DOMElement} Reference to a div that contains the drawn popup
	    */
	    draw: function(px) {
	        if (px == null) {
	            if ((this.lonlat != null) && (this.map != null)) {
	                px = this.map.getLayerPxFromLonLat(this.lonlat);
	            }
	        }

	        // this assumes that this.map already exists, which is okay because 
	        // this.draw is only called once the popup has been added to the map.
	        if (this.closeOnMove) {
	            this.map.events.register("movestart", this, this.hide);
	        }
	        
	        //listen to movestart, moveend to disable overflow (FF bug)
	        if (!this.disableFirefoxOverflowHack && OpenLayers.BROWSER_NAME == 'firefox') {
	            this.map.events.register("movestart", this, function() {
	                var style = document.defaultView.getComputedStyle(
	                    this.contentDiv, null
	                );
	                var currentOverflow = style.getPropertyValue("overflow");
	                if (currentOverflow != "hidden") {
	                    this.contentDiv._oldOverflow = currentOverflow;
	                    this.contentDiv.style.overflow = "hidden";
	                }
	            });
	            this.map.events.register("moveend", this, function() {
	                var oldOverflow = this.contentDiv._oldOverflow;
	                if (oldOverflow) {
	                    this.contentDiv.style.overflow = oldOverflow;
	                    this.contentDiv._oldOverflow = null;
	                }
	            });
	        }

	        this.moveTo(px);
	        if (!this.autoSize && !this.size) {
	            this.setSize(this.contentSize);
	        }
	        this.setBackgroundColor();
	        this.setOpacity();
	        this.setBorder();
	        this.setContentHTML();
	        
	        if (this.panMapIfOutOfView) {
	            this.panIntoView();
	        }    

	        return this.div;
	    },

	    /** 
	     * Method: updatePosition
	     * if the popup has a lonlat and its map members set, 
	     * then have it move itself to its proper position
	     */
	    updatePosition: function() {
	        if ((this.lonlat) && (this.map)) {
	            var px = this.map.getLayerPxFromLonLat(this.lonlat);
	            if (px) {
	                this.moveTo(px);           
	            }    
	        }
	    },

	    /**
	     * Method: moveTo
	     * 
	     * Parameters:
	     * px - {<OpenLayers.Pixel>} the top and left position of the popup div. 
	     */
	    moveTo: function(px) {
	        if ((px != null) && (this.div != null)) {
	            this.div.style.left = px.x + "px";
	            this.div.style.top = px.y + "px";
	        }
	    },

	    /**
	     * Method: visible
	     *
	     * Returns:      
	     * {Boolean} Boolean indicating whether or not the popup is visible
	     */
	    visible: function() {
	        return OpenLayers.Element.visible(this.div);
	    },

	    /**
	     * Method: toggle
	     * Toggles visibility of the popup.
	     */
	    toggle: function() {
	        if (this.visible()) {
	            this.hide();
	        } else {
	            this.show();
	        }
	    },

	    /**
	     * Method: show
	     * Makes the popup visible.
	     */
	    show: function() {
	        this.div.style.display = '';

	        if (this.panMapIfOutOfView) {
	            this.panIntoView();
	        }    
	    },

	    /**
	     * Method: hide
	     * Makes the popup invisible.
	     */
	    hide: function() {
	        this.div.style.display = 'none';
	    },

	    /**
	     * Method: setSize
	     * Used to adjust the size of the popup. 
	     *
	     * Parameters:
	     * contentSize - {<OpenLayers.Size>} the new size for the popup's 
	     *     contents div (in pixels).
	     */
	    setSize:function(contentSize) { 
	        this.size = contentSize.clone(); 
	        
	        // if our contentDiv has a css 'padding' set on it by a stylesheet, we 
	        //  must add that to the desired "size". 
	        var contentDivPadding = this.getContentDivPadding();
	        var wPadding = contentDivPadding.left + contentDivPadding.right;
	        var hPadding = contentDivPadding.top + contentDivPadding.bottom;

	        // take into account the popup's 'padding' property
	        this.fixPadding();
	        wPadding += this.padding.left + this.padding.right;
	        hPadding += this.padding.top + this.padding.bottom;

	        // make extra space for the close div
	        if (this.closeDiv) {
	            var closeDivWidth = parseInt(this.closeDiv.style.width);
	            wPadding += closeDivWidth + contentDivPadding.right;
	        }

	        //increase size of the main popup div to take into account the 
	        // users's desired padding and close div.        
	        this.size.w += wPadding;
	        this.size.h += hPadding;

	        //now if our browser is IE, we need to actually make the contents 
	        // div itself bigger to take its own padding into effect. this makes 
	        // me want to shoot someone, but so it goes.
	        if (OpenLayers.BROWSER_NAME == "msie") {
	            this.contentSize.w += 
	                contentDivPadding.left + contentDivPadding.right;
	            this.contentSize.h += 
	                contentDivPadding.bottom + contentDivPadding.top;
	        }

	        if (this.div != null) {
	            this.div.style.width = this.size.w + "px";
	            this.div.style.height = this.size.h + "px";
	        }
	        if (this.contentDiv != null){
	            this.contentDiv.style.width = contentSize.w + "px";
	            this.contentDiv.style.height = contentSize.h + "px";
	        }
	    },  

	    /**
	     * APIMethod: updateSize
	     * Auto size the popup so that it precisely fits its contents (as 
	     *     determined by this.contentDiv.innerHTML). Popup size will, of
	     *     course, be limited by the available space on the current map
	     */
	    updateSize: function() {
	        
	        // determine actual render dimensions of the contents by putting its
	        // contents into a fake contentDiv (for the CSS) and then measuring it
	        var preparedHTML = "<div class='" + this.contentDisplayClass+ "'>" + 
	            this.contentDiv.innerHTML + 
	            "</div>";
	 
	        var containerElement = (this.map) ? this.map.div : document.body;
	        var realSize = OpenLayers.Util.getRenderedDimensions(
	            preparedHTML, null, {
	                displayClass: this.displayClass,
	                containerElement: containerElement
	            }
	        );

	        // is the "real" size of the div is safe to display in our map?
	        var safeSize = this.getSafeContentSize(realSize);

	        var newSize = null;
	        if (safeSize.equals(realSize)) {
	            //real size of content is small enough to fit on the map, 
	            // so we use real size.
	            newSize = realSize;

	        } else {

	            // make a new 'size' object with the clipped dimensions 
	            // set or null if not clipped.
	            var fixedSize = {
	                w: (safeSize.w < realSize.w) ? safeSize.w : null,
	                h: (safeSize.h < realSize.h) ? safeSize.h : null
	            };
	        
	            if (fixedSize.w && fixedSize.h) {
	                //content is too big in both directions, so we will use 
	                // max popup size (safeSize), knowing well that it will 
	                // overflow both ways.                
	                newSize = safeSize;
	            } else {
	                //content is clipped in only one direction, so we need to 
	                // run getRenderedDimensions() again with a fixed dimension
	                var clippedSize = OpenLayers.Util.getRenderedDimensions(
	                    preparedHTML, fixedSize, {
	                        displayClass: this.contentDisplayClass,
	                        containerElement: containerElement
	                    }
	                );
	                
	                //if the clipped size is still the same as the safeSize, 
	                // that means that our content must be fixed in the 
	                // offending direction. If overflow is 'auto', this means 
	                // we are going to have a scrollbar for sure, so we must 
	                // adjust for that.
	                //
	                var currentOverflow = OpenLayers.Element.getStyle(
	                    this.contentDiv, "overflow"
	                );
	                if ( (currentOverflow != "hidden") && 
	                     (clippedSize.equals(safeSize)) ) {
	                    var scrollBar = OpenLayers.Util.getScrollbarWidth();
	                    if (fixedSize.w) {
	                        clippedSize.h += scrollBar;
	                    } else {
	                        clippedSize.w += scrollBar;
	                    }
	                }
	                
	                newSize = this.getSafeContentSize(clippedSize);
	            }
	        }                        
	        this.setSize(newSize);     
	    },    

	    /**
	     * Method: setBackgroundColor
	     * Sets the background color of the popup.
	     *
	     * Parameters:
	     * color - {String} the background color.  eg "#FFBBBB"
	     */
	    setBackgroundColor:function(color) { 
	        if (color != undefined) {
	            this.backgroundColor = color; 
	        }
	        
	        if (this.div != null) {
	            this.div.style.backgroundColor = this.backgroundColor;
	        }
	    },  
	    
	    /**
	     * Method: setOpacity
	     * Sets the opacity of the popup.
	     * 
	     * Parameters:
	     * opacity - {float} A value between 0.0 (transparent) and 1.0 (solid).   
	     */
	    setOpacity:function(opacity) { 
	        if (opacity != undefined) {
	            this.opacity = opacity; 
	        }
	        
	        if (this.div != null) {
	            // for Mozilla and Safari
	            this.div.style.opacity = this.opacity;

	            // for IE
	            this.div.style.filter = 'alpha(opacity=' + this.opacity*100 + ')';
	        }
	    },  
	    
	    /**
	     * Method: setBorder
	     * Sets the border style of the popup.
	     *
	     * Parameters:
	     * border - {String} The border style value. eg 2px 
	     */
	    setBorder:function(border) { 
	        if (border != undefined) {
	            this.border = border;
	        }
	        
	        if (this.div != null) {
	            this.div.style.border = this.border;
	        }
	    },      
	    
	    /**
	     * Method: setContentHTML
	     * Allows the user to set the HTML content of the popup.
	     *
	     * Parameters:
	     * contentHTML - {String} HTML for the div.
	     */
	    setContentHTML:function(contentHTML) {

	        if (contentHTML != null) {
	            this.contentHTML = contentHTML;
	        }
	       
	        if ((this.contentDiv != null) && 
	            (this.contentHTML != null) &&
	            (this.contentHTML != this.contentDiv.innerHTML)) {
	       
	            this.contentDiv.innerHTML = this.contentHTML;
	       
	            if (this.autoSize) {
	                
	                //if popup has images, listen for when they finish
	                // loading and resize accordingly
	                this.registerImageListeners();

	                //auto size the popup to its current contents
	                this.updateSize();
	            }
	        }    

	    },
	    
	    /**
	     * Method: registerImageListeners
	     * Called when an image contained by the popup loaded. this function
	     *     updates the popup size, then unregisters the image load listener.
	     */   
	    registerImageListeners: function() { 

	        // As the images load, this function will call updateSize() to 
	        // resize the popup to fit the content div (which presumably is now
	        // bigger than when the image was not loaded).
	        // 
	        // If the 'panMapIfOutOfView' property is set, we will pan the newly
	        // resized popup back into view.
	        // 
	        // Note that this function, when called, will have 'popup' and 
	        // 'img' properties in the context.
	        //
	        var onImgLoad = function() {
	            if (this.popup.id === null) { // this.popup has been destroyed!
	                return;
	            }
	            this.popup.updateSize();
	     
	            if ( this.popup.visible() && this.popup.panMapIfOutOfView ) {
	                this.popup.panIntoView();
	            }

	            OpenLayers.Event.stopObserving(
	                this.img, "load", this.img._onImgLoad
	            );
	    
	        };

	        //cycle through the images and if their size is 0x0, that means that 
	        // they haven't been loaded yet, so we attach the listener, which 
	        // will fire when the images finish loading and will resize the 
	        // popup accordingly to its new size.
	        var images = this.contentDiv.getElementsByTagName("img");
	        for (var i = 0, len = images.length; i < len; i++) {
	            var img = images[i];
	            if (img.width == 0 || img.height == 0) {

	                var context = {
	                    'popup': this,
	                    'img': img
	                };

	                //expando this function to the image itself before registering
	                // it. This way we can easily and properly unregister it.
	                img._onImgLoad = OpenLayers.Function.bind(onImgLoad, context);

	                OpenLayers.Event.observe(img, 'load', img._onImgLoad);
	            }    
	        } 
	    },

	    /**
	     * APIMethod: getSafeContentSize
	     * 
	     * Parameters:
	     * size - {<OpenLayers.Size>} Desired size to make the popup.
	     * 
	     * Returns:
	     * {<OpenLayers.Size>} A size to make the popup which is neither smaller
	     *     than the specified minimum size, nor bigger than the maximum 
	     *     size (which is calculated relative to the size of the viewport).
	     */
	    getSafeContentSize: function(size) {

	        var safeContentSize = size.clone();

	        // if our contentDiv has a css 'padding' set on it by a stylesheet, we 
	        //  must add that to the desired "size". 
	        var contentDivPadding = this.getContentDivPadding();
	        var wPadding = contentDivPadding.left + contentDivPadding.right;
	        var hPadding = contentDivPadding.top + contentDivPadding.bottom;

	        // take into account the popup's 'padding' property
	        this.fixPadding();
	        wPadding += this.padding.left + this.padding.right;
	        hPadding += this.padding.top + this.padding.bottom;

	        if (this.closeDiv) {
	            var closeDivWidth = parseInt(this.closeDiv.style.width);
	            wPadding += closeDivWidth + contentDivPadding.right;
	        }

	        // prevent the popup from being smaller than a specified minimal size
	        if (this.minSize) {
	            safeContentSize.w = Math.max(safeContentSize.w, 
	                (this.minSize.w - wPadding));
	            safeContentSize.h = Math.max(safeContentSize.h, 
	                (this.minSize.h - hPadding));
	        }

	        // prevent the popup from being bigger than a specified maximum size
	        if (this.maxSize) {
	            safeContentSize.w = Math.min(safeContentSize.w, 
	                (this.maxSize.w - wPadding));
	            safeContentSize.h = Math.min(safeContentSize.h, 
	                (this.maxSize.h - hPadding));
	        }
	        
	        //make sure the desired size to set doesn't result in a popup that 
	        // is bigger than the map's viewport.
	        //
	        if (this.map && this.map.size) {
	            
	            var extraX = 0, extraY = 0;
	            if (this.keepInMap && !this.panMapIfOutOfView) {
	                var px = this.map.getPixelFromLonLat(this.lonlat);
	                switch (this.relativePosition) {
	                    case "tr":
	                        extraX = px.x;
	                        extraY = this.map.size.h - px.y;
	                        break;
	                    case "tl":
	                        extraX = this.map.size.w - px.x;
	                        extraY = this.map.size.h - px.y;
	                        break;
	                    case "bl":
	                        extraX = this.map.size.w - px.x;
	                        extraY = px.y;
	                        break;
	                    case "br":
	                        extraX = px.x;
	                        extraY = px.y;
	                        break;
	                    default:    
	                        extraX = px.x;
	                        extraY = this.map.size.h - px.y;
	                        break;
	                }
	            }    
	          
	            var maxY = this.map.size.h - 
	                this.map.paddingForPopups.top - 
	                this.map.paddingForPopups.bottom - 
	                hPadding - extraY;
	            
	            var maxX = this.map.size.w - 
	                this.map.paddingForPopups.left - 
	                this.map.paddingForPopups.right - 
	                wPadding - extraX;
	            
	            safeContentSize.w = Math.min(safeContentSize.w, maxX);
	            safeContentSize.h = Math.min(safeContentSize.h, maxY);
	        }
	        
	        return safeContentSize;
	    },
	    
	    /**
	     * Method: getContentDivPadding
	     * Glorious, oh glorious hack in order to determine the css 'padding' of 
	     *     the contentDiv. IE/Opera return null here unless we actually add the 
	     *     popup's main 'div' element (which contains contentDiv) to the DOM. 
	     *     So we make it invisible and then add it to the document temporarily. 
	     *
	     *     Once we've taken the padding readings we need, we then remove it 
	     *     from the DOM (it will actually get added to the DOM in 
	     *     Map.js's addPopup)
	     *
	     * Returns:
	     * {<OpenLayers.Bounds>}
	     */
	    getContentDivPadding: function() {

	        //use cached value if we have it
	        var contentDivPadding = this._contentDivPadding;
	        if (!contentDivPadding) {

	            if (this.div.parentNode == null) {
	                //make the div invisible and add it to the page        
	                this.div.style.display = "none";
	                document.body.appendChild(this.div);
	            }
	                    
	            //read the padding settings from css, put them in an OL.Bounds        
	            contentDivPadding = new OpenLayers.Bounds(
	                OpenLayers.Element.getStyle(this.contentDiv, "padding-left"),
	                OpenLayers.Element.getStyle(this.contentDiv, "padding-bottom"),
	                OpenLayers.Element.getStyle(this.contentDiv, "padding-right"),
	                OpenLayers.Element.getStyle(this.contentDiv, "padding-top")
	            );
	    
	            //cache the value
	            this._contentDivPadding = contentDivPadding;

	            if (this.div.parentNode == document.body) {
	                //remove the div from the page and make it visible again
	                document.body.removeChild(this.div);
	                this.div.style.display = "";
	            }
	        }
	        return contentDivPadding;
	    },

	    /**
	     * Method: addCloseBox
	     * 
	     * Parameters:
	     * callback - {Function} The callback to be called when the close button
	     *     is clicked.
	     */
	    addCloseBox: function(callback) {

	        this.closeDiv = OpenLayers.Util.createDiv(
	            this.id + "_close", null, {w: 17, h: 17}
	        );
	        this.closeDiv.className = "olPopupCloseBox"; 
	        
	        // use the content div's css padding to determine if we should
	        //  padd the close div
	        var contentDivPadding = this.getContentDivPadding();
	         
	        this.closeDiv.style.right = contentDivPadding.right + "px";
	        this.closeDiv.style.top = contentDivPadding.top + "px";
	        this.groupDiv.appendChild(this.closeDiv);

	        var closePopup = callback || function(e) {
	            this.hide();
	            OpenLayers.Event.stop(e);
	        };
	        OpenLayers.Event.observe(this.closeDiv, "touchend", 
	                OpenLayers.Function.bindAsEventListener(closePopup, this));
	        OpenLayers.Event.observe(this.closeDiv, "click", 
	                OpenLayers.Function.bindAsEventListener(closePopup, this));
	    },

	    /**
	     * Method: panIntoView
	     * Pans the map such that the popup is totaly viewable (if necessary)
	     */
	    panIntoView: function() {
	        
	        var mapSize = this.map.getSize();
	    
	        //start with the top left corner of the popup, in px, 
	        // relative to the viewport
	        var origTL = this.map.getViewPortPxFromLayerPx( new OpenLayers.Pixel(
	            parseInt(this.div.style.left),
	            parseInt(this.div.style.top)
	        ));
	        var newTL = origTL.clone();
	    
	        //new left (compare to margins, using this.size to calculate right)
	        if (origTL.x < this.map.paddingForPopups.left) {
	            newTL.x = this.map.paddingForPopups.left;
	        } else 
	        if ( (origTL.x + this.size.w) > (mapSize.w - this.map.paddingForPopups.right)) {
	            newTL.x = mapSize.w - this.map.paddingForPopups.right - this.size.w;
	        }
	        
	        //new top (compare to margins, using this.size to calculate bottom)
	        if (origTL.y < this.map.paddingForPopups.top) {
	            newTL.y = this.map.paddingForPopups.top;
	        } else 
	        if ( (origTL.y + this.size.h) > (mapSize.h - this.map.paddingForPopups.bottom)) {
	            newTL.y = mapSize.h - this.map.paddingForPopups.bottom - this.size.h;
	        }
	        
	        var dx = origTL.x - newTL.x;
	        var dy = origTL.y - newTL.y;
	        
	        this.map.pan(dx, dy);
	    },

	    /** 
	     * Method: registerEvents
	     * Registers events on the popup.
	     *
	     * Do this in a separate function so that subclasses can 
	     *   choose to override it if they wish to deal differently
	     *   with mouse events
	     * 
	     *   Note in the following handler functions that some special
	     *    care is needed to deal correctly with mousing and popups. 
	     *   
	     *   Because the user might select the zoom-rectangle option and
	     *    then drag it over a popup, we need a safe way to allow the
	     *    mousemove and mouseup events to pass through the popup when
	     *    they are initiated from outside. The same procedure is needed for
	     *    touchmove and touchend events.
	     * 
	     *   Otherwise, we want to essentially kill the event propagation
	     *    for all other events, though we have to do so carefully, 
	     *    without disabling basic html functionality, like clicking on 
	     *    hyperlinks or drag-selecting text.
	     */
	     registerEvents:function() {
	        this.events = new OpenLayers.Events(this, this.div, null, true);

	        function onTouchstart(evt) {
	            OpenLayers.Event.stop(evt, true);
	        }
	        this.events.on({
	            "mousedown": this.onmousedown,
	            "mousemove": this.onmousemove,
	            "mouseup": this.onmouseup,
	            "click": this.onclick,
	            "mouseout": this.onmouseout,
	            "dblclick": this.ondblclick,
	            "touchstart": onTouchstart,
	            scope: this
	        });
	        
	     },

	    /** 
	     * Method: onmousedown 
	     * When mouse goes down within the popup, make a note of
	     *   it locally, and then do not propagate the mousedown 
	     *   (but do so safely so that user can select text inside)
	     * 
	     * Parameters:
	     * evt - {Event} 
	     */
	    onmousedown: function (evt) {
	        this.mousedown = true;
	        OpenLayers.Event.stop(evt, true);
	    },

	    /** 
	     * Method: onmousemove
	     * If the drag was started within the popup, then 
	     *   do not propagate the mousemove (but do so safely
	     *   so that user can select text inside)
	     * 
	     * Parameters:
	     * evt - {Event} 
	     */
	    onmousemove: function (evt) {
	        if (this.mousedown) {
	            OpenLayers.Event.stop(evt, true);
	        }
	    },

	    /** 
	     * Method: onmouseup
	     * When mouse comes up within the popup, after going down 
	     *   in it, reset the flag, and then (once again) do not 
	     *   propagate the event, but do so safely so that user can 
	     *   select text inside
	     * 
	     * Parameters:
	     * evt - {Event} 
	     */
	    onmouseup: function (evt) {
	        if (this.mousedown) {
	            this.mousedown = false;
	            OpenLayers.Event.stop(evt, true);
	        }
	    },

	    /**
	     * Method: onclick
	     * Ignore clicks, but allowing default browser handling
	     * 
	     * Parameters:
	     * evt - {Event} 
	     */
	    onclick: function (evt) {
	        OpenLayers.Event.stop(evt, true);
	    },

	    /** 
	     * Method: onmouseout
	     * When mouse goes out of the popup set the flag to false so that
	     *   if they let go and then drag back in, we won't be confused.
	     * 
	     * Parameters:
	     * evt - {Event} 
	     */
	    onmouseout: function (evt) {
	        this.mousedown = false;
	    },
	    
	    /** 
	     * Method: ondblclick
	     * Ignore double-clicks, but allowing default browser handling
	     * 
	     * Parameters:
	     * evt - {Event} 
	     */
	    ondblclick: function (evt) {
	        OpenLayers.Event.stop(evt, true);
	    },

	    CLASS_NAME: "OpenLayers.Popup"
	});

	OpenLayers.Popup.WIDTH = 200;
	OpenLayers.Popup.HEIGHT = 200;
	OpenLayers.Popup.COLOR = "white";
	OpenLayers.Popup.OPACITY = 1;
	OpenLayers.Popup.BORDER = "0px";
	/* ======================================================================
	    OpenLayers/Popup/Anchored.js
	   ====================================================================== */

	/* Copyright (c) 2006-2015 by OpenLayers Contributors (see authors.txt for
	 * full list of contributors). Published under the 2-clause BSD license.
	 * See license.txt in the OpenLayers distribution or repository for the
	 * full text of the license. */


	/**
	 * @requires OpenLayers/Popup.js
	 */

	/**
	 * Class: OpenLayers.Popup.Anchored
	 * 
	 * Inherits from:
	 *  - <OpenLayers.Popup>
	 */
	OpenLayers.Popup.Anchored = 
	  OpenLayers.Class(OpenLayers.Popup, {

	    /** 
	     * Property: relativePosition
	     * {String} Relative position of the popup ("br", "tr", "tl" or "bl").
	     */
	    relativePosition: null,
	    
	    /**
	     * APIProperty: keepInMap 
	     * {Boolean} If panMapIfOutOfView is false, and this property is true, 
	     *     contrain the popup such that it always fits in the available map
	     *     space. By default, this is set. If you are creating popups that are
	     *     near map edges and not allowing pannning, and especially if you have
	     *     a popup which has a fixedRelativePosition, setting this to false may
	     *     be a smart thing to do.
	     *   
	     *     For anchored popups, default is true, since subclasses will
	     *     usually want this functionality.
	     */
	    keepInMap: true,

	    /**
	     * Property: anchor
	     * {Object} Object to which we'll anchor the popup. Must expose a 
	     *     'size' (<OpenLayers.Size>) and 'offset' (<OpenLayers.Pixel>).
	     */
	    anchor: null,

	    /** 
	    * Constructor: OpenLayers.Popup.Anchored
	    * 
	    * Parameters:
	    * id - {String}
	    * lonlat - {<OpenLayers.LonLat>}
	    * contentSize - {<OpenLayers.Size>}
	    * contentHTML - {String}
	    * anchor - {Object} Object which must expose a 'size' <OpenLayers.Size> 
	    *     and 'offset' <OpenLayers.Pixel> (generally an <OpenLayers.Icon>).
	    * closeBox - {Boolean}
	    * closeBoxCallback - {Function} Function to be called on closeBox click.
	    */
	    initialize:function(id, lonlat, contentSize, contentHTML, anchor, closeBox,
	                        closeBoxCallback) {
	        var newArguments = [
	            id, lonlat, contentSize, contentHTML, closeBox, closeBoxCallback
	        ];
	        OpenLayers.Popup.prototype.initialize.apply(this, newArguments);

	        this.anchor = (anchor != null) ? anchor 
	                                       : { size: new OpenLayers.Size(0,0),
	                                           offset: new OpenLayers.Pixel(0,0)};
	    },

	    /**
	     * APIMethod: destroy
	     */
	    destroy: function() {
	        this.anchor = null;
	        this.relativePosition = null;
	        
	        OpenLayers.Popup.prototype.destroy.apply(this, arguments);        
	    },

	    /**
	     * APIMethod: show
	     * Overridden from Popup since user might hide popup and then show() it 
	     *     in a new location (meaning we might want to update the relative
	     *     position on the show)
	     */
	    show: function() {
	        this.updatePosition();
	        OpenLayers.Popup.prototype.show.apply(this, arguments);
	    },

	    /**
	     * Method: moveTo
	     * Since the popup is moving to a new px, it might need also to be moved
	     *     relative to where the marker is. We first calculate the new 
	     *     relativePosition, and then we calculate the new px where we will 
	     *     put the popup, based on the new relative position. 
	     * 
	     *     If the relativePosition has changed, we must also call 
	     *     updateRelativePosition() to make any visual changes to the popup 
	     *     which are associated with putting it in a new relativePosition.
	     * 
	     * Parameters:
	     * px - {<OpenLayers.Pixel>}
	     */
	    moveTo: function(px) {
	        var oldRelativePosition = this.relativePosition;
	        this.relativePosition = this.calculateRelativePosition(px);

	        OpenLayers.Popup.prototype.moveTo.call(this, this.calculateNewPx(px));
	        
	        //if this move has caused the popup to change its relative position, 
	        // we need to make the appropriate cosmetic changes.
	        if (this.relativePosition != oldRelativePosition) {
	            this.updateRelativePosition();
	        }
	    },

	    /**
	     * APIMethod: setSize
	     * 
	     * Parameters:
	     * contentSize - {<OpenLayers.Size>} the new size for the popup's 
	     *     contents div (in pixels).
	     */
	    setSize:function(contentSize) { 
	        OpenLayers.Popup.prototype.setSize.apply(this, arguments);

	        if ((this.lonlat) && (this.map)) {
	            var px = this.map.getLayerPxFromLonLat(this.lonlat);
	            this.moveTo(px);
	        }
	    },  
	    
	    /** 
	     * Method: calculateRelativePosition
	     * 
	     * Parameters:
	     * px - {<OpenLayers.Pixel>}
	     * 
	     * Returns:
	     * {String} The relative position ("br" "tr" "tl" "bl") at which the popup
	     *     should be placed.
	     */
	    calculateRelativePosition:function(px) {
	        var lonlat = this.map.getLonLatFromLayerPx(px);        
	        
	        var extent = this.map.getExtent();
	        var quadrant = extent.determineQuadrant(lonlat);
	        
	        return OpenLayers.Bounds.oppositeQuadrant(quadrant);
	    }, 

	    /**
	     * Method: updateRelativePosition
	     * The popup has been moved to a new relative location, so we may want to 
	     *     make some cosmetic adjustments to it. 
	     * 
	     *     Note that in the classic Anchored popup, there is nothing to do 
	     *     here, since the popup looks exactly the same in all four positions.
	     *     Subclasses such as Framed, however, will want to do something
	     *     special here.
	     */
	    updateRelativePosition: function() {
	        //to be overridden by subclasses
	    },

	    /** 
	     * Method: calculateNewPx
	     * 
	     * Parameters:
	     * px - {<OpenLayers.Pixel>}
	     * 
	     * Returns:
	     * {<OpenLayers.Pixel>} The the new px position of the popup on the screen
	     *     relative to the passed-in px.
	     */
	    calculateNewPx:function(px) {
	        var newPx = px.offset(this.anchor.offset);
	        
	        //use contentSize if size is not already set
	        var size = this.size || this.contentSize;

	        var top = (this.relativePosition.charAt(0) == 't');
	        newPx.y += (top) ? -size.h : this.anchor.size.h;
	        
	        var left = (this.relativePosition.charAt(1) == 'l');
	        newPx.x += (left) ? -size.w : this.anchor.size.w;

	        return newPx;   
	    },

	    CLASS_NAME: "OpenLayers.Popup.Anchored"
	});
	/* ======================================================================
	    OpenLayers/Popup/Framed.js
	   ====================================================================== */

	/* Copyright (c) 2006-2015 by OpenLayers Contributors (see authors.txt for
	 * full list of contributors). Published under the 2-clause BSD license.
	 * See license.txt in the OpenLayers distribution or repository for the
	 * full text of the license. */

	/**
	 * @requires OpenLayers/Popup/Anchored.js
	 */

	/**
	 * Class: OpenLayers.Popup.Framed
	 * 
	 * Inherits from:
	 *  - <OpenLayers.Popup.Anchored>
	 */
	OpenLayers.Popup.Framed =
	  OpenLayers.Class(OpenLayers.Popup.Anchored, {

	    /**
	     * Property: imageSrc
	     * {String} location of the image to be used as the popup frame
	     */
	    imageSrc: null,

	    /**
	     * Property: imageSize
	     * {<OpenLayers.Size>} Size (measured in pixels) of the image located
	     *     by the 'imageSrc' property.
	     */
	    imageSize: null,

	    /**
	     * APIProperty: isAlphaImage
	     * {Boolean} The image has some alpha and thus needs to use the alpha 
	     *     image hack. Note that setting this to true will have no noticeable
	     *     effect in FF or IE7 browsers, but will all but crush the ie6 
	     *     browser. 
	     *     Default is false.
	     */
	    isAlphaImage: false,

	    /**
	     * Property: positionBlocks
	     * {Object} Hash of different position blocks (Object/Hashs). Each block 
	     *     will be keyed by a two-character 'relativePosition' 
	     *     code string (ie "tl", "tr", "bl", "br"). Block properties are 
	     *     'offset', 'padding' (self-explanatory), and finally the 'blocks'
	     *     parameter, which is an array of the block objects. 
	     * 
	     *     Each block object must have 'size', 'anchor', and 'position' 
	     *     properties.
	     * 
	     *     Note that positionBlocks should never be modified at runtime.
	     */
	    positionBlocks: null,

	    /**
	     * Property: blocks
	     * {Array[Object]} Array of objects, each of which is one "block" of the 
	     *     popup. Each block has a 'div' and an 'image' property, both of 
	     *     which are DOMElements, and the latter of which is appended to the 
	     *     former. These are reused as the popup goes changing positions for
	     *     great economy and elegance.
	     */
	    blocks: null,

	    /** 
	     * APIProperty: fixedRelativePosition
	     * {Boolean} We want the framed popup to work dynamically placed relative
	     *     to its anchor but also in just one fixed position. A well designed
	     *     framed popup will have the pixels and logic to display itself in 
	     *     any of the four relative positions, but (understandably), this will
	     *     not be the case for all of them. By setting this property to 'true', 
	     *     framed popup will not recalculate for the best placement each time
	     *     it's open, but will always open the same way. 
	     *     Note that if this is set to true, it is generally advisable to also
	     *     set the 'panIntoView' property to true so that the popup can be 
	     *     scrolled into view (since it will often be offscreen on open)
	     *     Default is false.
	     */
	    fixedRelativePosition: false,

	    /** 
	     * Constructor: OpenLayers.Popup.Framed
	     * 
	     * Parameters:
	     * id - {String}
	     * lonlat - {<OpenLayers.LonLat>}
	     * contentSize - {<OpenLayers.Size>}
	     * contentHTML - {String}
	     * anchor - {Object} Object to which we'll anchor the popup. Must expose 
	     *     a 'size' (<OpenLayers.Size>) and 'offset' (<OpenLayers.Pixel>) 
	     *     (Note that this is generally an <OpenLayers.Icon>).
	     * closeBox - {Boolean}
	     * closeBoxCallback - {Function} Function to be called on closeBox click.
	     */
	    initialize:function(id, lonlat, contentSize, contentHTML, anchor, closeBox, 
	                        closeBoxCallback) {

	        OpenLayers.Popup.Anchored.prototype.initialize.apply(this, arguments);

	        if (this.fixedRelativePosition) {
	            //based on our decided relativePostion, set the current padding
	            // this keeps us from getting into trouble 
	            this.updateRelativePosition();
	            
	            //make calculateRelativePosition always return the specified
	            // fixed position.
	            this.calculateRelativePosition = function(px) {
	                return this.relativePosition;
	            };
	        }

	        this.contentDiv.style.position = "absolute";
	        this.contentDiv.style.zIndex = 1;

	        if (closeBox) {
	            this.closeDiv.style.zIndex = 1;
	        }

	        this.groupDiv.style.position = "absolute";
	        this.groupDiv.style.top = "0px";
	        this.groupDiv.style.left = "0px";
	        this.groupDiv.style.height = "100%";
	        this.groupDiv.style.width = "100%";
	    },

	    /** 
	     * APIMethod: destroy
	     */
	    destroy: function() {
	        this.imageSrc = null;
	        this.imageSize = null;
	        this.isAlphaImage = null;

	        this.fixedRelativePosition = false;
	        this.positionBlocks = null;

	        //remove our blocks
	        for(var i = 0; i < this.blocks.length; i++) {
	            var block = this.blocks[i];

	            if (block.image) {
	                block.div.removeChild(block.image);
	            }
	            block.image = null;

	            if (block.div) {
	                this.groupDiv.removeChild(block.div);
	            }
	            block.div = null;
	        }
	        this.blocks = null;

	        OpenLayers.Popup.Anchored.prototype.destroy.apply(this, arguments);
	    },

	    /**
	     * APIMethod: setBackgroundColor
	     */
	    setBackgroundColor:function(color) {
	        //does nothing since the framed popup's entire scheme is based on a 
	        // an image -- changing the background color makes no sense. 
	    },

	    /**
	     * APIMethod: setBorder
	     */
	    setBorder:function() {
	        //does nothing since the framed popup's entire scheme is based on a 
	        // an image -- changing the popup's border makes no sense. 
	    },

	    /**
	     * Method: setOpacity
	     * Sets the opacity of the popup.
	     * 
	     * Parameters:
	     * opacity - {float} A value between 0.0 (transparent) and 1.0 (solid).   
	     */
	    setOpacity:function(opacity) {
	        //does nothing since we suppose that we'll never apply an opacity
	        // to a framed popup
	    },

	    /**
	     * APIMethod: setSize
	     * Overridden here, because we need to update the blocks whenever the size
	     *     of the popup has changed.
	     * 
	     * Parameters:
	     * contentSize - {<OpenLayers.Size>} the new size for the popup's 
	     *     contents div (in pixels).
	     */
	    setSize:function(contentSize) { 
	        OpenLayers.Popup.Anchored.prototype.setSize.apply(this, arguments);

	        this.updateBlocks();
	    },

	    /**
	     * Method: updateRelativePosition
	     * When the relative position changes, we need to set the new padding 
	     *     BBOX on the popup, reposition the close div, and update the blocks.
	     */
	    updateRelativePosition: function() {

	        //update the padding
	        this.padding = this.positionBlocks[this.relativePosition].padding;

	        //update the position of our close box to new padding
	        if (this.closeDiv) {
	            // use the content div's css padding to determine if we should
	            //  padd the close div
	            var contentDivPadding = this.getContentDivPadding();

	            this.closeDiv.style.right = contentDivPadding.right + 
	                                        this.padding.right + "px";
	            this.closeDiv.style.top = contentDivPadding.top + 
	                                      this.padding.top + "px";
	        }

	        this.updateBlocks();
	    },

	    /** 
	     * Method: calculateNewPx
	     * Besides the standard offset as determined by the Anchored class, our 
	     *     Framed popups have a special 'offset' property for each of their 
	     *     positions, which is used to offset the popup relative to its anchor.
	     * 
	     * Parameters:
	     * px - {<OpenLayers.Pixel>}
	     * 
	     * Returns:
	     * {<OpenLayers.Pixel>} The the new px position of the popup on the screen
	     *     relative to the passed-in px.
	     */
	    calculateNewPx:function(px) {
	        var newPx = OpenLayers.Popup.Anchored.prototype.calculateNewPx.apply(
	            this, arguments
	        );

	        newPx = newPx.offset(this.positionBlocks[this.relativePosition].offset);

	        return newPx;
	    },

	    /**
	     * Method: createBlocks
	     */
	    createBlocks: function() {
	        this.blocks = [];

	        //since all positions contain the same number of blocks, we can 
	        // just pick the first position and use its blocks array to create
	        // our blocks array
	        var firstPosition = null;
	        for(var key in this.positionBlocks) {
	            firstPosition = key;
	            break;
	        }
	        
	        var position = this.positionBlocks[firstPosition];
	        for (var i = 0; i < position.blocks.length; i++) {

	            var block = {};
	            this.blocks.push(block);

	            var divId = this.id + '_FrameDecorationDiv_' + i;
	            block.div = OpenLayers.Util.createDiv(divId, 
	                null, null, null, "absolute", null, "hidden", null
	            );

	            var imgId = this.id + '_FrameDecorationImg_' + i;
	            var imageCreator = 
	                (this.isAlphaImage) ? OpenLayers.Util.createAlphaImageDiv
	                                    : OpenLayers.Util.createImage;

	            block.image = imageCreator(imgId, 
	                null, this.imageSize, this.imageSrc, 
	                "absolute", null, null, null
	            );

	            block.div.appendChild(block.image);
	            this.groupDiv.appendChild(block.div);
	        }
	    },

	    /**
	     * Method: updateBlocks
	     * Internal method, called on initialize and when the popup's relative
	     *     position has changed. This function takes care of re-positioning
	     *     the popup's blocks in their appropropriate places.
	     */
	    updateBlocks: function() {
	        if (!this.blocks) {
	            this.createBlocks();
	        }
	        
	        if (this.size && this.relativePosition) {
	            var position = this.positionBlocks[this.relativePosition];
	            for (var i = 0; i < position.blocks.length; i++) {
	    
	                var positionBlock = position.blocks[i];
	                var block = this.blocks[i];
	    
	                // adjust sizes
	                var l = positionBlock.anchor.left;
	                var b = positionBlock.anchor.bottom;
	                var r = positionBlock.anchor.right;
	                var t = positionBlock.anchor.top;
	    
	                //note that we use the isNaN() test here because if the 
	                // size object is initialized with a "auto" parameter, the 
	                // size constructor calls parseFloat() on the string, 
	                // which will turn it into NaN
	                //
	                var w = (isNaN(positionBlock.size.w)) ? this.size.w - (r + l) 
	                                                      : positionBlock.size.w;
	    
	                var h = (isNaN(positionBlock.size.h)) ? this.size.h - (b + t) 
	                                                      : positionBlock.size.h;
	    
	                block.div.style.width = (w < 0 ? 0 : w) + 'px';
	                block.div.style.height = (h < 0 ? 0 : h) + 'px';
	    
	                block.div.style.left = (l != null) ? l + 'px' : '';
	                block.div.style.bottom = (b != null) ? b + 'px' : '';
	                block.div.style.right = (r != null) ? r + 'px' : '';            
	                block.div.style.top = (t != null) ? t + 'px' : '';
	    
	                block.image.style.left = positionBlock.position.x + 'px';
	                block.image.style.top = positionBlock.position.y + 'px';
	            }
	    
	            this.contentDiv.style.left = this.padding.left + "px";
	            this.contentDiv.style.top = this.padding.top + "px";
	        }
	    },

	    CLASS_NAME: "OpenLayers.Popup.Framed"
	});
	/* ======================================================================
	    OpenLayers/Popup/FramedCloud.js
	   ====================================================================== */

	/* Copyright (c) 2006-2015 by OpenLayers Contributors (see authors.txt for
	 * full list of contributors). Published under the 2-clause BSD license.
	 * See license.txt in the OpenLayers distribution or repository for the
	 * full text of the license. */

	/**
	 * @requires OpenLayers/Popup/Framed.js
	 * @requires OpenLayers/Util.js
	 * @requires OpenLayers/BaseTypes/Bounds.js
	 * @requires OpenLayers/BaseTypes/Pixel.js
	 * @requires OpenLayers/BaseTypes/Size.js
	 */

	/**
	 * Class: OpenLayers.Popup.FramedCloud
	 * 
	 * Inherits from: 
	 *  - <OpenLayers.Popup.Framed>
	 */
	OpenLayers.Popup.FramedCloud = 
	  OpenLayers.Class(OpenLayers.Popup.Framed, {

	    /** 
	     * Property: contentDisplayClass
	     * {String} The CSS class of the popup content div.
	     */
	    contentDisplayClass: "olFramedCloudPopupContent",

	    /**
	     * APIProperty: autoSize
	     * {Boolean} Framed Cloud is autosizing by default.
	     */
	    autoSize: true,

	    /**
	     * APIProperty: panMapIfOutOfView
	     * {Boolean} Framed Cloud does pan into view by default.
	     */
	    panMapIfOutOfView: true,

	    /**
	     * APIProperty: imageSize
	     * {<OpenLayers.Size>}
	     */
	    imageSize: new OpenLayers.Size(1276, 736),

	    /**
	     * APIProperty: isAlphaImage
	     * {Boolean} The FramedCloud does not use an alpha image (in honor of the 
	     *     good ie6 folk out there)
	     */
	    isAlphaImage: false,

	    /** 
	     * APIProperty: fixedRelativePosition
	     * {Boolean} The Framed Cloud popup works in just one fixed position.
	     */
	    fixedRelativePosition: false,

	    /**
	     * Property: positionBlocks
	     * {Object} Hash of differen position blocks, keyed by relativePosition
	     *     two-character code string (ie "tl", "tr", "bl", "br")
	     */
	    positionBlocks: {
	        "tl": {
	            'offset': new OpenLayers.Pixel(44, 0),
	            'padding': new OpenLayers.Bounds(8, 40, 8, 9),
	            'blocks': [
	                { // top-left
	                    size: new OpenLayers.Size('auto', 'auto'),
	                    anchor: new OpenLayers.Bounds(0, 51, 22, 0),
	                    position: new OpenLayers.Pixel(0, 0)
	                },
	                { //top-right
	                    size: new OpenLayers.Size(22, 'auto'),
	                    anchor: new OpenLayers.Bounds(null, 50, 0, 0),
	                    position: new OpenLayers.Pixel(-1238, 0)
	                },
	                { //bottom-left
	                    size: new OpenLayers.Size('auto', 19),
	                    anchor: new OpenLayers.Bounds(0, 32, 22, null),
	                    position: new OpenLayers.Pixel(0, -631)
	                },
	                { //bottom-right
	                    size: new OpenLayers.Size(22, 18),
	                    anchor: new OpenLayers.Bounds(null, 32, 0, null),
	                    position: new OpenLayers.Pixel(-1238, -632)
	                },
	                { // stem
	                    size: new OpenLayers.Size(81, 35),
	                    anchor: new OpenLayers.Bounds(null, 0, 0, null),
	                    position: new OpenLayers.Pixel(0, -688)
	                }
	            ]
	        },
	        "tr": {
	            'offset': new OpenLayers.Pixel(-45, 0),
	            'padding': new OpenLayers.Bounds(8, 40, 8, 9),
	            'blocks': [
	                { // top-left
	                    size: new OpenLayers.Size('auto', 'auto'),
	                    anchor: new OpenLayers.Bounds(0, 51, 22, 0),
	                    position: new OpenLayers.Pixel(0, 0)
	                },
	                { //top-right
	                    size: new OpenLayers.Size(22, 'auto'),
	                    anchor: new OpenLayers.Bounds(null, 50, 0, 0),
	                    position: new OpenLayers.Pixel(-1238, 0)
	                },
	                { //bottom-left
	                    size: new OpenLayers.Size('auto', 19),
	                    anchor: new OpenLayers.Bounds(0, 32, 22, null),
	                    position: new OpenLayers.Pixel(0, -631)
	                },
	                { //bottom-right
	                    size: new OpenLayers.Size(22, 19),
	                    anchor: new OpenLayers.Bounds(null, 32, 0, null),
	                    position: new OpenLayers.Pixel(-1238, -631)
	                },
	                { // stem
	                    size: new OpenLayers.Size(81, 35),
	                    anchor: new OpenLayers.Bounds(0, 0, null, null),
	                    position: new OpenLayers.Pixel(-215, -687)
	                }
	            ]
	        },
	        "bl": {
	            'offset': new OpenLayers.Pixel(45, 0),
	            'padding': new OpenLayers.Bounds(8, 9, 8, 40),
	            'blocks': [
	                { // top-left
	                    size: new OpenLayers.Size('auto', 'auto'),
	                    anchor: new OpenLayers.Bounds(0, 21, 22, 32),
	                    position: new OpenLayers.Pixel(0, 0)
	                },
	                { //top-right
	                    size: new OpenLayers.Size(22, 'auto'),
	                    anchor: new OpenLayers.Bounds(null, 21, 0, 32),
	                    position: new OpenLayers.Pixel(-1238, 0)
	                },
	                { //bottom-left
	                    size: new OpenLayers.Size('auto', 21),
	                    anchor: new OpenLayers.Bounds(0, 0, 22, null),
	                    position: new OpenLayers.Pixel(0, -629)
	                },
	                { //bottom-right
	                    size: new OpenLayers.Size(22, 21),
	                    anchor: new OpenLayers.Bounds(null, 0, 0, null),
	                    position: new OpenLayers.Pixel(-1238, -629)
	                },
	                { // stem
	                    size: new OpenLayers.Size(81, 33),
	                    anchor: new OpenLayers.Bounds(null, null, 0, 0),
	                    position: new OpenLayers.Pixel(-101, -674)
	                }
	            ]
	        },
	        "br": {
	            'offset': new OpenLayers.Pixel(-44, 0),
	            'padding': new OpenLayers.Bounds(8, 9, 8, 40),
	            'blocks': [
	                { // top-left
	                    size: new OpenLayers.Size('auto', 'auto'),
	                    anchor: new OpenLayers.Bounds(0, 21, 22, 32),
	                    position: new OpenLayers.Pixel(0, 0)
	                },
	                { //top-right
	                    size: new OpenLayers.Size(22, 'auto'),
	                    anchor: new OpenLayers.Bounds(null, 21, 0, 32),
	                    position: new OpenLayers.Pixel(-1238, 0)
	                },
	                { //bottom-left
	                    size: new OpenLayers.Size('auto', 21),
	                    anchor: new OpenLayers.Bounds(0, 0, 22, null),
	                    position: new OpenLayers.Pixel(0, -629)
	                },
	                { //bottom-right
	                    size: new OpenLayers.Size(22, 21),
	                    anchor: new OpenLayers.Bounds(null, 0, 0, null),
	                    position: new OpenLayers.Pixel(-1238, -629)
	                },
	                { // stem
	                    size: new OpenLayers.Size(81, 33),
	                    anchor: new OpenLayers.Bounds(0, null, null, 0),
	                    position: new OpenLayers.Pixel(-311, -674)
	                }
	            ]
	        }
	    },

	    /**
	     * APIProperty: minSize
	     * {<OpenLayers.Size>}
	     */
	    minSize: new OpenLayers.Size(105, 10),

	    /**
	     * APIProperty: maxSize
	     * {<OpenLayers.Size>}
	     */
	    maxSize: new OpenLayers.Size(1200, 660),

	    /** 
	     * Constructor: OpenLayers.Popup.FramedCloud
	     * 
	     * Parameters:
	     * id - {String}
	     * lonlat - {<OpenLayers.LonLat>}
	     * contentSize - {<OpenLayers.Size>}
	     * contentHTML - {String}
	     * anchor - {Object} Object to which we'll anchor the popup. Must expose 
	     *     a 'size' (<OpenLayers.Size>) and 'offset' (<OpenLayers.Pixel>) 
	     *     (Note that this is generally an <OpenLayers.Icon>).
	     * closeBox - {Boolean}
	     * closeBoxCallback - {Function} Function to be called on closeBox click.
	     */
	    initialize:function(id, lonlat, contentSize, contentHTML, anchor, closeBox, 
	                        closeBoxCallback) {

	        this.imageSrc = OpenLayers.Util.getImageLocation('cloud-popup-relative.png');
	        OpenLayers.Popup.Framed.prototype.initialize.apply(this, arguments);
	        this.contentDiv.className = this.contentDisplayClass;
	    },

	    CLASS_NAME: "OpenLayers.Popup.FramedCloud"
	});
	/* ======================================================================
	    OpenLayers/Protocol.js
	   ====================================================================== */

	/* Copyright (c) 2006-2015 by OpenLayers Contributors (see authors.txt for
	 * full list of contributors). Published under the 2-clause BSD license.
	 * See license.txt in the OpenLayers distribution or repository for the
	 * full text of the license. */

	/**
	 * @requires OpenLayers/BaseTypes/Class.js
	 */

	/**
	 * Class: OpenLayers.Protocol
	 * Abstract vector layer protocol class.  Not to be instantiated directly.  Use
	 *     one of the protocol subclasses instead.
	 */
	OpenLayers.Protocol = OpenLayers.Class({
	    
	    /**
	     * Property: format
	     * {<OpenLayers.Format>} The format used by this protocol.
	     */
	    format: null,
	    
	    /**
	     * Property: options
	     * {Object} Any options sent to the constructor.
	     */
	    options: null,

	    /**
	     * Property: autoDestroy
	     * {Boolean} The creator of the protocol can set autoDestroy to false
	     *      to fully control when the protocol is destroyed. Defaults to
	     *      true.
	     */
	    autoDestroy: true,
	   
	    /**
	     * Property: defaultFilter
	     * {<OpenLayers.Filter>} Optional default filter to read requests
	     */
	    defaultFilter: null,
	    
	    /**
	     * Constructor: OpenLayers.Protocol
	     * Abstract class for vector protocols.  Create instances of a subclass.
	     *
	     * Parameters:
	     * options - {Object} Optional object whose properties will be set on the
	     *     instance.
	     */
	    initialize: function(options) {
	        options = options || {};
	        OpenLayers.Util.extend(this, options);
	        this.options = options;
	    },

	    /**
	     * Method: mergeWithDefaultFilter
	     * Merge filter passed to the read method with the default one
	     *
	     * Parameters:
	     * filter - {<OpenLayers.Filter>}
	     */
	    mergeWithDefaultFilter: function(filter) {
	        var merged;
	        if (filter && this.defaultFilter) {
	            merged = new OpenLayers.Filter.Logical({
	                type: OpenLayers.Filter.Logical.AND,
	                filters: [this.defaultFilter, filter]
	            });
	        } else {
	            merged = filter || this.defaultFilter || undefined;
	        }
	        return merged;
	    },

	    /**
	     * APIMethod: destroy
	     * Clean up the protocol.
	     */
	    destroy: function() {
	        this.options = null;
	        this.format = null;
	    },
	    
	    /**
	     * APIMethod: read
	     * Construct a request for reading new features.
	     *
	     * Parameters:
	     * options - {Object} Optional object for configuring the request.
	     *
	     * Returns:
	     * {<OpenLayers.Protocol.Response>} An <OpenLayers.Protocol.Response>
	     * object, the same object will be passed to the callback function passed
	     * if one exists in the options object.
	     */
	    read: function(options) {
	        options = options || {};
	        options.filter = this.mergeWithDefaultFilter(options.filter);
	    },
	    
	    
	    /**
	     * APIMethod: create
	     * Construct a request for writing newly created features.
	     *
	     * Parameters:
	     * features - {Array({<OpenLayers.Feature.Vector>})} or
	     *            {<OpenLayers.Feature.Vector>}
	     * options - {Object} Optional object for configuring the request.
	     *
	     * Returns:
	     * {<OpenLayers.Protocol.Response>} An <OpenLayers.Protocol.Response>
	     * object, the same object will be passed to the callback function passed
	     * if one exists in the options object.
	     */
	    create: function() {
	    },
	    
	    /**
	     * APIMethod: update
	     * Construct a request updating modified features.
	     *
	     * Parameters:
	     * features - {Array({<OpenLayers.Feature.Vector>})} or
	     *            {<OpenLayers.Feature.Vector>}
	     * options - {Object} Optional object for configuring the request.
	     *
	     * Returns:
	     * {<OpenLayers.Protocol.Response>} An <OpenLayers.Protocol.Response>
	     * object, the same object will be passed to the callback function passed
	     * if one exists in the options object.
	     */
	    update: function() {
	    },
	    
	    /**
	     * APIMethod: delete
	     * Construct a request deleting a removed feature.
	     *
	     * Parameters:
	     * feature - {<OpenLayers.Feature.Vector>}
	     * options - {Object} Optional object for configuring the request.
	     *
	     * Returns:
	     * {<OpenLayers.Protocol.Response>} An <OpenLayers.Protocol.Response>
	     * object, the same object will be passed to the callback function passed
	     * if one exists in the options object.
	     */
	    "delete": function() {
	    },

	    /**
	     * APIMethod: commit
	     * Go over the features and for each take action
	     * based on the feature state. Possible actions are create,
	     * update and delete.
	     *
	     * Parameters:
	     * features - {Array({<OpenLayers.Feature.Vector>})}
	     * options - {Object} Object whose possible keys are "create", "update",
	     *      "delete", "callback" and "scope", the values referenced by the
	     *      first three are objects as passed to the "create", "update", and
	     *      "delete" methods, the value referenced by the "callback" key is
	     *      a function which is called when the commit operation is complete
	     *      using the scope referenced by the "scope" key.
	     *
	     * Returns:
	     * {Array({<OpenLayers.Protocol.Response>})} An array of
	     * <OpenLayers.Protocol.Response> objects.
	     */
	    commit: function() {
	    },

	    /**
	     * Method: abort
	     * Abort an ongoing request.
	     *
	     * Parameters:
	     * response - {<OpenLayers.Protocol.Response>}
	     */
	    abort: function(response) {
	    },
	   
	    /**
	     * Method: createCallback
	     * Returns a function that applies the given public method with resp and
	     *     options arguments.
	     *
	     * Parameters:
	     * method - {Function} The method to be applied by the callback.
	     * response - {<OpenLayers.Protocol.Response>} The protocol response object.
	     * options - {Object} Options sent to the protocol method
	     */
	    createCallback: function(method, response, options) {
	        return OpenLayers.Function.bind(function() {
	            method.apply(this, [response, options]);
	        }, this);
	    },
	   
	    CLASS_NAME: "OpenLayers.Protocol" 
	});

	/**
	 * Class: OpenLayers.Protocol.Response
	 * Protocols return Response objects to their users.
	 */
	OpenLayers.Protocol.Response = OpenLayers.Class({
	    /**
	     * Property: code
	     * {Number} - OpenLayers.Protocol.Response.SUCCESS or
	     *            OpenLayers.Protocol.Response.FAILURE
	     */
	    code: null,

	    /**
	     * Property: requestType
	     * {String} The type of request this response corresponds to. Either
	     *      "create", "read", "update" or "delete".
	     */
	    requestType: null,

	    /**
	     * Property: last
	     * {Boolean} - true if this is the last response expected in a commit,
	     * false otherwise, defaults to true.
	     */
	    last: true,

	    /**
	     * Property: features
	     * {Array({<OpenLayers.Feature.Vector>})} or {<OpenLayers.Feature.Vector>}
	     * The features returned in the response by the server. Depending on the 
	     * protocol's read payload, either features or data will be populated.
	     */
	    features: null,

	    /**
	     * Property: data
	     * {Object}
	     * The data returned in the response by the server. Depending on the 
	     * protocol's read payload, either features or data will be populated.
	     */
	    data: null,

	    /**
	     * Property: reqFeatures
	     * {Array({<OpenLayers.Feature.Vector>})} or {<OpenLayers.Feature.Vector>}
	     * The features provided by the user and placed in the request by the
	     *      protocol.
	     */
	    reqFeatures: null,

	    /**
	     * Property: priv
	     */
	    priv: null,

	    /**
	     * Property: error
	     * {Object} The error object in case a service exception was encountered.
	     */
	    error: null,

	    /**
	     * Constructor: OpenLayers.Protocol.Response
	     *
	     * Parameters:
	     * options - {Object} Optional object whose properties will be set on the
	     *     instance.
	     */
	    initialize: function(options) {
	        OpenLayers.Util.extend(this, options);
	    },

	    /**
	     * Method: success
	     *
	     * Returns:
	     * {Boolean} - true on success, false otherwise
	     */
	    success: function() {
	        return this.code > 0;
	    },

	    CLASS_NAME: "OpenLayers.Protocol.Response"
	});

	OpenLayers.Protocol.Response.SUCCESS = 1;
	OpenLayers.Protocol.Response.FAILURE = 0;
	/* ======================================================================
	    OpenLayers/Request.js
	   ====================================================================== */

	/* Copyright (c) 2006-2015 by OpenLayers Contributors (see authors.txt for
	 * full list of contributors). Published under the 2-clause BSD license.
	 * See license.txt in the OpenLayers distribution or repository for the
	 * full text of the license. */

	/**
	 * @requires OpenLayers/Events.js
	 * @requires OpenLayers/Request/XMLHttpRequest.js
	 */

	/**
	 * TODO: deprecate me
	 * Use OpenLayers.Request.proxy instead.
	 */
	OpenLayers.ProxyHost = "";

	/**
	 * Namespace: OpenLayers.Request
	 * The OpenLayers.Request namespace contains convenience methods for working
	 *     with XMLHttpRequests.  These methods work with a cross-browser
	 *     W3C compliant <OpenLayers.Request.XMLHttpRequest> class.
	 */
	if (!OpenLayers.Request) {
	    /**
	     * This allows for OpenLayers/Request/XMLHttpRequest.js to be included
	     * before or after this script.
	     */
	    OpenLayers.Request = {};
	}
	OpenLayers.Util.extend(OpenLayers.Request, {
	    
	    /**
	     * Constant: DEFAULT_CONFIG
	     * {Object} Default configuration for all requests.
	     */
	    DEFAULT_CONFIG: {
	        method: "GET",
	        url: window.location.href,
	        async: true,
	        user: undefined,
	        password: undefined,
	        params: null,
	        proxy: OpenLayers.ProxyHost,
	        headers: {},
	        data: null,
	        callback: function() {},
	        success: null,
	        failure: null,
	        scope: null
	    },
	    
	    /**
	     * Constant: URL_SPLIT_REGEX
	     */
	    URL_SPLIT_REGEX: /([^:]*:)\/\/([^:]*:?[^@]*@)?([^:\/\?]*):?([^\/\?]*)/,
	    
	    /**
	     * APIProperty: events
	     * {<OpenLayers.Events>} An events object that handles all 
	     *     events on the {<OpenLayers.Request>} object.
	     *
	     * All event listeners will receive an event object with three properties:
	     * request - {<OpenLayers.Request.XMLHttpRequest>} The request object.
	     * config - {Object} The config object sent to the specific request method.
	     * requestUrl - {String} The request url.
	     * 
	     * Supported event types:
	     * complete - Triggered when we have a response from the request, if a
	     *     listener returns false, no further response processing will take
	     *     place.
	     * success - Triggered when the HTTP response has a success code (200-299).
	     * failure - Triggered when the HTTP response does not have a success code.
	     */
	    events: new OpenLayers.Events(this),
	    
	    /**
	     * Method: makeSameOrigin
	     * Using the specified proxy, returns a same origin url of the provided url.
	     *
	     * Parameters:
	     * url - {String} An arbitrary url
	     * proxy {String|Function} The proxy to use to make the provided url a
	     *     same origin url.
	     *
	     * Returns
	     * {String} the same origin url. If no proxy is provided, the returned url
	     *     will be the same as the provided url.
	     */
	    makeSameOrigin: function(url, proxy) {
	        var sameOrigin = url.indexOf("http") !== 0;
	        var urlParts = !sameOrigin && url.match(this.URL_SPLIT_REGEX);
	        if (urlParts) {
	            var location = window.location;
	            sameOrigin =
	                urlParts[1] == location.protocol &&
	                urlParts[3] == location.hostname;
	            var uPort = urlParts[4], lPort = location.port;
	            if (uPort != 80 && uPort != "" || lPort != "80" && lPort != "") {
	                sameOrigin = sameOrigin && uPort == lPort;
	            }
	        }
	        if (!sameOrigin) {
	            if (proxy) {
	                if (typeof proxy == "function") {
	                    url = proxy(url);
	                } else {
	                    url = proxy + encodeURIComponent(url);
	                }
	            }
	        }
	        return url;
	    },

	    /**
	     * APIMethod: issue
	     * Create a new XMLHttpRequest object, open it, set any headers, bind
	     *     a callback to done state, and send any data.  It is recommended that
	     *     you use one <GET>, <POST>, <PUT>, <DELETE>, <OPTIONS>, or <HEAD>.
	     *     This method is only documented to provide detail on the configuration
	     *     options available to all request methods.
	     *
	     * Parameters:
	     * config - {Object} Object containing properties for configuring the
	     *     request.  Allowed configuration properties are described below.
	     *     This object is modified and should not be reused.
	     *
	     * Allowed config properties:
	     * method - {String} One of GET, POST, PUT, DELETE, HEAD, or
	     *     OPTIONS.  Default is GET.
	     * url - {String} URL for the request.
	     * async - {Boolean} Open an asynchronous request.  Default is true.
	     * user - {String} User for relevant authentication scheme.  Set
	     *     to null to clear current user.
	     * password - {String} Password for relevant authentication scheme.
	     *     Set to null to clear current password.
	     * proxy - {String} Optional proxy.  Defaults to
	     *     <OpenLayers.ProxyHost>.
	     * params - {Object} Any key:value pairs to be appended to the
	     *     url as a query string.  Assumes url doesn't already include a query
	     *     string or hash.  Typically, this is only appropriate for <GET>
	     *     requests where the query string will be appended to the url.
	     *     Parameter values that are arrays will be
	     *     concatenated with a comma (note that this goes against form-encoding)
	     *     as is done with <OpenLayers.Util.getParameterString>.
	     * headers - {Object} Object with header:value pairs to be set on
	     *     the request.
	     * data - {String | Document} Optional data to send with the request.
	     *     Typically, this is only used with <POST> and <PUT> requests.
	     *     Make sure to provide the appropriate "Content-Type" header for your
	     *     data.  For <POST> and <PUT> requests, the content type defaults to
	     *     "application-xml".  If your data is a different content type, or
	     *     if you are using a different HTTP method, set the "Content-Type"
	     *     header to match your data type.
	     * callback - {Function} Function to call when request is done.
	     *     To determine if the request failed, check request.status (200
	     *     indicates success).
	     * success - {Function} Optional function to call if request status is in
	     *     the 200s.  This will be called in addition to callback above and
	     *     would typically only be used as an alternative.
	     * failure - {Function} Optional function to call if request status is not
	     *     in the 200s.  This will be called in addition to callback above and
	     *     would typically only be used as an alternative.
	     * scope - {Object} If callback is a public method on some object,
	     *     set the scope to that object.
	     *
	     * Returns:
	     * {XMLHttpRequest} Request object.  To abort the request before a response
	     *     is received, call abort() on the request object.
	     */
	    issue: function(config) {        
	        // apply default config - proxy host may have changed
	        var defaultConfig = OpenLayers.Util.extend(
	            this.DEFAULT_CONFIG,
	            {proxy: OpenLayers.ProxyHost}
	        );
	        config = config || {};
	        config.headers = config.headers || {};
	        config = OpenLayers.Util.applyDefaults(config, defaultConfig);
	        config.headers = OpenLayers.Util.applyDefaults(config.headers, defaultConfig.headers);
	        // Always set the "X-Requested-With" header to signal that this request
	        // was issued through the XHR-object. Since header keys are case 
	        // insensitive and we want to allow overriding of the "X-Requested-With"
	        // header through the user we cannot use applyDefaults, but have to 
	        // check manually whether we were called with a "X-Requested-With"
	        // header.
	        var customRequestedWithHeader = false,
	            headerKey;
	        for(headerKey in config.headers) {
	            if (config.headers.hasOwnProperty( headerKey )) {
	                if (headerKey.toLowerCase() === 'x-requested-with') {
	                    customRequestedWithHeader = true;
	                }
	            }
	        }
	        if (customRequestedWithHeader === false) {
	            // we did not have a custom "X-Requested-With" header
	            config.headers['X-Requested-With'] = 'XMLHttpRequest';
	        }

	        // create request, open, and set headers
	        var request = new OpenLayers.Request.XMLHttpRequest();
	        var url = OpenLayers.Util.urlAppend(config.url, 
	            OpenLayers.Util.getParameterString(config.params || {}));
	        url = OpenLayers.Request.makeSameOrigin(url, config.proxy);
	        request.open(
	            config.method, url, config.async, config.user, config.password
	        );
	        for(var header in config.headers) {
	            request.setRequestHeader(header, config.headers[header]);
	        }

	        var events = this.events;

	        // we want to execute runCallbacks with "this" as the
	        // execution scope
	        var self = this;
	        
	        request.onreadystatechange = function() {
	            if(request.readyState == OpenLayers.Request.XMLHttpRequest.DONE) {
	                var proceed = events.triggerEvent(
	                    "complete",
	                    {request: request, config: config, requestUrl: url}
	                );
	                if(proceed !== false) {
	                    self.runCallbacks(
	                        {request: request, config: config, requestUrl: url}
	                    );
	                }
	            }
	        };
	        
	        // send request (optionally with data) and return
	        // call in a timeout for asynchronous requests so the return is
	        // available before readyState == 4 for cached docs
	        if(config.async === false) {
	            request.send(config.data);
	        } else {
	            window.setTimeout(function(){
	                if (request.readyState !== 0) { // W3C: 0-UNSENT
	                    request.send(config.data);
	                }
	            }, 0);
	        }
	        return request;
	    },
	    
	    /**
	     * Method: runCallbacks
	     * Calls the complete, success and failure callbacks. Application
	     *    can listen to the "complete" event, have the listener 
	     *    display a confirm window and always return false, and
	     *    execute OpenLayers.Request.runCallbacks if the user
	     *    hits "yes" in the confirm window.
	     *
	     * Parameters:
	     * options - {Object} Hash containing request, config and requestUrl keys
	     */
	    runCallbacks: function(options) {
	        var request = options.request;
	        var config = options.config;
	        
	        // bind callbacks to readyState 4 (done)
	        var complete = (config.scope) ?
	            OpenLayers.Function.bind(config.callback, config.scope) :
	            config.callback;
	        
	        // optional success callback
	        var success;
	        if(config.success) {
	            success = (config.scope) ?
	                OpenLayers.Function.bind(config.success, config.scope) :
	                config.success;
	        }

	        // optional failure callback
	        var failure;
	        if(config.failure) {
	            failure = (config.scope) ?
	                OpenLayers.Function.bind(config.failure, config.scope) :
	                config.failure;
	        }

	        if (OpenLayers.Util.createUrlObject(config.url).protocol == "file:" &&
	                                                        request.responseText) {
	            request.status = 200;
	        }
	        complete(request);

	        if (!request.status || (request.status >= 200 && request.status < 300)) {
	            this.events.triggerEvent("success", options);
	            if(success) {
	                success(request);
	            }
	        }
	        if(request.status && (request.status < 200 || request.status >= 300)) {                    
	            this.events.triggerEvent("failure", options);
	            if(failure) {
	                failure(request);
	            }
	        }
	    },
	    
	    /**
	     * APIMethod: GET
	     * Send an HTTP GET request.  Additional configuration properties are
	     *     documented in the <issue> method, with the method property set
	     *     to GET.
	     *
	     * Parameters:
	     * config - {Object} Object with properties for configuring the request.
	     *     See the <issue> method for documentation of allowed properties.
	     *     This object is modified and should not be reused.
	     * 
	     * Returns:
	     * {XMLHttpRequest} Request object.
	     */
	    GET: function(config) {
	        config = OpenLayers.Util.extend(config, {method: "GET"});
	        return OpenLayers.Request.issue(config);
	    },
	    
	    /**
	     * APIMethod: POST
	     * Send a POST request.  Additional configuration properties are
	     *     documented in the <issue> method, with the method property set
	     *     to POST and "Content-Type" header set to "application/xml".
	     *
	     * Parameters:
	     * config - {Object} Object with properties for configuring the request.
	     *     See the <issue> method for documentation of allowed properties.  The
	     *     default "Content-Type" header will be set to "application-xml" if
	     *     none is provided.  This object is modified and should not be reused.
	     * 
	     * Returns:
	     * {XMLHttpRequest} Request object.
	     */
	    POST: function(config) {
	        config = OpenLayers.Util.extend(config, {method: "POST"});
	        // set content type to application/xml if it isn't already set
	        config.headers = config.headers ? config.headers : {};
	        if(!("CONTENT-TYPE" in OpenLayers.Util.upperCaseObject(config.headers))) {
	            config.headers["Content-Type"] = "application/xml";
	        }
	        return OpenLayers.Request.issue(config);
	    },
	    
	    /**
	     * APIMethod: PUT
	     * Send an HTTP PUT request.  Additional configuration properties are
	     *     documented in the <issue> method, with the method property set
	     *     to PUT and "Content-Type" header set to "application/xml".
	     *
	     * Parameters:
	     * config - {Object} Object with properties for configuring the request.
	     *     See the <issue> method for documentation of allowed properties.  The
	     *     default "Content-Type" header will be set to "application-xml" if
	     *     none is provided.  This object is modified and should not be reused.
	     * 
	     * Returns:
	     * {XMLHttpRequest} Request object.
	     */
	    PUT: function(config) {
	        config = OpenLayers.Util.extend(config, {method: "PUT"});
	        // set content type to application/xml if it isn't already set
	        config.headers = config.headers ? config.headers : {};
	        if(!("CONTENT-TYPE" in OpenLayers.Util.upperCaseObject(config.headers))) {
	            config.headers["Content-Type"] = "application/xml";
	        }
	        return OpenLayers.Request.issue(config);
	    },
	    
	    /**
	     * APIMethod: DELETE
	     * Send an HTTP DELETE request.  Additional configuration properties are
	     *     documented in the <issue> method, with the method property set
	     *     to DELETE.
	     *
	     * Parameters:
	     * config - {Object} Object with properties for configuring the request.
	     *     See the <issue> method for documentation of allowed properties.
	     *     This object is modified and should not be reused.
	     * 
	     * Returns:
	     * {XMLHttpRequest} Request object.
	     */
	    DELETE: function(config) {
	        config = OpenLayers.Util.extend(config, {method: "DELETE"});
	        return OpenLayers.Request.issue(config);
	    },
	  
	    /**
	     * APIMethod: HEAD
	     * Send an HTTP HEAD request.  Additional configuration properties are
	     *     documented in the <issue> method, with the method property set
	     *     to HEAD.
	     *
	     * Parameters:
	     * config - {Object} Object with properties for configuring the request.
	     *     See the <issue> method for documentation of allowed properties.
	     *     This object is modified and should not be reused.
	     * 
	     * Returns:
	     * {XMLHttpRequest} Request object.
	     */
	    HEAD: function(config) {
	        config = OpenLayers.Util.extend(config, {method: "HEAD"});
	        return OpenLayers.Request.issue(config);
	    },
	    
	    /**
	     * APIMethod: OPTIONS
	     * Send an HTTP OPTIONS request.  Additional configuration properties are
	     *     documented in the <issue> method, with the method property set
	     *     to OPTIONS.
	     *
	     * Parameters:
	     * config - {Object} Object with properties for configuring the request.
	     *     See the <issue> method for documentation of allowed properties.
	     *     This object is modified and should not be reused.
	     * 
	     * Returns:
	     * {XMLHttpRequest} Request object.
	     */
	    OPTIONS: function(config) {
	        config = OpenLayers.Util.extend(config, {method: "OPTIONS"});
	        return OpenLayers.Request.issue(config);
	    }

	});
	/* ======================================================================
	    OpenLayers/Request/XMLHttpRequest.js
	   ====================================================================== */

	// XMLHttpRequest.js Copyright (C) 2010 Sergey Ilinsky (http://www.ilinsky.com)
	//
	// Licensed under the Apache License, Version 2.0 (the "License");
	// you may not use this file except in compliance with the License.
	// You may obtain a copy of the License at
	//
	//   http://www.apache.org/licenses/LICENSE-2.0
	//
	// Unless required by applicable law or agreed to in writing, software
	// distributed under the License is distributed on an "AS IS" BASIS,
	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	// See the License for the specific language governing permissions and
	// limitations under the License.

	/**
	 * @requires OpenLayers/Request.js
	 */

	(function () {

	    // Save reference to earlier defined object implementation (if any)
	    var oXMLHttpRequest    = window.XMLHttpRequest;

	    // Define on browser type
	    var bGecko    = !!window.controllers,
	        bIE        = window.document.all && !window.opera,
	        bIE7    = bIE && window.navigator.userAgent.match(/MSIE 7.0/);

	    // Enables "XMLHttpRequest()" call next to "new XMLHttpReques()"
	    function fXMLHttpRequest() {
	        this._object    = oXMLHttpRequest && !bIE7 ? new oXMLHttpRequest : new window.ActiveXObject("Microsoft.XMLHTTP");
	        this._listeners    = [];
	    };

	    // Constructor
	    function cXMLHttpRequest() {
	        return new fXMLHttpRequest;
	    };
	    cXMLHttpRequest.prototype    = fXMLHttpRequest.prototype;

	    // BUGFIX: Firefox with Firebug installed would break pages if not executed
	    if (bGecko && oXMLHttpRequest.wrapped)
	        cXMLHttpRequest.wrapped    = oXMLHttpRequest.wrapped;

	    // Constants
	    cXMLHttpRequest.UNSENT                = 0;
	    cXMLHttpRequest.OPENED                = 1;
	    cXMLHttpRequest.HEADERS_RECEIVED    = 2;
	    cXMLHttpRequest.LOADING                = 3;
	    cXMLHttpRequest.DONE                = 4;

	    // Public Properties
	    cXMLHttpRequest.prototype.readyState    = cXMLHttpRequest.UNSENT;
	    cXMLHttpRequest.prototype.responseText    = '';
	    cXMLHttpRequest.prototype.responseXML    = null;
	    cXMLHttpRequest.prototype.status        = 0;
	    cXMLHttpRequest.prototype.statusText    = '';

	    // Priority proposal
	    cXMLHttpRequest.prototype.priority        = "NORMAL";

	    // Instance-level Events Handlers
	    cXMLHttpRequest.prototype.onreadystatechange    = null;

	    // Class-level Events Handlers
	    cXMLHttpRequest.onreadystatechange    = null;
	    cXMLHttpRequest.onopen                = null;
	    cXMLHttpRequest.onsend                = null;
	    cXMLHttpRequest.onabort                = null;

	    // Public Methods
	    cXMLHttpRequest.prototype.open    = function(sMethod, sUrl, bAsync, sUser, sPassword) {
	        // Delete headers, required when object is reused
	        delete this._headers;

	        // When bAsync parameter value is omitted, use true as default
	        if (arguments.length < 3)
	            bAsync    = true;

	        // Save async parameter for fixing Gecko bug with missing readystatechange in synchronous requests
	        this._async        = bAsync;

	        // Set the onreadystatechange handler
	        var oRequest    = this,
	            nState        = this.readyState,
	            fOnUnload;

	        // BUGFIX: IE - memory leak on page unload (inter-page leak)
	        if (bIE && bAsync) {
	            fOnUnload = function() {
	                if (nState != cXMLHttpRequest.DONE) {
	                    fCleanTransport(oRequest);
	                    // Safe to abort here since onreadystatechange handler removed
	                    oRequest.abort();
	                }
	            };
	            window.attachEvent("onunload", fOnUnload);
	        }

	        // Add method sniffer
	        if (cXMLHttpRequest.onopen)
	            cXMLHttpRequest.onopen.apply(this, arguments);

	        if (arguments.length > 4)
	            this._object.open(sMethod, sUrl, bAsync, sUser, sPassword);
	        else
	        if (arguments.length > 3)
	            this._object.open(sMethod, sUrl, bAsync, sUser);
	        else
	            this._object.open(sMethod, sUrl, bAsync);

	        this.readyState    = cXMLHttpRequest.OPENED;
	        fReadyStateChange(this);

	        this._object.onreadystatechange    = function() {
	            if (bGecko && !bAsync)
	                return;

	            // Synchronize state
	            oRequest.readyState        = oRequest._object.readyState;

	            //
	            fSynchronizeValues(oRequest);

	            // BUGFIX: Firefox fires unnecessary DONE when aborting
	            if (oRequest._aborted) {
	                // Reset readyState to UNSENT
	                oRequest.readyState    = cXMLHttpRequest.UNSENT;

	                // Return now
	                return;
	            }

	            if (oRequest.readyState == cXMLHttpRequest.DONE) {
	                // Free up queue
	                delete oRequest._data;
	/*                if (bAsync)
	                    fQueue_remove(oRequest);*/
	                //
	                fCleanTransport(oRequest);
	// Uncomment this block if you need a fix for IE cache
	/*
	                // BUGFIX: IE - cache issue
	                if (!oRequest._object.getResponseHeader("Date")) {
	                    // Save object to cache
	                    oRequest._cached    = oRequest._object;

	                    // Instantiate a new transport object
	                    cXMLHttpRequest.call(oRequest);

	                    // Re-send request
	                    if (sUser) {
	                         if (sPassword)
	                            oRequest._object.open(sMethod, sUrl, bAsync, sUser, sPassword);
	                        else
	                            oRequest._object.open(sMethod, sUrl, bAsync, sUser);
	                    }
	                    else
	                        oRequest._object.open(sMethod, sUrl, bAsync);
	                    oRequest._object.setRequestHeader("If-Modified-Since", oRequest._cached.getResponseHeader("Last-Modified") || new window.Date(0));
	                    // Copy headers set
	                    if (oRequest._headers)
	                        for (var sHeader in oRequest._headers)
	                            if (typeof oRequest._headers[sHeader] == "string")    // Some frameworks prototype objects with functions
	                                oRequest._object.setRequestHeader(sHeader, oRequest._headers[sHeader]);

	                    oRequest._object.onreadystatechange    = function() {
	                        // Synchronize state
	                        oRequest.readyState        = oRequest._object.readyState;

	                        if (oRequest._aborted) {
	                            //
	                            oRequest.readyState    = cXMLHttpRequest.UNSENT;

	                            // Return
	                            return;
	                        }

	                        if (oRequest.readyState == cXMLHttpRequest.DONE) {
	                            // Clean Object
	                            fCleanTransport(oRequest);

	                            // get cached request
	                            if (oRequest.status == 304)
	                                oRequest._object    = oRequest._cached;

	                            //
	                            delete oRequest._cached;

	                            //
	                            fSynchronizeValues(oRequest);

	                            //
	                            fReadyStateChange(oRequest);

	                            // BUGFIX: IE - memory leak in interrupted
	                            if (bIE && bAsync)
	                                window.detachEvent("onunload", fOnUnload);
	                        }
	                    };
	                    oRequest._object.send(null);

	                    // Return now - wait until re-sent request is finished
	                    return;
	                };
	*/
	                // BUGFIX: IE - memory leak in interrupted
	                if (bIE && bAsync)
	                    window.detachEvent("onunload", fOnUnload);
	            }

	            // BUGFIX: Some browsers (Internet Explorer, Gecko) fire OPEN readystate twice
	            if (nState != oRequest.readyState)
	                fReadyStateChange(oRequest);

	            nState    = oRequest.readyState;
	        }
	    };
	    function fXMLHttpRequest_send(oRequest) {
	        oRequest._object.send(oRequest._data);

	        // BUGFIX: Gecko - missing readystatechange calls in synchronous requests
	        if (bGecko && !oRequest._async) {
	            oRequest.readyState    = cXMLHttpRequest.OPENED;

	            // Synchronize state
	            fSynchronizeValues(oRequest);

	            // Simulate missing states
	            while (oRequest.readyState < cXMLHttpRequest.DONE) {
	                oRequest.readyState++;
	                fReadyStateChange(oRequest);
	                // Check if we are aborted
	                if (oRequest._aborted)
	                    return;
	            }
	        }
	    };
	    cXMLHttpRequest.prototype.send    = function(vData) {
	        // Add method sniffer
	        if (cXMLHttpRequest.onsend)
	            cXMLHttpRequest.onsend.apply(this, arguments);

	        if (!arguments.length)
	            vData    = null;

	        // BUGFIX: Safari - fails sending documents created/modified dynamically, so an explicit serialization required
	        // BUGFIX: IE - rewrites any custom mime-type to "text/xml" in case an XMLNode is sent
	        // BUGFIX: Gecko - fails sending Element (this is up to the implementation either to standard)
	        if (vData && vData.nodeType) {
	            vData    = window.XMLSerializer ? new window.XMLSerializer().serializeToString(vData) : vData.xml;
	            if (!this._headers["Content-Type"])
	                this._object.setRequestHeader("Content-Type", "application/xml");
	        }

	        this._data    = vData;
	/*
	        // Add to queue
	        if (this._async)
	            fQueue_add(this);
	        else*/
	            fXMLHttpRequest_send(this);
	    };
	    cXMLHttpRequest.prototype.abort    = function() {
	        // Add method sniffer
	        if (cXMLHttpRequest.onabort)
	            cXMLHttpRequest.onabort.apply(this, arguments);

	        // BUGFIX: Gecko - unnecessary DONE when aborting
	        if (this.readyState > cXMLHttpRequest.UNSENT)
	            this._aborted    = true;

	        this._object.abort();

	        // BUGFIX: IE - memory leak
	        fCleanTransport(this);

	        this.readyState    = cXMLHttpRequest.UNSENT;

	        delete this._data;
	/*        if (this._async)
	            fQueue_remove(this);*/
	    };
	    cXMLHttpRequest.prototype.getAllResponseHeaders    = function() {
	        return this._object.getAllResponseHeaders();
	    };
	    cXMLHttpRequest.prototype.getResponseHeader    = function(sName) {
	        return this._object.getResponseHeader(sName);
	    };
	    cXMLHttpRequest.prototype.setRequestHeader    = function(sName, sValue) {
	        // BUGFIX: IE - cache issue
	        if (!this._headers)
	            this._headers    = {};
	        this._headers[sName]    = sValue;

	        return this._object.setRequestHeader(sName, sValue);
	    };

	    // EventTarget interface implementation
	    cXMLHttpRequest.prototype.addEventListener    = function(sName, fHandler, bUseCapture) {
	        for (var nIndex = 0, oListener; oListener = this._listeners[nIndex]; nIndex++)
	            if (oListener[0] == sName && oListener[1] == fHandler && oListener[2] == bUseCapture)
	                return;
	        // Add listener
	        this._listeners.push([sName, fHandler, bUseCapture]);
	    };

	    cXMLHttpRequest.prototype.removeEventListener    = function(sName, fHandler, bUseCapture) {
	        for (var nIndex = 0, oListener; oListener = this._listeners[nIndex]; nIndex++)
	            if (oListener[0] == sName && oListener[1] == fHandler && oListener[2] == bUseCapture)
	                break;
	        // Remove listener
	        if (oListener)
	            this._listeners.splice(nIndex, 1);
	    };

	    cXMLHttpRequest.prototype.dispatchEvent    = function(oEvent) {
	        var oEventPseudo    = {
	            'type':            oEvent.type,
	            'target':        this,
	            'currentTarget':this,
	            'eventPhase':    2,
	            'bubbles':        oEvent.bubbles,
	            'cancelable':    oEvent.cancelable,
	            'timeStamp':    oEvent.timeStamp,
	            'stopPropagation':    function() {},    // There is no flow
	            'preventDefault':    function() {},    // There is no default action
	            'initEvent':        function() {}    // Original event object should be initialized
	        };

	        // Execute onreadystatechange
	        if (oEventPseudo.type == "readystatechange" && this.onreadystatechange)
	            (this.onreadystatechange.handleEvent || this.onreadystatechange).apply(this, [oEventPseudo]);

	        // Execute listeners
	        for (var nIndex = 0, oListener; oListener = this._listeners[nIndex]; nIndex++)
	            if (oListener[0] == oEventPseudo.type && !oListener[2])
	                (oListener[1].handleEvent || oListener[1]).apply(this, [oEventPseudo]);
	    };

	    //
	    cXMLHttpRequest.prototype.toString    = function() {
	        return '[' + "object" + ' ' + "XMLHttpRequest" + ']';
	    };

	    cXMLHttpRequest.toString    = function() {
	        return '[' + "XMLHttpRequest" + ']';
	    };

	    // Helper function
	    function fReadyStateChange(oRequest) {
	        // Sniffing code
	        if (cXMLHttpRequest.onreadystatechange)
	            cXMLHttpRequest.onreadystatechange.apply(oRequest);

	        // Fake event
	        oRequest.dispatchEvent({
	            'type':            "readystatechange",
	            'bubbles':        false,
	            'cancelable':    false,
	            'timeStamp':    new Date + 0
	        });
	    };

	    function fGetDocument(oRequest) {
	        var oDocument    = oRequest.responseXML,
	            sResponse    = oRequest.responseText;
	        // Try parsing responseText
	        if (bIE && sResponse && oDocument && !oDocument.documentElement && oRequest.getResponseHeader("Content-Type").match(/[^\/]+\/[^\+]+\+xml/)) {
	            oDocument    = new window.ActiveXObject("Microsoft.XMLDOM");
	            oDocument.async                = false;
	            oDocument.validateOnParse    = false;
	            oDocument.loadXML(sResponse);
	        }
	        // Check if there is no error in document
	        if (oDocument)
	            if ((bIE && oDocument.parseError != 0) || !oDocument.documentElement || (oDocument.documentElement && oDocument.documentElement.tagName == "parsererror"))
	                return null;
	        return oDocument;
	    };

	    function fSynchronizeValues(oRequest) {
	        try {    oRequest.responseText    = oRequest._object.responseText;    } catch (e) {}
	        try {    oRequest.responseXML    = fGetDocument(oRequest._object);    } catch (e) {}
	        try {    oRequest.status            = oRequest._object.status;            } catch (e) {}
	        try {    oRequest.statusText        = oRequest._object.statusText;        } catch (e) {}
	    };

	    function fCleanTransport(oRequest) {
	        // BUGFIX: IE - memory leak (on-page leak)
	        oRequest._object.onreadystatechange    = new window.Function;
	    };
	/*
	    // Queue manager
	    var oQueuePending    = {"CRITICAL":[],"HIGH":[],"NORMAL":[],"LOW":[],"LOWEST":[]},
	        aQueueRunning    = [];
	    function fQueue_add(oRequest) {
	        oQueuePending[oRequest.priority in oQueuePending ? oRequest.priority : "NORMAL"].push(oRequest);
	        //
	        setTimeout(fQueue_process);
	    };

	    function fQueue_remove(oRequest) {
	        for (var nIndex = 0, bFound    = false; nIndex < aQueueRunning.length; nIndex++)
	            if (bFound)
	                aQueueRunning[nIndex - 1]    = aQueueRunning[nIndex];
	            else
	            if (aQueueRunning[nIndex] == oRequest)
	                bFound    = true;
	        if (bFound)
	            aQueueRunning.length--;
	        //
	        setTimeout(fQueue_process);
	    };

	    function fQueue_process() {
	        if (aQueueRunning.length < 6) {
	            for (var sPriority in oQueuePending) {
	                if (oQueuePending[sPriority].length) {
	                    var oRequest    = oQueuePending[sPriority][0];
	                    oQueuePending[sPriority]    = oQueuePending[sPriority].slice(1);
	                    //
	                    aQueueRunning.push(oRequest);
	                    // Send request
	                    fXMLHttpRequest_send(oRequest);
	                    break;
	                }
	            }
	        }
	    };
	*/
	    // Internet Explorer 5.0 (missing apply)
	    if (!window.Function.prototype.apply) {
	        window.Function.prototype.apply    = function(oRequest, oArguments) {
	            if (!oArguments)
	                oArguments    = [];
	            oRequest.__func    = this;
	            oRequest.__func(oArguments[0], oArguments[1], oArguments[2], oArguments[3], oArguments[4]);
	            delete oRequest.__func;
	        };
	    };

	    // Register new object with window
	    /**
	     * Class: OpenLayers.Request.XMLHttpRequest
	     * Standard-compliant (W3C) cross-browser implementation of the
	     *     XMLHttpRequest object.  From
	     *     http://code.google.com/p/xmlhttprequest/.
	     */
	    if (!OpenLayers.Request) {
	        /**
	         * This allows for OpenLayers/Request.js to be included
	         * before or after this script.
	         */
	        OpenLayers.Request = {};
	    }
	    OpenLayers.Request.XMLHttpRequest = cXMLHttpRequest;
	})();
	/* ======================================================================
	    OpenLayers/Protocol/HTTP.js
	   ====================================================================== */

	/* Copyright (c) 2006-2015 by OpenLayers Contributors (see authors.txt for
	 * full list of contributors). Published under the 2-clause BSD license.
	 * See license.txt in the OpenLayers distribution or repository for the
	 * full text of the license. */

	/**
	 * @requires OpenLayers/Protocol.js
	 * @requires OpenLayers/Request/XMLHttpRequest.js
	 */

	/**
	 * if application uses the query string, for example, for BBOX parameters,
	 * OpenLayers/Format/QueryStringFilter.js should be included in the build config file
	 */

	/**
	 * Class: OpenLayers.Protocol.HTTP
	 * A basic HTTP protocol for vector layers.  Create a new instance with the
	 *     <OpenLayers.Protocol.HTTP> constructor.
	 *
	 * Inherits from:
	 *  - <OpenLayers.Protocol>
	 */
	OpenLayers.Protocol.HTTP = OpenLayers.Class(OpenLayers.Protocol, {

	    /**
	     * Property: url
	     * {String} Service URL, read-only, set through the options
	     *     passed to constructor.
	     */
	    url: null,

	    /**
	     * Property: headers
	     * {Object} HTTP request headers, read-only, set through the options
	     *     passed to the constructor,
	     *     Example: {'Content-Type': 'plain/text'}
	     */
	    headers: null,

	    /**
	     * Property: params
	     * {Object} Parameters of GET requests, read-only, set through the options
	     *     passed to the constructor,
	     *     Example: {'bbox': '5,5,5,5'}
	     */
	    params: null,
	    
	    /**
	     * Property: callback
	     * {Object} Function to be called when the <read>, <create>,
	     *     <update>, <delete> or <commit> operation completes, read-only,
	     *     set through the options passed to the constructor.
	     */
	    callback: null,

	    /**
	     * Property: scope
	     * {Object} Callback execution scope, read-only, set through the
	     *     options passed to the constructor.
	     */
	    scope: null,

	    /**
	     * APIProperty: readWithPOST
	     * {Boolean} true if read operations are done with POST requests
	     *     instead of GET, defaults to false.
	     */
	    readWithPOST: false,

	    /**
	     * APIProperty: updateWithPOST
	     * {Boolean} true if update operations are done with POST requests
	     *     defaults to false.
	     */
	    updateWithPOST: false,
	    
	    /**
	     * APIProperty: deleteWithPOST
	     * {Boolean} true if delete operations are done with POST requests
	     *     defaults to false.
	     *     if true, POST data is set to output of format.write().
	     */
	    deleteWithPOST: false,

	    /**
	     * Property: wildcarded.
	     * {Boolean} If true percent signs are added around values
	     *     read from LIKE filters, for example if the protocol
	     *     read method is passed a LIKE filter whose property
	     *     is "foo" and whose value is "bar" the string
	     *     "foo__ilike=%bar%" will be sent in the query string;
	     *     defaults to false.
	     */
	    wildcarded: false,

	    /**
	     * APIProperty: srsInBBOX
	     * {Boolean} Include the SRS identifier in BBOX query string parameter.  
	     *     Default is false.  If true and the layer has a projection object set,
	     *     any BBOX filter will be serialized with a fifth item identifying the
	     *     projection.  E.g. bbox=-1000,-1000,1000,1000,EPSG:900913
	     */
	    srsInBBOX: false,

	    /**
	     * Constructor: OpenLayers.Protocol.HTTP
	     * A class for giving layers generic HTTP protocol.
	     *
	     * Parameters:
	     * options - {Object} Optional object whose properties will be set on the
	     *     instance.
	     *
	     * Valid options include:
	     * url - {String}
	     * headers - {Object} 
	     * params - {Object} URL parameters for GET requests
	     * format - {<OpenLayers.Format>}
	     * callback - {Function}
	     * scope - {Object}
	     */
	    initialize: function(options) {
	        options = options || {};
	        this.params = {};
	        this.headers = {};
	        OpenLayers.Protocol.prototype.initialize.apply(this, arguments);

	        if (!this.filterToParams && OpenLayers.Format.QueryStringFilter) {
	            var format = new OpenLayers.Format.QueryStringFilter({
	                wildcarded: this.wildcarded,
	                srsInBBOX: this.srsInBBOX
	            });
	            this.filterToParams = function(filter, params) {
	                return format.write(filter, params);
	            };
	        }
	    },
	    
	    /**
	     * APIMethod: destroy
	     * Clean up the protocol.
	     */
	    destroy: function() {
	        this.params = null;
	        this.headers = null;
	        OpenLayers.Protocol.prototype.destroy.apply(this);
	    },

	    /**
	     * APIMethod: filterToParams
	     * Optional method to translate an <OpenLayers.Filter> object into an object
	     *     that can be serialized as request query string provided.  If a custom
	     *     method is not provided, the filter will be serialized using the 
	     *     <OpenLayers.Format.QueryStringFilter> class.
	     *
	     * Parameters:
	     * filter - {<OpenLayers.Filter>} filter to convert.
	     * params - {Object} The parameters object.
	     *
	     * Returns:
	     * {Object} The resulting parameters object.
	     */
	    
	    /**
	     * APIMethod: read
	     * Construct a request for reading new features.
	     *
	     * Parameters:
	     * options - {Object} Optional object for configuring the request.
	     *     This object is modified and should not be reused.
	     *
	     * Valid options:
	     * url - {String} Url for the request.
	     * params - {Object} Parameters to get serialized as a query string.
	     * headers - {Object} Headers to be set on the request.
	     * filter - {<OpenLayers.Filter>} Filter to get serialized as a
	     *     query string.
	     * readWithPOST - {Boolean} If the request should be done with POST.
	     *
	     * Returns:
	     * {<OpenLayers.Protocol.Response>} A response object, whose "priv" property
	     *     references the HTTP request, this object is also passed to the
	     *     callback function when the request completes, its "features" property
	     *     is then populated with the features received from the server.
	     */
	    read: function(options) {
	        OpenLayers.Protocol.prototype.read.apply(this, arguments);
	        options = options || {};
	        options.params = OpenLayers.Util.applyDefaults(
	            options.params, this.options.params);
	        options = OpenLayers.Util.applyDefaults(options, this.options);
	        if (options.filter && this.filterToParams) {
	            options.params = this.filterToParams(
	                options.filter, options.params
	            );
	        }
	        var readWithPOST = (options.readWithPOST !== undefined) ?
	                           options.readWithPOST : this.readWithPOST;
	        var resp = new OpenLayers.Protocol.Response({requestType: "read"});
	        if(readWithPOST) {
	            var headers = options.headers || {};
	            headers["Content-Type"] = "application/x-www-form-urlencoded";
	            resp.priv = OpenLayers.Request.POST({
	                url: options.url,
	                callback: this.createCallback(this.handleRead, resp, options),
	                data: OpenLayers.Util.getParameterString(options.params),
	                headers: headers
	            });
	        } else {
	            resp.priv = OpenLayers.Request.GET({
	                url: options.url,
	                callback: this.createCallback(this.handleRead, resp, options),
	                params: options.params,
	                headers: options.headers
	            });
	        }
	        return resp;
	    },

	    /**
	     * Method: handleRead
	     * Individual callbacks are created for read, create and update, should
	     *     a subclass need to override each one separately.
	     *
	     * Parameters:
	     * resp - {<OpenLayers.Protocol.Response>} The response object to pass to
	     *     the user callback.
	     * options - {Object} The user options passed to the read call.
	     */
	    handleRead: function(resp, options) {
	        this.handleResponse(resp, options);
	    },

	    /**
	     * APIMethod: create
	     * Construct a request for writing newly created features.
	     *
	     * Parameters:
	     * features - {Array({<OpenLayers.Feature.Vector>})} or
	     *     {<OpenLayers.Feature.Vector>}
	     * options - {Object} Optional object for configuring the request.
	     *     This object is modified and should not be reused.
	     *
	     * Returns:
	     * {<OpenLayers.Protocol.Response>} An <OpenLayers.Protocol.Response>
	     *     object, whose "priv" property references the HTTP request, this 
	     *     object is also passed to the callback function when the request
	     *     completes, its "features" property is then populated with the
	     *     the features received from the server.
	     */
	    create: function(features, options) {
	        options = OpenLayers.Util.applyDefaults(options, this.options);

	        var resp = new OpenLayers.Protocol.Response({
	            reqFeatures: features,
	            requestType: "create"
	        });

	        resp.priv = OpenLayers.Request.POST({
	            url: options.url,
	            callback: this.createCallback(this.handleCreate, resp, options),
	            headers: options.headers,
	            data: this.format.write(features)
	        });

	        return resp;
	    },

	    /**
	     * Method: handleCreate
	     * Called the the request issued by <create> is complete.  May be overridden
	     *     by subclasses.
	     *
	     * Parameters:
	     * resp - {<OpenLayers.Protocol.Response>} The response object to pass to
	     *     any user callback.
	     * options - {Object} The user options passed to the create call.
	     */
	    handleCreate: function(resp, options) {
	        this.handleResponse(resp, options);
	    },

	    /**
	     * APIMethod: update
	     * Construct a request updating modified feature.
	     *
	     * Parameters:
	     * feature - {<OpenLayers.Feature.Vector>}
	     * options - {Object} Optional object for configuring the request.
	     *     This object is modified and should not be reused.
	     *
	     * Returns:
	     * {<OpenLayers.Protocol.Response>} An <OpenLayers.Protocol.Response>
	     *     object, whose "priv" property references the HTTP request, this 
	     *     object is also passed to the callback function when the request
	     *     completes, its "features" property is then populated with the
	     *     the feature received from the server.
	     */
	    update: function(feature, options) {
	        options = options || {};
	        var url = options.url ||
	                  feature.url ||
	                  this.options.url + "/" + feature.fid;
	        options = OpenLayers.Util.applyDefaults(options, this.options);

	        var resp = new OpenLayers.Protocol.Response({
	            reqFeatures: feature,
	            requestType: "update"
	        });

	        var method = this.updateWithPOST ? "POST" : "PUT";
	        resp.priv = OpenLayers.Request[method]({
	            url: url,
	            callback: this.createCallback(this.handleUpdate, resp, options),
	            headers: options.headers,
	            data: this.format.write(feature)
	        });

	        return resp;
	    },

	    /**
	     * Method: handleUpdate
	     * Called the the request issued by <update> is complete.  May be overridden
	     *     by subclasses.
	     *
	     * Parameters:
	     * resp - {<OpenLayers.Protocol.Response>} The response object to pass to
	     *     any user callback.
	     * options - {Object} The user options passed to the update call.
	     */
	    handleUpdate: function(resp, options) {
	        this.handleResponse(resp, options);
	    },

	    /**
	     * APIMethod: delete
	     * Construct a request deleting a removed feature.
	     *
	     * Parameters:
	     * feature - {<OpenLayers.Feature.Vector>}
	     * options - {Object} Optional object for configuring the request.
	     *     This object is modified and should not be reused.
	     *
	     * Returns:
	     * {<OpenLayers.Protocol.Response>} An <OpenLayers.Protocol.Response>
	     *     object, whose "priv" property references the HTTP request, this 
	     *     object is also passed to the callback function when the request
	     *     completes.
	     */
	    "delete": function(feature, options) {
	        options = options || {};
	        var url = options.url ||
	                  feature.url ||
	                  this.options.url + "/" + feature.fid;
	        options = OpenLayers.Util.applyDefaults(options, this.options);

	        var resp = new OpenLayers.Protocol.Response({
	            reqFeatures: feature,
	            requestType: "delete"
	        });

	        var method = this.deleteWithPOST ? "POST" : "DELETE";
	        var requestOptions = {
	            url: url,
	            callback: this.createCallback(this.handleDelete, resp, options),
	            headers: options.headers
	        };
	        if (this.deleteWithPOST) {
	            requestOptions.data = this.format.write(feature);
	        }
	        resp.priv = OpenLayers.Request[method](requestOptions);

	        return resp;
	    },

	    /**
	     * Method: handleDelete
	     * Called the the request issued by <delete> is complete.  May be overridden
	     *     by subclasses.
	     *
	     * Parameters:
	     * resp - {<OpenLayers.Protocol.Response>} The response object to pass to
	     *     any user callback.
	     * options - {Object} The user options passed to the delete call.
	     */
	    handleDelete: function(resp, options) {
	        this.handleResponse(resp, options);
	    },

	    /**
	     * Method: handleResponse
	     * Called by CRUD specific handlers.
	     *
	     * Parameters:
	     * resp - {<OpenLayers.Protocol.Response>} The response object to pass to
	     *     any user callback.
	     * options - {Object} The user options passed to the create, read, update,
	     *     or delete call.
	     */
	    handleResponse: function(resp, options) {
	        var request = resp.priv;
	        if(options.callback) {
	            if(request.status >= 200 && request.status < 300) {
	                // success
	                if(resp.requestType != "delete") {
	                    resp.features = this.parseFeatures(request);
	                }
	                resp.code = OpenLayers.Protocol.Response.SUCCESS;
	            } else {
	                // failure
	                resp.code = OpenLayers.Protocol.Response.FAILURE;
	            }
	            options.callback.call(options.scope, resp);
	        }
	    },

	    /**
	     * Method: parseFeatures
	     * Read HTTP response body and return features.
	     *
	     * Parameters:
	     * request - {XMLHttpRequest} The request object
	     *
	     * Returns:
	     * {Array({<OpenLayers.Feature.Vector>})} or
	     *     {<OpenLayers.Feature.Vector>} Array of features or a single feature.
	     */
	    parseFeatures: function(request) {
	        var doc = request.responseXML;
	        if (!doc || !doc.documentElement) {
	            doc = request.responseText;
	        }
	        if (!doc || doc.length <= 0) {
	            return null;
	        }
	        return this.format.read(doc);
	    },

	    /**
	     * APIMethod: commit
	     * Iterate over each feature and take action based on the feature state.
	     *     Possible actions are create, update and delete.
	     *
	     * Parameters:
	     * features - {Array({<OpenLayers.Feature.Vector>})}
	     * options - {Object} Optional object for setting up intermediate commit
	     *     callbacks.
	     *
	     * Valid options:
	     * create - {Object} Optional object to be passed to the <create> method.
	     * update - {Object} Optional object to be passed to the <update> method.
	     * delete - {Object} Optional object to be passed to the <delete> method.
	     * callback - {Function} Optional function to be called when the commit
	     *     is complete.
	     * scope - {Object} Optional object to be set as the scope of the callback.
	     *
	     * Returns:
	     * {Array(<OpenLayers.Protocol.Response>)} An array of response objects,
	     *     one per request made to the server, each object's "priv" property
	     *     references the corresponding HTTP request.
	     */
	    commit: function(features, options) {
	        options = OpenLayers.Util.applyDefaults(options, this.options);
	        var resp = [], nResponses = 0;
	        
	        // Divide up features before issuing any requests.  This properly
	        // counts requests in the event that any responses come in before
	        // all requests have been issued.
	        var types = {};
	        types[OpenLayers.State.INSERT] = [];
	        types[OpenLayers.State.UPDATE] = [];
	        types[OpenLayers.State.DELETE] = [];
	        var feature, list, requestFeatures = [];
	        for(var i=0, len=features.length; i<len; ++i) {
	            feature = features[i];
	            list = types[feature.state];
	            if(list) {
	                list.push(feature);
	                requestFeatures.push(feature); 
	            }
	        }
	        // tally up number of requests
	        var nRequests = (types[OpenLayers.State.INSERT].length > 0 ? 1 : 0) +
	            types[OpenLayers.State.UPDATE].length +
	            types[OpenLayers.State.DELETE].length;
	        
	        // This response will be sent to the final callback after all the others
	        // have been fired.
	        var success = true;
	        var finalResponse = new OpenLayers.Protocol.Response({
	            reqFeatures: requestFeatures        
	        });
	        
	        function insertCallback(response) {
	            var len = response.features ? response.features.length : 0;
	            var fids = new Array(len);
	            for(var i=0; i<len; ++i) {
	                fids[i] = response.features[i].fid;
	            }   
	            finalResponse.insertIds = fids;
	            callback.apply(this, [response]);
	        }
	 
	        function callback(response) {
	            this.callUserCallback(response, options);
	            success = success && response.success();
	            nResponses++;
	            if (nResponses >= nRequests) {
	                if (options.callback) {
	                    finalResponse.code = success ? 
	                        OpenLayers.Protocol.Response.SUCCESS :
	                        OpenLayers.Protocol.Response.FAILURE;
	                    options.callback.apply(options.scope, [finalResponse]);
	                }    
	            }
	        }

	        // start issuing requests
	        var queue = types[OpenLayers.State.INSERT];
	        if(queue.length > 0) {
	            resp.push(this.create(
	                queue, OpenLayers.Util.applyDefaults(
	                    {callback: insertCallback, scope: this}, options.create
	                )
	            ));
	        }
	        queue = types[OpenLayers.State.UPDATE];
	        for(var i=queue.length-1; i>=0; --i) {
	            resp.push(this.update(
	                queue[i], OpenLayers.Util.applyDefaults(
	                    {callback: callback, scope: this}, options.update
	                ))
	            );
	        }
	        queue = types[OpenLayers.State.DELETE];
	        for(var i=queue.length-1; i>=0; --i) {
	            resp.push(this["delete"](
	                queue[i], OpenLayers.Util.applyDefaults(
	                    {callback: callback, scope: this}, options["delete"]
	                ))
	            );
	        }
	        return resp;
	    },

	    /**
	     * APIMethod: abort
	     * Abort an ongoing request, the response object passed to
	     * this method must come from this HTTP protocol (as a result
	     * of a create, read, update, delete or commit operation).
	     *
	     * Parameters:
	     * response - {<OpenLayers.Protocol.Response>}
	     */
	    abort: function(response) {
	        if (response) {
	            response.priv.abort();
	        }
	    },

	    /**
	     * Method: callUserCallback
	     * This method is used from within the commit method each time an
	     *     an HTTP response is received from the server, it is responsible
	     *     for calling the user-supplied callbacks.
	     *
	     * Parameters:
	     * resp - {<OpenLayers.Protocol.Response>}
	     * options - {Object} The map of options passed to the commit call.
	     */
	    callUserCallback: function(resp, options) {
	        var opt = options[resp.requestType];
	        if(opt && opt.callback) {
	            opt.callback.call(opt.scope, resp);
	        }
	    },

	    CLASS_NAME: "OpenLayers.Protocol.HTTP" 
	});
	/* ======================================================================
	    OpenLayers/Geometry.js
	   ====================================================================== */

	/* Copyright (c) 2006-2015 by OpenLayers Contributors (see authors.txt for
	 * full list of contributors). Published under the 2-clause BSD license.
	 * See license.txt in the OpenLayers distribution or repository for the
	 * full text of the license. */
	 
	/**
	 * @requires OpenLayers/BaseTypes/Class.js
	 */

	/**
	 * Class: OpenLayers.Geometry
	 * A Geometry is a description of a geographic object.  Create an instance of
	 * this class with the <OpenLayers.Geometry> constructor.  This is a base class,
	 * typical geometry types are described by subclasses of this class.
	 *
	 * Note that if you use the <OpenLayers.Geometry.fromWKT> method, you must
	 * explicitly include the OpenLayers.Format.WKT in your build.
	 */
	OpenLayers.Geometry = OpenLayers.Class({

	    /**
	     * Property: id
	     * {String} A unique identifier for this geometry.
	     */
	    id: null,

	    /**
	     * Property: parent
	     * {<OpenLayers.Geometry>}This is set when a Geometry is added as component
	     * of another geometry
	     */
	    parent: null,

	    /**
	     * Property: bounds 
	     * {<OpenLayers.Bounds>} The bounds of this geometry
	     */
	    bounds: null,

	    /**
	     * Constructor: OpenLayers.Geometry
	     * Creates a geometry object.  
	     */
	    initialize: function() {
	        this.id = OpenLayers.Util.createUniqueID(this.CLASS_NAME+ "_");
	    },
	    
	    /**
	     * Method: destroy
	     * Destroy this geometry.
	     */
	    destroy: function() {
	        this.id = null;
	        this.bounds = null;
	    },
	    
	    /**
	     * APIMethod: clone
	     * Create a clone of this geometry.  Does not set any non-standard
	     *     properties of the cloned geometry.
	     * 
	     * Returns:
	     * {<OpenLayers.Geometry>} An exact clone of this geometry.
	     */
	    clone: function() {
	        return new OpenLayers.Geometry();
	    },
	    
	    /**
	     * Method: setBounds
	     * Set the bounds for this Geometry.
	     * 
	     * Parameters:
	     * bounds - {<OpenLayers.Bounds>} 
	     */
	    setBounds: function(bounds) {
	        if (bounds) {
	            this.bounds = bounds.clone();
	        }
	    },
	    
	    /**
	     * Method: clearBounds
	     * Nullify this components bounds and that of its parent as well.
	     */
	    clearBounds: function() {
	        this.bounds = null;
	        if (this.parent) {
	            this.parent.clearBounds();
	        }    
	    },
	    
	    /**
	     * Method: extendBounds
	     * Extend the existing bounds to include the new bounds. 
	     * If geometry's bounds is not yet set, then set a new Bounds.
	     * 
	     * Parameters:
	     * newBounds - {<OpenLayers.Bounds>} 
	     */
	    extendBounds: function(newBounds){
	        var bounds = this.getBounds();
	        if (!bounds) {
	            this.setBounds(newBounds);
	        } else {
	            this.bounds.extend(newBounds);
	        }
	    },
	    
	    /**
	     * APIMethod: getBounds
	     * Get the bounds for this Geometry. If bounds is not set, it 
	     * is calculated again, this makes queries faster.
	     * 
	     * Returns:
	     * {<OpenLayers.Bounds>}
	     */
	    getBounds: function() {
	        if (this.bounds == null) {
	            this.calculateBounds();
	        }
	        return this.bounds;
	    },
	    
	    /** 
	     * APIMethod: calculateBounds
	     * Recalculate the bounds for the geometry. 
	     */
	    calculateBounds: function() {
	        //
	        // This should be overridden by subclasses.
	        //
	    },
	    
	    /**
	     * APIMethod: distanceTo
	     * Calculate the closest distance between two geometries (on the x-y plane).
	     *
	     * Parameters:
	     * geometry - {<OpenLayers.Geometry>} The target geometry.
	     * options - {Object} Optional properties for configuring the distance
	     *     calculation.
	     *
	     * Valid options depend on the specific geometry type.
	     * 
	     * Returns:
	     * {Number | Object} The distance between this geometry and the target.
	     *     If details is true, the return will be an object with distance,
	     *     x0, y0, x1, and x2 properties.  The x0 and y0 properties represent
	     *     the coordinates of the closest point on this geometry. The x1 and y1
	     *     properties represent the coordinates of the closest point on the
	     *     target geometry.
	     */
	    distanceTo: function(geometry, options) {
	    },
	    
	    /**
	     * APIMethod: getVertices
	     * Return a list of all points in this geometry.
	     *
	     * Parameters:
	     * nodes - {Boolean} For lines, only return vertices that are
	     *     endpoints.  If false, for lines, only vertices that are not
	     *     endpoints will be returned.  If not provided, all vertices will
	     *     be returned.
	     *
	     * Returns:
	     * {Array} A list of all vertices in the geometry.
	     */
	    getVertices: function(nodes) {
	    },

	    /**
	     * Method: atPoint
	     * Note - This is only an approximation based on the bounds of the 
	     * geometry.
	     * 
	     * Parameters:
	     * lonlat - {<OpenLayers.LonLat>|Object} OpenLayers.LonLat or an
	     *     object with a 'lon' and 'lat' properties.
	     * toleranceLon - {float} Optional tolerance in Geometric Coords
	     * toleranceLat - {float} Optional tolerance in Geographic Coords
	     * 
	     * Returns:
	     * {Boolean} Whether or not the geometry is at the specified location
	     */
	    atPoint: function(lonlat, toleranceLon, toleranceLat) {
	        var atPoint = false;
	        var bounds = this.getBounds();
	        if ((bounds != null) && (lonlat != null)) {

	            var dX = (toleranceLon != null) ? toleranceLon : 0;
	            var dY = (toleranceLat != null) ? toleranceLat : 0;
	    
	            var toleranceBounds = 
	                new OpenLayers.Bounds(this.bounds.left - dX,
	                                      this.bounds.bottom - dY,
	                                      this.bounds.right + dX,
	                                      this.bounds.top + dY);

	            atPoint = toleranceBounds.containsLonLat(lonlat);
	        }
	        return atPoint;
	    },
	    
	    /**
	     * Method: getLength
	     * Calculate the length of this geometry. This method is defined in
	     * subclasses.
	     * 
	     * Returns:
	     * {Float} The length of the collection by summing its parts
	     */
	    getLength: function() {
	        //to be overridden by geometries that actually have a length
	        //
	        return 0.0;
	    },

	    /**
	     * Method: getArea
	     * Calculate the area of this geometry. This method is defined in subclasses.
	     * 
	     * Returns:
	     * {Float} The area of the collection by summing its parts
	     */
	    getArea: function() {
	        //to be overridden by geometries that actually have an area
	        //
	        return 0.0;
	    },
	    
	    /**
	     * APIMethod: getCentroid
	     * Calculate the centroid of this geometry. This method is defined in subclasses.
	     *
	     * Returns:
	     * {<OpenLayers.Geometry.Point>} The centroid of the collection
	     */
	    getCentroid: function() {
	        return null;
	    },

	    /**
	     * Method: toString
	     * Returns a text representation of the geometry.  If the WKT format is
	     *     included in a build, this will be the Well-Known Text 
	     *     representation.
	     *
	     * Returns:
	     * {String} String representation of this geometry.
	     */
	    toString: function() {
	        var string;
	        if (OpenLayers.Format && OpenLayers.Format.WKT) {
	            string = OpenLayers.Format.WKT.prototype.write(
	                new OpenLayers.Feature.Vector(this)
	            );
	        } else {
	            string = Object.prototype.toString.call(this);
	        }
	        return string;
	    },

	    CLASS_NAME: "OpenLayers.Geometry"
	});

	/**
	 * Function: OpenLayers.Geometry.fromWKT
	 * Generate a geometry given a Well-Known Text string.  For this method to
	 *     work, you must include the OpenLayers.Format.WKT in your build 
	 *     explicitly.
	 *
	 * Parameters:
	 * wkt - {String} A string representing the geometry in Well-Known Text.
	 *
	 * Returns:
	 * {<OpenLayers.Geometry>} A geometry of the appropriate class.
	 */
	OpenLayers.Geometry.fromWKT = function(wkt) {
	    var geom;
	    if (OpenLayers.Format && OpenLayers.Format.WKT) {
	        var format = OpenLayers.Geometry.fromWKT.format;
	        if (!format) {
	            format = new OpenLayers.Format.WKT();
	            OpenLayers.Geometry.fromWKT.format = format;
	        }
	        var result = format.read(wkt);
	        if (result instanceof OpenLayers.Feature.Vector) {
	            geom = result.geometry;
	        } else if (OpenLayers.Util.isArray(result)) {
	            var len = result.length;
	            var components = new Array(len);
	            for (var i=0; i<len; ++i) {
	                components[i] = result[i].geometry;
	            }
	            geom = new OpenLayers.Geometry.Collection(components);
	        }
	    }
	    return geom;
	};
	    
	/**
	 * Method: OpenLayers.Geometry.segmentsIntersect
	 * Determine whether two line segments intersect.  Optionally calculates
	 *     and returns the intersection point.  This function is optimized for
	 *     cases where seg1.x2 >= seg2.x1 || seg2.x2 >= seg1.x1.  In those
	 *     obvious cases where there is no intersection, the function should
	 *     not be called.
	 *
	 * Parameters:
	 * seg1 - {Object} Object representing a segment with properties x1, y1, x2,
	 *     and y2.  The start point is represented by x1 and y1.  The end point
	 *     is represented by x2 and y2.  Start and end are ordered so that x1 < x2.
	 * seg2 - {Object} Object representing a segment with properties x1, y1, x2,
	 *     and y2.  The start point is represented by x1 and y1.  The end point
	 *     is represented by x2 and y2.  Start and end are ordered so that x1 < x2.
	 * options - {Object} Optional properties for calculating the intersection.
	 *
	 * Valid options:
	 * point - {Boolean} Return the intersection point.  If false, the actual
	 *     intersection point will not be calculated.  If true and the segments
	 *     intersect, the intersection point will be returned.  If true and
	 *     the segments do not intersect, false will be returned.  If true and
	 *     the segments are coincident, true will be returned.
	 * tolerance - {Number} If a non-null value is provided, if the segments are
	 *     within the tolerance distance, this will be considered an intersection.
	 *     In addition, if the point option is true and the calculated intersection
	 *     is within the tolerance distance of an end point, the endpoint will be
	 *     returned instead of the calculated intersection.  Further, if the
	 *     intersection is within the tolerance of endpoints on both segments, or
	 *     if two segment endpoints are within the tolerance distance of eachother
	 *     (but no intersection is otherwise calculated), an endpoint on the
	 *     first segment provided will be returned.
	 *
	 * Returns:
	 * {Boolean | <OpenLayers.Geometry.Point>}  The two segments intersect.
	 *     If the point argument is true, the return will be the intersection
	 *     point or false if none exists.  If point is true and the segments
	 *     are coincident, return will be true (and the instersection is equal
	 *     to the shorter segment).
	 */
	OpenLayers.Geometry.segmentsIntersect = function(seg1, seg2, options) {
	    var point = options && options.point;
	    var tolerance = options && options.tolerance;
	    var intersection = false;
	    var x11_21 = seg1.x1 - seg2.x1;
	    var y11_21 = seg1.y1 - seg2.y1;
	    var x12_11 = seg1.x2 - seg1.x1;
	    var y12_11 = seg1.y2 - seg1.y1;
	    var y22_21 = seg2.y2 - seg2.y1;
	    var x22_21 = seg2.x2 - seg2.x1;
	    var d = (y22_21 * x12_11) - (x22_21 * y12_11);
	    var n1 = (x22_21 * y11_21) - (y22_21 * x11_21);
	    var n2 = (x12_11 * y11_21) - (y12_11 * x11_21);
	    if(d == 0) {
	        // parallel
	        if(n1 == 0 && n2 == 0) {
	            // coincident
	            intersection = true;
	        }
	    } else {
	        var along1 = n1 / d;
	        var along2 = n2 / d;
	        if(along1 >= 0 && along1 <= 1 && along2 >=0 && along2 <= 1) {
	            // intersect
	            if(!point) {
	                intersection = true;
	            } else {
	                // calculate the intersection point
	                var x = seg1.x1 + (along1 * x12_11);
	                var y = seg1.y1 + (along1 * y12_11);
	                intersection = new OpenLayers.Geometry.Point(x, y);
	            }
	        }
	    }
	    if(tolerance) {
	        var dist;
	        if(intersection) {
	            if(point) {
	                var segs = [seg1, seg2];
	                var seg, x, y;
	                // check segment endpoints for proximity to intersection
	                // set intersection to first endpoint within the tolerance
	                outer: for(var i=0; i<2; ++i) {
	                    seg = segs[i];
	                    for(var j=1; j<3; ++j) {
	                        x = seg["x" + j];
	                        y = seg["y" + j];
	                        dist = Math.sqrt(
	                            Math.pow(x - intersection.x, 2) +
	                            Math.pow(y - intersection.y, 2)
	                        );
	                        if(dist < tolerance) {
	                            intersection.x = x;
	                            intersection.y = y;
	                            break outer;
	                        }
	                    }
	                }
	                
	            }
	        } else {
	            // no calculated intersection, but segments could be within
	            // the tolerance of one another
	            var segs = [seg1, seg2];
	            var source, target, x, y, p, result;
	            // check segment endpoints for proximity to intersection
	            // set intersection to first endpoint within the tolerance
	            outer: for(var i=0; i<2; ++i) {
	                source = segs[i];
	                target = segs[(i+1)%2];
	                for(var j=1; j<3; ++j) {
	                    p = {x: source["x"+j], y: source["y"+j]};
	                    result = OpenLayers.Geometry.distanceToSegment(p, target);
	                    if(result.distance < tolerance) {
	                        if(point) {
	                            intersection = new OpenLayers.Geometry.Point(p.x, p.y);
	                        } else {
	                            intersection = true;
	                        }
	                        break outer;
	                    }
	                }
	            }
	        }
	    }
	    return intersection;
	};

	/**
	 * Function: OpenLayers.Geometry.distanceToSegment
	 *
	 * Parameters:
	 * point - {Object} An object with x and y properties representing the
	 *     point coordinates.
	 * segment - {Object} An object with x1, y1, x2, and y2 properties
	 *     representing endpoint coordinates.
	 *
	 * Returns:
	 * {Object} An object with distance, along, x, and y properties.  The distance
	 *     will be the shortest distance between the input point and segment.
	 *     The x and y properties represent the coordinates along the segment
	 *     where the shortest distance meets the segment. The along attribute
	 *     describes how far between the two segment points the given point is.
	 */
	OpenLayers.Geometry.distanceToSegment = function(point, segment) {
	    var result = OpenLayers.Geometry.distanceSquaredToSegment(point, segment);
	    result.distance = Math.sqrt(result.distance);
	    return result;
	};

	/**
	 * Function: OpenLayers.Geometry.distanceSquaredToSegment
	 *
	 * Usually the distanceToSegment function should be used. This variant however
	 * can be used for comparisons where the exact distance is not important.
	 *
	 * Parameters:
	 * point - {Object} An object with x and y properties representing the
	 *     point coordinates.
	 * segment - {Object} An object with x1, y1, x2, and y2 properties
	 *     representing endpoint coordinates.
	 *
	 * Returns:
	 * {Object} An object with squared distance, along, x, and y properties.
	 *     The distance will be the shortest distance between the input point and
	 *     segment. The x and y properties represent the coordinates along the
	 *     segment where the shortest distance meets the segment. The along
	 *     attribute describes how far between the two segment points the given
	 *     point is.
	 */
	OpenLayers.Geometry.distanceSquaredToSegment = function(point, segment) {
	    var x0 = point.x;
	    var y0 = point.y;
	    var x1 = segment.x1;
	    var y1 = segment.y1;
	    var x2 = segment.x2;
	    var y2 = segment.y2;
	    var dx = x2 - x1;
	    var dy = y2 - y1;
	    var along = (dx == 0 && dy == 0) ? 0 : ((dx * (x0 - x1)) + (dy * (y0 - y1))) /
	                (Math.pow(dx, 2) + Math.pow(dy, 2));
	    var x, y;
	    if(along <= 0.0) {
	        x = x1;
	        y = y1;
	    } else if(along >= 1.0) {
	        x = x2;
	        y = y2;
	    } else {
	        x = x1 + along * dx;
	        y = y1 + along * dy;
	    }
	    return {
	        distance: Math.pow(x - x0, 2) + Math.pow(y - y0, 2),
	        x: x, y: y,
	        along: along
	    };
	};
	/* ======================================================================
	    OpenLayers/Geometry/Collection.js
	   ====================================================================== */

	/* Copyright (c) 2006-2015 by OpenLayers Contributors (see authors.txt for
	 * full list of contributors). Published under the 2-clause BSD license.
	 * See license.txt in the OpenLayers distribution or repository for the
	 * full text of the license. */

	/**
	 * @requires OpenLayers/Geometry.js
	 */

	/**
	 * Class: OpenLayers.Geometry.Collection
	 * A Collection is exactly what it sounds like: A collection of different 
	 * Geometries. These are stored in the local parameter <components> (which
	 * can be passed as a parameter to the constructor). 
	 * 
	 * As new geometries are added to the collection, they are NOT cloned. 
	 * When removing geometries, they need to be specified by reference (ie you 
	 * have to pass in the *exact* geometry to be removed).
	 * 
	 * The <getArea> and <getLength> functions here merely iterate through
	 * the components, summing their respective areas and lengths.
	 *
	 * Create a new instance with the <OpenLayers.Geometry.Collection> constructor.
	 *
	 * Inherits from:
	 *  - <OpenLayers.Geometry> 
	 */
	OpenLayers.Geometry.Collection = OpenLayers.Class(OpenLayers.Geometry, {

	    /**
	     * APIProperty: components
	     * {Array(<OpenLayers.Geometry>)} The component parts of this geometry
	     */
	    components: null,
	    
	    /**
	     * Property: componentTypes
	     * {Array(String)} An array of class names representing the types of
	     * components that the collection can include.  A null value means the
	     * component types are not restricted.
	     */
	    componentTypes: null,

	    /**
	     * Constructor: OpenLayers.Geometry.Collection
	     * Creates a Geometry Collection -- a list of geoms.
	     *
	     * Parameters: 
	     * components - {Array(<OpenLayers.Geometry>)} Optional array of geometries
	     *
	     */
	    initialize: function (components) {
	        OpenLayers.Geometry.prototype.initialize.apply(this, arguments);
	        this.components = [];
	        if (components != null) {
	            this.addComponents(components);
	        }
	    },

	    /**
	     * APIMethod: destroy
	     * Destroy this geometry.
	     */
	    destroy: function () {
	        this.components.length = 0;
	        this.components = null;
	        OpenLayers.Geometry.prototype.destroy.apply(this, arguments);
	    },

	    /**
	     * APIMethod: clone
	     * Clone this geometry.
	     *
	     * Returns:
	     * {<OpenLayers.Geometry.Collection>} An exact clone of this collection
	     */
	    clone: function() {
	        var Constructor = OpenLayers.Util.getConstructor(this.CLASS_NAME);
	        var geometry = new Constructor();
	        for(var i=0, len=this.components.length; i<len; i++) {
	            geometry.addComponent(this.components[i].clone());
	        }
	        
	        // catch any randomly tagged-on properties
	        OpenLayers.Util.applyDefaults(geometry, this);
	        
	        return geometry;
	    },

	    /**
	     * Method: getComponentsString
	     * Get a string representing the components for this collection
	     * 
	     * Returns:
	     * {String} A string representation of the components of this geometry
	     */
	    getComponentsString: function(){
	        var strings = [];
	        for(var i=0, len=this.components.length; i<len; i++) {
	            strings.push(this.components[i].toShortString()); 
	        }
	        return strings.join(",");
	    },

	    /**
	     * APIMethod: calculateBounds
	     * Recalculate the bounds by iterating through the components and 
	     * calling calling extendBounds() on each item.
	     */
	    calculateBounds: function() {
	        this.bounds = null;
	        var bounds = new OpenLayers.Bounds();
	        var components = this.components;
	        if (components) {
	            for (var i=0, len=components.length; i<len; i++) {
	                bounds.extend(components[i].getBounds());
	            }
	        }
	        // to preserve old behavior, we only set bounds if non-null
	        // in the future, we could add bounds.isEmpty()
	        if (bounds.left != null && bounds.bottom != null && 
	            bounds.right != null && bounds.top != null) {
	            this.setBounds(bounds);
	        }
	    },

	    /**
	     * APIMethod: addComponents
	     * Add components to this geometry.
	     *
	     * Parameters:
	     * components - {Array(<OpenLayers.Geometry>)} An array of geometries to add
	     */
	    addComponents: function(components){
	        if(!(OpenLayers.Util.isArray(components))) {
	            components = [components];
	        }
	        for(var i=0, len=components.length; i<len; i++) {
	            this.addComponent(components[i]);
	        }
	    },

	    /**
	     * Method: addComponent
	     * Add a new component (geometry) to the collection.  If this.componentTypes
	     * is set, then the component class name must be in the componentTypes array.
	     *
	     * The bounds cache is reset.
	     * 
	     * Parameters:
	     * component - {<OpenLayers.Geometry>} A geometry to add
	     * index - {int} Optional index into the array to insert the component
	     *
	     * Returns:
	     * {Boolean} The component geometry was successfully added
	     */    
	    addComponent: function(component, index) {
	        var added = false;
	        if(component) {
	            if(this.componentTypes == null ||
	               (OpenLayers.Util.indexOf(this.componentTypes,
	                                        component.CLASS_NAME) > -1)) {

	                if(index != null && (index < this.components.length)) {
	                    var components1 = this.components.slice(0, index);
	                    var components2 = this.components.slice(index, 
	                                                           this.components.length);
	                    components1.push(component);
	                    this.components = components1.concat(components2);
	                } else {
	                    this.components.push(component);
	                }
	                component.parent = this;
	                this.clearBounds();
	                added = true;
	            }
	        }
	        return added;
	    },
	    
	    /**
	     * APIMethod: removeComponents
	     * Remove components from this geometry.
	     *
	     * Parameters:
	     * components - {Array(<OpenLayers.Geometry>)} The components to be removed
	     *
	     * Returns: 
	     * {Boolean} A component was removed.
	     */
	    removeComponents: function(components) {
	        var removed = false;

	        if(!(OpenLayers.Util.isArray(components))) {
	            components = [components];
	        }
	        for(var i=components.length-1; i>=0; --i) {
	            removed = this.removeComponent(components[i]) || removed;
	        }
	        return removed;
	    },
	    
	    /**
	     * Method: removeComponent
	     * Remove a component from this geometry.
	     *
	     * Parameters:
	     * component - {<OpenLayers.Geometry>} 
	     *
	     * Returns: 
	     * {Boolean} The component was removed.
	     */
	    removeComponent: function(component) {
	        
	        OpenLayers.Util.removeItem(this.components, component);
	        
	        // clearBounds() so that it gets recalculated on the next call
	        // to this.getBounds();
	        this.clearBounds();
	        return true;
	    },

	    /**
	     * APIMethod: getLength
	     * Calculate the length of this geometry
	     *
	     * Returns:
	     * {Float} The length of the geometry
	     */
	    getLength: function() {
	        var length = 0.0;
	        for (var i=0, len=this.components.length; i<len; i++) {
	            length += this.components[i].getLength();
	        }
	        return length;
	    },
	    
	    /**
	     * APIMethod: getArea
	     * Calculate the area of this geometry. Note how this function is overridden
	     * in <OpenLayers.Geometry.Polygon>.
	     *
	     * Returns:
	     * {Float} The area of the collection by summing its parts
	     */
	    getArea: function() {
	        var area = 0.0;
	        for (var i=0, len=this.components.length; i<len; i++) {
	            area += this.components[i].getArea();
	        }
	        return area;
	    },

	    /** 
	     * APIMethod: getGeodesicArea
	     * Calculate the approximate area of the polygon were it projected onto
	     *     the earth.
	     *
	     * Parameters:
	     * projection - {<OpenLayers.Projection>} The spatial reference system
	     *     for the geometry coordinates.  If not provided, Geographic/WGS84 is
	     *     assumed.
	     * 
	     * Reference:
	     * Robert. G. Chamberlain and William H. Duquette, "Some Algorithms for
	     *     Polygons on a Sphere", JPL Publication 07-03, Jet Propulsion
	     *     Laboratory, Pasadena, CA, June 2007 http://trs-new.jpl.nasa.gov/dspace/handle/2014/40409
	     *
	     * Returns:
	     * {float} The approximate geodesic area of the geometry in square meters.
	     */
	    getGeodesicArea: function(projection) {
	        var area = 0.0;
	        for(var i=0, len=this.components.length; i<len; i++) {
	            area += this.components[i].getGeodesicArea(projection);
	        }
	        return area;
	    },
	    
	    /**
	     * APIMethod: getCentroid
	     *
	     * Compute the centroid for this geometry collection.
	     *
	     * Parameters:
	     * weighted - {Boolean} Perform the getCentroid computation recursively,
	     * returning an area weighted average of all geometries in this collection.
	     *
	     * Returns:
	     * {<OpenLayers.Geometry.Point>} The centroid of the collection
	     */
	    getCentroid: function(weighted) {
	        if (!weighted) {
	            return this.components.length && this.components[0].getCentroid();
	        }
	        var len = this.components.length;
	        if (!len) {
	            return false;
	        }
	        
	        var areas = [];
	        var centroids = [];
	        var areaSum = 0;
	        var minArea = Number.MAX_VALUE;
	        var component;
	        for (var i=0; i<len; ++i) {
	            component = this.components[i];
	            var area = component.getArea();
	            var centroid = component.getCentroid(true);
	            if (isNaN(area) || isNaN(centroid.x) || isNaN(centroid.y)) {
	                continue;
	            }
	            areas.push(area);
	            areaSum += area;
	            minArea = (area < minArea && area > 0) ? area : minArea;
	            centroids.push(centroid);
	        }
	        len = areas.length;
	        if (areaSum === 0) {
	            // all the components in this collection have 0 area
	            // probably a collection of points -- weight all the points the same
	            for (var i=0; i<len; ++i) {
	                areas[i] = 1;
	            }
	            areaSum = areas.length;
	        } else {
	            // normalize all the areas where the smallest area will get
	            // a value of 1
	            for (var i=0; i<len; ++i) {
	                areas[i] /= minArea;
	            }
	            areaSum /= minArea;
	        }
	        
	        var xSum = 0, ySum = 0, centroid, area;
	        for (var i=0; i<len; ++i) {
	            centroid = centroids[i];
	            area = areas[i];
	            xSum += centroid.x * area;
	            ySum += centroid.y * area;
	        }
	        
	        return new OpenLayers.Geometry.Point(xSum/areaSum, ySum/areaSum);
	    },

	    /**
	     * APIMethod: getGeodesicLength
	     * Calculate the approximate length of the geometry were it projected onto
	     *     the earth.
	     *
	     * projection - {<OpenLayers.Projection>} The spatial reference system
	     *     for the geometry coordinates.  If not provided, Geographic/WGS84 is
	     *     assumed.
	     * 
	     * Returns:
	     * {Float} The appoximate geodesic length of the geometry in meters.
	     */
	    getGeodesicLength: function(projection) {
	        var length = 0.0;
	        for(var i=0, len=this.components.length; i<len; i++) {
	            length += this.components[i].getGeodesicLength(projection);
	        }
	        return length;
	    },

	    /**
	     * APIMethod: move
	     * Moves a geometry by the given displacement along positive x and y axes.
	     *     This modifies the position of the geometry and clears the cached
	     *     bounds.
	     *
	     * Parameters:
	     * x - {Float} Distance to move geometry in positive x direction. 
	     * y - {Float} Distance to move geometry in positive y direction.
	     */
	    move: function(x, y) {
	        for(var i=0, len=this.components.length; i<len; i++) {
	            this.components[i].move(x, y);
	        }
	    },

	    /**
	     * APIMethod: rotate
	     * Rotate a geometry around some origin
	     *
	     * Parameters:
	     * angle - {Float} Rotation angle in degrees (measured counterclockwise
	     *                 from the positive x-axis)
	     * origin - {<OpenLayers.Geometry.Point>} Center point for the rotation
	     */
	    rotate: function(angle, origin) {
	        for(var i=0, len=this.components.length; i<len; ++i) {
	            this.components[i].rotate(angle, origin);
	        }
	    },

	    /**
	     * APIMethod: resize
	     * Resize a geometry relative to some origin.  Use this method to apply
	     *     a uniform scaling to a geometry.
	     *
	     * Parameters:
	     * scale - {Float} Factor by which to scale the geometry.  A scale of 2
	     *                 doubles the size of the geometry in each dimension
	     *                 (lines, for example, will be twice as long, and polygons
	     *                 will have four times the area).
	     * origin - {<OpenLayers.Geometry.Point>} Point of origin for resizing
	     * ratio - {Float} Optional x:y ratio for resizing.  Default ratio is 1.
	     * 
	     * Returns:
	     * {<OpenLayers.Geometry>} - The current geometry. 
	     */
	    resize: function(scale, origin, ratio) {
	        for(var i=0; i<this.components.length; ++i) {
	            this.components[i].resize(scale, origin, ratio);
	        }
	        return this;
	    },

	    /**
	     * APIMethod: distanceTo
	     * Calculate the closest distance between two geometries (on the x-y plane).
	     *
	     * Parameters:
	     * geometry - {<OpenLayers.Geometry>} The target geometry.
	     * options - {Object} Optional properties for configuring the distance
	     *     calculation.
	     *
	     * Valid options:
	     * details - {Boolean} Return details from the distance calculation.
	     *     Default is false.
	     * edge - {Boolean} Calculate the distance from this geometry to the
	     *     nearest edge of the target geometry.  Default is true.  If true,
	     *     calling distanceTo from a geometry that is wholly contained within
	     *     the target will result in a non-zero distance.  If false, whenever
	     *     geometries intersect, calling distanceTo will return 0.  If false,
	     *     details cannot be returned.
	     *
	     * Returns:
	     * {Number | Object} The distance between this geometry and the target.
	     *     If details is true, the return will be an object with distance,
	     *     x0, y0, x1, and y1 properties.  The x0 and y0 properties represent
	     *     the coordinates of the closest point on this geometry. The x1 and y1
	     *     properties represent the coordinates of the closest point on the
	     *     target geometry.
	     */
	    distanceTo: function(geometry, options) {
	        var edge = !(options && options.edge === false);
	        var details = edge && options && options.details;
	        var result, best, distance;
	        var min = Number.POSITIVE_INFINITY;
	        for(var i=0, len=this.components.length; i<len; ++i) {
	            result = this.components[i].distanceTo(geometry, options);
	            distance = details ? result.distance : result;
	            if(distance < min) {
	                min = distance;
	                best = result;
	                if(min == 0) {
	                    break;
	                }
	            }
	        }
	        return best;
	    },

	    /** 
	     * APIMethod: equals
	     * Determine whether another geometry is equivalent to this one.  Geometries
	     *     are considered equivalent if all components have the same coordinates.
	     * 
	     * Parameters:
	     * geometry - {<OpenLayers.Geometry>} The geometry to test. 
	     *
	     * Returns:
	     * {Boolean} The supplied geometry is equivalent to this geometry.
	     */
	    equals: function(geometry) {
	        var equivalent = true;
	        if(!geometry || !geometry.CLASS_NAME ||
	           (this.CLASS_NAME != geometry.CLASS_NAME)) {
	            equivalent = false;
	        } else if(!(OpenLayers.Util.isArray(geometry.components)) ||
	                  (geometry.components.length != this.components.length)) {
	            equivalent = false;
	        } else {
	            for(var i=0, len=this.components.length; i<len; ++i) {
	                if(!this.components[i].equals(geometry.components[i])) {
	                    equivalent = false;
	                    break;
	                }
	            }
	        }
	        return equivalent;
	    },

	    /**
	     * APIMethod: transform
	     * Reproject the components geometry from source to dest.
	     * 
	     * Parameters:
	     * source - {<OpenLayers.Projection>} 
	     * dest - {<OpenLayers.Projection>}
	     * 
	     * Returns:
	     * {<OpenLayers.Geometry>} 
	     */
	    transform: function(source, dest) {
	        if (source && dest) {
	            for (var i=0, len=this.components.length; i<len; i++) {  
	                var component = this.components[i];
	                component.transform(source, dest);
	            }
	            this.bounds = null;
	        }
	        return this;
	    },

	    /**
	     * APIMethod: intersects
	     * Determine if the input geometry intersects this one.
	     *
	     * Parameters:
	     * geometry - {<OpenLayers.Geometry>} Any type of geometry.
	     *
	     * Returns:
	     * {Boolean} The input geometry intersects this one.
	     */
	    intersects: function(geometry) {
	        var intersect = false;
	        for(var i=0, len=this.components.length; i<len; ++ i) {
	            intersect = geometry.intersects(this.components[i]);
	            if(intersect) {
	                break;
	            }
	        }
	        return intersect;
	    },

	    /**
	     * APIMethod: getVertices
	     * Return a list of all points in this geometry.
	     *
	     * Parameters:
	     * nodes - {Boolean} For lines, only return vertices that are
	     *     endpoints.  If false, for lines, only vertices that are not
	     *     endpoints will be returned.  If not provided, all vertices will
	     *     be returned.
	     *
	     * Returns:
	     * {Array} A list of all vertices in the geometry.
	     */
	    getVertices: function(nodes) {
	        var vertices = [];
	        for(var i=0, len=this.components.length; i<len; ++i) {
	            Array.prototype.push.apply(
	                vertices, this.components[i].getVertices(nodes)
	            );
	        }
	        return vertices;
	    },


	    CLASS_NAME: "OpenLayers.Geometry.Collection"
	});
	/* ======================================================================
	    OpenLayers/Geometry/Point.js
	   ====================================================================== */

	/* Copyright (c) 2006-2015 by OpenLayers Contributors (see authors.txt for
	 * full list of contributors). Published under the 2-clause BSD license.
	 * See license.txt in the OpenLayers distribution or repository for the
	 * full text of the license. */

	/**
	 * @requires OpenLayers/Geometry.js
	 */

	/**
	 * Class: OpenLayers.Geometry.Point
	 * Point geometry class. 
	 * 
	 * Inherits from:
	 *  - <OpenLayers.Geometry> 
	 */
	OpenLayers.Geometry.Point = OpenLayers.Class(OpenLayers.Geometry, {

	    /** 
	     * APIProperty: x 
	     * {float} 
	     */
	    x: null,

	    /** 
	     * APIProperty: y 
	     * {float} 
	     */
	    y: null,

	    /**
	     * Constructor: OpenLayers.Geometry.Point
	     * Construct a point geometry.
	     *
	     * Parameters:
	     * x - {float} 
	     * y - {float}
	     * 
	     */
	    initialize: function(x, y) {
	        OpenLayers.Geometry.prototype.initialize.apply(this, arguments);
	        
	        this.x = parseFloat(x);
	        this.y = parseFloat(y);
	    },

	    /**
	     * APIMethod: clone
	     * 
	     * Returns:
	     * {<OpenLayers.Geometry.Point>} An exact clone of this OpenLayers.Geometry.Point
	     */
	    clone: function(obj) {
	        if (obj == null) {
	            obj = new OpenLayers.Geometry.Point(this.x, this.y);
	        }

	        // catch any randomly tagged-on properties
	        OpenLayers.Util.applyDefaults(obj, this);

	        return obj;
	    },

	    /** 
	     * Method: calculateBounds
	     * Create a new Bounds based on the lon/lat
	     */
	    calculateBounds: function () {
	        this.bounds = new OpenLayers.Bounds(this.x, this.y,
	                                            this.x, this.y);
	    },

	    /**
	     * APIMethod: distanceTo
	     * Calculate the closest distance between two geometries (on the x-y plane).
	     *
	     * Parameters:
	     * geometry - {<OpenLayers.Geometry>} The target geometry.
	     * options - {Object} Optional properties for configuring the distance
	     *     calculation.
	     *
	     * Valid options:
	     * details - {Boolean} Return details from the distance calculation.
	     *     Default is false.
	     * edge - {Boolean} Calculate the distance from this geometry to the
	     *     nearest edge of the target geometry.  Default is true.  If true,
	     *     calling distanceTo from a geometry that is wholly contained within
	     *     the target will result in a non-zero distance.  If false, whenever
	     *     geometries intersect, calling distanceTo will return 0.  If false,
	     *     details cannot be returned.
	     *
	     * Returns:
	     * {Number | Object} The distance between this geometry and the target.
	     *     If details is true, the return will be an object with distance,
	     *     x0, y0, x1, and x2 properties.  The x0 and y0 properties represent
	     *     the coordinates of the closest point on this geometry. The x1 and y1
	     *     properties represent the coordinates of the closest point on the
	     *     target geometry.
	     */
	    distanceTo: function(geometry, options) {
	        var edge = !(options && options.edge === false);
	        var details = edge && options && options.details;
	        var distance, x0, y0, x1, y1, result;
	        if(geometry instanceof OpenLayers.Geometry.Point) {
	            x0 = this.x;
	            y0 = this.y;
	            x1 = geometry.x;
	            y1 = geometry.y;
	            distance = Math.sqrt(Math.pow(x0 - x1, 2) + Math.pow(y0 - y1, 2));
	            result = !details ?
	                distance : {x0: x0, y0: y0, x1: x1, y1: y1, distance: distance};
	        } else {
	            result = geometry.distanceTo(this, options);
	            if(details) {
	                // switch coord order since this geom is target
	                result = {
	                    x0: result.x1, y0: result.y1,
	                    x1: result.x0, y1: result.y0,
	                    distance: result.distance
	                };
	            }
	        }
	        return result;
	    },
	    
	    /** 
	     * APIMethod: equals
	     * Determine whether another geometry is equivalent to this one.  Geometries
	     *     are considered equivalent if all components have the same coordinates.
	     * 
	     * Parameters:
	     * geom - {<OpenLayers.Geometry.Point>} The geometry to test. 
	     *
	     * Returns:
	     * {Boolean} The supplied geometry is equivalent to this geometry.
	     */
	    equals: function(geom) {
	        var equals = false;
	        if (geom != null) {
	            equals = ((this.x == geom.x && this.y == geom.y) ||
	                      (isNaN(this.x) && isNaN(this.y) && isNaN(geom.x) && isNaN(geom.y)));
	        }
	        return equals;
	    },
	    
	    /**
	     * Method: toShortString
	     *
	     * Returns:
	     * {String} Shortened String representation of Point object. 
	     *         (ex. <i>"5, 42"</i>)
	     */
	    toShortString: function() {
	        return (this.x + ", " + this.y);
	    },
	    
	    /**
	     * APIMethod: move
	     * Moves a geometry by the given displacement along positive x and y axes.
	     *     This modifies the position of the geometry and clears the cached
	     *     bounds.
	     *
	     * Parameters:
	     * x - {Float} Distance to move geometry in positive x direction. 
	     * y - {Float} Distance to move geometry in positive y direction.
	     */
	    move: function(x, y) {
	        this.x = this.x + x;
	        this.y = this.y + y;
	        this.clearBounds();
	    },

	    /**
	     * APIMethod: rotate
	     * Rotate a point around another.
	     *
	     * Parameters:
	     * angle - {Float} Rotation angle in degrees (measured counterclockwise
	     *                 from the positive x-axis)
	     * origin - {<OpenLayers.Geometry.Point>} Center point for the rotation
	     */
	    rotate: function(angle, origin) {
	        angle *= Math.PI / 180;
	        var radius = this.distanceTo(origin);
	        var theta = angle + Math.atan2(this.y - origin.y, this.x - origin.x);
	        this.x = origin.x + (radius * Math.cos(theta));
	        this.y = origin.y + (radius * Math.sin(theta));
	        this.clearBounds();
	    },
	    
	    /**
	     * APIMethod: getCentroid
	     *
	     * Returns:
	     * {<OpenLayers.Geometry.Point>} The centroid of the collection
	     */
	    getCentroid: function() {
	        return new OpenLayers.Geometry.Point(this.x, this.y);
	    },

	    /**
	     * APIMethod: resize
	     * Resize a point relative to some origin.  For points, this has the effect
	     *     of scaling a vector (from the origin to the point).  This method is
	     *     more useful on geometry collection subclasses.
	     *
	     * Parameters:
	     * scale - {Float} Ratio of the new distance from the origin to the old
	     *                 distance from the origin.  A scale of 2 doubles the
	     *                 distance between the point and origin.
	     * origin - {<OpenLayers.Geometry.Point>} Point of origin for resizing
	     * ratio - {Float} Optional x:y ratio for resizing.  Default ratio is 1.
	     * 
	     * Returns:
	     * {<OpenLayers.Geometry>} - The current geometry. 
	     */
	    resize: function(scale, origin, ratio) {
	        ratio = (ratio == undefined) ? 1 : ratio;
	        this.x = origin.x + (scale * ratio * (this.x - origin.x));
	        this.y = origin.y + (scale * (this.y - origin.y));
	        this.clearBounds();
	        return this;
	    },
	    
	    /**
	     * APIMethod: intersects
	     * Determine if the input geometry intersects this one.
	     *
	     * Parameters:
	     * geometry - {<OpenLayers.Geometry>} Any type of geometry.
	     *
	     * Returns:
	     * {Boolean} The input geometry intersects this one.
	     */
	    intersects: function(geometry) {
	        var intersect = false;
	        if(geometry.CLASS_NAME == "OpenLayers.Geometry.Point") {
	            intersect = this.equals(geometry);
	        } else {
	            intersect = geometry.intersects(this);
	        }
	        return intersect;
	    },
	    
	    /**
	     * APIMethod: transform
	     * Translate the x,y properties of the point from source to dest.
	     * 
	     * Parameters:
	     * source - {<OpenLayers.Projection>} 
	     * dest - {<OpenLayers.Projection>}
	     * 
	     * Returns:
	     * {<OpenLayers.Geometry>} 
	     */
	    transform: function(source, dest) {
	        if ((source && dest)) {
	            OpenLayers.Projection.transform(
	                this, source, dest); 
	            this.bounds = null;
	        }       
	        return this;
	    },

	    /**
	     * APIMethod: getVertices
	     * Return a list of all points in this geometry.
	     *
	     * Parameters:
	     * nodes - {Boolean} For lines, only return vertices that are
	     *     endpoints.  If false, for lines, only vertices that are not
	     *     endpoints will be returned.  If not provided, all vertices will
	     *     be returned.
	     *
	     * Returns:
	     * {Array} A list of all vertices in the geometry.
	     */
	    getVertices: function(nodes) {
	        return [this];
	    },

	    CLASS_NAME: "OpenLayers.Geometry.Point"
	});
	/* ======================================================================
	    OpenLayers/Geometry/MultiPoint.js
	   ====================================================================== */

	/* Copyright (c) 2006-2015 by OpenLayers Contributors (see authors.txt for
	 * full list of contributors). Published under the 2-clause BSD license.
	 * See license.txt in the OpenLayers distribution or repository for the
	 * full text of the license. */

	/**
	 * @requires OpenLayers/Geometry/Collection.js
	 * @requires OpenLayers/Geometry/Point.js
	 */

	/**
	 * Class: OpenLayers.Geometry.MultiPoint
	 * MultiPoint is a collection of Points.  Create a new instance with the
	 * <OpenLayers.Geometry.MultiPoint> constructor.
	 *
	 * Inherits from:
	 *  - <OpenLayers.Geometry.Collection>
	 *  - <OpenLayers.Geometry>
	 */
	OpenLayers.Geometry.MultiPoint = OpenLayers.Class(
	  OpenLayers.Geometry.Collection, {

	    /**
	     * Property: componentTypes
	     * {Array(String)} An array of class names representing the types of
	     * components that the collection can include.  A null value means the
	     * component types are not restricted.
	     */
	    componentTypes: ["OpenLayers.Geometry.Point"],

	    /**
	     * Constructor: OpenLayers.Geometry.MultiPoint
	     * Create a new MultiPoint Geometry
	     *
	     * Parameters:
	     * components - {Array(<OpenLayers.Geometry.Point>)} 
	     *
	     * Returns:
	     * {<OpenLayers.Geometry.MultiPoint>}
	     */

	    /**
	     * APIMethod: addPoint
	     * Wrapper for <OpenLayers.Geometry.Collection.addComponent>
	     *
	     * Parameters:
	     * point - {<OpenLayers.Geometry.Point>} Point to be added
	     * index - {Integer} Optional index
	     */
	    addPoint: function(point, index) {
	        this.addComponent(point, index);
	    },
	    
	    /**
	     * APIMethod: removePoint
	     * Wrapper for <OpenLayers.Geometry.Collection.removeComponent>
	     *
	     * Parameters:
	     * point - {<OpenLayers.Geometry.Point>} Point to be removed
	     */
	    removePoint: function(point){
	        this.removeComponent(point);
	    },

	    CLASS_NAME: "OpenLayers.Geometry.MultiPoint"
	});
	/* ======================================================================
	    OpenLayers/Geometry/Curve.js
	   ====================================================================== */

	/* Copyright (c) 2006-2015 by OpenLayers Contributors (see authors.txt for
	 * full list of contributors). Published under the 2-clause BSD license.
	 * See license.txt in the OpenLayers distribution or repository for the
	 * full text of the license. */

	/**
	 * @requires OpenLayers/Geometry/MultiPoint.js
	 */

	/**
	 * Class: OpenLayers.Geometry.Curve
	 * A Curve is a MultiPoint, whose points are assumed to be connected. To 
	 * this end, we provide a "getLength()" function, which iterates through 
	 * the points, summing the distances between them. 
	 * 
	 * Inherits: 
	 *  - <OpenLayers.Geometry.MultiPoint>
	 */
	OpenLayers.Geometry.Curve = OpenLayers.Class(OpenLayers.Geometry.MultiPoint, {

	    /**
	     * Property: componentTypes
	     * {Array(String)} An array of class names representing the types of 
	     *                 components that the collection can include.  A null 
	     *                 value means the component types are not restricted.
	     */
	    componentTypes: ["OpenLayers.Geometry.Point"],

	    /**
	     * Constructor: OpenLayers.Geometry.Curve
	     * 
	     * Parameters:
	     * point - {Array(<OpenLayers.Geometry.Point>)}
	     */
	    
	    /**
	     * APIMethod: getLength
	     * 
	     * Returns:
	     * {Float} The length of the curve
	     */
	    getLength: function() {
	        var length = 0.0;
	        if ( this.components && (this.components.length > 1)) {
	            for(var i=1, len=this.components.length; i<len; i++) {
	                length += this.components[i-1].distanceTo(this.components[i]);
	            }
	        }
	        return length;
	    },

	    /**
	     * APIMethod: getGeodesicLength
	     * Calculate the approximate length of the geometry were it projected onto
	     *     the earth.
	     *
	     * projection - {<OpenLayers.Projection>} The spatial reference system
	     *     for the geometry coordinates.  If not provided, Geographic/WGS84 is
	     *     assumed.
	     * 
	     * Returns:
	     * {Float} The appoximate geodesic length of the geometry in meters.
	     */
	    getGeodesicLength: function(projection) {
	        var geom = this;  // so we can work with a clone if needed
	        if(projection) {
	            var gg = new OpenLayers.Projection("EPSG:4326");
	            if(!gg.equals(projection)) {
	                geom = this.clone().transform(projection, gg);
	            }
	        }
	        var length = 0.0;
	        if(geom.components && (geom.components.length > 1)) {
	            var p1, p2;
	            for(var i=1, len=geom.components.length; i<len; i++) {
	                p1 = geom.components[i-1];
	                p2 = geom.components[i];
	                // this returns km and requires lon/lat properties
	                length += OpenLayers.Util.distVincenty(
	                    {lon: p1.x, lat: p1.y}, {lon: p2.x, lat: p2.y}
	                );
	            }
	        }
	        // convert to m
	        return length * 1000;
	    },

	    CLASS_NAME: "OpenLayers.Geometry.Curve"
	});
	/* ======================================================================
	    OpenLayers/Geometry/LineString.js
	   ====================================================================== */

	/* Copyright (c) 2006-2015 by OpenLayers Contributors (see authors.txt for
	 * full list of contributors). Published under the 2-clause BSD license.
	 * See license.txt in the OpenLayers distribution or repository for the
	 * full text of the license. */

	/**
	 * @requires OpenLayers/Geometry/Curve.js
	 */

	/**
	 * Class: OpenLayers.Geometry.LineString
	 * A LineString is a Curve which, once two points have been added to it, can 
	 * never be less than two points long.
	 * 
	 * Inherits from:
	 *  - <OpenLayers.Geometry.Curve>
	 */
	OpenLayers.Geometry.LineString = OpenLayers.Class(OpenLayers.Geometry.Curve, {

	    /**
	     * Constructor: OpenLayers.Geometry.LineString
	     * Create a new LineString geometry
	     *
	     * Parameters:
	     * points - {Array(<OpenLayers.Geometry.Point>)} An array of points used to
	     *          generate the linestring
	     *
	     */

	    /**
	     * APIMethod: removeComponent
	     * Only allows removal of a point if there are three or more points in 
	     * the linestring. (otherwise the result would be just a single point)
	     *
	     * Parameters: 
	     * point - {<OpenLayers.Geometry.Point>} The point to be removed
	     *
	     * Returns: 
	     * {Boolean} The component was removed.
	     */
	    removeComponent: function(point) {
	        var removed = this.components && (this.components.length > 2);
	        if (removed) {
	            OpenLayers.Geometry.Collection.prototype.removeComponent.apply(this, 
	                                                                  arguments);
	        }
	        return removed;
	    },
	    
	    /**
	     * APIMethod: intersects
	     * Test for instersection between two geometries.  This is a cheapo
	     *     implementation of the Bently-Ottmann algorigithm.  It doesn't
	     *     really keep track of a sweep line data structure.  It is closer
	     *     to the brute force method, except that segments are sorted and
	     *     potential intersections are only calculated when bounding boxes
	     *     intersect.
	     *
	     * Parameters:
	     * geometry - {<OpenLayers.Geometry>}
	     *
	     * Returns:
	     * {Boolean} The input geometry intersects this geometry.
	     */
	    intersects: function(geometry) {
	        var intersect = false;
	        var type = geometry.CLASS_NAME;
	        if(type == "OpenLayers.Geometry.LineString" ||
	           type == "OpenLayers.Geometry.LinearRing" ||
	           type == "OpenLayers.Geometry.Point") {
	            var segs1 = this.getSortedSegments();
	            var segs2;
	            if(type == "OpenLayers.Geometry.Point") {
	                segs2 = [{
	                    x1: geometry.x, y1: geometry.y,
	                    x2: geometry.x, y2: geometry.y
	                }];
	            } else {
	                segs2 = geometry.getSortedSegments();
	            }
	            var seg1, seg1x1, seg1x2, seg1y1, seg1y2,
	                seg2, seg2y1, seg2y2;
	            // sweep right
	            outer: for(var i=0, len=segs1.length; i<len; ++i) {
	                seg1 = segs1[i];
	                seg1x1 = seg1.x1;
	                seg1x2 = seg1.x2;
	                seg1y1 = seg1.y1;
	                seg1y2 = seg1.y2;
	                inner: for(var j=0, jlen=segs2.length; j<jlen; ++j) {
	                    seg2 = segs2[j];
	                    if(seg2.x1 > seg1x2) {
	                        // seg1 still left of seg2
	                        break;
	                    }
	                    if(seg2.x2 < seg1x1) {
	                        // seg2 still left of seg1
	                        continue;
	                    }
	                    seg2y1 = seg2.y1;
	                    seg2y2 = seg2.y2;
	                    if(Math.min(seg2y1, seg2y2) > Math.max(seg1y1, seg1y2)) {
	                        // seg2 above seg1
	                        continue;
	                    }
	                    if(Math.max(seg2y1, seg2y2) < Math.min(seg1y1, seg1y2)) {
	                        // seg2 below seg1
	                        continue;
	                    }
	                    if(OpenLayers.Geometry.segmentsIntersect(seg1, seg2)) {
	                        intersect = true;
	                        break outer;
	                    }
	                }
	            }
	        } else {
	            intersect = geometry.intersects(this);
	        }
	        return intersect;
	    },
	    
	    /**
	     * Method: getSortedSegments
	     *
	     * Returns:
	     * {Array} An array of segment objects.  Segment objects have properties
	     *     x1, y1, x2, and y2.  The start point is represented by x1 and y1.
	     *     The end point is represented by x2 and y2.  Start and end are
	     *     ordered so that x1 < x2.
	     */
	    getSortedSegments: function() {
	        var numSeg = this.components.length - 1;
	        var segments = new Array(numSeg), point1, point2;
	        for(var i=0; i<numSeg; ++i) {
	            point1 = this.components[i];
	            point2 = this.components[i + 1];
	            if(point1.x < point2.x) {
	                segments[i] = {
	                    x1: point1.x,
	                    y1: point1.y,
	                    x2: point2.x,
	                    y2: point2.y
	                };
	            } else {
	                segments[i] = {
	                    x1: point2.x,
	                    y1: point2.y,
	                    x2: point1.x,
	                    y2: point1.y
	                };
	            }
	        }
	        // more efficient to define this somewhere static
	        function byX1(seg1, seg2) {
	            return seg1.x1 - seg2.x1;
	        }
	        return segments.sort(byX1);
	    },
	    
	    /**
	     * Method: splitWithSegment
	     * Split this geometry with the given segment.
	     *
	     * Parameters:
	     * seg - {Object} An object with x1, y1, x2, and y2 properties referencing
	     *     segment endpoint coordinates.
	     * options - {Object} Properties of this object will be used to determine
	     *     how the split is conducted.
	     *
	     * Valid options:
	     * edge - {Boolean} Allow splitting when only edges intersect.  Default is
	     *     true.  If false, a vertex on the source segment must be within the
	     *     tolerance distance of the intersection to be considered a split.
	     * tolerance - {Number} If a non-null value is provided, intersections
	     *     within the tolerance distance of one of the source segment's
	     *     endpoints will be assumed to occur at the endpoint.
	     *
	     * Returns:
	     * {Object} An object with *lines* and *points* properties.  If the given
	     *     segment intersects this linestring, the lines array will reference
	     *     geometries that result from the split.  The points array will contain
	     *     all intersection points.  Intersection points are sorted along the
	     *     segment (in order from x1,y1 to x2,y2).
	     */
	    splitWithSegment: function(seg, options) {
	        var edge = !(options && options.edge === false);
	        var tolerance = options && options.tolerance;
	        var lines = [];
	        var verts = this.getVertices();
	        var points = [];
	        var intersections = [];
	        var split = false;
	        var vert1, vert2, point;
	        var node, vertex, target;
	        var interOptions = {point: true, tolerance: tolerance};
	        var result = null;
	        for(var i=0, stop=verts.length-2; i<=stop; ++i) {
	            vert1 = verts[i];
	            points.push(vert1.clone());
	            vert2 = verts[i+1];
	            target = {x1: vert1.x, y1: vert1.y, x2: vert2.x, y2: vert2.y};
	            point = OpenLayers.Geometry.segmentsIntersect(
	                seg, target, interOptions
	            );
	            if(point instanceof OpenLayers.Geometry.Point) {
	                if((point.x === seg.x1 && point.y === seg.y1) ||
	                   (point.x === seg.x2 && point.y === seg.y2) ||
	                   point.equals(vert1) || point.equals(vert2)) {
	                    vertex = true;
	                } else {
	                    vertex = false;
	                }
	                if(vertex || edge) {
	                    // push intersections different than the previous
	                    if(!point.equals(intersections[intersections.length-1])) {
	                        intersections.push(point.clone());
	                    }
	                    if(i === 0) {
	                        if(point.equals(vert1)) {
	                            continue;
	                        }
	                    }
	                    if(point.equals(vert2)) {
	                        continue;
	                    }
	                    split = true;
	                    if(!point.equals(vert1)) {
	                        points.push(point);
	                    }
	                    lines.push(new OpenLayers.Geometry.LineString(points));
	                    points = [point.clone()];
	                }
	            }
	        }
	        if(split) {
	            points.push(vert2.clone());
	            lines.push(new OpenLayers.Geometry.LineString(points));
	        }
	        if(intersections.length > 0) {
	            // sort intersections along segment
	            var xDir = seg.x1 < seg.x2 ? 1 : -1;
	            var yDir = seg.y1 < seg.y2 ? 1 : -1;
	            result = {
	                lines: lines,
	                points: intersections.sort(function(p1, p2) {
	                    return (xDir * p1.x - xDir * p2.x) || (yDir * p1.y - yDir * p2.y);
	                })
	            };
	        }
	        return result;
	    },

	    /**
	     * Method: split
	     * Use this geometry (the source) to attempt to split a target geometry.
	     * 
	     * Parameters:
	     * target - {<OpenLayers.Geometry>} The target geometry.
	     * options - {Object} Properties of this object will be used to determine
	     *     how the split is conducted.
	     *
	     * Valid options:
	     * mutual - {Boolean} Split the source geometry in addition to the target
	     *     geometry.  Default is false.
	     * edge - {Boolean} Allow splitting when only edges intersect.  Default is
	     *     true.  If false, a vertex on the source must be within the tolerance
	     *     distance of the intersection to be considered a split.
	     * tolerance - {Number} If a non-null value is provided, intersections
	     *     within the tolerance distance of an existing vertex on the source
	     *     will be assumed to occur at the vertex.
	     * 
	     * Returns:
	     * {Array} A list of geometries (of this same type as the target) that
	     *     result from splitting the target with the source geometry.  The
	     *     source and target geometry will remain unmodified.  If no split
	     *     results, null will be returned.  If mutual is true and a split
	     *     results, return will be an array of two arrays - the first will be
	     *     all geometries that result from splitting the source geometry and
	     *     the second will be all geometries that result from splitting the
	     *     target geometry.
	     */
	    split: function(target, options) {
	        var results = null;
	        var mutual = options && options.mutual;
	        var sourceSplit, targetSplit, sourceParts, targetParts;
	        if(target instanceof OpenLayers.Geometry.LineString) {
	            var verts = this.getVertices();
	            var vert1, vert2, seg, splits, lines, point;
	            var points = [];
	            sourceParts = [];
	            for(var i=0, stop=verts.length-2; i<=stop; ++i) {
	                vert1 = verts[i];
	                vert2 = verts[i+1];
	                seg = {
	                    x1: vert1.x, y1: vert1.y,
	                    x2: vert2.x, y2: vert2.y
	                };
	                targetParts = targetParts || [target];
	                if(mutual) {
	                    points.push(vert1.clone());
	                }
	                for(var j=0; j<targetParts.length; ++j) {
	                    splits = targetParts[j].splitWithSegment(seg, options);
	                    if(splits) {
	                        // splice in new features
	                        lines = splits.lines;
	                        if(lines.length > 0) {
	                            lines.unshift(j, 1);
	                            Array.prototype.splice.apply(targetParts, lines);
	                            j += lines.length - 2;
	                        }
	                        if(mutual) {
	                            for(var k=0, len=splits.points.length; k<len; ++k) {
	                                point = splits.points[k];
	                                if(!point.equals(vert1)) {
	                                    points.push(point);
	                                    sourceParts.push(new OpenLayers.Geometry.LineString(points));
	                                    if(point.equals(vert2)) {
	                                        points = [];
	                                    } else {
	                                        points = [point.clone()];
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	            if(mutual && sourceParts.length > 0 && points.length > 0) {
	                points.push(vert2.clone());
	                sourceParts.push(new OpenLayers.Geometry.LineString(points));
	            }
	        } else {
	            results = target.splitWith(this, options);
	        }
	        if(targetParts && targetParts.length > 1) {
	            targetSplit = true;
	        } else {
	            targetParts = [];
	        }
	        if(sourceParts && sourceParts.length > 1) {
	            sourceSplit = true;
	        } else {
	            sourceParts = [];
	        }
	        if(targetSplit || sourceSplit) {
	            if(mutual) {
	                results = [sourceParts, targetParts];
	            } else {
	                results = targetParts;
	            }
	        }
	        return results;
	    },

	    /**
	     * Method: splitWith
	     * Split this geometry (the target) with the given geometry (the source).
	     *
	     * Parameters:
	     * geometry - {<OpenLayers.Geometry>} A geometry used to split this
	     *     geometry (the source).
	     * options - {Object} Properties of this object will be used to determine
	     *     how the split is conducted.
	     *
	     * Valid options:
	     * mutual - {Boolean} Split the source geometry in addition to the target
	     *     geometry.  Default is false.
	     * edge - {Boolean} Allow splitting when only edges intersect.  Default is
	     *     true.  If false, a vertex on the source must be within the tolerance
	     *     distance of the intersection to be considered a split.
	     * tolerance - {Number} If a non-null value is provided, intersections
	     *     within the tolerance distance of an existing vertex on the source
	     *     will be assumed to occur at the vertex.
	     * 
	     * Returns:
	     * {Array} A list of geometries (of this same type as the target) that
	     *     result from splitting the target with the source geometry.  The
	     *     source and target geometry will remain unmodified.  If no split
	     *     results, null will be returned.  If mutual is true and a split
	     *     results, return will be an array of two arrays - the first will be
	     *     all geometries that result from splitting the source geometry and
	     *     the second will be all geometries that result from splitting the
	     *     target geometry.
	     */
	    splitWith: function(geometry, options) {
	        return geometry.split(this, options);

	    },

	    /**
	     * APIMethod: getVertices
	     * Return a list of all points in this geometry.
	     *
	     * Parameters:
	     * nodes - {Boolean} For lines, only return vertices that are
	     *     endpoints.  If false, for lines, only vertices that are not
	     *     endpoints will be returned.  If not provided, all vertices will
	     *     be returned.
	     *
	     * Returns:
	     * {Array} A list of all vertices in the geometry.
	     */
	    getVertices: function(nodes) {
	        var vertices;
	        if(nodes === true) {
	            vertices = [
	                this.components[0],
	                this.components[this.components.length-1]
	            ];
	        } else if (nodes === false) {
	            vertices = this.components.slice(1, this.components.length-1);
	        } else {
	            vertices = this.components.slice();
	        }
	        return vertices;
	    },

	    /**
	     * APIMethod: distanceTo
	     * Calculate the closest distance between two geometries (on the x-y plane).
	     *
	     * Parameters:
	     * geometry - {<OpenLayers.Geometry>} The target geometry.
	     * options - {Object} Optional properties for configuring the distance
	     *     calculation.
	     *
	     * Valid options:
	     * details - {Boolean} Return details from the distance calculation.
	     *     Default is false.
	     * edge - {Boolean} Calculate the distance from this geometry to the
	     *     nearest edge of the target geometry.  Default is true.  If true,
	     *     calling distanceTo from a geometry that is wholly contained within
	     *     the target will result in a non-zero distance.  If false, whenever
	     *     geometries intersect, calling distanceTo will return 0.  If false,
	     *     details cannot be returned.
	     *
	     * Returns:
	     * {Number | Object} The distance between this geometry and the target.
	     *     If details is true, the return will be an object with distance,
	     *     x0, y0, x1, and x2 properties.  The x0 and y0 properties represent
	     *     the coordinates of the closest point on this geometry. The x1 and y1
	     *     properties represent the coordinates of the closest point on the
	     *     target geometry.
	     */
	    distanceTo: function(geometry, options) {
	        var edge = !(options && options.edge === false);
	        var details = edge && options && options.details;
	        var result, best = {};
	        var min = Number.POSITIVE_INFINITY;
	        if(geometry instanceof OpenLayers.Geometry.Point) {
	            var segs = this.getSortedSegments();
	            var x = geometry.x;
	            var y = geometry.y;
	            var seg;
	            for(var i=0, len=segs.length; i<len; ++i) {
	                seg = segs[i];
	                result = OpenLayers.Geometry.distanceToSegment(geometry, seg);
	                if(result.distance < min) {
	                    min = result.distance;
	                    if(details) {
	                        best = {
	                            distance: min,
	                            x0: result.x, y0: result.y,
	                            x1: x, y1: y,
	                            index: i,
	                            indexDistance: new OpenLayers.Geometry.Point(seg.x1, seg.y1).distanceTo(geometry)
	                        };
	                    } else {
	                        best = min;
	                    }
	                    if(min === 0) {
	                        break;
	                    }
	                }
	            }
	        } else if(geometry instanceof OpenLayers.Geometry.LineString) { 
	            var segs0 = this.getSortedSegments();
	            var segs1 = geometry.getSortedSegments();
	            var seg0, seg1, intersection, x0, y0;
	            var len1 = segs1.length;
	            var interOptions = {point: true};
	            outer: for(var i=0, len=segs0.length; i<len; ++i) {
	                seg0 = segs0[i];
	                x0 = seg0.x1;
	                y0 = seg0.y1;
	                for(var j=0; j<len1; ++j) {
	                    seg1 = segs1[j];
	                    intersection = OpenLayers.Geometry.segmentsIntersect(seg0, seg1, interOptions);
	                    if(intersection) {
	                        min = 0;
	                        best = {
	                            distance: 0,
	                            x0: intersection.x, y0: intersection.y,
	                            x1: intersection.x, y1: intersection.y
	                        };
	                        break outer;
	                    } else {
	                        result = OpenLayers.Geometry.distanceToSegment({x: x0, y: y0}, seg1);
	                        if(result.distance < min) {
	                            min = result.distance;
	                            best = {
	                                distance: min,
	                                x0: x0, y0: y0,
	                                x1: result.x, y1: result.y
	                            };
	                        }
	                    }
	                }
	            }
	            if(!details) {
	                best = best.distance;
	            }
	            if(min !== 0) {
	                // check the final vertex in this line's sorted segments
	                if(seg0) {
	                    result = geometry.distanceTo(
	                        new OpenLayers.Geometry.Point(seg0.x2, seg0.y2),
	                        options
	                    );
	                    var dist = details ? result.distance : result;
	                    if(dist < min) {
	                        if(details) {
	                            best = {
	                                distance: min,
	                                x0: result.x1, y0: result.y1,
	                                x1: result.x0, y1: result.y0
	                            };
	                        } else {
	                            best = dist;
	                        }
	                    }
	                }
	            }
	        } else {
	            best = geometry.distanceTo(this, options);
	            // swap since target comes from this line
	            if(details) {
	                best = {
	                    distance: best.distance,
	                    x0: best.x1, y0: best.y1,
	                    x1: best.x0, y1: best.y0
	                };
	            }
	        }
	        return best;
	    },
	    
	    /**
	     * APIMethod: simplify
	     * This function will return a simplified LineString.
	     * Simplification is based on the Douglas-Peucker algorithm.
	     *
	     *
	     * Parameters:
	     * tolerance - {number} threshold for simplification in map units
	     *
	     * Returns:
	     * {OpenLayers.Geometry.LineString} the simplified LineString
	     */
	    simplify: function(tolerance){
	        if (this && this !== null) {
	            var points = this.getVertices();
	            if (points.length < 3) {
	                return this;
	            }
	    
	            var compareNumbers = function(a, b){
	                return (a-b);
	            };
	    
	            /**
	             * Private function doing the Douglas-Peucker reduction
	             */
	            var douglasPeuckerReduction = function(points, firstPoint, lastPoint, tolerance){
	                var maxDistance = 0;
	                var indexFarthest = 0;
	    
	                for (var index = firstPoint, distance; index < lastPoint; index++) {
	                    distance = perpendicularDistance(points[firstPoint], points[lastPoint], points[index]);
	                    if (distance > maxDistance) {
	                        maxDistance = distance;
	                        indexFarthest = index;
	                    }
	                }
	    
	                if (maxDistance > tolerance && indexFarthest != firstPoint) {
	                    //Add the largest point that exceeds the tolerance
	                    pointIndexsToKeep.push(indexFarthest);
	                    douglasPeuckerReduction(points, firstPoint, indexFarthest, tolerance);
	                    douglasPeuckerReduction(points, indexFarthest, lastPoint, tolerance);
	                }
	            };
	    
	            /**
	             * Private function calculating the perpendicular distance
	             * TODO: check whether OpenLayers.Geometry.LineString::distanceTo() is faster or slower
	             */
	            var perpendicularDistance = function(point1, point2, point){
	                //Area = |(1/2)(x1y2 + x2y3 + x3y1 - x2y1 - x3y2 - x1y3)|   *Area of triangle
	                //Base = v((x1-x2)Â²+(x1-x2)Â²)                               *Base of Triangle*
	                //Area = .5*Base*H                                          *Solve for height
	                //Height = Area/.5/Base
	    
	                var area = Math.abs(0.5 * (point1.x * point2.y + point2.x * point.y + point.x * point1.y - point2.x * point1.y - point.x * point2.y - point1.x * point.y));
	                var bottom = Math.sqrt(Math.pow(point1.x - point2.x, 2) + Math.pow(point1.y - point2.y, 2));
	                var height = area / bottom * 2;
	    
	                return height;
	            };
	    
	            var firstPoint = 0;
	            var lastPoint = points.length - 1;
	            var pointIndexsToKeep = [];
	    
	            //Add the first and last index to the keepers
	            pointIndexsToKeep.push(firstPoint);
	            pointIndexsToKeep.push(lastPoint);
	    
	            //The first and the last point cannot be the same
	            while (points[firstPoint].equals(points[lastPoint])) {
	                lastPoint--;
	                //Addition: the first point not equal to first point in the LineString is kept as well
	                pointIndexsToKeep.push(lastPoint);
	            }
	    
	            douglasPeuckerReduction(points, firstPoint, lastPoint, tolerance);
	            var returnPoints = [];
	            pointIndexsToKeep.sort(compareNumbers);
	            for (var index = 0; index < pointIndexsToKeep.length; index++) {
	                returnPoints.push(points[pointIndexsToKeep[index]]);
	            }
	            return new OpenLayers.Geometry.LineString(returnPoints);
	    
	        }
	        else {
	            return this;
	        }
	    },

	    CLASS_NAME: "OpenLayers.Geometry.LineString"
	});


	/**
	 * Function: OpenLayers.Geometry.LineString.geodesic
	 *
	 * Parameters:
	 * interpolate - {function(number): OpenLayers.Geometry.Point} Interpolate
	 *     function.
	 * transform - {function(OpenLayers.Geometry.Point): OpenLayers.Geometry.Point}
	 *     Transform from longitude/latitude to projected coordinates.
	 * squaredTolerance - {number} Squared tolerance.
	 *
	 * Returns:
	 * {OpenLayers.Geometry.LineString}
	 */
	OpenLayers.Geometry.LineString.geodesic =
	        function(interpolate, transform, squaredTolerance) {
	    // FIXME reduce garbage generation
	    // FIXME optimize stack operations

	    var components = [];

	    var geoA = interpolate(0);
	    var geoB = interpolate(1);

	    var a = transform(geoA);
	    var b = transform(geoB);

	    var geoStack = [geoB, geoA];
	    var stack = [b, a];
	    var fractionStack = [1, 0];

	    var fractions = {};

	    var maxIterations = 1e5;
	    var geoM, m, fracA, fracB, fracM, key;

	    while (--maxIterations > 0 && fractionStack.length > 0) {
	        // Pop the a coordinate off the stack
	        fracA = fractionStack.pop();
	        geoA = geoStack.pop();
	        a = stack.pop();
	        // Add the a coordinate if it has not been added yet
	        key = fracA.toString();
	        if (!(key in fractions)) {
	            components.push(a);
	            fractions[key] = true;
	        }
	        // Pop the b coordinate off the stack
	        fracB = fractionStack.pop();
	        geoB = geoStack.pop();
	        b = stack.pop();
	        // Find the m point between the a and b coordinates
	        fracM = (fracA + fracB) / 2;
	        geoM = interpolate(fracM);
	        m = transform(geoM);
	        if (OpenLayers.Geometry.distanceSquaredToSegment(m, {x1: a.x, y1: a.y,
	                x2: b.x, y2: b.y}).distance < squaredTolerance) {
	            // If the m point is sufficiently close to the straight line, then
	            // we discard it. Just use the b coordinate and move on to the next
	            // line segment.
	            components.push(b);
	            key = fracB.toString();
	            fractions[key] = true;
	        } else {
	            // Otherwise, we need to subdivide the current line segment.
	            // Split it into two and push the two line segments onto the stack.
	            fractionStack.push(fracB, fracM, fracM, fracA);
	            stack.push(b, m, m, a);
	            geoStack.push(geoB, geoM, geoM, geoA);
	        }
	    }

	    return new OpenLayers.Geometry.LineString(components);
	};


	/**
	 * Function: OpenLayers.Geometry.LineString.geodesicMeridian
	 * Generate a meridian (line at constant longitude).
	 *
	 * Parameters:
	 * lon - {number} Longitude.
	 * lat1 - {number} Latitude 1.
	 * lat2 - {number} Latitude 2.
	 * projection - {OpenLayers.Projection} Projection.
	 * squaredTolerance - {number} Squared tolerance.
	 *
	 * Returns:
	 * {OpenLayers.Geometry.LineString} Line geometry for the meridian at <lon>.
	 */
	OpenLayers.Geometry.LineString.geodesicMeridian =
	        function(lon, lat1, lat2, projection, squaredTolerance) {
	    var epsg4326Projection = new OpenLayers.Projection('EPSG:4326');
	    return OpenLayers.Geometry.LineString.geodesic(
	        function(frac) {
	            return new OpenLayers.Geometry.Point(
	                    lon, lat1 + ((lat2 - lat1) * frac));
	        },
	        function(point) {
	            return point.transform(epsg4326Projection, projection);
	        },
	        squaredTolerance
	  );
	};


	/**
	 * Function: OpenLayers.Geometry.LineString.geodesicParallel
	 * Generate a parallel (line at constant latitude).
	 *
	 * Parameters:
	 * lat - {number} Latitude.
	 * lon1 - {number} Longitude 1.
	 * lon2 - {number} Longitude 2.
	 * projection {OpenLayers.Projection} Projection.
	 * squaredTolerance - {number} Squared tolerance.
	 *
	 * Returns:
	 * {OpenLayers.Geometry.LineString} Line geometry for the parallel at <lat>.
	 */
	OpenLayers.Geometry.LineString.geodesicParallel =
	        function(lat, lon1, lon2, projection, squaredTolerance) {
	    var epsg4326Projection = new OpenLayers.Projection('EPSG:4326');
	    return OpenLayers.Geometry.LineString.geodesic(
	        function(frac) {
	            return new OpenLayers.Geometry.Point(
	                    lon1 + ((lon2 - lon1) * frac), lat);
	        },
	        function(point) {
	            return point.transform(epsg4326Projection, projection);
	        },
	        squaredTolerance
	    );
	};

	/* ======================================================================
	    OpenLayers/Geometry/LinearRing.js
	   ====================================================================== */

	/* Copyright (c) 2006-2015 by OpenLayers Contributors (see authors.txt for
	 * full list of contributors). Published under the 2-clause BSD license.
	 * See license.txt in the OpenLayers distribution or repository for the
	 * full text of the license. */

	/**
	 * @requires OpenLayers/Geometry/LineString.js
	 */

	/**
	 * Class: OpenLayers.Geometry.LinearRing
	 * 
	 * A Linear Ring is a special LineString which is closed. It closes itself 
	 * automatically on every addPoint/removePoint by adding a copy of the first
	 * point as the last point. 
	 * 
	 * Also, as it is the first in the line family to close itself, a getArea()
	 * function is defined to calculate the enclosed area of the linearRing
	 * 
	 * Inherits:
	 *  - <OpenLayers.Geometry.LineString>
	 */
	OpenLayers.Geometry.LinearRing = OpenLayers.Class(
	  OpenLayers.Geometry.LineString, {

	    /**
	     * Property: componentTypes
	     * {Array(String)} An array of class names representing the types of 
	     *                 components that the collection can include.  A null 
	     *                 value means the component types are not restricted.
	     */
	    componentTypes: ["OpenLayers.Geometry.Point"],

	    /**
	     * Constructor: OpenLayers.Geometry.LinearRing
	     * Linear rings are constructed with an array of points.  This array
	     *     can represent a closed or open ring.  If the ring is open (the last
	     *     point does not equal the first point), the constructor will close
	     *     the ring.  If the ring is already closed (the last point does equal
	     *     the first point), it will be left closed.
	     * 
	     * Parameters:
	     * points - {Array(<OpenLayers.Geometry.Point>)} points
	     */

	    /**
	     * APIMethod: addComponent
	     * Adds a point to geometry components.  If the point is to be added to
	     *     the end of the components array and it is the same as the last point
	     *     already in that array, the duplicate point is not added.  This has 
	     *     the effect of closing the ring if it is not already closed, and 
	     *     doing the right thing if it is already closed.  This behavior can 
	     *     be overridden by calling the method with a non-null index as the 
	     *     second argument.
	     *
	     * Parameters:
	     * point - {<OpenLayers.Geometry.Point>}
	     * index - {Integer} Index into the array to insert the component
	     * 
	     * Returns:
	     * {Boolean} Was the Point successfully added?
	     */
	    addComponent: function(point, index) {
	        var added = false;

	        //remove last point
	        var lastPoint = this.components.pop();

	        // given an index, add the point
	        // without an index only add non-duplicate points
	        if(index != null || !point.equals(lastPoint)) {
	            added = OpenLayers.Geometry.Collection.prototype.addComponent.apply(this, 
	                                                                    arguments);
	        }

	        //append copy of first point
	        var firstPoint = this.components[0];
	        OpenLayers.Geometry.Collection.prototype.addComponent.apply(this, 
	                                                                [firstPoint]);
	        
	        return added;
	    },
	    
	    /**
	     * APIMethod: removeComponent
	     * Removes a point from geometry components.
	     *
	     * Parameters:
	     * point - {<OpenLayers.Geometry.Point>}
	     *
	     * Returns: 
	     * {Boolean} The component was removed.
	     */
	    removeComponent: function(point) {
	        var removed = this.components && (this.components.length > 3);
	        if (removed) {
	            //remove last point
	            this.components.pop();
	            
	            //remove our point
	            OpenLayers.Geometry.Collection.prototype.removeComponent.apply(this, 
	                                                                    arguments);
	            //append copy of first point
	            var firstPoint = this.components[0];
	            OpenLayers.Geometry.Collection.prototype.addComponent.apply(this, 
	                                                                [firstPoint]);
	        }
	        return removed;
	    },
	    
	    /**
	     * APIMethod: move
	     * Moves a geometry by the given displacement along positive x and y axes.
	     *     This modifies the position of the geometry and clears the cached
	     *     bounds.
	     *
	     * Parameters:
	     * x - {Float} Distance to move geometry in positive x direction. 
	     * y - {Float} Distance to move geometry in positive y direction.
	     */
	    move: function(x, y) {
	        for(var i = 0, len=this.components.length; i<len - 1; i++) {
	            this.components[i].move(x, y);
	        }
	    },

	    /**
	     * APIMethod: rotate
	     * Rotate a geometry around some origin
	     *
	     * Parameters:
	     * angle - {Float} Rotation angle in degrees (measured counterclockwise
	     *                 from the positive x-axis)
	     * origin - {<OpenLayers.Geometry.Point>} Center point for the rotation
	     */
	    rotate: function(angle, origin) {
	        for(var i=0, len=this.components.length; i<len - 1; ++i) {
	            this.components[i].rotate(angle, origin);
	        }
	    },

	    /**
	     * APIMethod: resize
	     * Resize a geometry relative to some origin.  Use this method to apply
	     *     a uniform scaling to a geometry.
	     *
	     * Parameters:
	     * scale - {Float} Factor by which to scale the geometry.  A scale of 2
	     *                 doubles the size of the geometry in each dimension
	     *                 (lines, for example, will be twice as long, and polygons
	     *                 will have four times the area).
	     * origin - {<OpenLayers.Geometry.Point>} Point of origin for resizing
	     * ratio - {Float} Optional x:y ratio for resizing.  Default ratio is 1.
	     * 
	     * Returns:
	     * {<OpenLayers.Geometry>} - The current geometry. 
	     */
	    resize: function(scale, origin, ratio) {
	        for(var i=0, len=this.components.length; i<len - 1; ++i) {
	            this.components[i].resize(scale, origin, ratio);
	        }
	        return this;
	    },
	    
	    /**
	     * APIMethod: transform
	     * Reproject the components geometry from source to dest.
	     *
	     * Parameters:
	     * source - {<OpenLayers.Projection>}
	     * dest - {<OpenLayers.Projection>}
	     * 
	     * Returns:
	     * {<OpenLayers.Geometry>} 
	     */
	    transform: function(source, dest) {
	        if (source && dest) {
	            for (var i=0, len=this.components.length; i<len - 1; i++) {
	                var component = this.components[i];
	                component.transform(source, dest);
	            }
	            this.bounds = null;
	        }
	        return this;
	    },
	    
	    /**
	     * APIMethod: getCentroid
	     *
	     * Returns:
	     * {<OpenLayers.Geometry.Point>} The centroid of the collection
	     */
	    getCentroid: function() {
	        if (this.components) {
	            var len = this.components.length;
	            if (len > 0 && len <= 2) {
	                return this.components[0].clone();
	            } else if (len > 2) {
	                var sumX = 0.0;
	                var sumY = 0.0;
	                var x0 = this.components[0].x;
	                var y0 = this.components[0].y;
	                var area = -1 * this.getArea();
	                if (area != 0) {
	                    for (var i = 0; i < len - 1; i++) {
	                        var b = this.components[i];
	                        var c = this.components[i+1];
	                        sumX += (b.x + c.x - 2 * x0) * ((b.x - x0) * (c.y - y0) - (c.x - x0) * (b.y - y0));
	                        sumY += (b.y + c.y - 2 * y0) * ((b.x - x0) * (c.y - y0) - (c.x - x0) * (b.y - y0));
	                    }
	                    var x = x0 + sumX / (6 * area);
	                    var y = y0 + sumY / (6 * area);
	                } else {
	                    for (var i = 0; i < len - 1; i++) {
	                        sumX += this.components[i].x;
	                        sumY += this.components[i].y;
	                    }
	                    var x = sumX / (len - 1);
	                    var y = sumY / (len - 1);
	                }
	                return new OpenLayers.Geometry.Point(x, y);
	            } else {
	                return null;
	            }
	        }
	    },

	    /**
	     * APIMethod: getArea
	     * Note - The area is positive if the ring is oriented CW, otherwise
	     *         it will be negative.
	     * 
	     * Returns:
	     * {Float} The signed area for a ring.
	     */
	    getArea: function() {
	        var area = 0.0;
	        if ( this.components && (this.components.length > 2)) {
	            var sum = 0.0;
	            for (var i=0, len=this.components.length; i<len - 1; i++) {
	                var b = this.components[i];
	                var c = this.components[i+1];
	                sum += (b.x + c.x) * (c.y - b.y);
	            }
	            area = - sum / 2.0;
	        }
	        return area;
	    },
	    
	    /**
	     * APIMethod: getGeodesicArea
	     * Calculate the approximate area of the polygon were it projected onto
	     *     the earth.  Note that this area will be positive if ring is oriented
	     *     clockwise, otherwise it will be negative.
	     *
	     * Parameters:
	     * projection - {<OpenLayers.Projection>} The spatial reference system
	     *     for the geometry coordinates.  If not provided, Geographic/WGS84 is
	     *     assumed.
	     * 
	     * Reference:
	     * Robert. G. Chamberlain and William H. Duquette, "Some Algorithms for
	     *     Polygons on a Sphere", JPL Publication 07-03, Jet Propulsion
	     *     Laboratory, Pasadena, CA, June 2007 http://trs-new.jpl.nasa.gov/dspace/handle/2014/40409
	     *
	     * Returns:
	     * {float} The approximate signed geodesic area of the polygon in square
	     *     meters.
	     */
	    getGeodesicArea: function(projection) {
	        var ring = this;  // so we can work with a clone if needed
	        if(projection) {
	            var gg = new OpenLayers.Projection("EPSG:4326");
	            if(!gg.equals(projection)) {
	                ring = this.clone().transform(projection, gg);
	            }
	        }
	        var area = 0.0;
	        var len = ring.components && ring.components.length;
	        if(len > 2) {
	            var p1, p2;
	            for(var i=0; i<len-1; i++) {
	                p1 = ring.components[i];
	                p2 = ring.components[i+1];
	                area += OpenLayers.Util.rad(p2.x - p1.x) *
	                        (2 + Math.sin(OpenLayers.Util.rad(p1.y)) +
	                        Math.sin(OpenLayers.Util.rad(p2.y)));
	            }
	            area = area * OpenLayers.Util.VincentyConstants.a * OpenLayers.Util.VincentyConstants.a / 2.0;
	        }
	        return area;
	    },
	    
	    /**
	     * Method: containsPoint
	     * Test if a point is inside a linear ring.  For the case where a point
	     *     is coincident with a linear ring edge, returns 1.  Otherwise,
	     *     returns boolean.
	     *
	     * Parameters:
	     * point - {<OpenLayers.Geometry.Point>}
	     *
	     * Returns:
	     * {Boolean | Number} The point is inside the linear ring.  Returns 1 if
	     *     the point is coincident with an edge.  Returns boolean otherwise.
	     */
	    containsPoint: function(point) {
	        var approx = OpenLayers.Number.limitSigDigs;
	        var digs = 14;
	        var px = approx(point.x, digs);
	        var py = approx(point.y, digs);
	        function getX(y, x1, y1, x2, y2) {
	            return (y - y2) * ((x2 - x1) / (y2 - y1)) + x2;
	        }
	        var numSeg = this.components.length - 1;
	        var start, end, x1, y1, x2, y2, cx, cy;
	        var crosses = 0;
	        for(var i=0; i<numSeg; ++i) {
	            start = this.components[i];
	            x1 = approx(start.x, digs);
	            y1 = approx(start.y, digs);
	            end = this.components[i + 1];
	            x2 = approx(end.x, digs);
	            y2 = approx(end.y, digs);
	            
	            /**
	             * The following conditions enforce five edge-crossing rules:
	             *    1. points coincident with edges are considered contained;
	             *    2. an upward edge includes its starting endpoint, and
	             *    excludes its final endpoint;
	             *    3. a downward edge excludes its starting endpoint, and
	             *    includes its final endpoint;
	             *    4. horizontal edges are excluded; and
	             *    5. the edge-ray intersection point must be strictly right
	             *    of the point P.
	             */
	            if(y1 == y2) {
	                // horizontal edge
	                if(py == y1) {
	                    // point on horizontal line
	                    if(x1 <= x2 && (px >= x1 && px <= x2) || // right or vert
	                       x1 >= x2 && (px <= x1 && px >= x2)) { // left or vert
	                        // point on edge
	                        crosses = -1;
	                        break;
	                    }
	                }
	                // ignore other horizontal edges
	                continue;
	            }
	            cx = approx(getX(py, x1, y1, x2, y2), digs);
	            if(cx == px) {
	                // point on line
	                if(y1 < y2 && (py >= y1 && py <= y2) || // upward
	                   y1 > y2 && (py <= y1 && py >= y2)) { // downward
	                    // point on edge
	                    crosses = -1;
	                    break;
	                }
	            }
	            if(cx <= px) {
	                // no crossing to the right
	                continue;
	            }
	            if(x1 != x2 && (cx < Math.min(x1, x2) || cx > Math.max(x1, x2))) {
	                // no crossing
	                continue;
	            }
	            if(y1 < y2 && (py >= y1 && py < y2) || // upward
	               y1 > y2 && (py < y1 && py >= y2)) { // downward
	                ++crosses;
	            }
	        }
	        var contained = (crosses == -1) ?
	            // on edge
	            1 :
	            // even (out) or odd (in)
	            !!(crosses & 1);

	        return contained;
	    },

	    /**
	     * APIMethod: intersects
	     * Determine if the input geometry intersects this one.
	     *
	     * Parameters:
	     * geometry - {<OpenLayers.Geometry>} Any type of geometry.
	     *
	     * Returns:
	     * {Boolean} The input geometry intersects this one.
	     */
	    intersects: function(geometry) {
	        var intersect = false;
	        if(geometry.CLASS_NAME == "OpenLayers.Geometry.Point") {
	            intersect = this.containsPoint(geometry);
	        } else if(geometry.CLASS_NAME == "OpenLayers.Geometry.LineString") {
	            intersect = geometry.intersects(this);
	        } else if(geometry.CLASS_NAME == "OpenLayers.Geometry.LinearRing") {
	            intersect = OpenLayers.Geometry.LineString.prototype.intersects.apply(
	                this, [geometry]
	            );
	        } else {
	            // check for component intersections
	            for(var i=0, len=geometry.components.length; i<len; ++ i) {
	                intersect = geometry.components[i].intersects(this);
	                if(intersect) {
	                    break;
	                }
	            }
	        }
	        return intersect;
	    },

	    /**
	     * APIMethod: getVertices
	     * Return a list of all points in this geometry.
	     *
	     * Parameters:
	     * nodes - {Boolean} For lines, only return vertices that are
	     *     endpoints.  If false, for lines, only vertices that are not
	     *     endpoints will be returned.  If not provided, all vertices will
	     *     be returned.
	     *
	     * Returns:
	     * {Array} A list of all vertices in the geometry.
	     */
	    getVertices: function(nodes) {
	        return (nodes === true) ? [] : this.components.slice(0, this.components.length-1);
	    },

	    CLASS_NAME: "OpenLayers.Geometry.LinearRing"
	});
	/* ======================================================================
	    OpenLayers/Geometry/Polygon.js
	   ====================================================================== */

	/* Copyright (c) 2006-2015 by OpenLayers Contributors (see authors.txt for
	 * full list of contributors). Published under the 2-clause BSD license.
	 * See license.txt in the OpenLayers distribution or repository for the
	 * full text of the license. */

	/**
	 * @requires OpenLayers/Geometry/Collection.js
	 * @requires OpenLayers/Geometry/LinearRing.js
	 */

	/**
	 * Class: OpenLayers.Geometry.Polygon 
	 * Polygon is a collection of Geometry.LinearRings. 
	 * 
	 * Inherits from:
	 *  - <OpenLayers.Geometry.Collection> 
	 *  - <OpenLayers.Geometry> 
	 */
	OpenLayers.Geometry.Polygon = OpenLayers.Class(
	  OpenLayers.Geometry.Collection, {

	    /**
	     * Property: componentTypes
	     * {Array(String)} An array of class names representing the types of
	     * components that the collection can include.  A null value means the
	     * component types are not restricted.
	     */
	    componentTypes: ["OpenLayers.Geometry.LinearRing"],

	    /**
	     * Constructor: OpenLayers.Geometry.Polygon
	     * Constructor for a Polygon geometry. 
	     * The first ring (this.component[0])is the outer bounds of the polygon and 
	     * all subsequent rings (this.component[1-n]) are internal holes.
	     *
	     *
	     * Parameters:
	     * components - {Array(<OpenLayers.Geometry.LinearRing>)} 
	     */

	    /** 
	     * APIMethod: getArea
	     * Calculated by subtracting the areas of the internal holes from the 
	     *   area of the outer hole.
	     * 
	     * Returns:
	     * {float} The area of the geometry
	     */
	    getArea: function() {
	        var area = 0.0;
	        if ( this.components && (this.components.length > 0)) {
	            area += Math.abs(this.components[0].getArea());
	            for (var i=1, len=this.components.length; i<len; i++) {
	                area -= Math.abs(this.components[i].getArea());
	            }
	        }
	        return area;
	    },

	    /** 
	     * APIMethod: getGeodesicArea
	     * Calculate the approximate area of the polygon were it projected onto
	     *     the earth.
	     *
	     * Parameters:
	     * projection - {<OpenLayers.Projection>} The spatial reference system
	     *     for the geometry coordinates.  If not provided, Geographic/WGS84 is
	     *     assumed.
	     * 
	     * Reference:
	     * Robert. G. Chamberlain and William H. Duquette, "Some Algorithms for
	     *     Polygons on a Sphere", JPL Publication 07-03, Jet Propulsion
	     *     Laboratory, Pasadena, CA, June 2007 http://trs-new.jpl.nasa.gov/dspace/handle/2014/40409
	     *
	     * Returns:
	     * {float} The approximate geodesic area of the polygon in square meters.
	     */
	    getGeodesicArea: function(projection) {
	        var area = 0.0;
	        if(this.components && (this.components.length > 0)) {
	            area += Math.abs(this.components[0].getGeodesicArea(projection));
	            for(var i=1, len=this.components.length; i<len; i++) {
	                area -= Math.abs(this.components[i].getGeodesicArea(projection));
	            }
	        }
	        return area;
	    },

	    /**
	     * Method: containsPoint
	     * Test if a point is inside a polygon.  Points on a polygon edge are
	     *     considered inside.
	     *
	     * Parameters:
	     * point - {<OpenLayers.Geometry.Point>}
	     *
	     * Returns:
	     * {Boolean | Number} The point is inside the polygon.  Returns 1 if the
	     *     point is on an edge.  Returns boolean otherwise.
	     */
	    containsPoint: function(point) {
	        var numRings = this.components.length;
	        var contained = false;
	        if(numRings > 0) {
	            // check exterior ring - 1 means on edge, boolean otherwise
	            contained = this.components[0].containsPoint(point);
	            if(contained !== 1) {
	                if(contained && numRings > 1) {
	                    // check interior rings
	                    var hole;
	                    for(var i=1; i<numRings; ++i) {
	                        hole = this.components[i].containsPoint(point);
	                        if(hole) {
	                            if(hole === 1) {
	                                // on edge
	                                contained = 1;
	                            } else {
	                                // in hole
	                                contained = false;
	                            }                            
	                            break;
	                        }
	                    }
	                }
	            }
	        }
	        return contained;
	    },

	    /**
	     * APIMethod: intersects
	     * Determine if the input geometry intersects this one.
	     *
	     * Parameters:
	     * geometry - {<OpenLayers.Geometry>} Any type of geometry.
	     *
	     * Returns:
	     * {Boolean} The input geometry intersects this one.
	     */
	    intersects: function(geometry) {
	        var intersect = false;
	        var i, len;
	        if(geometry.CLASS_NAME == "OpenLayers.Geometry.Point") {
	            intersect = this.containsPoint(geometry);
	        } else if(geometry.CLASS_NAME == "OpenLayers.Geometry.LineString" ||
	                  geometry.CLASS_NAME == "OpenLayers.Geometry.LinearRing") {
	            // check if rings/linestrings intersect
	            for(i=0, len=this.components.length; i<len; ++i) {
	                intersect = geometry.intersects(this.components[i]);
	                if(intersect) {
	                    break;
	                }
	            }
	            if(!intersect) {
	                // check if this poly contains points of the ring/linestring
	                for(i=0, len=geometry.components.length; i<len; ++i) {
	                    intersect = this.containsPoint(geometry.components[i]);
	                    if(intersect) {
	                        break;
	                    }
	                }
	            }
	        } else {
	            for(i=0, len=geometry.components.length; i<len; ++ i) {
	                intersect = this.intersects(geometry.components[i]);
	                if(intersect) {
	                    break;
	                }
	            }
	        }
	        // check case where this poly is wholly contained by another
	        if(!intersect && geometry.CLASS_NAME == "OpenLayers.Geometry.Polygon") {
	            // exterior ring points will be contained in the other geometry
	            var ring = this.components[0];
	            for(i=0, len=ring.components.length; i<len; ++i) {
	                intersect = geometry.containsPoint(ring.components[i]);
	                if(intersect) {
	                    break;
	                }
	            }
	        }
	        return intersect;
	    },

	    /**
	     * APIMethod: distanceTo
	     * Calculate the closest distance between two geometries (on the x-y plane).
	     *
	     * Parameters:
	     * geometry - {<OpenLayers.Geometry>} The target geometry.
	     * options - {Object} Optional properties for configuring the distance
	     *     calculation.
	     *
	     * Valid options:
	     * details - {Boolean} Return details from the distance calculation.
	     *     Default is false.
	     * edge - {Boolean} Calculate the distance from this geometry to the
	     *     nearest edge of the target geometry.  Default is true.  If true,
	     *     calling distanceTo from a geometry that is wholly contained within
	     *     the target will result in a non-zero distance.  If false, whenever
	     *     geometries intersect, calling distanceTo will return 0.  If false,
	     *     details cannot be returned.
	     *
	     * Returns:
	     * {Number | Object} The distance between this geometry and the target.
	     *     If details is true, the return will be an object with distance,
	     *     x0, y0, x1, and y1 properties.  The x0 and y0 properties represent
	     *     the coordinates of the closest point on this geometry. The x1 and y1
	     *     properties represent the coordinates of the closest point on the
	     *     target geometry.
	     */
	    distanceTo: function(geometry, options) {
	        var edge = !(options && options.edge === false);
	        var result;
	        // this is the case where we might not be looking for distance to edge
	        if(!edge && this.intersects(geometry)) {
	            result = 0;
	        } else {
	            result = OpenLayers.Geometry.Collection.prototype.distanceTo.apply(
	                this, [geometry, options]
	            );
	        }
	        return result;
	    },

	    CLASS_NAME: "OpenLayers.Geometry.Polygon"
	});

	/**
	 * APIMethod: createRegularPolygon
	 * Create a regular polygon around a radius. Useful for creating circles 
	 * and the like.
	 *
	 * Parameters:
	 * origin - {<OpenLayers.Geometry.Point>} center of polygon.
	 * radius - {Float} distance to vertex, in map units.
	 * sides - {Integer} Number of sides. 20 approximates a circle.
	 * rotation - {Float} original angle of rotation, in degrees.
	 */
	OpenLayers.Geometry.Polygon.createRegularPolygon = function(origin, radius, sides, rotation) {  
	    var angle = Math.PI * ((1/sides) - (1/2));
	    if(rotation) {
	        angle += (rotation / 180) * Math.PI;
	    }
	    var rotatedAngle, x, y;
	    var points = [];
	    for(var i=0; i<sides; ++i) {
	        rotatedAngle = angle + (i * 2 * Math.PI / sides);
	        x = origin.x + (radius * Math.cos(rotatedAngle));
	        y = origin.y + (radius * Math.sin(rotatedAngle));
	        points.push(new OpenLayers.Geometry.Point(x, y));
	    }
	    var ring = new OpenLayers.Geometry.LinearRing(points);
	    return new OpenLayers.Geometry.Polygon([ring]);
	};
	/* ======================================================================
	    OpenLayers/Feature.js
	   ====================================================================== */

	/* Copyright (c) 2006-2015 by OpenLayers Contributors (see authors.txt for
	 * full list of contributors). Published under the 2-clause BSD license.
	 * See license.txt in the OpenLayers distribution or repository for the
	 * full text of the license. */


	/**
	 * @requires OpenLayers/BaseTypes/Class.js
	 * @requires OpenLayers/Util.js
	 */

	/**
	 * Class: OpenLayers.Feature
	 * Features are combinations of geography and attributes. The OpenLayers.Feature
	 *     class specifically combines a marker and a lonlat.
	 */
	OpenLayers.Feature = OpenLayers.Class({

	    /** 
	     * Property: layer 
	     * {<OpenLayers.Layer>} 
	     */
	    layer: null,

	    /** 
	     * Property: id 
	     * {String} 
	     */
	    id: null,
	    
	    /** 
	     * Property: lonlat 
	     * {<OpenLayers.LonLat>} 
	     */
	    lonlat: null,

	    /** 
	     * Property: data 
	     * {Object} 
	     */
	    data: null,

	    /** 
	     * Property: marker 
	     * {<OpenLayers.Marker>} 
	     */
	    marker: null,

	    /**
	     * APIProperty: popupClass
	     * {<OpenLayers.Class>} The class which will be used to instantiate
	     *     a new Popup. Default is <OpenLayers.Popup.Anchored>.
	     */
	    popupClass: null,

	    /** 
	     * Property: popup 
	     * {<OpenLayers.Popup>} 
	     */
	    popup: null,

	    /** 
	     * Constructor: OpenLayers.Feature
	     * Constructor for features.
	     *
	     * Parameters:
	     * layer - {<OpenLayers.Layer>} 
	     * lonlat - {<OpenLayers.LonLat>} 
	     * data - {Object} 
	     * 
	     * Returns:
	     * {<OpenLayers.Feature>}
	     */
	    initialize: function(layer, lonlat, data) {
	        this.layer = layer;
	        this.lonlat = lonlat;
	        this.data = (data != null) ? data : {};
	        this.id = OpenLayers.Util.createUniqueID(this.CLASS_NAME + "_"); 
	    },

	    /** 
	     * Method: destroy
	     * nullify references to prevent circular references and memory leaks
	     */
	    destroy: function() {

	        //remove the popup from the map
	        if ((this.layer != null) && (this.layer.map != null)) {
	            if (this.popup != null) {
	                this.layer.map.removePopup(this.popup);
	            }
	        }
	        // remove the marker from the layer
	        if (this.layer != null && this.marker != null) {
	            this.layer.removeMarker(this.marker);
	        }

	        this.layer = null;
	        this.id = null;
	        this.lonlat = null;
	        this.data = null;
	        if (this.marker != null) {
	            this.destroyMarker(this.marker);
	            this.marker = null;
	        }
	        if (this.popup != null) {
	            this.destroyPopup(this.popup);
	            this.popup = null;
	        }
	    },
	    
	    /**
	     * Method: onScreen
	     * 
	     * Returns:
	     * {Boolean} Whether or not the feature is currently visible on screen
	     *           (based on its 'lonlat' property)
	     */
	    onScreen:function() {
	        
	        var onScreen = false;
	        if ((this.layer != null) && (this.layer.map != null)) {
	            var screenBounds = this.layer.map.getExtent();
	            onScreen = screenBounds.containsLonLat(this.lonlat);
	        }    
	        return onScreen;
	    },
	    

	    /**
	     * Method: createMarker
	     * Based on the data associated with the Feature, create and return a marker object.
	     *
	     * Returns: 
	     * {<OpenLayers.Marker>} A Marker Object created from the 'lonlat' and 'icon' properties
	     *          set in this.data. If no 'lonlat' is set, returns null. If no
	     *          'icon' is set, OpenLayers.Marker() will load the default image.
	     *          
	     *          Note - this.marker is set to return value
	     * 
	     */
	    createMarker: function() {

	        if (this.lonlat != null) {
	            this.marker = new OpenLayers.Marker(this.lonlat, this.data.icon);
	        }
	        return this.marker;
	    },

	    /**
	     * Method: destroyMarker
	     * Destroys marker.
	     * If user overrides the createMarker() function, s/he should be able
	     *   to also specify an alternative function for destroying it
	     */
	    destroyMarker: function() {
	        this.marker.destroy();  
	    },

	    /**
	     * Method: createPopup
	     * Creates a popup object created from the 'lonlat', 'popupSize',
	     *     and 'popupContentHTML' properties set in this.data. It uses
	     *     this.marker.icon as default anchor. 
	     *  
	     *  If no 'lonlat' is set, returns null. 
	     *  If no this.marker has been created, no anchor is sent.
	     *
	     *  Note - the returned popup object is 'owned' by the feature, so you
	     *      cannot use the popup's destroy method to discard the popup.
	     *      Instead, you must use the feature's destroyPopup
	     * 
	     *  Note - this.popup is set to return value
	     * 
	     * Parameters: 
	     * closeBox - {Boolean} create popup with closebox or not
	     * 
	     * Returns:
	     * {<OpenLayers.Popup>} Returns the created popup, which is also set
	     *     as 'popup' property of this feature. Will be of whatever type
	     *     specified by this feature's 'popupClass' property, but must be
	     *     of type <OpenLayers.Popup>.
	     * 
	     */
	    createPopup: function(closeBox) {

	        if (this.lonlat != null) {
	            if (!this.popup) {
	                var anchor = (this.marker) ? this.marker.icon : null;
	                var popupClass = this.popupClass ? 
	                    this.popupClass : OpenLayers.Popup.Anchored;
	                this.popup = new popupClass(this.id + "_popup", 
	                                            this.lonlat,
	                                            this.data.popupSize,
	                                            this.data.popupContentHTML,
	                                            anchor, 
	                                            closeBox); 
	            }    
	            if (this.data.overflow != null) {
	                this.popup.contentDiv.style.overflow = this.data.overflow;
	            }    
	            
	            this.popup.feature = this;
	        }        
	        return this.popup;
	    },

	    
	    /**
	     * Method: destroyPopup
	     * Destroys the popup created via createPopup.
	     *
	     * As with the marker, if user overrides the createPopup() function, s/he 
	     *   should also be able to override the destruction
	     */
	    destroyPopup: function() {
	        if (this.popup) {
	            this.popup.feature = null;
	            this.popup.destroy();
	            this.popup = null;
	        }    
	    },

	    CLASS_NAME: "OpenLayers.Feature"
	});
	/* ======================================================================
	    OpenLayers/Feature/Vector.js
	   ====================================================================== */

	/* Copyright (c) 2006-2015 by OpenLayers Contributors (see authors.txt for
	 * full list of contributors). Published under the 2-clause BSD license.
	 * See license.txt in the OpenLayers distribution or repository for the
	 * full text of the license. */

	// TRASH THIS
	OpenLayers.State = {
	    /** states */
	    UNKNOWN: 'Unknown',
	    INSERT: 'Insert',
	    UPDATE: 'Update',
	    DELETE: 'Delete'
	};

	/**
	 * @requires OpenLayers/Feature.js
	 * @requires OpenLayers/Util.js
	 */

	/**
	 * Class: OpenLayers.Feature.Vector
	 * Vector features use the OpenLayers.Geometry classes as geometry description.
	 * They have an 'attributes' property, which is the data object, and a 'style'
	 * property, the default values of which are defined in the 
	 * <OpenLayers.Feature.Vector.style> objects.
	 * 
	 * Inherits from:
	 *  - <OpenLayers.Feature>
	 */
	OpenLayers.Feature.Vector = OpenLayers.Class(OpenLayers.Feature, {

	    /** 
	     * Property: fid 
	     * {String} 
	     */
	    fid: null,
	    
	    /** 
	     * APIProperty: geometry 
	     * {<OpenLayers.Geometry>} 
	     */
	    geometry: null,

	    /** 
	     * APIProperty: attributes 
	     * {Object} This object holds arbitrary, serializable properties that
	     *     describe the feature.
	     */
	    attributes: null,

	    /**
	     * Property: bounds
	     * {<OpenLayers.Bounds>} The box bounding that feature's geometry, that
	     *     property can be set by an <OpenLayers.Format> object when
	     *     deserializing the feature, so in most cases it represents an
	     *     information set by the server. 
	     */
	    bounds: null,

	    /** 
	     * Property: state 
	     * {String} 
	     */
	    state: null,
	    
	    /** 
	     * APIProperty: style 
	     * {Object} 
	     */
	    style: null,

	    /**
	     * APIProperty: url
	     * {String} If this property is set it will be taken into account by
	     *     {<OpenLayers.HTTP>} when updating or deleting the feature.
	     */
	    url: null,
	    
	    /**
	     * Property: renderIntent
	     * {String} rendering intent currently being used
	     */
	    renderIntent: "default",
	    
	    /**
	     * APIProperty: modified
	     * {Object} An object with the originals of the geometry and attributes of
	     * the feature, if they were changed. Currently this property is only read
	     * by <OpenLayers.Format.WFST.v1>, and written by
	     * <OpenLayers.Control.ModifyFeature>, which sets the geometry property.
	     * Applications can set the originals of modified attributes in the
	     * attributes property. Note that applications have to check if this
	     * object and the attributes property is already created before using it.
	     * After a change made with ModifyFeature, this object could look like
	     *
	     * (code)
	     * {
	     *     geometry: >Object
	     * }
	     * (end)
	     *
	     * When an application has made changes to feature attributes, it could
	     * have set the attributes to something like this:
	     *
	     * (code)
	     * {
	     *     attributes: {
	     *         myAttribute: "original"
	     *     }
	     * }
	     * (end)
	     *
	     * Note that <OpenLayers.Format.WFST.v1> only checks for truthy values in
	     * *modified.geometry* and the attribute names in *modified.attributes*,
	     * but it is recommended to set the original values (and not just true) as
	     * attribute value, so applications could use this information to undo
	     * changes.
	     */
	    modified: null,

	    /** 
	     * Constructor: OpenLayers.Feature.Vector
	     * Create a vector feature. 
	     * 
	     * Parameters:
	     * geometry - {<OpenLayers.Geometry>} The geometry that this feature
	     *     represents.
	     * attributes - {Object} An optional object that will be mapped to the
	     *     <attributes> property. 
	     * style - {Object} An optional style object.
	     */
	    initialize: function(geometry, attributes, style) {
	        OpenLayers.Feature.prototype.initialize.apply(this,
	                                                      [null, null, attributes]);
	        this.lonlat = null;
	        this.geometry = geometry ? geometry : null;
	        this.state = null;
	        this.attributes = {};
	        if (attributes) {
	            this.attributes = OpenLayers.Util.extend(this.attributes,
	                                                     attributes);
	        }
	        this.style = style ? style : null; 
	    },
	    
	    /** 
	     * Method: destroy
	     * nullify references to prevent circular references and memory leaks
	     */
	    destroy: function() {
	        if (this.layer) {
	            this.layer.removeFeatures(this);
	            this.layer = null;
	        }
	            
	        this.geometry = null;
	        this.modified = null;
	        OpenLayers.Feature.prototype.destroy.apply(this, arguments);
	    },
	    
	    /**
	     * Method: clone
	     * Create a clone of this vector feature.  Does not set any non-standard
	     *     properties.
	     *
	     * Returns:
	     * {<OpenLayers.Feature.Vector>} An exact clone of this vector feature.
	     */
	    clone: function () {
	        return new OpenLayers.Feature.Vector(
	            this.geometry ? this.geometry.clone() : null,
	            this.attributes,
	            this.style);
	    },

	    /**
	     * Method: onScreen
	     * Determine whether the feature is within the map viewport.  This method
	     *     tests for an intersection between the geometry and the viewport
	     *     bounds.  If a more efficient but less precise geometry bounds
	     *     intersection is desired, call the method with the boundsOnly
	     *     parameter true.
	     *
	     * Parameters:
	     * boundsOnly - {Boolean} Only test whether a feature's bounds intersects
	     *     the viewport bounds.  Default is false.  If false, the feature's
	     *     geometry must intersect the viewport for onScreen to return true.
	     * 
	     * Returns:
	     * {Boolean} The feature is currently visible on screen (optionally
	     *     based on its bounds if boundsOnly is true).
	     */
	    onScreen:function(boundsOnly) {
	        var onScreen = false;
	        if(this.layer && this.layer.map) {
	            var screenBounds = this.layer.map.getExtent();
	            if(boundsOnly) {
	                var featureBounds = this.geometry.getBounds();
	                onScreen = screenBounds.intersectsBounds(featureBounds);
	            } else {
	                var screenPoly = screenBounds.toGeometry();
	                onScreen = screenPoly.intersects(this.geometry);
	            }
	        }    
	        return onScreen;
	    },

	    /**
	     * Method: getVisibility
	     * Determine whether the feature is displayed or not. It may not displayed
	     *     because:
	     *     - its style display property is set to 'none',
	     *     - it doesn't belong to any layer,
	     *     - the styleMap creates a symbolizer with display property set to 'none'
	     *          for it,
	     *     - the layer which it belongs to is not visible.
	     * 
	     * Returns:
	     * {Boolean} The feature is currently displayed.
	     */
	    getVisibility: function() {
	        return !(this.style && this.style.display == 'none' ||
	                 !this.layer ||
	                 this.layer && this.layer.styleMap &&
	                 this.layer.styleMap.createSymbolizer(this, this.renderIntent).display == 'none' ||
	                 this.layer && !this.layer.getVisibility());
	    },
	    
	    /**
	     * Method: createMarker
	     * HACK - we need to decide if all vector features should be able to
	     *     create markers
	     * 
	     * Returns:
	     * {<OpenLayers.Marker>} For now just returns null
	     */
	    createMarker: function() {
	        return null;
	    },

	    /**
	     * Method: destroyMarker
	     * HACK - we need to decide if all vector features should be able to
	     *     delete markers
	     * 
	     * If user overrides the createMarker() function, s/he should be able
	     *   to also specify an alternative function for destroying it
	     */
	    destroyMarker: function() {
	        // pass
	    },

	    /**
	     * Method: createPopup
	     * HACK - we need to decide if all vector features should be able to
	     *     create popups
	     * 
	     * Returns:
	     * {<OpenLayers.Popup>} For now just returns null
	     */
	    createPopup: function() {
	        return null;
	    },

	    /**
	     * Method: atPoint
	     * Determins whether the feature intersects with the specified location.
	     * 
	     * Parameters: 
	     * lonlat - {<OpenLayers.LonLat>|Object} OpenLayers.LonLat or an
	     *     object with a 'lon' and 'lat' properties.
	     * toleranceLon - {float} Optional tolerance in Geometric Coords
	     * toleranceLat - {float} Optional tolerance in Geographic Coords
	     * 
	     * Returns:
	     * {Boolean} Whether or not the feature is at the specified location
	     */
	    atPoint: function(lonlat, toleranceLon, toleranceLat) {
	        var atPoint = false;
	        if(this.geometry) {
	            atPoint = this.geometry.atPoint(lonlat, toleranceLon, 
	                                                    toleranceLat);
	        }
	        return atPoint;
	    },

	    /**
	     * Method: destroyPopup
	     * HACK - we need to decide if all vector features should be able to
	     * delete popups
	     */
	    destroyPopup: function() {
	        // pass
	    },

	    /**
	     * Method: move
	     * Moves the feature and redraws it at its new location
	     *
	     * Parameters:
	     * location - {<OpenLayers.LonLat> or <OpenLayers.Pixel>} the
	     *         location to which to move the feature.
	     */
	    move: function(location) {

	        if(!this.layer || !this.geometry.move){
	            //do nothing if no layer or immoveable geometry
	            return undefined;
	        }

	        var pixel;
	        if (location.CLASS_NAME == "OpenLayers.LonLat") {
	            pixel = this.layer.getViewPortPxFromLonLat(location);
	        } else {
	            pixel = location;
	        }
	        
	        var lastPixel = this.layer.getViewPortPxFromLonLat(this.geometry.getBounds().getCenterLonLat());
	        var res = this.layer.map.getResolution();
	        this.geometry.move(res * (pixel.x - lastPixel.x),
	                           res * (lastPixel.y - pixel.y));
	        this.layer.drawFeature(this);
	        return lastPixel;
	    },
	    
	    /**
	     * Method: toState
	     * Sets the new state
	     *
	     * Parameters:
	     * state - {String} 
	     */
	    toState: function(state) {
	        if (state == OpenLayers.State.UPDATE) {
	            switch (this.state) {
	                case OpenLayers.State.UNKNOWN:
	                case OpenLayers.State.DELETE:
	                    this.state = state;
	                    break;
	                case OpenLayers.State.UPDATE:
	                case OpenLayers.State.INSERT:
	                    break;
	            }
	        } else if (state == OpenLayers.State.INSERT) {
	            switch (this.state) {
	                case OpenLayers.State.UNKNOWN:
	                    break;
	                default:
	                    this.state = state;
	                    break;
	            }
	        } else if (state == OpenLayers.State.DELETE) {
	            switch (this.state) {
	                case OpenLayers.State.INSERT:
	                    // the feature should be destroyed
	                    break;
	                case OpenLayers.State.DELETE:
	                    break;
	                case OpenLayers.State.UNKNOWN:
	                case OpenLayers.State.UPDATE:
	                    this.state = state;
	                    break;
	            }
	        } else if (state == OpenLayers.State.UNKNOWN) {
	            this.state = state;
	        }
	    },
	    
	    CLASS_NAME: "OpenLayers.Feature.Vector"
	});


	/**
	 * Constant: OpenLayers.Feature.Vector.style
	 * OpenLayers features can have a number of style attributes. The 'default' 
	 *     style will typically be used if no other style is specified. These
	 *     styles correspond for the most part, to the styling properties defined
	 *     by the SVG standard. 
	 *     Information on fill properties: http://www.w3.org/TR/SVG/painting.html#FillProperties
	 *     Information on stroke properties: http://www.w3.org/TR/SVG/painting.html#StrokeProperties
	 *
	 * Symbolizer properties:
	 * fill - {Boolean} Set to false if no fill is desired.
	 * fillColor - {String} Hex fill color.  Default is "#ee9900".
	 * fillOpacity - {Number} Fill opacity (0-1).  Default is 0.4 
	 * stroke - {Boolean} Set to false if no stroke is desired.
	 * strokeColor - {String} Hex stroke color.  Default is "#ee9900".
	 * strokeOpacity - {Number} Stroke opacity (0-1).  Default is 1.
	 * strokeWidth - {Number} Pixel stroke width.  Default is 1.
	 * strokeLinecap - {String} Stroke cap type.  Default is "round".  [butt | round | square]
	 * strokeDashstyle - {String} Stroke dash style.  Default is "solid". [dot | dash | dashdot | longdash | longdashdot | solid]
	 * graphic - {Boolean} Set to false if no graphic is desired.
	 * pointRadius - {Number} Pixel point radius.  Default is 6.
	 * pointerEvents - {String}  Default is "visiblePainted".
	 * cursor - {String} Default is "".
	 * externalGraphic - {String} Url to an external graphic that will be used for rendering points.
	 * graphicWidth - {Number} Pixel width for sizing an external graphic.
	 * graphicHeight - {Number} Pixel height for sizing an external graphic.
	 * graphicOpacity - {Number} Opacity (0-1) for an external graphic.
	 * graphicXOffset - {Number} Pixel offset along the positive x axis for displacing an external graphic.
	 * graphicYOffset - {Number} Pixel offset along the positive y axis for displacing an external graphic.
	 * rotation - {Number} For point symbolizers, this is the rotation of a graphic in the clockwise direction about its center point (or any point off center as specified by graphicXOffset and graphicYOffset).
	 * graphicZIndex - {Number} The integer z-index value to use in rendering.
	 * graphicName - {String} Named graphic to use when rendering points.  Supported values include "circle" (default),
	 *     "square", "star", "x", "cross", "triangle".
	 * graphicTitle - {String} Tooltip when hovering over a feature. *deprecated*, use title instead
	 * title - {String} Tooltip when hovering over a feature. Not supported by the canvas renderer.
	 * backgroundGraphic - {String} Url to a graphic to be used as the background under an externalGraphic.
	 * backgroundGraphicZIndex - {Number} The integer z-index value to use in rendering the background graphic.
	 * backgroundXOffset - {Number} The x offset (in pixels) for the background graphic.
	 * backgroundYOffset - {Number} The y offset (in pixels) for the background graphic.
	 * backgroundHeight - {Number} The height of the background graphic.  If not provided, the graphicHeight will be used.
	 * backgroundWidth - {Number} The width of the background width.  If not provided, the graphicWidth will be used.
	 * label - {String} The text for an optional label. For browsers that use the canvas renderer, this requires either
	 *     fillText or mozDrawText to be available.
	 * labelAlign - {String} Label alignment. This specifies the insertion point relative to the text. It is a string
	 *     composed of two characters. The first character is for the horizontal alignment, the second for the vertical
	 *     alignment. Valid values for horizontal alignment: "l"=left, "c"=center, "r"=right. Valid values for vertical
	 *     alignment: "t"=top, "m"=middle, "b"=bottom. Example values: "lt", "cm", "rb". Default is "cm".
	 * labelXOffset - {Number} Pixel offset along the positive x axis for displacing the label. Not supported by the canvas renderer.
	 * labelYOffset - {Number} Pixel offset along the positive y axis for displacing the label. Not supported by the canvas renderer.
	 * labelSelect - {Boolean} If set to true, labels will be selectable using SelectFeature or similar controls.
	 *     Default is false.
	 * labelOutlineColor - {String} The color of the label outline. Default is 'white'. Only supported by the canvas & SVG renderers.
	 * labelOutlineWidth - {Number} The width of the label outline. Default is 3, set to 0 or null to disable. Only supported by the  SVG renderers.
	 * labelOutlineOpacity - {Number} The opacity (0-1) of the label outline. Default is fontOpacity. Only supported by the canvas & SVG renderers.
	 * fontColor - {String} The font color for the label, to be provided like CSS.
	 * fontOpacity - {Number} Opacity (0-1) for the label
	 * fontFamily - {String} The font family for the label, to be provided like in CSS.
	 * fontSize - {String} The font size for the label, to be provided like in CSS.
	 * fontStyle - {String} The font style for the label, to be provided like in CSS.
	 * fontWeight - {String} The font weight for the label, to be provided like in CSS.
	 * display - {String} Symbolizers will have no effect if display is set to "none".  All other values have no effect.
	 */ 
	OpenLayers.Feature.Vector.style = {
	    'default': {
	        fillColor: "#ee9900",
	        fillOpacity: 0.4, 
	        hoverFillColor: "white",
	        hoverFillOpacity: 0.8,
	        strokeColor: "#ee9900",
	        strokeOpacity: 1,
	        strokeWidth: 1,
	        strokeLinecap: "round",
	        strokeDashstyle: "solid",
	        hoverStrokeColor: "red",
	        hoverStrokeOpacity: 1,
	        hoverStrokeWidth: 0.2,
	        pointRadius: 6,
	        hoverPointRadius: 1,
	        hoverPointUnit: "%",
	        pointerEvents: "visiblePainted",
	        cursor: "inherit",
	        fontColor: "#000000",
	        labelAlign: "cm",
	        labelOutlineColor: "white",
	        labelOutlineWidth: 3
	    },
	    'select': {
	        fillColor: "blue",
	        fillOpacity: 0.4, 
	        hoverFillColor: "white",
	        hoverFillOpacity: 0.8,
	        strokeColor: "blue",
	        strokeOpacity: 1,
	        strokeWidth: 2,
	        strokeLinecap: "round",
	        strokeDashstyle: "solid",
	        hoverStrokeColor: "red",
	        hoverStrokeOpacity: 1,
	        hoverStrokeWidth: 0.2,
	        pointRadius: 6,
	        hoverPointRadius: 1,
	        hoverPointUnit: "%",
	        pointerEvents: "visiblePainted",
	        cursor: "pointer",
	        fontColor: "#000000",
	        labelAlign: "cm",
	        labelOutlineColor: "white",
	        labelOutlineWidth: 3

	    },
	    'temporary': {
	        fillColor: "#66cccc",
	        fillOpacity: 0.2, 
	        hoverFillColor: "white",
	        hoverFillOpacity: 0.8,
	        strokeColor: "#66cccc",
	        strokeOpacity: 1,
	        strokeLinecap: "round",
	        strokeWidth: 2,
	        strokeDashstyle: "solid",
	        hoverStrokeColor: "red",
	        hoverStrokeOpacity: 1,
	        hoverStrokeWidth: 0.2,
	        pointRadius: 6,
	        hoverPointRadius: 1,
	        hoverPointUnit: "%",
	        pointerEvents: "visiblePainted",
	        cursor: "inherit",
	        fontColor: "#000000",
	        labelAlign: "cm",
	        labelOutlineColor: "white",
	        labelOutlineWidth: 3

	    },
	    'delete': {
	        display: "none"
	    }
	};    
	/* ======================================================================
	    OpenLayers/Style.js
	   ====================================================================== */

	/* Copyright (c) 2006-2015 by OpenLayers Contributors (see authors.txt for
	 * full list of contributors). Published under the 2-clause BSD license.
	 * See license.txt in the OpenLayers distribution or repository for the
	 * full text of the license. */


	/**
	 * @requires OpenLayers/BaseTypes/Class.js
	 * @requires OpenLayers/Util.js
	 * @requires OpenLayers/Feature/Vector.js
	 */

	/**
	 * Class: OpenLayers.Style
	 * This class represents a UserStyle obtained
	 *     from a SLD, containing styling rules.
	 */
	OpenLayers.Style = OpenLayers.Class({

	    /**
	     * Property: id
	     * {String} A unique id for this session.
	     */
	    id: null,
	    
	    /**
	     * APIProperty: name
	     * {String}
	     */
	    name: null,
	    
	    /**
	     * Property: title
	     * {String} Title of this style (set if included in SLD)
	     */
	    title: null,
	    
	    /**
	     * Property: description
	     * {String} Description of this style (set if abstract is included in SLD)
	     */
	    description: null,

	    /**
	     * APIProperty: layerName
	     * {<String>} name of the layer that this style belongs to, usually
	     * according to the NamedLayer attribute of an SLD document.
	     */
	    layerName: null,
	    
	    /**
	     * APIProperty: isDefault
	     * {Boolean}
	     */
	    isDefault: false,
	     
	    /** 
	     * Property: rules 
	     * {Array(<OpenLayers.Rule>)}
	     */
	    rules: null,
	    
	    /**
	     * APIProperty: context
	     * {Object} An optional object with properties that symbolizers' property
	     * values should be evaluated against. If no context is specified,
	     * feature.attributes will be used
	     */
	    context: null,

	    /**
	     * Property: defaultStyle
	     * {Object} hash of style properties to use as default for merging
	     * rule-based style symbolizers onto. If no rules are defined,
	     * createSymbolizer will return this style. If <defaultsPerSymbolizer> is set to
	     * true, the defaultStyle will only be taken into account if there are
	     * rules defined.
	     */
	    defaultStyle: null,
	    
	    /**
	     * Property: defaultsPerSymbolizer
	     * {Boolean} If set to true, the <defaultStyle> will extend the symbolizer
	     * of every rule. Properties of the <defaultStyle> will also be used to set
	     * missing symbolizer properties if the symbolizer has stroke, fill or
	     * graphic set to true. Default is false.
	     */
	    defaultsPerSymbolizer: false,
	    
	    /**
	     * Property: propertyStyles
	     * {Hash of Boolean} cache of style properties that need to be parsed for
	     * propertyNames. Property names are keys, values won't be used.
	     */
	    propertyStyles: null,
	    

	    /** 
	     * Constructor: OpenLayers.Style
	     * Creates a UserStyle.
	     *
	     * Parameters:
	     * style        - {Object} Optional hash of style properties that will be
	     *                used as default style for this style object. This style
	     *                applies if no rules are specified. Symbolizers defined in
	     *                rules will extend this default style.
	     * options - {Object} An optional object with properties to set on the
	     *     style.
	     *
	     * Valid options:
	     * rules - {Array(<OpenLayers.Rule>)} List of rules to be added to the
	     *     style.
	     * 
	     * Returns:
	     * {<OpenLayers.Style>}
	     */
	    initialize: function(style, options) {

	        OpenLayers.Util.extend(this, options);
	        this.rules = [];
	        if(options && options.rules) {
	            this.addRules(options.rules);
	        }

	        // use the default style from OpenLayers.Feature.Vector if no style
	        // was given in the constructor
	        this.setDefaultStyle(style ||
	                             OpenLayers.Feature.Vector.style["default"]);

	        this.id = OpenLayers.Util.createUniqueID(this.CLASS_NAME + "_");
	    },

	    /** 
	     * APIMethod: destroy
	     * nullify references to prevent circular references and memory leaks
	     */
	    destroy: function() {
	        for (var i=0, len=this.rules.length; i<len; i++) {
	            this.rules[i].destroy();
	            this.rules[i] = null;
	        }
	        this.rules = null;
	        this.defaultStyle = null;
	    },
	    
	    /**
	     * Method: createSymbolizer
	     * creates a style by applying all feature-dependent rules to the base
	     * style.
	     * 
	     * Parameters:
	     * feature - {<OpenLayers.Feature>} feature to evaluate rules for
	     * 
	     * Returns:
	     * {Object} symbolizer hash
	     */
	    createSymbolizer: function(feature) {
	        var style = this.defaultsPerSymbolizer ? {} : this.createLiterals(
	            OpenLayers.Util.extend({}, this.defaultStyle), feature);
	        
	        var rules = this.rules;

	        var rule, context;
	        var elseRules = [];
	        var appliedRules = false;
	        for(var i=0, len=rules.length; i<len; i++) {
	            rule = rules[i];
	            // does the rule apply?
	            var applies = rule.evaluate(feature);
	            
	            if(applies) {
	                if(rule instanceof OpenLayers.Rule && rule.elseFilter) {
	                    elseRules.push(rule);
	                } else {
	                    appliedRules = true;
	                    this.applySymbolizer(rule, style, feature);
	                }
	            }
	        }
	        
	        // if no other rules apply, apply the rules with else filters
	        if(appliedRules == false && elseRules.length > 0) {
	            appliedRules = true;
	            for(var i=0, len=elseRules.length; i<len; i++) {
	                this.applySymbolizer(elseRules[i], style, feature);
	            }
	        }

	        // don't display if there were rules but none applied
	        if(rules.length > 0 && appliedRules == false) {
	            style.display = "none";
	        }
	        
	        if (style.label != null && typeof style.label !== "string") {
	            style.label = String(style.label);
	        }
	        
	        return style;
	    },
	    
	    /**
	     * Method: applySymbolizer
	     *
	     * Parameters:
	     * rule - {<OpenLayers.Rule>}
	     * style - {Object}
	     * feature - {<OpenLayer.Feature.Vector>}
	     *
	     * Returns:
	     * {Object} A style with new symbolizer applied.
	     */
	    applySymbolizer: function(rule, style, feature) {
	        var symbolizerPrefix = feature.geometry ?
	                this.getSymbolizerPrefix(feature.geometry) :
	                OpenLayers.Style.SYMBOLIZER_PREFIXES[0];

	        var symbolizer = rule.symbolizer[symbolizerPrefix] || rule.symbolizer;
	        
	        if(this.defaultsPerSymbolizer === true) {
	            var defaults = this.defaultStyle;
	            OpenLayers.Util.applyDefaults(symbolizer, {
	                pointRadius: defaults.pointRadius
	            });
	            if(symbolizer.stroke === true || symbolizer.graphic === true) {
	                OpenLayers.Util.applyDefaults(symbolizer, {
	                    strokeWidth: defaults.strokeWidth,
	                    strokeColor: defaults.strokeColor,
	                    strokeOpacity: defaults.strokeOpacity,
	                    strokeDashstyle: defaults.strokeDashstyle,
	                    strokeLinecap: defaults.strokeLinecap
	                });
	            }
	            if(symbolizer.fill === true || symbolizer.graphic === true) {
	                OpenLayers.Util.applyDefaults(symbolizer, {
	                    fillColor: defaults.fillColor,
	                    fillOpacity: defaults.fillOpacity
	                });
	            }
	            if(symbolizer.graphic === true) {
	                OpenLayers.Util.applyDefaults(symbolizer, {
	                    pointRadius: this.defaultStyle.pointRadius,
	                    externalGraphic: this.defaultStyle.externalGraphic,
	                    graphicName: this.defaultStyle.graphicName,
	                    graphicOpacity: this.defaultStyle.graphicOpacity,
	                    graphicWidth: this.defaultStyle.graphicWidth,
	                    graphicHeight: this.defaultStyle.graphicHeight,
	                    graphicXOffset: this.defaultStyle.graphicXOffset,
	                    graphicYOffset: this.defaultStyle.graphicYOffset
	                });
	            }
	        }

	        // merge the style with the current style
	        return this.createLiterals(
	                OpenLayers.Util.extend(style, symbolizer), feature);
	    },
	    
	    /**
	     * Method: createLiterals
	     * creates literals for all style properties that have an entry in
	     * <this.propertyStyles>.
	     * 
	     * Parameters:
	     * style   - {Object} style to create literals for. Will be modified
	     *           inline.
	     * feature - {Object}
	     * 
	     * Returns:
	     * {Object} the modified style
	     */
	    createLiterals: function(style, feature) {
	        var context = OpenLayers.Util.extend({}, feature.attributes || feature.data);
	        OpenLayers.Util.extend(context, this.context);
	        
	        for (var i in this.propertyStyles) {
	            style[i] = OpenLayers.Style.createLiteral(style[i], context, feature, i);
	        }
	        return style;
	    },
	    
	    /**
	     * Method: findPropertyStyles
	     * Looks into all rules for this style and the defaultStyle to collect
	     * all the style hash property names containing ${...} strings that have
	     * to be replaced using the createLiteral method before returning them.
	     * 
	     * Returns:
	     * {Object} hash of property names that need createLiteral parsing. The
	     * name of the property is the key, and the value is true;
	     */
	    findPropertyStyles: function() {
	        var propertyStyles = {};

	        // check the default style
	        var style = this.defaultStyle;
	        this.addPropertyStyles(propertyStyles, style);

	        // walk through all rules to check for properties in their symbolizer
	        var rules = this.rules;
	        var symbolizer, value;
	        for (var i=0, len=rules.length; i<len; i++) {
	            symbolizer = rules[i].symbolizer;
	            for (var key in symbolizer) {
	                value = symbolizer[key];
	                if (typeof value == "object") {
	                    // symbolizer key is "Point", "Line" or "Polygon"
	                    this.addPropertyStyles(propertyStyles, value);
	                } else {
	                    // symbolizer is a hash of style properties
	                    this.addPropertyStyles(propertyStyles, symbolizer);
	                    break;
	                }
	            }
	        }
	        return propertyStyles;
	    },
	    
	    /**
	     * Method: addPropertyStyles
	     * 
	     * Parameters:
	     * propertyStyles - {Object} hash to add new property styles to. Will be
	     *                  modified inline
	     * symbolizer     - {Object} search this symbolizer for property styles
	     * 
	     * Returns:
	     * {Object} propertyStyles hash
	     */
	    addPropertyStyles: function(propertyStyles, symbolizer) {
	        var property;
	        for (var key in symbolizer) {
	            property = symbolizer[key];
	            if (typeof property == "string" &&
	                    property.match(/\$\{\w+\}/)) {
	                propertyStyles[key] = true;
	            }
	        }
	        return propertyStyles;
	    },
	    
	    /**
	     * APIMethod: addRules
	     * Adds rules to this style.
	     * 
	     * Parameters:
	     * rules - {Array(<OpenLayers.Rule>)}
	     */
	    addRules: function(rules) {
	        Array.prototype.push.apply(this.rules, rules);
	        this.propertyStyles = this.findPropertyStyles();
	    },
	    
	    /**
	     * APIMethod: setDefaultStyle
	     * Sets the default style for this style object.
	     * 
	     * Parameters:
	     * style - {Object} Hash of style properties
	     */
	    setDefaultStyle: function(style) {
	        this.defaultStyle = style; 
	        this.propertyStyles = this.findPropertyStyles();
	    },
	        
	    /**
	     * Method: getSymbolizerPrefix
	     * Returns the correct symbolizer prefix according to the
	     * geometry type of the passed geometry
	     * 
	     * Parameters:
	     * geometry - {<OpenLayers.Geometry>}
	     * 
	     * Returns:
	     * {String} key of the according symbolizer
	     */
	    getSymbolizerPrefix: function(geometry) {
	        var prefixes = OpenLayers.Style.SYMBOLIZER_PREFIXES;
	        for (var i=0, len=prefixes.length; i<len; i++) {
	            if (geometry.CLASS_NAME.indexOf(prefixes[i]) != -1) {
	                return prefixes[i];
	            }
	        }
	    },
	    
	    /**
	     * APIMethod: clone
	     * Clones this style.
	     * 
	     * Returns:
	     * {<OpenLayers.Style>} Clone of this style.
	     */
	    clone: function() {
	        var options = OpenLayers.Util.extend({}, this);
	        // clone rules
	        if(this.rules) {
	            options.rules = [];
	            for(var i=0, len=this.rules.length; i<len; ++i) {
	                options.rules.push(this.rules[i].clone());
	            }
	        }
	        // clone context
	        options.context = this.context && OpenLayers.Util.extend({}, this.context);
	        //clone default style
	        var defaultStyle = OpenLayers.Util.extend({}, this.defaultStyle);
	        return new OpenLayers.Style(defaultStyle, options);
	    },
	    
	    CLASS_NAME: "OpenLayers.Style"
	});


	/**
	 * Function: createLiteral
	 * converts a style value holding a combination of PropertyName and Literal
	 * into a Literal, taking the property values from the passed features.
	 * 
	 * Parameters:
	 * value - {String} value to parse. If this string contains a construct like
	 *         "foo ${bar}", then "foo " will be taken as literal, and "${bar}"
	 *         will be replaced by the value of the "bar" attribute of the passed
	 *         feature.
	 * context - {Object} context to take attribute values from
	 * feature - {<OpenLayers.Feature.Vector>} optional feature to pass to
	 *           <OpenLayers.String.format> for evaluating functions in the
	 *           context.
	 * property - {String} optional, name of the property for which the literal is
	 *            being created for evaluating functions in the context.
	 * 
	 * Returns:
	 * {String} the parsed value. In the example of the value parameter above, the
	 * result would be "foo valueOfBar", assuming that the passed feature has an
	 * attribute named "bar" with the value "valueOfBar".
	 */
	OpenLayers.Style.createLiteral = function(value, context, feature, property) {
	    if (typeof value == "string" && value.indexOf("${") != -1) {
	        value = OpenLayers.String.format(value, context, [feature, property]);
	        value = (isNaN(value) || !value) ? value : parseFloat(value);
	    }
	    return value;
	};
	    
	/**
	 * Constant: OpenLayers.Style.SYMBOLIZER_PREFIXES
	 * {Array} prefixes of the sld symbolizers. These are the
	 * same as the main geometry types
	 */
	OpenLayers.Style.SYMBOLIZER_PREFIXES = ['Point', 'Line', 'Polygon', 'Text',
	    'Raster'];
	/* ======================================================================
	    OpenLayers/StyleMap.js
	   ====================================================================== */

	/* Copyright (c) 2006-2015 by OpenLayers Contributors (see authors.txt for
	 * full list of contributors). Published under the 2-clause BSD license.
	 * See license.txt in the OpenLayers distribution or repository for the
	 * full text of the license. */

	/**
	 * @requires OpenLayers/BaseTypes/Class.js
	 * @requires OpenLayers/Style.js
	 * @requires OpenLayers/Feature/Vector.js
	 */
	 
	/**
	 * Class: OpenLayers.StyleMap
	 */
	OpenLayers.StyleMap = OpenLayers.Class({
	    
	    /**
	     * Property: styles
	     * {Object} Hash of {<OpenLayers.Style>}, keyed by names of well known
	     * rendering intents (e.g. "default", "temporary", "select", "delete").
	     */
	    styles: null,
	    
	    /**
	     * Property: extendDefault
	     * {Boolean} if true, every render intent will extend the symbolizers
	     * specified for the "default" intent at rendering time. Otherwise, every
	     * rendering intent will be treated as a completely independent style.
	     */
	    extendDefault: true,
	    
	    /**
	     * Constructor: OpenLayers.StyleMap
	     * 
	     * Parameters:
	     * style   - {Object} Optional. Either a style hash, or a style object, or
	     *           a hash of style objects (style hashes) keyed by rendering
	     *           intent. If just one style hash or style object is passed,
	     *           this will be used for all known render intents (default,
	     *           select, temporary)
	     * options - {Object} optional hash of additional options for this
	     *           instance
	     */
	    initialize: function (style, options) {
	        this.styles = {
	            "default": new OpenLayers.Style(
	                OpenLayers.Feature.Vector.style["default"]),
	            "select": new OpenLayers.Style(
	                OpenLayers.Feature.Vector.style["select"]),
	            "temporary": new OpenLayers.Style(
	                OpenLayers.Feature.Vector.style["temporary"]),
	            "delete": new OpenLayers.Style(
	                OpenLayers.Feature.Vector.style["delete"])
	        };
	        
	        // take whatever the user passed as style parameter and convert it
	        // into parts of stylemap.
	        if(style instanceof OpenLayers.Style) {
	            // user passed a style object
	            this.styles["default"] = style;
	            this.styles["select"] = style;
	            this.styles["temporary"] = style;
	            this.styles["delete"] = style;
	        } else if(typeof style == "object") {
	            for(var key in style) {
	                if(style[key] instanceof OpenLayers.Style) {
	                    // user passed a hash of style objects
	                    this.styles[key] = style[key];
	                } else if(typeof style[key] == "object") {
	                    // user passsed a hash of style hashes
	                    this.styles[key] = new OpenLayers.Style(style[key]);
	                } else {
	                    // user passed a style hash (i.e. symbolizer)
	                    this.styles["default"] = new OpenLayers.Style(style);
	                    this.styles["select"] = new OpenLayers.Style(style);
	                    this.styles["temporary"] = new OpenLayers.Style(style);
	                    this.styles["delete"] = new OpenLayers.Style(style);
	                    break;
	                }
	            }
	        }
	        OpenLayers.Util.extend(this, options);
	    },

	    /**
	     * Method: destroy
	     */
	    destroy: function() {
	        for(var key in this.styles) {
	            this.styles[key].destroy();
	        }
	        this.styles = null;
	    },
	    
	    /**
	     * Method: createSymbolizer
	     * Creates the symbolizer for a feature for a render intent.
	     * 
	     * Parameters:
	     * feature - {<OpenLayers.Feature>} The feature to evaluate the rules
	     *           of the intended style against.
	     * intent  - {String} The intent determines the symbolizer that will be
	     *           used to draw the feature. Well known intents are "default"
	     *           (for just drawing the features), "select" (for selected
	     *           features) and "temporary" (for drawing features).
	     * 
	     * Returns:
	     * {Object} symbolizer hash
	     */
	    createSymbolizer: function(feature, intent) {
	        if(!feature) {
	            feature = new OpenLayers.Feature.Vector();
	        }
	        if(!this.styles[intent]) {
	            intent = "default";
	        }
	        feature.renderIntent = intent;
	        var defaultSymbolizer = {};
	        if(this.extendDefault && intent != "default") {
	            defaultSymbolizer = this.styles["default"].createSymbolizer(feature);
	        }
	        return OpenLayers.Util.extend(defaultSymbolizer,
	            this.styles[intent].createSymbolizer(feature));
	    },
	    
	    /**
	     * Method: addUniqueValueRules
	     * Convenience method to create comparison rules for unique values of a
	     * property. The rules will be added to the style object for a specified
	     * rendering intent. This method is a shortcut for creating something like
	     * the "unique value legends" familiar from well known desktop GIS systems
	     * 
	     * Parameters:
	     * renderIntent - {String} rendering intent to add the rules to
	     * property     - {String} values of feature attributes to create the
	     *                rules for
	     * symbolizers  - {Object} Hash of symbolizers, keyed by the desired
	     *                property values 
	     * context      - {Object} An optional object with properties that
	     *                symbolizers' property values should be evaluated
	     *                against. If no context is specified, feature.attributes
	     *                will be used
	     */
	    addUniqueValueRules: function(renderIntent, property, symbolizers, context) {
	        var rules = [];
	        for (var value in symbolizers) {
	            rules.push(new OpenLayers.Rule({
	                symbolizer: symbolizers[value],
	                context: context,
	                filter: new OpenLayers.Filter.Comparison({
	                    type: OpenLayers.Filter.Comparison.EQUAL_TO,
	                    property: property,
	                    value: value
	                })
	            }));
	        }
	        this.styles[renderIntent].addRules(rules);
	    },

	    CLASS_NAME: "OpenLayers.StyleMap"
	});
	/* ======================================================================
	    OpenLayers/Layer/Vector.js
	   ====================================================================== */

	/* Copyright (c) 2006-2015 by OpenLayers Contributors (see authors.txt for
	 * full list of contributors). Published under the 2-clause BSD license.
	 * See license.txt in the OpenLayers distribution or repository for the
	 * full text of the license. */

	/**
	 * @requires OpenLayers/Layer.js
	 * @requires OpenLayers/Renderer.js
	 * @requires OpenLayers/StyleMap.js
	 * @requires OpenLayers/Feature/Vector.js
	 * @requires OpenLayers/Console.js
	 * @requires OpenLayers/Lang.js
	 */

	/**
	 * Class: OpenLayers.Layer.Vector
	 * Instances of OpenLayers.Layer.Vector are used to render vector data from
	 *     a variety of sources. Create a new vector layer with the
	 *     <OpenLayers.Layer.Vector> constructor.
	 *
	 * Inherits from:
	 *  - <OpenLayers.Layer>
	 */
	OpenLayers.Layer.Vector = OpenLayers.Class(OpenLayers.Layer, {

	    /**
	     * APIProperty: events
	     * {<OpenLayers.Events>}
	     *
	     * Register a listener for a particular event with the following syntax:
	     * (code)
	     * layer.events.register(type, obj, listener);
	     * (end)
	     *
	     * Listeners will be called with a reference to an event object.  The
	     *     properties of this event depends on exactly what happened.
	     *
	     * All event objects have at least the following properties:
	     * object - {Object} A reference to layer.events.object.
	     * element - {DOMElement} A reference to layer.events.element.
	     *
	     * Supported map event types (in addition to those from <OpenLayers.Layer.events>):
	     * beforefeatureadded - Triggered before a feature is added.  Listeners
	     *      will receive an object with a *feature* property referencing the
	     *      feature to be added.  To stop the feature from being added, a
	     *      listener should return false.
	     * beforefeaturesadded - Triggered before an array of features is added.
	     *      Listeners will receive an object with a *features* property
	     *      referencing the feature to be added. To stop the features from
	     *      being added, a listener should return false.
	     * featureadded - Triggered after a feature is added.  The event
	     *      object passed to listeners will have a *feature* property with a
	     *      reference to the added feature.
	     * featuresadded - Triggered after features are added.  The event
	     *      object passed to listeners will have a *features* property with a
	     *      reference to an array of added features.
	     * beforefeatureremoved - Triggered before a feature is removed. Listeners
	     *      will receive an object with a *feature* property referencing the
	     *      feature to be removed.
	     * beforefeaturesremoved - Triggered before multiple features are removed. 
	     *      Listeners will receive an object with a *features* property
	     *      referencing the features to be removed.
	     * featureremoved - Triggered after a feature is removed. The event
	     *      object passed to listeners will have a *feature* property with a
	     *      reference to the removed feature.
	     * featuresremoved - Triggered after features are removed. The event
	     *      object passed to listeners will have a *features* property with a
	     *      reference to an array of removed features.
	     * beforefeatureselected - Triggered before a feature is selected.  Listeners
	     *      will receive an object with a *feature* property referencing the
	     *      feature to be selected. To stop the feature from being selectd, a
	     *      listener should return false.
	     * featureselected - Triggered after a feature is selected.  Listeners
	     *      will receive an object with a *feature* property referencing the
	     *      selected feature.
	     * featureunselected - Triggered after a feature is unselected.
	     *      Listeners will receive an object with a *feature* property
	     *      referencing the unselected feature.
	     * beforefeaturemodified - Triggered when a feature is selected to 
	     *      be modified.  Listeners will receive an object with a *feature* 
	     *      property referencing the selected feature.
	     * featuremodified - Triggered when a feature has been modified.
	     *      Listeners will receive an object with a *feature* property referencing 
	     *      the modified feature.
	     * afterfeaturemodified - Triggered when a feature is finished being modified.
	     *      Listeners will receive an object with a *feature* property referencing 
	     *      the modified feature.
	     * vertexmodified - Triggered when a vertex within any feature geometry
	     *      has been modified.  Listeners will receive an object with a
	     *      *feature* property referencing the modified feature, a *vertex*
	     *      property referencing the vertex modified (always a point geometry),
	     *      and a *pixel* property referencing the pixel location of the
	     *      modification.
	     * vertexremoved - Triggered when a vertex within any feature geometry
	     *      has been deleted.  Listeners will receive an object with a
	     *      *feature* property referencing the modified feature, a *vertex*
	     *      property referencing the vertex modified (always a point geometry),
	     *      and a *pixel* property referencing the pixel location of the
	     *      removal.
	     * sketchstarted - Triggered when a feature sketch bound for this layer
	     *      is started.  Listeners will receive an object with a *feature*
	     *      property referencing the new sketch feature and a *vertex* property
	     *      referencing the creation point.
	     * sketchmodified - Triggered when a feature sketch bound for this layer
	     *      is modified.  Listeners will receive an object with a *vertex*
	     *      property referencing the modified vertex and a *feature* property
	     *      referencing the sketch feature.
	     * sketchcomplete - Triggered when a feature sketch bound for this layer
	     *      is complete.  Listeners will receive an object with a *feature*
	     *      property referencing the sketch feature.  By returning false, a
	     *      listener can stop the sketch feature from being added to the layer.
	     * refresh - Triggered when something wants a strategy to ask the protocol
	     *      for a new set of features.
	     */

	    /**
	     * APIProperty: isBaseLayer
	     * {Boolean} The layer is a base layer.  Default is false.  Set this property
	     * in the layer options.
	     */
	    isBaseLayer: false,

	    /** 
	     * APIProperty: isFixed
	     * {Boolean} Whether the layer remains in one place while dragging the
	     * map. Note that setting this to true will move the layer to the bottom
	     * of the layer stack.
	     */
	    isFixed: false,

	    /** 
	     * APIProperty: features
	     * {Array(<OpenLayers.Feature.Vector>)} 
	     */
	    features: null,
	    
	    /** 
	     * Property: filter
	     * {<OpenLayers.Filter>} The filter set in this layer,
	     *     a strategy launching read requests can combined
	     *     this filter with its own filter.
	     */
	    filter: null,
	    
	    /** 
	     * Property: selectedFeatures
	     * {Array(<OpenLayers.Feature.Vector>)} 
	     */
	    selectedFeatures: null,
	    
	    /**
	     * Property: unrenderedFeatures
	     * {Object} hash of features, keyed by feature.id, that the renderer
	     *     failed to draw
	     */
	    unrenderedFeatures: null,

	    /**
	     * APIProperty: reportError
	     * {Boolean} report friendly error message when loading of renderer
	     * fails.
	     */
	    reportError: true, 

	    /** 
	     * APIProperty: style
	     * {Object} Default style for the layer
	     */
	    style: null,
	    
	    /**
	     * Property: styleMap
	     * {<OpenLayers.StyleMap>}
	     */
	    styleMap: null,
	    
	    /**
	     * Property: strategies
	     * {Array(<OpenLayers.Strategy>})} Optional list of strategies for the layer.
	     */
	    strategies: null,
	    
	    /**
	     * Property: protocol
	     * {<OpenLayers.Protocol>} Optional protocol for the layer.
	     */
	    protocol: null,
	    
	    /**
	     * Property: renderers
	     * {Array(String)} List of supported Renderer classes. Add to this list to
	     * add support for additional renderers. This list is ordered:
	     * the first renderer which returns true for the  'supported()'
	     * method will be used, if not defined in the 'renderer' option.
	     */
	    renderers: ['SVG', 'VML', 'Canvas'],
	    
	    /** 
	     * Property: renderer
	     * {<OpenLayers.Renderer>}
	     */
	    renderer: null,
	    
	    /**
	     * APIProperty: rendererOptions
	     * {Object} Options for the renderer. See {<OpenLayers.Renderer>} for
	     *     supported options.
	     */
	    rendererOptions: null,
	    
	    /** 
	     * APIProperty: geometryType
	     * {String} geometryType allows you to limit the types of geometries this
	     * layer supports. This should be set to something like
	     * "OpenLayers.Geometry.Point" to limit types.
	     */
	    geometryType: null,

	    /** 
	     * Property: drawn
	     * {Boolean} Whether the Vector Layer features have been drawn yet.
	     */
	    drawn: false,
	    
	    /** 
	     * APIProperty: ratio
	     * {Float} This specifies the ratio of the size of the visiblity of the Vector Layer features to the size of the map.
	     */   
	    ratio: 1,

	    /**
	     * Constructor: OpenLayers.Layer.Vector
	     * Create a new vector layer
	     *
	     * Parameters:
	     * name - {String} A name for the layer
	     * options - {Object} Optional object with non-default properties to set on
	     *           the layer.
	     *
	     * Returns:
	     * {<OpenLayers.Layer.Vector>} A new vector layer
	     */
	    initialize: function(name, options) {
	        OpenLayers.Layer.prototype.initialize.apply(this, arguments);

	        // allow user-set renderer, otherwise assign one
	        if (!this.renderer || !this.renderer.supported()) {  
	            this.assignRenderer();
	        }

	        // if no valid renderer found, display error
	        if (!this.renderer || !this.renderer.supported()) {
	            this.renderer = null;
	            this.displayError();
	        } 

	        if (!this.styleMap) {
	            this.styleMap = new OpenLayers.StyleMap();
	        }

	        this.features = [];
	        this.selectedFeatures = [];
	        this.unrenderedFeatures = {};
	        
	        // Allow for custom layer behavior
	        if(this.strategies){
	            for(var i=0, len=this.strategies.length; i<len; i++) {
	                this.strategies[i].setLayer(this);
	            }
	        }

	    },

	    /**
	     * APIMethod: destroy
	     * Destroy this layer
	     */
	    destroy: function() {
	        if (this.strategies) {
	            var strategy, i, len;
	            for(i=0, len=this.strategies.length; i<len; i++) {
	                strategy = this.strategies[i];
	                if(strategy.autoDestroy) {
	                    strategy.destroy();
	                }
	            }
	            this.strategies = null;
	        }
	        if (this.protocol) {
	            if(this.protocol.autoDestroy) {
	                this.protocol.destroy();
	            }
	            this.protocol = null;
	        }
	        this.destroyFeatures();
	        this.features = null;
	        this.selectedFeatures = null;
	        this.unrenderedFeatures = null;
	        if (this.renderer) {
	            this.renderer.destroy();
	        }
	        this.renderer = null;
	        this.geometryType = null;
	        this.drawn = null;
	        OpenLayers.Layer.prototype.destroy.apply(this, arguments);  
	    },

	    /**
	     * Method: clone
	     * Create a clone of this layer.
	     * 
	     * Note: Features of the layer are also cloned.
	     *
	     * Returns:
	     * {<OpenLayers.Layer.Vector>} An exact clone of this layer
	     */
	    clone: function (obj) {
	        
	        if (obj == null) {
	            obj = new OpenLayers.Layer.Vector(this.name, this.getOptions());
	        }

	        //get all additions from superclasses
	        obj = OpenLayers.Layer.prototype.clone.apply(this, [obj]);

	        // copy/set any non-init, non-simple values here
	        var features = this.features;
	        var len = features.length;
	        var clonedFeatures = new Array(len);
	        for(var i=0; i<len; ++i) {
	            clonedFeatures[i] = features[i].clone();
	        }
	        obj.features = clonedFeatures;

	        return obj;
	    },    
	    
	    /**
	     * Method: refresh
	     * Ask the layer to request features again and redraw them.  Triggers
	     *     the refresh event if the layer is in range and visible.
	     *
	     * Parameters:
	     * obj - {Object} Optional object with properties for any listener of
	     *     the refresh event.
	     */
	    refresh: function(obj) {
	        if(this.calculateInRange() && this.visibility) {
	            this.events.triggerEvent("refresh", obj);
	        }
	    },

	    /** 
	     * Method: assignRenderer
	     * Iterates through the available renderer implementations and selects 
	     * and assigns the first one whose "supported()" function returns true.
	     */    
	    assignRenderer: function()  {
	        for (var i=0, len=this.renderers.length; i<len; i++) {
	            var rendererClass = this.renderers[i];
	            var renderer = (typeof rendererClass == "function") ?
	                rendererClass :
	                OpenLayers.Renderer[rendererClass];
	            if (renderer && renderer.prototype.supported()) {
	                this.renderer = new renderer(this.div, this.rendererOptions);
	                break;
	            }  
	        }  
	    },

	    /** 
	     * Method: displayError 
	     * Let the user know their browser isn't supported.
	     */
	    displayError: function() {
	        if (this.reportError) {
	            OpenLayers.Console.userError(OpenLayers.i18n("browserNotSupported", 
	                                     {renderers: this. renderers.join('\n')}));
	        }    
	    },

	    /** 
	     * Method: setMap
	     * The layer has been added to the map. 
	     * 
	     * If there is no renderer set, the layer can't be used. Remove it.
	     * Otherwise, give the renderer a reference to the map and set its size.
	     * 
	     * Parameters:
	     * map - {<OpenLayers.Map>} 
	     */
	    setMap: function(map) {        
	        OpenLayers.Layer.prototype.setMap.apply(this, arguments);

	        if (!this.renderer) {
	            this.map.removeLayer(this);
	        } else {
	            this.renderer.map = this.map;

	            var newSize = this.map.getSize();
	            newSize.w = newSize.w * this.ratio;
	            newSize.h = newSize.h * this.ratio;
	            this.renderer.setSize(newSize);
	        }
	    },

	    /**
	     * Method: afterAdd
	     * Called at the end of the map.addLayer sequence.  At this point, the map
	     *     will have a base layer.  Any autoActivate strategies will be
	     *     activated here.
	     */
	    afterAdd: function() {
	        if(this.strategies) {
	            var strategy, i, len;
	            for(i=0, len=this.strategies.length; i<len; i++) {
	                strategy = this.strategies[i];
	                if(strategy.autoActivate) {
	                    strategy.activate();
	                }
	            }
	        }
	    },

	    /**
	     * Method: removeMap
	     * The layer has been removed from the map.
	     *
	     * Parameters:
	     * map - {<OpenLayers.Map>}
	     */
	    removeMap: function(map) {
	        this.drawn = false;
	        if(this.strategies) {
	            var strategy, i, len;
	            for(i=0, len=this.strategies.length; i<len; i++) {
	                strategy = this.strategies[i];
	                if(strategy.autoActivate) {
	                    strategy.deactivate();
	                }
	            }
	        }
	    },
	    
	    /**
	     * Method: onMapResize
	     * Notify the renderer of the change in size. 
	     * 
	     */
	    onMapResize: function() {
	        OpenLayers.Layer.prototype.onMapResize.apply(this, arguments);
	        
	        var newSize = this.map.getSize();
	        newSize.w = newSize.w * this.ratio;
	        newSize.h = newSize.h * this.ratio;
	        this.renderer.setSize(newSize);
	    },

	    /**
	     * Method: moveTo
	     *  Reset the vector layer's div so that it once again is lined up with 
	     *   the map. Notify the renderer of the change of extent, and in the
	     *   case of a change of zoom level (resolution), have the 
	     *   renderer redraw features.
	     * 
	     *  If the layer has not yet been drawn, cycle through the layer's 
	     *   features and draw each one.
	     * 
	     * Parameters:
	     * bounds - {<OpenLayers.Bounds>} 
	     * zoomChanged - {Boolean} 
	     * dragging - {Boolean} 
	     */
	    moveTo: function(bounds, zoomChanged, dragging) {
	        OpenLayers.Layer.prototype.moveTo.apply(this, arguments);
	        
	        var coordSysUnchanged = true;
	        if (!dragging) {
	            this.renderer.root.style.visibility = 'hidden';

	            var viewSize = this.map.getSize(),
	                viewWidth = viewSize.w,
	                viewHeight = viewSize.h,
	                offsetLeft = (viewWidth / 2 * this.ratio) - viewWidth / 2,
	                offsetTop = (viewHeight / 2 * this.ratio) - viewHeight / 2;
	            offsetLeft += this.map.layerContainerOriginPx.x;
	            offsetLeft = -Math.round(offsetLeft);
	            offsetTop += this.map.layerContainerOriginPx.y;
	            offsetTop = -Math.round(offsetTop);

	            this.div.style.left = offsetLeft + 'px';
	            this.div.style.top = offsetTop + 'px';

	            var extent = this.map.getExtent().scale(this.ratio);
	            coordSysUnchanged = this.renderer.setExtent(extent, zoomChanged);

	            this.renderer.root.style.visibility = 'visible';

	            // Force a reflow on gecko based browsers to prevent jump/flicker.
	            // This seems to happen on only certain configurations; it was originally
	            // noticed in FF 2.0 and Linux.
	            if (OpenLayers.IS_GECKO === true) {
	                this.div.scrollLeft = this.div.scrollLeft;
	            }
	            
	            if (!zoomChanged && coordSysUnchanged) {
	                for (var i in this.unrenderedFeatures) {
	                    var feature = this.unrenderedFeatures[i];
	                    this.drawFeature(feature);
	                }
	            }
	        }
	        if (!this.drawn || zoomChanged || !coordSysUnchanged) {
	            this.drawn = true;
	            var feature;
	            for(var i=0, len=this.features.length; i<len; i++) {
	                this.renderer.locked = (i !== (len - 1));
	                feature = this.features[i];
	                this.drawFeature(feature);
	            }
	        }    
	    },
	    
	    /** 
	     * APIMethod: display
	     * Hide or show the Layer
	     * 
	     * Parameters:
	     * display - {Boolean}
	     */
	    display: function(display) {
	        OpenLayers.Layer.prototype.display.apply(this, arguments);
	        // we need to set the display style of the root in case it is attached
	        // to a foreign layer
	        var currentDisplay = this.div.style.display;
	        if(currentDisplay != this.renderer.root.style.display) {
	            this.renderer.root.style.display = currentDisplay;
	        }
	    },

	    /**
	     * APIMethod: addFeatures
	     * Add Features to the layer.
	     *
	     * Parameters:
	     * features - {Array(<OpenLayers.Feature.Vector>)} 
	     * options - {Object}
	     */
	    addFeatures: function(features, options) {
	        if (!(OpenLayers.Util.isArray(features))) {
	            features = [features];
	        }
	        
	        var notify = !options || !options.silent;
	        if(notify) {
	            var event = {features: features};
	            var ret = this.events.triggerEvent("beforefeaturesadded", event);
	            if(ret === false) {
	                return;
	            }
	            features = event.features;
	        }
	        
	        // Track successfully added features for featuresadded event, since
	        // beforefeatureadded can veto single features.
	        var featuresAdded = [];
	        for (var i=0, len=features.length; i<len; i++) {
	            if (i != (features.length - 1)) {
	                this.renderer.locked = true;
	            } else {
	                this.renderer.locked = false;
	            }    
	            var feature = features[i];
	            
	            if (this.geometryType &&
	              !(feature.geometry instanceof this.geometryType)) {
	                throw new TypeError('addFeatures: component should be an ' +
	                                    this.geometryType.prototype.CLASS_NAME);
	              }

	            //give feature reference to its layer
	            feature.layer = this;

	            if (!feature.style && this.style) {
	                feature.style = OpenLayers.Util.extend({}, this.style);
	            }

	            if (notify) {
	                if(this.events.triggerEvent("beforefeatureadded",
	                                            {feature: feature}) === false) {
	                    continue;
	                }
	                this.preFeatureInsert(feature);
	            }

	            featuresAdded.push(feature);
	            this.features.push(feature);
	            this.drawFeature(feature);
	            
	            if (notify) {
	                this.events.triggerEvent("featureadded", {
	                    feature: feature
	                });
	                this.onFeatureInsert(feature);
	            }
	        }
	        
	        if(notify) {
	            this.events.triggerEvent("featuresadded", {features: featuresAdded});
	        }
	    },


	    /**
	     * APIMethod: removeFeatures
	     * Remove features from the layer.  This erases any drawn features and
	     *     removes them from the layer's control.  The beforefeatureremoved
	     *     and featureremoved events will be triggered for each feature.  The
	     *     featuresremoved event will be triggered after all features have
	     *     been removed.  To suppress event triggering, use the silent option.
	     * 
	     * Parameters:
	     * features - {Array(<OpenLayers.Feature.Vector>)} List of features to be
	     *     removed.
	     * options - {Object} Optional properties for changing behavior of the
	     *     removal.
	     *
	     * Valid options:
	     * silent - {Boolean} Suppress event triggering.  Default is false.
	     */
	    removeFeatures: function(features, options) {
	        if(!features || features.length === 0) {
	            return;
	        }
	        if (features === this.features) {
	            return this.removeAllFeatures(options);
	        }
	        if (!(OpenLayers.Util.isArray(features))) {
	            features = [features];
	        }
	        if (features === this.selectedFeatures) {
	            features = features.slice();
	        }

	        var notify = !options || !options.silent;
	        
	        if (notify) {
	            this.events.triggerEvent(
	                "beforefeaturesremoved", {features: features}
	            );
	        }

	        for (var i = features.length - 1; i >= 0; i--) {
	            // We remain locked so long as we're not at 0
	            // and the 'next' feature has a geometry. We do the geometry check
	            // because if all the features after the current one are 'null', we
	            // won't call eraseGeometry, so we break the 'renderer functions
	            // will always be called with locked=false *last*' rule. The end result
	            // is a possible gratiutious unlocking to save a loop through the rest 
	            // of the list checking the remaining features every time. So long as
	            // null geoms are rare, this is probably okay.    
	            if (i != 0 && features[i-1].geometry) {
	                this.renderer.locked = true;
	            } else {
	                this.renderer.locked = false;
	            }
	    
	            var feature = features[i];
	            delete this.unrenderedFeatures[feature.id];

	            if (notify) {
	                this.events.triggerEvent("beforefeatureremoved", {
	                    feature: feature
	                });
	            }

	            this.features = OpenLayers.Util.removeItem(this.features, feature);
	            // feature has no layer at this point
	            feature.layer = null;

	            if (feature.geometry) {
	                this.renderer.eraseFeatures(feature);
	            }
	                    
	            //in the case that this feature is one of the selected features, 
	            // remove it from that array as well.
	            if (OpenLayers.Util.indexOf(this.selectedFeatures, feature) != -1){
	                OpenLayers.Util.removeItem(this.selectedFeatures, feature);
	            }

	            if (notify) {
	                this.events.triggerEvent("featureremoved", {
	                    feature: feature
	                });
	            }
	        }

	        if (notify) {
	            this.events.triggerEvent("featuresremoved", {features: features});
	        }
	    },
	    
	    /** 
	     * APIMethod: removeAllFeatures
	     * Remove all features from the layer.
	     *
	     * Parameters:
	     * options - {Object} Optional properties for changing behavior of the
	     *     removal.
	     *
	     * Valid options:
	     * silent - {Boolean} Suppress event triggering.  Default is false.
	     */
	    removeAllFeatures: function(options) {
	        var notify = !options || !options.silent;
	        var features = this.features;
	        if (notify) {
	            this.events.triggerEvent(
	                "beforefeaturesremoved", {features: features}
	            );
	        }
	        var feature;
	        for (var i = features.length-1; i >= 0; i--) {
	            feature = features[i];
	            if (notify) {
	                this.events.triggerEvent("beforefeatureremoved", {
	                    feature: feature
	                });
	            }
	            feature.layer = null;
	            if (notify) {
	                this.events.triggerEvent("featureremoved", {
	                    feature: feature
	                });
	            }
	        }
	        this.renderer.clear();
	        this.features = [];
	        this.unrenderedFeatures = {};
	        this.selectedFeatures = [];
	        if (notify) {
	            this.events.triggerEvent("featuresremoved", {features: features});
	        }
	    },

	    /**
	     * APIMethod: destroyFeatures
	     * Erase and destroy features on the layer.
	     *
	     * Parameters:
	     * features - {Array(<OpenLayers.Feature.Vector>)} An optional array of
	     *     features to destroy.  If not supplied, all features on the layer
	     *     will be destroyed.
	     * options - {Object}
	     */
	    destroyFeatures: function(features, options) {
	        var all = (features == undefined); // evaluates to true if
	                                           // features is null
	        if(all) {
	            features = this.features;
	        }
	        if(features) {
	            this.removeFeatures(features, options);
	            for(var i=features.length-1; i>=0; i--) {
	                features[i].destroy();
	            }
	        }
	    },

	    /**
	     * APIMethod: drawFeature
	     * Draw (or redraw) a feature on the layer.  If the optional style argument
	     * is included, this style will be used.  If no style is included, the
	     * feature's style will be used.  If the feature doesn't have a style,
	     * the layer's style will be used.
	     * 
	     * This function is not designed to be used when adding features to 
	     * the layer (use addFeatures instead). It is meant to be used when
	     * the style of a feature has changed, or in some other way needs to 
	     * visually updated *after* it has already been added to a layer. You
	     * must add the feature to the layer for most layer-related events to 
	     * happen.
	     *
	     * Parameters: 
	     * feature - {<OpenLayers.Feature.Vector>} 
	     * style - {String | Object} Named render intent or full symbolizer object.
	     */
	    drawFeature: function(feature, style) {
	        // don't try to draw the feature with the renderer if the layer is not 
	        // drawn itself
	        if (!this.drawn) {
	            return;
	        }
	        if (typeof style != "object") {
	            if(!style && feature.state === OpenLayers.State.DELETE) {
	                style = "delete";
	            }
	            var renderIntent = style || feature.renderIntent;
	            style = feature.style || this.style;
	            if (!style) {
	                style = this.styleMap.createSymbolizer(feature, renderIntent);
	            }
	        }
	        
	        var drawn = this.renderer.drawFeature(feature, style);
	        //TODO remove the check for null when we get rid of Renderer.SVG
	        if (drawn === false || drawn === null) {
	            this.unrenderedFeatures[feature.id] = feature;
	        } else {
	            delete this.unrenderedFeatures[feature.id];
	        }
	    },
	    
	    /**
	     * Method: eraseFeatures
	     * Erase features from the layer.
	     *
	     * Parameters:
	     * features - {Array(<OpenLayers.Feature.Vector>)} 
	     */
	    eraseFeatures: function(features) {
	        this.renderer.eraseFeatures(features);
	    },

	    /**
	     * Method: getFeatureFromEvent
	     * Given an event, return a feature if the event occurred over one.
	     * Otherwise, return null.
	     *
	     * Parameters:
	     * evt - {Event} 
	     *
	     * Returns:
	     * {<OpenLayers.Feature.Vector>} A feature if one was under the event.
	     */
	    getFeatureFromEvent: function(evt) {
	        if (!this.renderer) {
	            throw new Error('getFeatureFromEvent called on layer with no ' +
	                            'renderer. This usually means you destroyed a ' +
	                            'layer, but not some handler which is associated ' +
	                            'with it.');
	        }
	        var feature = null;
	        var featureId = this.renderer.getFeatureIdFromEvent(evt);
	        if (featureId) {
	            if (typeof featureId === "string") {
	                feature = this.getFeatureById(featureId);
	            } else {
	                feature = featureId;
	            }
	        }
	        return feature;
	    },

	    /**
	     * APIMethod: getFeatureBy
	     * Given a property value, return the feature if it exists in the features array
	     *
	     * Parameters:
	     * property - {String}
	     * value - {String}
	     *
	     * Returns:
	     * {<OpenLayers.Feature.Vector>} A feature corresponding to the given
	     * property value or null if there is no such feature.
	     */
	    getFeatureBy: function(property, value) {
	        //TBD - would it be more efficient to use a hash for this.features?
	        var feature = null;
	        for(var i=0, len=this.features.length; i<len; ++i) {
	            if(this.features[i][property] == value) {
	                feature = this.features[i];
	                break;
	            }
	        }
	        return feature;
	    },

	    /**
	     * APIMethod: getFeatureById
	     * Given a feature id, return the feature if it exists in the features array
	     *
	     * Parameters:
	     * featureId - {String}
	     *
	     * Returns:
	     * {<OpenLayers.Feature.Vector>} A feature corresponding to the given
	     * featureId or null if there is no such feature.
	     */
	    getFeatureById: function(featureId) {
	        return this.getFeatureBy('id', featureId);
	    },

	    /**
	     * APIMethod: getFeatureByFid
	     * Given a feature fid, return the feature if it exists in the features array
	     *
	     * Parameters:
	     * featureFid - {String}
	     *
	     * Returns:
	     * {<OpenLayers.Feature.Vector>} A feature corresponding to the given
	     * featureFid or null if there is no such feature.
	     */
	    getFeatureByFid: function(featureFid) {
	        return this.getFeatureBy('fid', featureFid);
	    },
	    
	    /**
	     * APIMethod: getFeaturesByAttribute
	     * Returns an array of features that have the given attribute key set to the
	     * given value. Comparison of attribute values takes care of datatypes, e.g.
	     * the string '1234' is not equal to the number 1234.
	     *
	     * Parameters:
	     * attrName - {String}
	     * attrValue - {Mixed}
	     *
	     * Returns:
	     * Array({<OpenLayers.Feature.Vector>}) An array of features that have the 
	     * passed named attribute set to the given value.
	     */
	    getFeaturesByAttribute: function(attrName, attrValue) {
	        var i,
	            feature,    
	            len = this.features.length,
	            foundFeatures = [];
	        for(i = 0; i < len; i++) {            
	            feature = this.features[i];
	            if(feature && feature.attributes) {
	                if (feature.attributes[attrName] === attrValue) {
	                    foundFeatures.push(feature);
	                }
	            }
	        }
	        return foundFeatures;
	    },

	    /**
	     * Unselect the selected features
	     * i.e. clears the featureSelection array
	     * change the style back
	    clearSelection: function() {

	       var vectorLayer = this.map.vectorLayer;
	        for (var i = 0; i < this.map.featureSelection.length; i++) {
	            var featureSelection = this.map.featureSelection[i];
	            vectorLayer.drawFeature(featureSelection, vectorLayer.style);
	        }
	        this.map.featureSelection = [];
	    },
	     */


	    /**
	     * APIMethod: onFeatureInsert
	     * method called after a feature is inserted.
	     * Does nothing by default. Override this if you
	     * need to do something on feature updates.
	     *
	     * Parameters: 
	     * feature - {<OpenLayers.Feature.Vector>} 
	     */
	    onFeatureInsert: function(feature) {
	    },
	    
	    /**
	     * APIMethod: preFeatureInsert
	     * method called before a feature is inserted.
	     * Does nothing by default. Override this if you
	     * need to do something when features are first added to the
	     * layer, but before they are drawn, such as adjust the style.
	     *
	     * Parameters:
	     * feature - {<OpenLayers.Feature.Vector>} 
	     */
	    preFeatureInsert: function(feature) {
	    },

	    /** 
	     * APIMethod: getDataExtent
	     * Calculates the max extent which includes all of the features.
	     * 
	     * Returns:
	     * {<OpenLayers.Bounds>} or null if the layer has no features with
	     * geometries.
	     */
	    getDataExtent: function () {
	        var maxExtent = null;
	        var features = this.features;
	        if(features && (features.length > 0)) {
	            var geometry = null;
	            for(var i=0, len=features.length; i<len; i++) {
	                geometry = features[i].geometry;
	                if (geometry) {
	                    if (maxExtent === null) {
	                        maxExtent = new OpenLayers.Bounds();
	                    }
	                    maxExtent.extend(geometry.getBounds());
	                }
	            }
	        }
	        return maxExtent;
	    },

	    CLASS_NAME: "OpenLayers.Layer.Vector"
	});
	/* ======================================================================
	    OpenLayers/Layer/Markers.js
	   ====================================================================== */

	/* Copyright (c) 2006-2015 by OpenLayers Contributors (see authors.txt for
	 * full list of contributors). Published under the 2-clause BSD license.
	 * See license.txt in the OpenLayers distribution or repository for the
	 * full text of the license. */


	/**
	 * @requires OpenLayers/Layer.js
	 */

	/**
	 * Class: OpenLayers.Layer.Markers
	 * 
	 * Inherits from:
	 *  - <OpenLayers.Layer> 
	 */
	OpenLayers.Layer.Markers = OpenLayers.Class(OpenLayers.Layer, {
	    
	    /** 
	     * APIProperty: isBaseLayer 
	     * {Boolean} Markers layer is never a base layer.  
	     */
	    isBaseLayer: false,
	    
	    /** 
	     * APIProperty: markers 
	     * {Array(<OpenLayers.Marker>)} internal marker list 
	     */
	    markers: null,


	    /** 
	     * Property: drawn 
	     * {Boolean} internal state of drawing. This is a workaround for the fact
	     * that the map does not call moveTo with a zoomChanged when the map is
	     * first starting up. This lets us catch the case where we have *never*
	     * drawn the layer, and draw it even if the zoom hasn't changed.
	     */
	    drawn: false,
	    
	    /**
	     * Constructor: OpenLayers.Layer.Markers 
	     * Create a Markers layer.
	     *
	     * Parameters:
	     * name - {String} 
	     * options - {Object} Hashtable of extra options to tag onto the layer
	     */
	    initialize: function(name, options) {
	        OpenLayers.Layer.prototype.initialize.apply(this, arguments);
	        this.markers = [];
	    },
	    
	    /**
	     * APIMethod: destroy 
	     */
	    destroy: function() {
	        this.clearMarkers();
	        this.markers = null;
	        OpenLayers.Layer.prototype.destroy.apply(this, arguments);
	    },

	    /**
	     * APIMethod: setOpacity
	     * Sets the opacity for all the markers.
	     * 
	     * Parameters:
	     * opacity - {Float}
	     */
	    setOpacity: function(opacity) {
	        if (opacity != this.opacity) {
	            this.opacity = opacity;
	            for (var i=0, len=this.markers.length; i<len; i++) {
	                this.markers[i].setOpacity(this.opacity);
	            }
	        }
	    },

	    /** 
	     * Method: moveTo
	     *
	     * Parameters:
	     * bounds - {<OpenLayers.Bounds>} 
	     * zoomChanged - {Boolean} 
	     * dragging - {Boolean} 
	     */
	    moveTo:function(bounds, zoomChanged, dragging) {
	        OpenLayers.Layer.prototype.moveTo.apply(this, arguments);

	        if (zoomChanged || !this.drawn) {
	            for(var i=0, len=this.markers.length; i<len; i++) {
	                this.drawMarker(this.markers[i]);
	            }
	            this.drawn = true;
	        }
	    },

	    /**
	     * APIMethod: addMarker
	     *
	     * Parameters:
	     * marker - {<OpenLayers.Marker>} 
	     */
	    addMarker: function(marker) {
	        this.markers.push(marker);

	        if (this.opacity < 1) {
	            marker.setOpacity(this.opacity);
	        }

	        if (this.map && this.map.getExtent()) {
	            marker.map = this.map;
	            this.drawMarker(marker);
	        }
	    },

	    /**
	     * APIMethod: removeMarker
	     *
	     * Parameters:
	     * marker - {<OpenLayers.Marker>} 
	     */
	    removeMarker: function(marker) {
	        if (this.markers && this.markers.length) {
	            OpenLayers.Util.removeItem(this.markers, marker);
	            marker.erase();
	        }
	    },

	    /**
	     * Method: clearMarkers
	     * This method removes all markers from a layer. The markers are not
	     * destroyed by this function, but are removed from the list of markers.
	     */
	    clearMarkers: function() {
	        if (this.markers != null) {
	            while(this.markers.length > 0) {
	                this.removeMarker(this.markers[0]);
	            }
	        }
	    },

	    /** 
	     * Method: drawMarker
	     * Calculate the pixel location for the marker, create it, and 
	     *    add it to the layer's div
	     *
	     * Parameters:
	     * marker - {<OpenLayers.Marker>} 
	     */
	    drawMarker: function(marker) {
	        var px = this.map.getLayerPxFromLonLat(marker.lonlat);
	        if (px == null) {
	            marker.display(false);
	        } else {
	            if (!marker.isDrawn()) {
	                var markerImg = marker.draw(px);
	                this.div.appendChild(markerImg);
	            } else if(marker.icon) {
	                marker.icon.moveTo(px);
	            }
	        }
	    },
	    
	    /** 
	     * APIMethod: getDataExtent
	     * Calculates the max extent which includes all of the markers.
	     * 
	     * Returns:
	     * {<OpenLayers.Bounds>}
	     */
	    getDataExtent: function () {
	        var maxExtent = null;
	        
	        if ( this.markers && (this.markers.length > 0)) {
	            var maxExtent = new OpenLayers.Bounds();
	            for(var i=0, len=this.markers.length; i<len; i++) {
	                var marker = this.markers[i];
	                maxExtent.extend(marker.lonlat);
	            }
	        }

	        return maxExtent;
	    },

	    CLASS_NAME: "OpenLayers.Layer.Markers"
	});
	/* ======================================================================
	    OpenLayers/Layer/Zoomify.js
	   ====================================================================== */

	/* Copyright (c) 2006-2015 by OpenLayers Contributors (see authors.txt for
	 * full list of contributors). Published under the 2-clause BSD license.
	 * See license.txt in the OpenLayers distribution or repository for the
	 * full text of the license. */

	/*
	 * Development supported by a R&D grant DC08P02OUK006 - Old Maps Online
	 * (www.oldmapsonline.org) from Ministry of Culture of the Czech Republic.
	 */


	/**
	 * @requires OpenLayers/Layer/Grid.js
	 */

	/**
	 * Class: OpenLayers.Layer.Zoomify
	 *
	 * Inherits from:
	 *  - <OpenLayers.Layer.Grid>
	 */
	OpenLayers.Layer.Zoomify = OpenLayers.Class(OpenLayers.Layer.Grid, {

	    /**
	     * Property: size
	     * {<OpenLayers.Size>} The Zoomify image size in pixels.
	     */
	    size: null,

	    /**
	     * APIProperty: isBaseLayer
	     * {Boolean}
	     */
	    isBaseLayer: true,

	    /**
	     * Property: standardTileSize
	     * {Integer} The size of a standard (non-border) square tile in pixels.
	     */
	    standardTileSize: 256,

	    /** 
	     * Property: tileOriginCorner
	     * {String} This layer uses top-left as tile origin
	     **/
	    tileOriginCorner: "tl",

	    /**
	     * Property: numberOfTiers
	     * {Integer} Depth of the Zoomify pyramid, number of tiers (zoom levels)
	     *                          - filled during Zoomify pyramid initialization.
	     */
	    numberOfTiers: 0,

	    /**
	     * Property: tileCountUpToTier
	     * {Array(Integer)} Number of tiles up to the given tier of pyramid.
	     *                          - filled during Zoomify pyramid initialization.
	     */
	    tileCountUpToTier: null,

	    /**
	     * Property: tierSizeInTiles
	     * {Array(<OpenLayers.Size>)} Size (in tiles) for each tier of pyramid.
	     *                          - filled during Zoomify pyramid initialization.
	     */
	    tierSizeInTiles: null,

	    /**
	     * Property: tierImageSize
	     * {Array(<OpenLayers.Size>)} Image size in pixels for each pyramid tier.
	     *                          - filled during Zoomify pyramid initialization.
	     */
	    tierImageSize: null,

	    /**
	     * Constructor: OpenLayers.Layer.Zoomify
	     *
	     * Parameters:
	     * name - {String} A name for the layer.
	     * url - {String} - Relative or absolute path to the image or more
	     *        precisely to the TileGroup[X] directories root.
	     *        Flash plugin use the variable name "zoomifyImagePath" for this.
	     * size - {<OpenLayers.Size>} The size (in pixels) of the image.
	     * options - {Object} Hashtable of extra options to tag onto the layer
	     */
	    initialize: function(name, url, size, options) {

	        // initialize the Zoomify pyramid for given size
	        this.initializeZoomify(size);

	        OpenLayers.Layer.Grid.prototype.initialize.apply(this, [
	            name, url, {}, options
	        ]);
	    },

	    /**
	     * Method: initializeZoomify
	     * It generates constants for all tiers of the Zoomify pyramid
	     *
	     * Parameters:
	     * size - {<OpenLayers.Size>} The size of the image in pixels
	     *
	     */
	    initializeZoomify: function( size ) {

	        var imageSize = size.clone();
	        this.size = size.clone();
	        var tiles = new OpenLayers.Size(
	            Math.ceil( imageSize.w / this.standardTileSize ),
	            Math.ceil( imageSize.h / this.standardTileSize )
	            );

	        this.tierSizeInTiles = [tiles];
	        this.tierImageSize = [imageSize];

	        while (imageSize.w > this.standardTileSize ||
	               imageSize.h > this.standardTileSize ) {

	            imageSize = new OpenLayers.Size(
	                Math.floor( imageSize.w / 2 ),
	                Math.floor( imageSize.h / 2 )
	                );
	            tiles = new OpenLayers.Size(
	                Math.ceil( imageSize.w / this.standardTileSize ),
	                Math.ceil( imageSize.h / this.standardTileSize )
	                );
	            this.tierSizeInTiles.push( tiles );
	            this.tierImageSize.push( imageSize );
	        }

	        this.tierSizeInTiles.reverse();
	        this.tierImageSize.reverse();

	        this.numberOfTiers = this.tierSizeInTiles.length;
	        var resolutions = [1];
	        this.tileCountUpToTier = [0];
	        for (var i = 1; i < this.numberOfTiers; i++) {
	            resolutions.unshift(Math.pow(2, i));
	            this.tileCountUpToTier.push(
	                this.tierSizeInTiles[i-1].w * this.tierSizeInTiles[i-1].h +
	                this.tileCountUpToTier[i-1]
	                );
	        }
	        if (!this.serverResolutions) {
	            this.serverResolutions = resolutions;
	        }
	    },

	    /**
	     * APIMethod:destroy
	     */
	    destroy: function() {
	        // for now, nothing special to do here.
	        OpenLayers.Layer.Grid.prototype.destroy.apply(this, arguments);

	        // Remove from memory the Zoomify pyramid - is that enough?
	        this.tileCountUpToTier.length = 0;
	        this.tierSizeInTiles.length = 0;
	        this.tierImageSize.length = 0;

	    },

	    /**
	     * APIMethod: clone
	     *
	     * Parameters:
	     * obj - {Object}
	     *
	     * Returns:
	     * {<OpenLayers.Layer.Zoomify>} An exact clone of this <OpenLayers.Layer.Zoomify>
	     */
	    clone: function (obj) {

	        if (obj == null) {
	            obj = new OpenLayers.Layer.Zoomify(this.name,
	                                           this.url,
	                                           this.size,
	                                           this.options);
	        }

	        //get all additions from superclasses
	        obj = OpenLayers.Layer.Grid.prototype.clone.apply(this, [obj]);

	        // copy/set any non-init, non-simple values here

	        return obj;
	    },

	    /**
	     * Method: createBackBuffer
	     * Create a back buffer.
	     *
	     * Returns:
	     * {DOMElement} The DOM element for the back buffer, undefined if the
	     * grid isn't initialized yet.
	     */
	    createBackBuffer: function() {
	        var backBuffer = OpenLayers.Layer.Grid.prototype.createBackBuffer.apply(this, arguments);
	        if(backBuffer) {
	            var image;
	            for (var i=backBuffer.childNodes.length-1; i>=0; --i) {
	                image = backBuffer.childNodes[i];
	                image._w = image.width;
	                image._h = image.height;
	            }
	        }
	        return backBuffer;
	    },

	    /**
	     * Method: getURL
	     *
	     * Parameters:
	     * bounds - {<OpenLayers.Bounds>}
	     *
	     * Returns:
	     * {String} A string with the layer's url and parameters and also the
	     *          passed-in bounds and appropriate tile size specified as
	     *          parameters
	     */
	    getURL: function (bounds) {
	        bounds = this.adjustBounds(bounds);
	        var res = this.getServerResolution();
	        var x = Math.round((bounds.left - this.tileOrigin.lon) / (res * this.tileSize.w));
	        var y = Math.round((this.tileOrigin.lat - bounds.top) / (res * this.tileSize.h));
	        var z = this.getZoomForResolution( res );

	        var tileIndex = x + y * this.tierSizeInTiles[z].w + this.tileCountUpToTier[z];
	        var path = "TileGroup" + Math.floor( (tileIndex) / 256 ) +
	            "/" + z + "-" + x + "-" + y + ".jpg";
	        var url = this.url;
	        if (OpenLayers.Util.isArray(url)) {
	            url = this.selectUrl(path, url);
	        }
	        return url + path;
	    },

	    /**
	     * Method: getImageSize
	     * getImageSize returns size for a particular tile. If bounds are given as
	     * first argument, size is calculated (bottom-right tiles are non square).
	     *
	     */
	    getImageSize: function() {
	        if (arguments.length > 0) {
	            var bounds = this.adjustBounds(arguments[0]);
	            var res = this.getServerResolution();
	            var x = Math.round((bounds.left - this.tileOrigin.lon) / (res * this.tileSize.w));
	            var y = Math.round((this.tileOrigin.lat - bounds.top) / (res * this.tileSize.h));
	            var z = this.getZoomForResolution( res );
	            var w = this.standardTileSize;
	            var h = this.standardTileSize;
	            if (x == this.tierSizeInTiles[z].w -1 ) {
	                var w = this.tierImageSize[z].w % this.standardTileSize;
	                if (w == 0) {
	                    w = this.standardTileSize;
	                }
	            }
	            if (y == this.tierSizeInTiles[z].h -1 ) {
	                var h = this.tierImageSize[z].h % this.standardTileSize;
	                if (h == 0) {
	                    h = this.standardTileSize;
	                }
	            }
	            // in jp2 format, dimensions of tiles are ceiled, that means there may be requested part of image (1px usually) above dimension stated in tierImageSize. 
	            if (x == this.tierSizeInTiles[z].w) {
	                w = Math.ceil(this.size.w / Math.pow(2, this.numberOfTiers - 1 - z) - this.tierImageSize[z].w);
	            }
	            if (y == this.tierSizeInTiles[z].h) {
	                h = Math.ceil(this.size.h / Math.pow(2, this.numberOfTiers - 1 - z) - this.tierImageSize[z].h);
	            }
	            return (new OpenLayers.Size(w, h));
	        } else {
	            return this.tileSize;
	        }
	    },

	    /**
	     * APIMethod: setMap
	     * When the layer is added to a map, then we can fetch our origin
	     *    (if we don't have one.)
	     *
	     * Parameters:
	     * map - {<OpenLayers.Map>}
	     */
	    setMap: function(map) {
	        OpenLayers.Layer.Grid.prototype.setMap.apply(this, arguments);
	        this.tileOrigin = new OpenLayers.LonLat(this.map.maxExtent.left,
	                                                this.map.maxExtent.top);
	    },

	    CLASS_NAME: "OpenLayers.Layer.Zoomify"
	});
	/* ======================================================================
	    OpenLayers/Layer/TMS.js
	   ====================================================================== */

	/* Copyright (c) 2006-2015 by OpenLayers Contributors (see authors.txt for
	 * full list of contributors). Published under the 2-clause BSD license.
	 * See license.txt in the OpenLayers distribution or repository for the
	 * full text of the license. */


	/**
	 * @requires OpenLayers/Layer/Grid.js
	 */

	/**
	 * Class: OpenLayers.Layer.TMS
	 * Create a layer for accessing tiles from services that conform with the 
	 *     Tile Map Service Specification 
	 *     (http://wiki.osgeo.org/wiki/Tile_Map_Service_Specification).
	 *
	 * Example:
	 * (code)
	 *     var layer = new OpenLayers.Layer.TMS(
	 *         "My Layer", // name for display in LayerSwitcher
	 *         "http://tilecache.osgeo.org/wms-c/Basic.py/", // service endpoint
	 *         {layername: "basic", type: "png"} // required properties
	 *     );
	 * (end)
	 * 
	 * Inherits from:
	 *  - <OpenLayers.Layer.Grid>
	 */
	OpenLayers.Layer.TMS = OpenLayers.Class(OpenLayers.Layer.Grid, {

	    /**
	     * APIProperty: serviceVersion
	     * {String} Service version for tile requests.  Default is "1.0.0".
	     */
	    serviceVersion: "1.0.0",

	    /**
	     * APIProperty: layername
	     * {String} The identifier for the <TileMap> as advertised by the service.  
	     *     For example, if the service advertises a <TileMap> with 
	     *    'href="http://tms.osgeo.org/1.0.0/vmap0"', the <layername> property 
	     *     would be set to "vmap0".
	     */
	    layername: null,

	    /**
	     * APIProperty: type
	     * {String} The format extension corresponding to the requested tile image
	     *     type.  This is advertised in a <TileFormat> element as the 
	     *     "extension" attribute.  For example, if the service advertises a 
	     *     <TileMap> with <TileFormat width="256" height="256" mime-type="image/jpeg" extension="jpg" />,
	     *     the <type> property would be set to "jpg".
	     */
	    type: null,

	    /**
	     * APIProperty: isBaseLayer
	     * {Boolean} Make this layer a base layer.  Default is true.  Set false to
	     *     use the layer as an overlay.
	     */
	    isBaseLayer: true,

	    /**
	     * APIProperty: tileOrigin
	     * {<OpenLayers.LonLat>} Optional origin for aligning the grid of tiles.
	     *     If provided, requests for tiles at all resolutions will be aligned
	     *     with this location (no tiles shall overlap this location).  If
	     *     not provided, the grid of tiles will be aligned with the bottom-left
	     *     corner of the map's <maxExtent>.  Default is ``null``.
	     *
	     * Example:
	     * (code)
	     *     var layer = new OpenLayers.Layer.TMS(
	     *         "My Layer",
	     *         "http://tilecache.osgeo.org/wms-c/Basic.py/",
	     *         {
	     *             layername: "basic", 
	     *             type: "png",
	     *             // set if different than the bottom left of map.maxExtent
	     *             tileOrigin: new OpenLayers.LonLat(-180, -90)
	     *         }
	     *     );
	     * (end)
	     */
	    tileOrigin: null,

	    /**
	     * APIProperty: serverResolutions
	     * {Array} A list of all resolutions available on the server.  Only set this
	     *     property if the map resolutions differ from the server. This
	     *     property serves two purposes. (a) <serverResolutions> can include
	     *     resolutions that the server supports and that you don't want to
	     *     provide with this layer; you can also look at <zoomOffset>, which is
	     *     an alternative to <serverResolutions> for that specific purpose.
	     *     (b) The map can work with resolutions that aren't supported by
	     *     the server, i.e. that aren't in <serverResolutions>. When the
	     *     map is displayed in such a resolution data for the closest
	     *     server-supported resolution is loaded and the layer div is
	     *     stretched as necessary.
	     */
	    serverResolutions: null,

	    /**
	     * APIProperty: zoomOffset
	     * {Number} If your cache has more zoom levels than you want to provide
	     *     access to with this layer, supply a zoomOffset.  This zoom offset
	     *     is added to the current map zoom level to determine the level
	     *     for a requested tile.  For example, if you supply a zoomOffset
	     *     of 3, when the map is at the zoom 0, tiles will be requested from
	     *     level 3 of your cache.  Default is 0 (assumes cache level and map
	     *     zoom are equivalent).  Using <zoomOffset> is an alternative to
	     *     setting <serverResolutions> if you only want to expose a subset
	     *     of the server resolutions.
	     */
	    zoomOffset: 0,
	    
	    /**
	     * Constructor: OpenLayers.Layer.TMS
	     * 
	     * Parameters:
	     * name - {String} Title to be displayed in a <OpenLayers.Control.LayerSwitcher>
	     * url - {String} Service endpoint (without the version number).  E.g.
	     *     "http://tms.osgeo.org/".
	     * options - {Object} Additional properties to be set on the layer.  The
	     *     <layername> and <type> properties must be set here.
	     */
	    initialize: function(name, url, options) {
	        var newArguments = [];
	        newArguments.push(name, url, {}, options);
	        OpenLayers.Layer.Grid.prototype.initialize.apply(this, newArguments);
	    },    

	    /**
	     * APIMethod: clone
	     * Create a complete copy of this layer.
	     *
	     * Parameters:
	     * obj - {Object} Should only be provided by subclasses that call this
	     *     method.
	     * 
	     * Returns:
	     * {<OpenLayers.Layer.TMS>} An exact clone of this <OpenLayers.Layer.TMS>
	     */
	    clone: function (obj) {
	        
	        if (obj == null) {
	            obj = new OpenLayers.Layer.TMS(this.name,
	                                           this.url,
	                                           this.getOptions());
	        }

	        //get all additions from superclasses
	        obj = OpenLayers.Layer.Grid.prototype.clone.apply(this, [obj]);

	        // copy/set any non-init, non-simple values here

	        return obj;
	    },    
	    
	    /**
	     * Method: getURL
	     * 
	     * Parameters:
	     * bounds - {<OpenLayers.Bounds>}
	     * 
	     * Returns:
	     * {String} A string with the layer's url and parameters and also the 
	     *          passed-in bounds and appropriate tile size specified as 
	     *          parameters
	     */
	    getURL: function (bounds) {
	        bounds = this.adjustBounds(bounds);
	        var res = this.getServerResolution();
	        var x = Math.round((bounds.left - this.tileOrigin.lon) / (res * this.tileSize.w));
	        var y = Math.round((bounds.bottom - this.tileOrigin.lat) / (res * this.tileSize.h));
	        var z = this.getServerZoom();
	        var path = this.serviceVersion + "/" + this.layername + "/" + z + "/" + x + "/" + y + "." + this.type; 
	        var url = this.url;
	        if (OpenLayers.Util.isArray(url)) {
	            url = this.selectUrl(path, url);
	        }
	        return url + path;
	    },

	    /** 
	     * Method: setMap
	     * When the layer is added to a map, then we can fetch our origin 
	     *    (if we don't have one.) 
	     * 
	     * Parameters:
	     * map - {<OpenLayers.Map>}
	     */
	    setMap: function(map) {
	        OpenLayers.Layer.Grid.prototype.setMap.apply(this, arguments);
	        if (!this.tileOrigin) { 
	            this.tileOrigin = new OpenLayers.LonLat(this.map.maxExtent.left,
	                                                this.map.maxExtent.bottom);
	        }                                       
	    },

	    CLASS_NAME: "OpenLayers.Layer.TMS"
	});
	/* ======================================================================
	    OpenLayers/BaseTypes/Date.js
	   ====================================================================== */

	/* Copyright (c) 2006-2015 by OpenLayers Contributors (see authors.txt for
	 * full list of contributors). Published under the 2-clause BSD license.
	 * See license.txt in the OpenLayers distribution or repository for the
	 * full text of the license. */

	/**
	 * @requires OpenLayers/SingleFile.js
	 */

	/**
	 * Namespace: OpenLayers.Date
	 * Contains implementations of Date.parse and date.toISOString that match the
	 *     ECMAScript 5 specification for parsing RFC 3339 dates.
	 *     http://tools.ietf.org/html/rfc3339
	 */
	OpenLayers.Date = {

	    /** 
	     * APIProperty: dateRegEx
	     * The regex to be used for validating dates. You can provide your own
	     * regex for instance for adding support for years before BC. Default
	     * value is: /^(?:(\d{4})(?:-(\d{2})(?:-(\d{2}))?)?)?(?:(?:T(\d{1,2}):(\d{2}):(\d{2}(?:\.\d+)?)(Z|(?:[+-]\d{1,2}(?::(\d{2}))?)))|Z)?$/
	     */
	    dateRegEx: /^(?:(\d{4})(?:-(\d{2})(?:-(\d{2}))?)?)?(?:(?:T(\d{1,2}):(\d{2}):(\d{2}(?:\.\d+)?)(Z|(?:[+-]\d{1,2}(?::(\d{2}))?)))|Z)?$/,

	    /**
	     * APIMethod: toISOString
	     * Generates a string representing a date.  The format of the string follows
	     *     the profile of ISO 8601 for date and time on the Internet (see
	     *     http://tools.ietf.org/html/rfc3339).  If the toISOString method is
	     *     available on the Date prototype, that is used.  The toISOString
	     *     method for Date instances is defined in ECMA-262.
	     *
	     * Parameters:
	     * date - {Date} A date object.
	     *
	     * Returns:
	     * {String} A string representing the date (e.g.
	     *     "2010-08-07T16:58:23.123Z").  If the date does not have a valid time
	     *     (i.e. isNaN(date.getTime())) this method returns the string "Invalid
	     *     Date".  The ECMA standard says the toISOString method should throw
	     *     RangeError in this case, but Firefox returns a string instead.  For
	     *     best results, use isNaN(date.getTime()) to determine date validity
	     *     before generating date strings.
	     */
	    toISOString: (function() {
	        if ("toISOString" in Date.prototype) {
	            return function(date) {
	                return date.toISOString();
	            };
	        } else {
	            return function(date) {
	                var str;
	                if (isNaN(date.getTime())) {
	                    // ECMA-262 says throw RangeError, Firefox returns
	                    // "Invalid Date"
	                    str = "Invalid Date";
	                } else {
	                    str =
	                        date.getUTCFullYear() + "-" +
	                        OpenLayers.Number.zeroPad(date.getUTCMonth() + 1, 2) + "-" +
	                        OpenLayers.Number.zeroPad(date.getUTCDate(), 2) + "T" +
	                        OpenLayers.Number.zeroPad(date.getUTCHours(), 2) + ":" +
	                        OpenLayers.Number.zeroPad(date.getUTCMinutes(), 2) + ":" +
	                        OpenLayers.Number.zeroPad(date.getUTCSeconds(), 2) + "." +
	                        OpenLayers.Number.zeroPad(date.getUTCMilliseconds(), 3) + "Z";
	                }
	                return str;
	            };
	        }

	    })(),

	    /**
	     * APIMethod: parse
	     * Generate a date object from a string.  The format for the string follows
	     *     the profile of ISO 8601 for date and time on the Internet (see
	     *     http://tools.ietf.org/html/rfc3339).  We don't call the native
	     *     Date.parse because of inconsistency between implmentations.  In
	     *     Chrome, calling Date.parse with a string that doesn't contain any
	     *     indication of the timezone (e.g. "2011"), the date is interpreted
	     *     in local time.  On Firefox, the assumption is UTC.
	     *
	     * Parameters:
	     * str - {String} A string representing the date (e.g.
	     *     "2010", "2010-08", "2010-08-07", "2010-08-07T16:58:23.123Z",
	     *     "2010-08-07T11:58:23.123-06").
	     *
	     * Returns:
	     * {Date} A date object.  If the string could not be parsed, an invalid
	     *     date is returned (i.e. isNaN(date.getTime())).
	     */
	    parse: function(str) {
	        var date;
	        var match = str.match(this.dateRegEx);
	        if (match && (match[1] || match[7])) { // must have at least year or time
	            var year = parseInt(match[1], 10) || 0;
	            var month = (parseInt(match[2], 10) - 1) || 0;
	            var day = parseInt(match[3], 10) || 1;
	            date = new Date(Date.UTC(year, month, day));
	            // optional time
	            var type = match[7];
	            if (type) {
	                var hours = parseInt(match[4], 10);
	                var minutes = parseInt(match[5], 10);
	                var secFrac = parseFloat(match[6]);
	                var seconds = secFrac | 0;
	                var milliseconds = Math.round(1000 * (secFrac - seconds));
	                date.setUTCHours(hours, minutes, seconds, milliseconds);
	                // check offset
	                if (type !== "Z") {
	                    var hoursOffset = parseInt(type, 10);
	                    var minutesOffset = parseInt(match[8], 10) || 0;
	                    var offset = -1000 * (60 * (hoursOffset * 60) + minutesOffset * 60);
	                    date = new Date(date.getTime() + offset);
	                }
	            }
	        } else {
	            date = new Date("invalid");
	        }
	        return date;
	    }
	};
	/* ======================================================================
	    OpenLayers/Format.js
	   ====================================================================== */

	/* Copyright (c) 2006-2015 by OpenLayers Contributors (see authors.txt for
	 * full list of contributors). Published under the 2-clause BSD license.
	 * See license.txt in the OpenLayers distribution or repository for the
	 * full text of the license. */

	/**
	 * @requires OpenLayers/BaseTypes/Class.js
	 * @requires OpenLayers/Util.js
	 */

	/**
	 * Class: OpenLayers.Format
	 * Base class for format reading/writing a variety of formats.  Subclasses
	 *     of OpenLayers.Format are expected to have read and write methods.
	 */
	OpenLayers.Format = OpenLayers.Class({
	    
	    /**
	     * Property: options
	     * {Object} A reference to options passed to the constructor.
	     */
	    options: null,
	    
	    /**
	     * APIProperty: externalProjection
	     * {<OpenLayers.Projection>} When passed a externalProjection and
	     *     internalProjection, the format will reproject the geometries it
	     *     reads or writes. The externalProjection is the projection used by
	     *     the content which is passed into read or which comes out of write.
	     *     In order to reproject, a projection transformation function for the
	     *     specified projections must be available. This support may be 
	     *     provided via proj4js or via a custom transformation function. See
	     *     {<OpenLayers.Projection.addTransform>} for more information on
	     *     custom transformations.
	     */
	    externalProjection: null,

	    /**
	     * APIProperty: internalProjection
	     * {<OpenLayers.Projection>} When passed a externalProjection and
	     *     internalProjection, the format will reproject the geometries it
	     *     reads or writes. The internalProjection is the projection used by
	     *     the geometries which are returned by read or which are passed into
	     *     write.  In order to reproject, a projection transformation function
	     *     for the specified projections must be available. This support may be
	     *     provided via proj4js or via a custom transformation function. See
	     *     {<OpenLayers.Projection.addTransform>} for more information on
	     *     custom transformations.
	     */
	    internalProjection: null,

	    /**
	     * APIProperty: data
	     * {Object} When <keepData> is true, this is the parsed string sent to
	     *     <read>.
	     */
	    data: null,

	    /**
	     * APIProperty: keepData
	     * {Object} Maintain a reference (<data>) to the most recently read data.
	     *     Default is false.
	     */
	    keepData: false,

	    /**
	     * Constructor: OpenLayers.Format
	     * Instances of this class are not useful.  See one of the subclasses.
	     *
	     * Parameters:
	     * options - {Object} An optional object with properties to set on the
	     *           format
	     *
	     * Valid options:
	     * keepData - {Boolean} If true, upon <read>, the data property will be
	     *     set to the parsed object (e.g. the json or xml object).
	     *
	     * Returns:
	     * An instance of OpenLayers.Format
	     */
	    initialize: function(options) {
	        OpenLayers.Util.extend(this, options);
	        this.options = options;
	    },
	    
	    /**
	     * APIMethod: destroy
	     * Clean up.
	     */
	    destroy: function() {
	    },

	    /**
	     * Method: read
	     * Read data from a string, and return an object whose type depends on the
	     * subclass. 
	     * 
	     * Parameters:
	     * data - {string} Data to read/parse.
	     *
	     * Returns:
	     * Depends on the subclass
	     */
	    read: function(data) {
	        throw new Error('Read not implemented.');
	    },
	    
	    /**
	     * Method: write
	     * Accept an object, and return a string. 
	     *
	     * Parameters:
	     * object - {Object} Object to be serialized
	     *
	     * Returns:
	     * {String} A string representation of the object.
	     */
	    write: function(object) {
	        throw new Error('Write not implemented.');
	    },

	    CLASS_NAME: "OpenLayers.Format"
	});     
	/* ======================================================================
	    OpenLayers/Format/XML.js
	   ====================================================================== */

	/* Copyright (c) 2006-2015 by OpenLayers Contributors (see authors.txt for
	 * full list of contributors). Published under the 2-clause BSD license.
	 * See license.txt in the OpenLayers distribution or repository for the
	 * full text of the license. */

	/**
	 * @requires OpenLayers/Format.js
	 */

	/**
	 * Class: OpenLayers.Format.XML
	 * Read and write XML.  For cross-browser XML generation, use methods on an
	 *     instance of the XML format class instead of on <code>document<end>.
	 *     The DOM creation and traversing methods exposed here all mimic the
	 *     W3C XML DOM methods.  Create a new parser with the
	 *     <OpenLayers.Format.XML> constructor.
	 *
	 * Inherits from:
	 *  - <OpenLayers.Format>
	 */
	OpenLayers.Format.XML = OpenLayers.Class(OpenLayers.Format, {
	    
	    /**
	     * Property: namespaces
	     * {Object} Mapping of namespace aliases to namespace URIs.  Properties
	     *     of this object should not be set individually.  Read-only.  All
	     *     XML subclasses should have their own namespaces object.  Use
	     *     <setNamespace> to add or set a namespace alias after construction.
	     */
	    namespaces: null,
	    
	    /**
	     * Property: namespaceAlias
	     * {Object} Mapping of namespace URI to namespace alias.  This object
	     *     is read-only.  Use <setNamespace> to add or set a namespace alias.
	     */
	    namespaceAlias: null,
	    
	    /**
	     * Property: defaultPrefix
	     * {String} The default namespace alias for creating element nodes.
	     */
	    defaultPrefix: null,
	    
	    /**
	     * Property: readers
	     * Contains public functions, grouped by namespace prefix, that will
	     *     be applied when a namespaced node is found matching the function
	     *     name.  The function will be applied in the scope of this parser
	     *     with two arguments: the node being read and a context object passed
	     *     from the parent.
	     */
	    readers: {},
	    
	    /**
	     * Property: writers
	     * As a compliment to the <readers> property, this structure contains public
	     *     writing functions grouped by namespace alias and named like the
	     *     node names they produce.
	     */
	    writers: {},

	    /**
	     * Property: xmldom
	     * {XMLDom} If this browser uses ActiveX, this will be set to a XMLDOM
	     *     object.  It is not intended to be a browser sniffing property.
	     *     Instead, the xmldom property is used instead of <code>document<end>
	     *     where namespaced node creation methods are not supported. In all
	     *     other browsers, this remains null.
	     */
	    xmldom: null,

	    /**
	     * Constructor: OpenLayers.Format.XML
	     * Construct an XML parser.  The parser is used to read and write XML.
	     *     Reading XML from a string returns a DOM element.  Writing XML from
	     *     a DOM element returns a string.
	     *
	     * Parameters:
	     * options - {Object} Optional object whose properties will be set on
	     *     the object.
	     */
	    initialize: function(options) {
	        if (OpenLayers.Format.XML.supportActiveX) {
	            this.xmldom = new ActiveXObject("Microsoft.XMLDOM");
	        }
	        OpenLayers.Format.prototype.initialize.apply(this, [options]);
	        // clone the namespace object and set all namespace aliases
	        this.namespaces = OpenLayers.Util.extend({}, this.namespaces);
	        this.namespaceAlias = {};
	        for(var alias in this.namespaces) {
	            this.namespaceAlias[this.namespaces[alias]] = alias;
	        }
	    },
	    
	    /**
	     * APIMethod: destroy
	     * Clean up.
	     */
	    destroy: function() {
	        this.xmldom = null;
	        OpenLayers.Format.prototype.destroy.apply(this, arguments);
	    },
	    
	    /**
	     * Method: setNamespace
	     * Set a namespace alias and URI for the format.
	     *
	     * Parameters:
	     * alias - {String} The namespace alias (prefix).
	     * uri - {String} The namespace URI.
	     */
	    setNamespace: function(alias, uri) {
	        this.namespaces[alias] = uri;
	        this.namespaceAlias[uri] = alias;
	    },

	    /**
	     * APIMethod: read
	     * Deserialize a XML string and return a DOM node.
	     *
	     * Parameters:
	     * text - {String} A XML string
	     
	     * Returns:
	     * {DOMElement} A DOM node
	     */
	    read: function(text) {
	        var index = text.indexOf('<');
	        if(index > 0) {
	            text = text.substring(index);
	        }
	        var node = OpenLayers.Util.Try(
	            OpenLayers.Function.bind((
	                function() {
	                    var xmldom;
	                    /**
	                     * Since we want to be able to call this method on the prototype
	                     * itself, this.xmldom may not exist even if in IE.
	                     */
	                    if (OpenLayers.Format.XML.supportActiveX && !this.xmldom) {
	                        xmldom = new ActiveXObject("Microsoft.XMLDOM");
	                    } else {
	                        xmldom = this.xmldom;
	                        
	                    }
	                    xmldom.loadXML(text);
	                    return xmldom;
	                }
	            ), this),
	            function() {
	                return new DOMParser().parseFromString(text, 'text/xml');
	            },
	            function() {
	                var req = new XMLHttpRequest();
	                req.open("GET", "data:" + "text/xml" +
	                         ";charset=utf-8," + encodeURIComponent(text), false);
	                if(req.overrideMimeType) {
	                    req.overrideMimeType("text/xml");
	                }
	                req.send(null);
	                return req.responseXML;
	            }
	        );

	        if(this.keepData) {
	            this.data = node;
	        }

	        return node;
	    },

	    /**
	     * APIMethod: write
	     * Serialize a DOM node into a XML string.
	     * 
	     * Parameters:
	     * node - {DOMElement} A DOM node.
	     *
	     * Returns:
	     * {String} The XML string representation of the input node.
	     */
	    write: function(node) {
	        var data;
	        if(this.xmldom) {
	            data = node.xml;
	        } else {
	            var serializer = new XMLSerializer();
	            if (node.nodeType == 1) {
	                // Add nodes to a document before serializing. Everything else
	                // is serialized as is. This may need more work. See #1218 .
	                var doc = document.implementation.createDocument("", "", null);
	                if (doc.importNode) {
	                    node = doc.importNode(node, true);
	                }
	                doc.appendChild(node);
	                data = serializer.serializeToString(doc);
	            } else {
	                data = serializer.serializeToString(node);
	            }
	        }
	        return data;
	    },

	    /**
	     * APIMethod: createElementNS
	     * Create a new element with namespace.  This node can be appended to
	     *     another node with the standard node.appendChild method.  For
	     *     cross-browser support, this method must be used instead of
	     *     document.createElementNS.
	     *
	     * Parameters:
	     * uri - {String} Namespace URI for the element.
	     * name - {String} The qualified name of the element (prefix:localname).
	     * 
	     * Returns:
	     * {Element} A DOM element with namespace.
	     */
	    createElementNS: function(uri, name) {
	        var element;
	        if(this.xmldom) {
	            if(typeof uri == "string") {
	                element = this.xmldom.createNode(1, name, uri);
	            } else {
	                element = this.xmldom.createNode(1, name, "");
	            }
	        } else {
	            element = document.createElementNS(uri, name);
	        }
	        return element;
	    },

	    /**
	     * APIMethod: createDocumentFragment
	     * Create a document fragment node that can be appended to another node
	     *     created by createElementNS.  This will call 
	     *     document.createDocumentFragment outside of IE.  In IE, the ActiveX
	     *     object's createDocumentFragment method is used.
	     *
	     * Returns:
	     * {Element} A document fragment.
	     */
	    createDocumentFragment: function() {
	        var element;
	        if (this.xmldom) {
	            element = this.xmldom.createDocumentFragment();
	        } else {
	            element = document.createDocumentFragment();
	        }
	        return element;
	    },

	    /**
	     * APIMethod: createTextNode
	     * Create a text node.  This node can be appended to another node with
	     *     the standard node.appendChild method.  For cross-browser support,
	     *     this method must be used instead of document.createTextNode.
	     * 
	     * Parameters:
	     * text - {String} The text of the node.
	     * 
	     * Returns: 
	     * {DOMElement} A DOM text node.
	     */
	    createTextNode: function(text) {
	        var node;
	        if (typeof text !== "string") {
	            text = String(text);
	        }
	        if(this.xmldom) {
	            node = this.xmldom.createTextNode(text);
	        } else {
	            node = document.createTextNode(text);
	        }
	        return node;
	    },

	    /**
	     * APIMethod: getElementsByTagNameNS
	     * Get a list of elements on a node given the namespace URI and local name.
	     *     To return all nodes in a given namespace, use '*' for the name
	     *     argument.  To return all nodes of a given (local) name, regardless
	     *     of namespace, use '*' for the uri argument.
	     * 
	     * Parameters:
	     * node - {Element} Node on which to search for other nodes.
	     * uri - {String} Namespace URI.
	     * name - {String} Local name of the tag (without the prefix).
	     * 
	     * Returns:
	     * {NodeList} A node list or array of elements.
	     */
	    getElementsByTagNameNS: function(node, uri, name) {
	        var elements = [];
	        if(node.getElementsByTagNameNS) {
	            elements = node.getElementsByTagNameNS(uri, name);
	        } else {
	            // brute force method
	            var allNodes = node.getElementsByTagName("*");
	            var potentialNode, fullName;
	            for(var i=0, len=allNodes.length; i<len; ++i) {
	                potentialNode = allNodes[i];
	                fullName = (potentialNode.prefix) ?
	                           (potentialNode.prefix + ":" + name) : name;
	                if((name == "*") || (fullName == potentialNode.nodeName)) {
	                    if((uri == "*") || (uri == potentialNode.namespaceURI)) {
	                        elements.push(potentialNode);
	                    }
	                }
	            }
	        }
	        return elements;
	    },

	    /**
	     * APIMethod: getAttributeNodeNS
	     * Get an attribute node given the namespace URI and local name.
	     * 
	     * Parameters:
	     * node - {Element} Node on which to search for attribute nodes.
	     * uri - {String} Namespace URI.
	     * name - {String} Local name of the attribute (without the prefix).
	     * 
	     * Returns:
	     * {DOMElement} An attribute node or null if none found.
	     */
	    getAttributeNodeNS: function(node, uri, name) {
	        var attributeNode = null;
	        if(node.getAttributeNodeNS) {
	            attributeNode = node.getAttributeNodeNS(uri, name);
	        } else {
	            var attributes = node.attributes;
	            var potentialNode, fullName;
	            for(var i=0, len=attributes.length; i<len; ++i) {
	                potentialNode = attributes[i];
	                if(potentialNode.namespaceURI == uri) {
	                    fullName = (potentialNode.prefix) ?
	                               (potentialNode.prefix + ":" + name) : name;
	                    if(fullName == potentialNode.nodeName) {
	                        attributeNode = potentialNode;
	                        break;
	                    }
	                }
	            }
	        }
	        return attributeNode;
	    },

	    /**
	     * APIMethod: getAttributeNS
	     * Get an attribute value given the namespace URI and local name.
	     * 
	     * Parameters:
	     * node - {Element} Node on which to search for an attribute.
	     * uri - {String} Namespace URI.
	     * name - {String} Local name of the attribute (without the prefix).
	     * 
	     * Returns:
	     * {String} An attribute value or and empty string if none found.
	     */
	    getAttributeNS: function(node, uri, name) {
	        var attributeValue = "";
	        if(node.getAttributeNS) {
	            attributeValue = node.getAttributeNS(uri, name) || "";
	        } else {
	            var attributeNode = this.getAttributeNodeNS(node, uri, name);
	            if(attributeNode) {
	                attributeValue = attributeNode.nodeValue;
	            }
	        }
	        return attributeValue;
	    },
	    
	    /**
	     * APIMethod: getChildValue
	     * Get the textual value of the node if it exists, or return an
	     *     optional default string.  Returns an empty string if no first child
	     *     exists and no default value is supplied.
	     *
	     * Parameters:
	     * node - {DOMElement} The element used to look for a first child value.
	     * def - {String} Optional string to return in the event that no
	     *     first child value exists.
	     *
	     * Returns:
	     * {String} The value of the first child of the given node.
	     */
	    getChildValue: function(node, def) {
	        var value = def || "";
	        if(node) {
	            for(var child=node.firstChild; child; child=child.nextSibling) {
	                switch(child.nodeType) {
	                    case 3: // text node
	                    case 4: // cdata section
	                        value += child.nodeValue;
	                }
	            }
	        }
	        return value;
	    },

	    /**
	     * APIMethod: isSimpleContent
	     * Test if the given node has only simple content (i.e. no child element
	     *     nodes).
	     *
	     * Parameters:
	     * node - {DOMElement} An element node.
	     *
	     * Returns:
	     * {Boolean} The node has no child element nodes (nodes of type 1). 
	     */
	    isSimpleContent: function(node) {
	        var simple = true;
	        for(var child=node.firstChild; child; child=child.nextSibling) {
	            if(child.nodeType === 1) {
	                simple = false;
	                break;
	            }
	        }
	        return simple;
	    },
	    
	    /**
	     * APIMethod: contentType
	     * Determine the content type for a given node.
	     *
	     * Parameters:
	     * node - {DOMElement}
	     *
	     * Returns:
	     * {Integer} One of OpenLayers.Format.XML.CONTENT_TYPE.{EMPTY,SIMPLE,COMPLEX,MIXED}
	     *     if the node has no, simple, complex, or mixed content.
	     */
	    contentType: function(node) {
	        var simple = false,
	            complex = false;
	            
	        var type = OpenLayers.Format.XML.CONTENT_TYPE.EMPTY;

	        for(var child=node.firstChild; child; child=child.nextSibling) {
	            switch(child.nodeType) {
	                case 1: // element
	                    complex = true;
	                    break;
	                case 8: // comment
	                    break;
	                default:
	                    simple = true;
	            }
	            if(complex && simple) {
	                break;
	            }
	        }
	        
	        if(complex && simple) {
	            type = OpenLayers.Format.XML.CONTENT_TYPE.MIXED;
	        } else if(complex) {
	            return OpenLayers.Format.XML.CONTENT_TYPE.COMPLEX;
	        } else if(simple) {
	            return OpenLayers.Format.XML.CONTENT_TYPE.SIMPLE;
	        }
	        return type;
	    },

	    /**
	     * APIMethod: hasAttributeNS
	     * Determine whether a node has a particular attribute matching the given
	     *     name and namespace.
	     * 
	     * Parameters:
	     * node - {Element} Node on which to search for an attribute.
	     * uri - {String} Namespace URI.
	     * name - {String} Local name of the attribute (without the prefix).
	     * 
	     * Returns:
	     * {Boolean} The node has an attribute matching the name and namespace.
	     */
	    hasAttributeNS: function(node, uri, name) {
	        var found = false;
	        if(node.hasAttributeNS) {
	            found = node.hasAttributeNS(uri, name);
	        } else {
	            found = !!this.getAttributeNodeNS(node, uri, name);
	        }
	        return found;
	    },
	    
	    /**
	     * APIMethod: setAttributeNS
	     * Adds a new attribute or changes the value of an attribute with the given
	     *     namespace and name.
	     *
	     * Parameters:
	     * node - {Element} Element node on which to set the attribute.
	     * uri - {String} Namespace URI for the attribute.
	     * name - {String} Qualified name (prefix:localname) for the attribute.
	     * value - {String} Attribute value.
	     */
	    setAttributeNS: function(node, uri, name, value) {
	        if(node.setAttributeNS) {
	            node.setAttributeNS(uri, name, value);
	        } else {
	            if(this.xmldom) {
	                if(uri) {
	                    var attribute = node.ownerDocument.createNode(
	                        2, name, uri
	                    );
	                    attribute.nodeValue = value;
	                    node.setAttributeNode(attribute);
	                } else {
	                    node.setAttribute(name, value);
	                }
	            } else {
	                throw "setAttributeNS not implemented";
	            }
	        }
	    },

	    /**
	     * Method: createElementNSPlus
	     * Shorthand for creating namespaced elements with optional attributes and
	     *     child text nodes.
	     *
	     * Parameters:
	     * name - {String} The qualified node name.
	     * options - {Object} Optional object for node configuration.
	     *
	     * Valid options:
	     * uri - {String} Optional namespace uri for the element - supply a prefix
	     *     instead if the namespace uri is a property of the format's namespace
	     *     object.
	     * attributes - {Object} Optional attributes to be set using the
	     *     <setAttributes> method.
	     * value - {String} Optional text to be appended as a text node.
	     *
	     * Returns:
	     * {Element} An element node.
	     */
	    createElementNSPlus: function(name, options) {
	        options = options || {};
	        // order of prefix preference
	        // 1. in the uri option
	        // 2. in the prefix option
	        // 3. in the qualified name
	        // 4. from the defaultPrefix
	        var uri = options.uri || this.namespaces[options.prefix];
	        if(!uri) {
	            var loc = name.indexOf(":");
	            uri = this.namespaces[name.substring(0, loc)];
	        }
	        if(!uri) {
	            uri = this.namespaces[this.defaultPrefix];
	        }
	        var node = this.createElementNS(uri, name);
	        if(options.attributes) {
	            this.setAttributes(node, options.attributes);
	        }
	        var value = options.value;
	        if(value != null) {
	            node.appendChild(this.createTextNode(value));
	        }
	        return node;
	    },
	    
	    /**
	     * Method: setAttributes
	     * Set multiple attributes given key value pairs from an object.
	     *
	     * Parameters:
	     * node - {Element} An element node.
	     * obj - {Object || Array} An object whose properties represent attribute
	     *     names and values represent attribute values.  If an attribute name
	     *     is a qualified name ("prefix:local"), the prefix will be looked up
	     *     in the parsers {namespaces} object.  If the prefix is found,
	     *     setAttributeNS will be used instead of setAttribute.
	     */
	    setAttributes: function(node, obj) {
	        var value, uri;
	        for(var name in obj) {
	            if(obj[name] != null && obj[name].toString) {
	                value = obj[name].toString();
	                // check for qualified attribute name ("prefix:local")
	                uri = this.namespaces[name.substring(0, name.indexOf(":"))] || null;
	                this.setAttributeNS(node, uri, name, value);
	            }
	        }
	    },

	    /**
	     * Method: getFirstElementChild
	     * Implementation of firstElementChild attribute that works on ie7 and ie8.
	     *
	     * Parameters:
	     * node - {DOMElement} The parent node (required).
	     *
	     * Returns:
	     * {DOMElement} The first child element.
	     */
	    getFirstElementChild: function(node) {
	        if (node.firstElementChild) {
	            return node.firstElementChild;
	        }
	        else {
	            var child = node.firstChild;
	            while (child.nodeType != 1 && (child = child.nextSibling)) {}
	            return child;
	        }
	    },

	    /**
	     * Method: readNode
	     * Shorthand for applying one of the named readers given the node
	     *     namespace and local name.  Readers take two args (node, obj) and
	     *     generally extend or modify the second.
	     *
	     * Parameters:
	     * node - {DOMElement} The node to be read (required).
	     * obj - {Object} The object to be modified (optional).
	     *
	     * Returns:
	     * {Object} The input object, modified (or a new one if none was provided).
	     */
	    readNode: function(node, obj) {
	        if(!obj) {
	            obj = {};
	        }
	        var group = this.readers[node.namespaceURI ? this.namespaceAlias[node.namespaceURI]: this.defaultPrefix];
	        if(group) {
	            var local = node.localName || node.nodeName.split(":").pop();
	            var reader = group[local] || group["*"];
	            if(reader) {
	                reader.apply(this, [node, obj]);
	            }
	        }
	        return obj;
	    },

	    /**
	     * Method: readChildNodes
	     * Shorthand for applying the named readers to all children of a node.
	     *     For each child of type 1 (element), <readSelf> is called.
	     *
	     * Parameters:
	     * node - {DOMElement} The node to be read (required).
	     * obj - {Object} The object to be modified (optional).
	     *
	     * Returns:
	     * {Object} The input object, modified.
	     */
	    readChildNodes: function(node, obj) {
	        if(!obj) {
	            obj = {};
	        }
	        var children = node.childNodes;
	        var child;
	        for(var i=0, len=children.length; i<len; ++i) {
	            child = children[i];
	            if(child.nodeType == 1) {
	                this.readNode(child, obj);
	            }
	        }
	        return obj;
	    },

	    /**
	     * Method: writeNode
	     * Shorthand for applying one of the named writers and appending the
	     *     results to a node.  If a qualified name is not provided for the
	     *     second argument (and a local name is used instead), the namespace
	     *     of the parent node will be assumed.
	     *
	     * Parameters:
	     * name - {String} The name of a node to generate.  If a qualified name
	     *     (e.g. "pre:Name") is used, the namespace prefix is assumed to be
	     *     in the <writers> group.  If a local name is used (e.g. "Name") then
	     *     the namespace of the parent is assumed.  If a local name is used
	     *     and no parent is supplied, then the default namespace is assumed.
	     * obj - {Object} Structure containing data for the writer.
	     * parent - {DOMElement} Result will be appended to this node.  If no parent
	     *     is supplied, the node will not be appended to anything.
	     *
	     * Returns:
	     * {DOMElement} The child node.
	     */
	    writeNode: function(name, obj, parent) {
	        var prefix, local;
	        var split = name.indexOf(":");
	        if(split > 0) {
	            prefix = name.substring(0, split);
	            local = name.substring(split + 1);
	        } else {
	            if(parent) {
	                prefix = this.namespaceAlias[parent.namespaceURI];
	            } else {
	                prefix = this.defaultPrefix;
	            }
	            local = name;
	        }
	        var child = this.writers[prefix][local].apply(this, [obj]);
	        if(parent) {
	            parent.appendChild(child);
	        }
	        return child;
	    },

	    /**
	     * APIMethod: getChildEl
	     * Get the first child element.  Optionally only return the first child
	     *     if it matches the given name and namespace URI.
	     *
	     * Parameters:
	     * node - {DOMElement} The parent node.
	     * name - {String} Optional node name (local) to search for.
	     * uri - {String} Optional namespace URI to search for.
	     *
	     * Returns:
	     * {DOMElement} The first child.  Returns null if no element is found, if
	     *     something significant besides an element is found, or if the element
	     *     found does not match the optional name and uri.
	     */
	    getChildEl: function(node, name, uri) {
	        return node && this.getThisOrNextEl(node.firstChild, name, uri);
	    },
	    
	    /**
	     * APIMethod: getNextEl
	     * Get the next sibling element.  Optionally get the first sibling only
	     *     if it matches the given local name and namespace URI.
	     *
	     * Parameters:
	     * node - {DOMElement} The node.
	     * name - {String} Optional local name of the sibling to search for.
	     * uri - {String} Optional namespace URI of the sibling to search for.
	     *
	     * Returns:
	     * {DOMElement} The next sibling element.  Returns null if no element is
	     *     found, something significant besides an element is found, or the
	     *     found element does not match the optional name and uri.
	     */
	    getNextEl: function(node, name, uri) {
	        return node && this.getThisOrNextEl(node.nextSibling, name, uri);
	    },
	    
	    /**
	     * Method: getThisOrNextEl
	     * Return this node or the next element node.  Optionally get the first
	     *     sibling with the given local name or namespace URI.
	     *
	     * Parameters:
	     * node - {DOMElement} The node.
	     * name - {String} Optional local name of the sibling to search for.
	     * uri - {String} Optional namespace URI of the sibling to search for.
	     *
	     * Returns:
	     * {DOMElement} The next sibling element.  Returns null if no element is
	     *     found, something significant besides an element is found, or the
	     *     found element does not match the query.
	     */
	    getThisOrNextEl: function(node, name, uri) {
	        outer: for(var sibling=node; sibling; sibling=sibling.nextSibling) {
	            switch(sibling.nodeType) {
	                case 1: // Element
	                    if((!name || name === (sibling.localName || sibling.nodeName.split(":").pop())) &&
	                       (!uri || uri === sibling.namespaceURI)) {
	                        // matches
	                        break outer;
	                    }
	                    sibling = null;
	                    break outer;
	                case 3: // Text
	                    if(/^\s*$/.test(sibling.nodeValue)) {
	                        break;
	                    }
	                case 4: // CDATA
	                case 6: // ENTITY_NODE
	                case 12: // NOTATION_NODE
	                case 10: // DOCUMENT_TYPE_NODE
	                case 11: // DOCUMENT_FRAGMENT_NODE
	                    sibling = null;
	                    break outer;
	            } // ignore comments and processing instructions
	        }
	        return sibling || null;
	    },
	    
	    /**
	     * APIMethod: lookupNamespaceURI
	     * Takes a prefix and returns the namespace URI associated with it on the given
	     *     node if found (and null if not). Supplying null for the prefix will
	     *     return the default namespace.
	     *
	     * For browsers that support it, this calls the native lookupNamesapceURI
	     *     function.  In other browsers, this is an implementation of
	     *     http://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3-lookupNamespaceURI.
	     *
	     * For browsers that don't support the attribute.ownerElement property, this
	     *     method cannot be called on attribute nodes.
	     *     
	     * Parameters:
	     * node - {DOMElement} The node from which to start looking.
	     * prefix - {String} The prefix to lookup or null to lookup the default namespace.
	     * 
	     * Returns:
	     * {String} The namespace URI for the given prefix.  Returns null if the prefix
	     *     cannot be found or the node is the wrong type.
	     */
	    lookupNamespaceURI: function(node, prefix) {
	        var uri = null;
	        if(node) {
	            if(node.lookupNamespaceURI) {
	                uri = node.lookupNamespaceURI(prefix);
	            } else {
	                outer: switch(node.nodeType) {
	                    case 1: // ELEMENT_NODE
	                        if(node.namespaceURI !== null && node.prefix === prefix) {
	                            uri = node.namespaceURI;
	                            break outer;
	                        }
	                        var len = node.attributes.length;
	                        if(len) {
	                            var attr;
	                            for(var i=0; i<len; ++i) {
	                                attr = node.attributes[i];
	                                if(attr.prefix === "xmlns" && attr.name === "xmlns:" + prefix) {
	                                    uri = attr.value || null;
	                                    break outer;
	                                } else if(attr.name === "xmlns" && prefix === null) {
	                                    uri = attr.value || null;
	                                    break outer;
	                                }
	                            }
	                        }
	                        uri = this.lookupNamespaceURI(node.parentNode, prefix);
	                        break outer;
	                    case 2: // ATTRIBUTE_NODE
	                        uri = this.lookupNamespaceURI(node.ownerElement, prefix);
	                        break outer;
	                    case 9: // DOCUMENT_NODE
	                        uri = this.lookupNamespaceURI(node.documentElement, prefix);
	                        break outer;
	                    case 6: // ENTITY_NODE
	                    case 12: // NOTATION_NODE
	                    case 10: // DOCUMENT_TYPE_NODE
	                    case 11: // DOCUMENT_FRAGMENT_NODE
	                        break outer;
	                    default: 
	                        // TEXT_NODE (3), CDATA_SECTION_NODE (4), ENTITY_REFERENCE_NODE (5),
	                        // PROCESSING_INSTRUCTION_NODE (7), COMMENT_NODE (8)
	                        uri =  this.lookupNamespaceURI(node.parentNode, prefix);
	                        break outer;
	                }
	            }
	        }
	        return uri;
	    },
	    
	    /**
	     * Method: getXMLDoc
	     * Get an XML document for nodes that are not supported in HTML (e.g.
	     * createCDATASection). On IE, this will either return an existing or
	     * create a new <xmldom> on the instance. On other browsers, this will
	     * either return an existing or create a new shared document (see
	     * <OpenLayers.Format.XML.document>).
	     *
	     * Returns:
	     * {XMLDocument}
	     */
	    getXMLDoc: function() {
	        if (!OpenLayers.Format.XML.document && !this.xmldom) {
	            if (document.implementation && document.implementation.createDocument) {
	                OpenLayers.Format.XML.document =
	                    document.implementation.createDocument("", "", null);
	            } else if (!this.xmldom && OpenLayers.Format.XML.supportActiveX) {
	                this.xmldom = new ActiveXObject("Microsoft.XMLDOM");
	            }
	        }
	        return OpenLayers.Format.XML.document || this.xmldom;
	    },

	    CLASS_NAME: "OpenLayers.Format.XML" 

	});     

	OpenLayers.Format.XML.CONTENT_TYPE = {EMPTY: 0, SIMPLE: 1, COMPLEX: 2, MIXED: 3};

	/**
	 * APIFunction: OpenLayers.Format.XML.lookupNamespaceURI
	 * Takes a prefix and returns the namespace URI associated with it on the given
	 *     node if found (and null if not). Supplying null for the prefix will
	 *     return the default namespace.
	 *
	 * For browsers that support it, this calls the native lookupNamesapceURI
	 *     function.  In other browsers, this is an implementation of
	 *     http://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3-lookupNamespaceURI.
	 *
	 * For browsers that don't support the attribute.ownerElement property, this
	 *     method cannot be called on attribute nodes.
	 *     
	 * Parameters:
	 * node - {DOMElement} The node from which to start looking.
	 * prefix - {String} The prefix to lookup or null to lookup the default namespace.
	 * 
	 * Returns:
	 * {String} The namespace URI for the given prefix.  Returns null if the prefix
	 *     cannot be found or the node is the wrong type.
	 */
	OpenLayers.Format.XML.lookupNamespaceURI = OpenLayers.Function.bind(
	    OpenLayers.Format.XML.prototype.lookupNamespaceURI,
	    OpenLayers.Format.XML.prototype
	);

	/**
	 * Property: OpenLayers.Format.XML.document
	 * {XMLDocument} XML document to reuse for creating non-HTML compliant nodes,
	 * like document.createCDATASection.
	 */
	OpenLayers.Format.XML.document = null;

	/**
	 * APIFunction: OpenLayers.Format.XML.supportActiveX
	 * Returns a poolean flag to check if this browser uses ActiveX.
	 */
	OpenLayers.Format.XML.supportActiveX = (function () {
	    return (Object.getOwnPropertyDescriptor &&
	            Object.getOwnPropertyDescriptor(window, "ActiveXObject")) ||
	            ("ActiveXObject" in window);
	})();
	/* ======================================================================
	    OpenLayers/Format/KML.js
	   ====================================================================== */

	/* Copyright (c) 2006-2015 by OpenLayers Contributors (see authors.txt for
	 * full list of contributors). Published under the 2-clause BSD license.
	 * See license.txt in the OpenLayers distribution or repository for the
	 * full text of the license. */

	/**
	 * @requires OpenLayers/BaseTypes/Date.js
	 * @requires OpenLayers/Format/XML.js
	 * @requires OpenLayers/Feature/Vector.js
	 * @requires OpenLayers/Geometry/Point.js
	 * @requires OpenLayers/Geometry/LineString.js
	 * @requires OpenLayers/Geometry/Polygon.js
	 * @requires OpenLayers/Geometry/Collection.js
	 * @requires OpenLayers/Request/XMLHttpRequest.js
	 * @requires OpenLayers/Projection.js
	 */

	/**
	 * Class: OpenLayers.Format.KML
	 * Read/Write KML. Create a new instance with the <OpenLayers.Format.KML>
	 *     constructor. 
	 * 
	 * Inherits from:
	 *  - <OpenLayers.Format.XML>
	 */
	OpenLayers.Format.KML = OpenLayers.Class(OpenLayers.Format.XML, {
	    
	    /**
	     * Property: namespaces
	     * {Object} Mapping of namespace aliases to namespace URIs.
	     */
	    namespaces: {
	        kml: "http://www.opengis.net/kml/2.2",
	        gx: "http://www.google.com/kml/ext/2.2"
	    },

	    /**
	     * APIProperty: kmlns
	     * {String} KML Namespace to use. Defaults to 2.0 namespace.
	     */
	    kmlns: "http://earth.google.com/kml/2.0",
	    
	    /** 
	     * APIProperty: placemarksDesc
	     * {String} Name of the placemarks.  Default is "No description available".
	     */
	    placemarksDesc: "No description available",
	    
	    /** 
	     * APIProperty: foldersName
	     * {String} Name of the folders.  Default is "OpenLayers export".
	     *          If set to null, no name element will be created.
	     */
	    foldersName: "OpenLayers export",
	    
	    /** 
	     * APIProperty: foldersDesc
	     * {String} Description of the folders. Default is "Exported on [date]."
	     *          If set to null, no description element will be created.
	     */
	    foldersDesc: "Exported on " + new Date(),
	    
	    /**
	     * APIProperty: extractAttributes
	     * {Boolean} Extract attributes from KML.  Default is true.
	     *           Extracting styleUrls requires this to be set to true
	     *           Note that currently only Data and SimpleData 
	     *           elements are handled.
	     */
	    extractAttributes: true,
	    
	    /**
	     * APIProperty: kvpAttributes
	     * {Boolean} Only used if extractAttributes is true.
	     *           If set to true, attributes will be simple
	     *           key-value pairs, compatible with other formats,
	     *           Any displayName elements will be ignored.
	     *           If set to false, attributes will be objects,
	     *           retaining any displayName elements, but not
	     *           compatible with other formats. Any CDATA in
	     *           displayName will be read in as a string value.
	     *           Default is false.
	     */
	    kvpAttributes: false,
	    
	    /**
	     * Property: extractStyles
	     * {Boolean} Extract styles from KML.  Default is false.
	     *           Extracting styleUrls also requires extractAttributes to be
	     *           set to true
	     */
	    extractStyles: false,
	    
	    /**
	     * APIProperty: extractTracks
	     * {Boolean} Extract gx:Track elements from Placemark elements.  Default
	     *     is false.  If true, features will be generated for all points in
	     *     all gx:Track elements.  Features will have a when (Date) attribute
	     *     based on when elements in the track.  If tracks include angle
	     *     elements, features will have heading, tilt, and roll attributes.
	     *     If track point coordinates have three values, features will have
	     *     an altitude attribute with the third coordinate value.
	     */
	    extractTracks: false,
	    
	    /**
	     * APIProperty: trackAttributes
	     * {Array} If <extractTracks> is true, points within gx:Track elements will 
	     *     be parsed as features with when, heading, tilt, and roll attributes.
	     *     Any additional attribute names can be provided in <trackAttributes>.
	     */
	    trackAttributes: null,
	    
	    /**
	     * Property: internalns
	     * {String} KML Namespace to use -- defaults to the namespace of the
	     *     Placemark node being parsed, but falls back to kmlns. 
	     */
	    internalns: null,

	    /**
	     * Property: features
	     * {Array} Array of features
	     *     
	     */
	    features: null,

	    /**
	     * Property: styles
	     * {Object} Storage of style objects
	     *     
	     */
	    styles: null,
	    
	    /**
	     * Property: styleBaseUrl
	     * {String}
	     */
	    styleBaseUrl: "",

	    /**
	     * Property: fetched
	     * {Object} Storage of KML URLs that have been fetched before
	     *     in order to prevent reloading them.
	     */
	    fetched: null,

	    /**
	     * APIProperty: maxDepth
	     * {Integer} Maximum depth for recursive loading external KML URLs 
	     *           Defaults to 0: do no external fetching
	     */
	    maxDepth: 0,

	    /**
	     * Constructor: OpenLayers.Format.KML
	     * Create a new parser for KML.
	     *
	     * Parameters:
	     * options - {Object} An optional object whose properties will be set on
	     *     this instance.
	     */
	    initialize: function(options) {
	        // compile regular expressions once instead of every time they are used
	        this.regExes = {
	            trimSpace: (/^\s*|\s*$/g),
	            removeSpace: (/\s*/g),
	            splitSpace: (/\s+/),
	            trimComma: (/\s*,\s*/g),
	            kmlColor: (/(\w{2})(\w{2})(\w{2})(\w{2})/),
	            kmlIconPalette: (/root:\/\/icons\/palette-(\d+)(\.\w+)/),
	            straightBracket: (/\$\[(.*?)\]/g)
	        };
	        // KML coordinates are always in longlat WGS84
	        this.externalProjection = new OpenLayers.Projection("EPSG:4326");

	        OpenLayers.Format.XML.prototype.initialize.apply(this, [options]);
	    },

	    /**
	     * APIMethod: read
	     * Read data from a string, and return a list of features. 
	     * 
	     * Parameters: 
	     * data    - {String} or {DOMElement} data to read/parse.
	     *
	     * Returns:
	     * {Array(<OpenLayers.Feature.Vector>)} List of features.
	     */
	    read: function(data) {
	        this.features = [];
	        this.styles   = {};
	        this.fetched  = {};

	        // Set default options 
	        var options = {
	            depth: 0,
	            styleBaseUrl: this.styleBaseUrl
	        };

	        return this.parseData(data, options);
	    },

	    /**
	     * Method: parseData
	     * Read data from a string, and return a list of features. 
	     * 
	     * Parameters: 
	     * data    - {String} or {DOMElement} data to read/parse.
	     * options - {Object} Hash of options
	     *
	     * Returns:
	     * {Array(<OpenLayers.Feature.Vector>)} List of features.
	     */
	    parseData: function(data, options) {
	        if(typeof data == "string") {
	            data = OpenLayers.Format.XML.prototype.read.apply(this, [data]);
	        }

	        // Loop through the following node types in this order and
	        // process the nodes found 
	        var types = ["Link", "NetworkLink", "Style", "StyleMap", "Placemark"];
	        for(var i=0, len=types.length; i<len; ++i) {
	            var type = types[i];

	            var nodes = this.getElementsByTagNameNS(data, "*", type);

	            // skip to next type if no nodes are found
	            if(nodes.length == 0) { 
	                continue;
	            }

	            switch (type.toLowerCase()) {

	                // Fetch external links 
	                case "link":
	                case "networklink":
	                    this.parseLinks(nodes, options);
	                    break;

	                // parse style information
	                case "style":
	                    if (this.extractStyles) {
	                        this.parseStyles(nodes, options);
	                    }
	                    break;
	                case "stylemap":
	                    if (this.extractStyles) {
	                        this.parseStyleMaps(nodes, options);
	                    }
	                    break;

	                // parse features
	                case "placemark":
	                    this.parseFeatures(nodes, options);
	                    break;
	            }
	        }
	        
	        return this.features;
	    },

	    /**
	     * Method: parseLinks
	     * Finds URLs of linked KML documents and fetches them
	     * 
	     * Parameters: 
	     * nodes   - {Array} of {DOMElement} data to read/parse.
	     * options - {Object} Hash of options
	     * 
	     */
	    parseLinks: function(nodes, options) {
	        
	        // Fetch external links <NetworkLink> and <Link>
	        // Don't do anything if we have reached our maximum depth for recursion
	        if (options.depth >= this.maxDepth) {
	            return false;
	        }

	        // increase depth
	        var newOptions = OpenLayers.Util.extend({}, options);
	        newOptions.depth++;

	        for(var i=0, len=nodes.length; i<len; i++) {
	            var href = this.parseProperty(nodes[i], "*", "href");
	            if(href && !this.fetched[href]) {
	                this.fetched[href] = true; // prevent reloading the same urls
	                var data = this.fetchLink(href);
	                if (data) {
	                    this.parseData(data, newOptions);
	                }
	            } 
	        }

	    },

	    /**
	     * Method: fetchLink
	     * Fetches a URL and returns the result
	     * 
	     * Parameters: 
	     * href  - {String} url to be fetched
	     * 
	     */
	    fetchLink: function(href) {
	        var request = OpenLayers.Request.GET({url: href, async: false});
	        if (request) {
	            return request.responseText;
	        }
	    },

	    /**
	     * Method: parseStyles
	     * Parses <Style> nodes
	     * 
	     * Parameters: 
	     * nodes    - {Array} of {DOMElement} data to read/parse.
	     * options  - {Object} Hash of options
	     * 
	     */
	    parseStyles: function(nodes, options) {
	        for(var i=0, len=nodes.length; i<len; i++) {
	            var style = this.parseStyle(nodes[i]);
	            if(style) {
	                var styleName = (options.styleBaseUrl || "") + "#" + style.id;
	                
	                this.styles[styleName] = style;
	            }
	        }
	    },

	    /**
	     * Method: parseKmlColor
	     * Parses a kml color (in 'aabbggrr' format) and returns the corresponding 
	     * color and opacity or null if the color is invalid.
	     *
	     * Parameters: 
	     * kmlColor - {String} a kml formatted color
	     *
	     * Returns:
	     * {Object}
	     */
	    parseKmlColor: function(kmlColor) {
	        var color = null;
	        if (kmlColor) {
	            var matches = kmlColor.match(this.regExes.kmlColor);
	            if (matches) {
	                color = {
	                    color: '#' + matches[4] + matches[3] + matches[2],
	                    opacity: parseInt(matches[1], 16) / 255
	                };
	            }
	        }
	        return color;
	    },

	    /**
	     * Method: parseStyle
	     * Parses the children of a <Style> node and builds the style hash
	     * accordingly
	     * 
	     * Parameters: 
	     * node - {DOMElement} <Style> node
	     * 
	     */
	    parseStyle: function(node) {
	        var style = {};
	        
	        var types = ["LineStyle", "PolyStyle", "IconStyle", "BalloonStyle", 
	                     "LabelStyle"];
	        var type, styleTypeNode, nodeList, geometry, parser;
	        for(var i=0, len=types.length; i<len; ++i) {
	            type = types[i];
	            styleTypeNode = this.getElementsByTagNameNS(node, "*", type)[0];
	            if(!styleTypeNode) { 
	                continue;
	            }

	            // only deal with first geometry of this type
	            switch (type.toLowerCase()) {
	                case "linestyle":
	                    var kmlColor = this.parseProperty(styleTypeNode, "*", "color");
	                    var color = this.parseKmlColor(kmlColor);
	                    if (color) {
	                        style["strokeColor"] = color.color;
	                        style["strokeOpacity"] = color.opacity;
	                    }
	                    
	                    var width = this.parseProperty(styleTypeNode, "*", "width");
	                    if (width) {
	                        style["strokeWidth"] = width;
	                    }
	                    break;

	                case "polystyle":
	                    var kmlColor = this.parseProperty(styleTypeNode, "*", "color");
	                    var color = this.parseKmlColor(kmlColor);
	                    if (color) {
	                        style["fillOpacity"] = color.opacity;
	                        style["fillColor"] = color.color;
	                    }
	                    // Check if fill is disabled
	                    var fill = this.parseProperty(styleTypeNode, "*", "fill");
	                    if (fill == "0") {
	                        style["fillColor"] = "none";
	                    }
	                    // Check if outline is disabled
	                    var outline = this.parseProperty(styleTypeNode, "*", "outline");
	                    if (outline == "0") {
	                        style["strokeWidth"] = "0";
	                    }
	                   
	                    break;

	                case "iconstyle":
	                    // set scale
	                    var scale = parseFloat(this.parseProperty(styleTypeNode, 
	                                                          "*", "scale") || 1);
	  
	                    // set default width and height of icon
	                    var width = 32 * scale;
	                    var height = 32 * scale;

	                    var iconNode = this.getElementsByTagNameNS(styleTypeNode, 
	                                               "*", 
	                                               "Icon")[0];
	                    if (iconNode) {
	                        var href = this.parseProperty(iconNode, "*", "href");
	                        if (href) {                                                   

	                            var w = this.parseProperty(iconNode, "*", "w");
	                            var h = this.parseProperty(iconNode, "*", "h");

	                            // Settings for Google specific icons that are 64x64
	                            // We set the width and height to 64 and halve the
	                            // scale to prevent icons from being too big
	                            var google = "http://maps.google.com/mapfiles/kml";
	                            if (OpenLayers.String.startsWith(
	                                                 href, google) && !w && !h) {
	                                w = 64;
	                                h = 64;
	                                scale = scale / 2;
	                            }
	                                
	                            // if only dimension is defined, make sure the
	                            // other one has the same value
	                            w = w || h;
	                            h = h || w;

	                            if (w) {
	                                width = parseInt(w) * scale;
	                            }

	                            if (h) {
	                                height = parseInt(h) * scale;
	                            }

	                            // support for internal icons 
	                            //    (/root://icons/palette-x.png)
	                            // x and y tell the position on the palette:
	                            // - in pixels
	                            // - starting from the left bottom
	                            // We translate that to a position in the list 
	                            // and request the appropriate icon from the 
	                            // google maps website
	                            var matches = href.match(this.regExes.kmlIconPalette);
	                            if (matches)  {
	                                var palette = matches[1];
	                                var file_extension = matches[2];

	                                var x = this.parseProperty(iconNode, "*", "x");
	                                var y = this.parseProperty(iconNode, "*", "y");

	                                var posX = x ? x/32 : 0;
	                                var posY = y ? (7 - y/32) : 7;

	                                var pos = posY * 8 + posX;
	                                href = "http://maps.google.com/mapfiles/kml/pal" 
	                                     + palette + "/icon" + pos + file_extension;
	                            }

	                            style["graphicOpacity"] = 1; // fully opaque
	                            style["externalGraphic"] = href;
	                        }

	                    }


	                    // hotSpots define the offset for an Icon
	                    var hotSpotNode = this.getElementsByTagNameNS(styleTypeNode, 
	                                               "*", 
	                                               "hotSpot")[0];
	                    if (hotSpotNode) {
	                        var x = parseFloat(hotSpotNode.getAttribute("x"));
	                        var y = parseFloat(hotSpotNode.getAttribute("y"));

	                        var xUnits = hotSpotNode.getAttribute("xunits");
	                        if (xUnits == "pixels") {
	                            style["graphicXOffset"] = -x * scale;
	                        }
	                        else if (xUnits == "insetPixels") {
	                            style["graphicXOffset"] = -width + (x * scale);
	                        }
	                        else if (xUnits == "fraction") {
	                            style["graphicXOffset"] = -width * x;
	                        }

	                        var yUnits = hotSpotNode.getAttribute("yunits");
	                        if (yUnits == "pixels") {
	                            style["graphicYOffset"] = -height + (y * scale) + 1;
	                        }
	                        else if (yUnits == "insetPixels") {
	                            style["graphicYOffset"] = -(y * scale) + 1;
	                        }
	                        else if (yUnits == "fraction") {
	                            style["graphicYOffset"] =  -height * (1 - y) + 1;
	                        }
	                    }

	                    style["graphicWidth"] = width;
	                    style["graphicHeight"] = height;
	                    break;

	                case "balloonstyle":
	                    var balloonStyle = OpenLayers.Util.getXmlNodeValue(
	                                            styleTypeNode);
	                    if (balloonStyle) {
	                        style["balloonStyle"] = balloonStyle.replace(
	                                       this.regExes.straightBracket, "${$1}");
	                    }
	                    break;
	                case "labelstyle":
	                    var kmlColor = this.parseProperty(styleTypeNode, "*", "color");
	                    var color = this.parseKmlColor(kmlColor);
	                    if (color) {
	                        style["fontColor"] = color.color;
	                        style["fontOpacity"] = color.opacity;
	                    }
	                    break;

	                default:
	            }
	        }

	        // Some polygons have no line color, so we use the fillColor for that
	        if (!style["strokeColor"] && style["fillColor"]) {
	            style["strokeColor"] = style["fillColor"];
	        }

	        var id = node.getAttribute("id");
	        if (id && style) {
	            style.id = id;
	        }

	        return style;
	    },

	    /**
	     * Method: parseStyleMaps
	     * Parses <StyleMap> nodes, but only uses the 'normal' key
	     * 
	     * Parameters: 
	     * nodes    - {Array} of {DOMElement} data to read/parse.
	     * options  - {Object} Hash of options
	     * 
	     */
	    parseStyleMaps: function(nodes, options) {
	        // Only the default or "normal" part of the StyleMap is processed now
	        // To do the select or "highlight" bit, we'd need to change lots more

	        for(var i=0, len=nodes.length; i<len; i++) {
	            var node = nodes[i];
	            var pairs = this.getElementsByTagNameNS(node, "*", 
	                            "Pair");

	            var id = node.getAttribute("id");
	            for (var j=0, jlen=pairs.length; j<jlen; j++) {
	                var pair = pairs[j];
	                // Use the shortcut in the SLD format to quickly retrieve the 
	                // value of a node. Maybe it's good to have a method in 
	                // Format.XML to do this
	                var key = this.parseProperty(pair, "*", "key");
	                var styleUrl = this.parseProperty(pair, "*", "styleUrl");

	                if (styleUrl && key == "normal") {
	                    this.styles[(options.styleBaseUrl || "") + "#" + id] =
	                        this.styles[(options.styleBaseUrl || "") + styleUrl];
	                }

	                // TODO: implement the "select" part
	                //if (styleUrl && key == "highlight") {
	                //}

	            }
	        }

	    },


	    /**
	     * Method: parseFeatures
	     * Loop through all Placemark nodes and parse them.
	     * Will create a list of features
	     * 
	     * Parameters: 
	     * nodes    - {Array} of {DOMElement} data to read/parse.
	     * options  - {Object} Hash of options
	     * 
	     */
	    parseFeatures: function(nodes, options) {
	        var features = [];
	        for(var i=0, len=nodes.length; i<len; i++) {
	            var featureNode = nodes[i];
	            var feature = this.parseFeature.apply(this,[featureNode]) ;
	            if(feature) {

	                // Create reference to styleUrl 
	                if (this.extractStyles && feature.attributes &&
	                    feature.attributes.styleUrl) {
	                    feature.style = this.getStyle(feature.attributes.styleUrl, options);
	                }

	                if (this.extractStyles) {
	                    // Make sure that <Style> nodes within a placemark are 
	                    // processed as well
	                    var inlineStyleNode = this.getElementsByTagNameNS(featureNode,
	                                                        "*",
	                                                        "Style")[0];
	                    if (inlineStyleNode) {
	                        var inlineStyle= this.parseStyle(inlineStyleNode);
	                        if (inlineStyle) {
	                            feature.style = OpenLayers.Util.extend(
	                                feature.style, inlineStyle
	                            );
	                        }
	                    }
	                }

	                // check if gx:Track elements should be parsed
	                if (this.extractTracks) {
	                    var tracks = this.getElementsByTagNameNS(
	                        featureNode, this.namespaces.gx, "Track"
	                    );
	                    if (tracks && tracks.length > 0) {
	                        var track = tracks[0];
	                        var container = {
	                            features: [],
	                            feature: feature
	                        };
	                        this.readNode(track, container);
	                        if (container.features.length > 0) {
	                            features.push.apply(features, container.features);
	                        }
	                    }
	                } else {
	                    // add feature to list of features
	                    features.push(feature);                    
	                }
	            } else {
	                throw "Bad Placemark: " + i;
	            }
	        }

	        // add new features to existing feature list
	        this.features = this.features.concat(features);
	    },
	    
	    /**
	     * Property: readers
	     * Contains public functions, grouped by namespace prefix, that will
	     *     be applied when a namespaced node is found matching the function
	     *     name.  The function will be applied in the scope of this parser
	     *     with two arguments: the node being read and a context object passed
	     *     from the parent.
	     */
	    readers: {
	        "kml": {
	            "when": function(node, container) {
	                container.whens.push(OpenLayers.Date.parse(
	                    this.getChildValue(node)
	                ));
	            },
	            "_trackPointAttribute": function(node, container) {
	                var name = node.nodeName.split(":").pop();
	                container.attributes[name].push(this.getChildValue(node));
	            }
	        },
	        "gx": {
	            "Track": function(node, container) {
	                var obj = {
	                    whens: [],
	                    points: [],
	                    angles: []
	                };
	                if (this.trackAttributes) {
	                    var name;
	                    obj.attributes = {};
	                    for (var i=0, ii=this.trackAttributes.length; i<ii; ++i) {
	                        name = this.trackAttributes[i];
	                        obj.attributes[name] = [];
	                        if (!(name in this.readers.kml)) {
	                            this.readers.kml[name] = this.readers.kml._trackPointAttribute;
	                        }
	                    }
	                }
	                this.readChildNodes(node, obj);
	                if (obj.whens.length !== obj.points.length) {
	                    throw new Error("gx:Track with unequal number of when (" +
	                                    obj.whens.length + ") and gx:coord (" +
	                                    obj.points.length + ") elements.");
	                }
	                var hasAngles = obj.angles.length > 0;
	                if (hasAngles && obj.whens.length !== obj.angles.length) {
	                    throw new Error("gx:Track with unequal number of when (" +
	                                    obj.whens.length + ") and gx:angles (" +
	                                    obj.angles.length + ") elements.");
	                }
	                var feature, point, angles;
	                for (var i=0, ii=obj.whens.length; i<ii; ++i) {
	                    feature = container.feature.clone();
	                    feature.fid = container.feature.fid || container.feature.id;
	                    point = obj.points[i];
	                    feature.geometry = point;
	                    if ("z" in point) {
	                        feature.attributes.altitude = point.z;
	                    }
	                    if (this.internalProjection && this.externalProjection) {
	                        feature.geometry.transform(
	                            this.externalProjection, this.internalProjection
	                        ); 
	                    }
	                    if (this.trackAttributes) {
	                        for (var j=0, jj=this.trackAttributes.length; j<jj; ++j) {
	                            var name = this.trackAttributes[j];
	                            feature.attributes[name] = obj.attributes[name][i];
	                        }
	                    }
	                    feature.attributes.when = obj.whens[i];
	                    feature.attributes.trackId = container.feature.id;
	                    if (hasAngles) {
	                        angles = obj.angles[i];
	                        feature.attributes.heading = parseFloat(angles[0]);
	                        feature.attributes.tilt = parseFloat(angles[1]);
	                        feature.attributes.roll = parseFloat(angles[2]);
	                    }
	                    container.features.push(feature);
	                }
	            },
	            "coord": function(node, container) {
	                var str = this.getChildValue(node);
	                var coords = str.replace(this.regExes.trimSpace, "").split(/\s+/);
	                var point = new OpenLayers.Geometry.Point(coords[0], coords[1]);
	                if (coords.length > 2) {
	                    point.z = parseFloat(coords[2]);
	                }
	                container.points.push(point);
	            },
	            "angles": function(node, container) {
	                var str = this.getChildValue(node);
	                var parts = str.replace(this.regExes.trimSpace, "").split(/\s+/);
	                container.angles.push(parts);
	            }
	        }
	    },
	    
	    /**
	     * Method: parseFeature
	     * This function is the core of the KML parsing code in OpenLayers.
	     *     It creates the geometries that are then attached to the returned
	     *     feature, and calls parseAttributes() to get attribute data out.
	     *
	     * Parameters:
	     * node - {DOMElement}
	     *
	     * Returns:
	     * {<OpenLayers.Feature.Vector>} A vector feature.
	     */
	    parseFeature: function(node) {
	        // only accept one geometry per feature - look for highest "order"
	        var order = ["MultiGeometry", "Polygon", "LineString", "Point"];
	        var type, nodeList, geometry, parser;
	        for(var i=0, len=order.length; i<len; ++i) {
	            type = order[i];
	            this.internalns = node.namespaceURI ? 
	                    node.namespaceURI : this.kmlns;
	            nodeList = this.getElementsByTagNameNS(node, 
	                                                   this.internalns, type);
	            if(nodeList.length > 0) {
	                // only deal with first geometry of this type
	                var parser = this.parseGeometry[type.toLowerCase()];
	                if(parser) {
	                    geometry = parser.apply(this, [nodeList[0]]);
	                    if (this.internalProjection && this.externalProjection) {
	                        geometry.transform(this.externalProjection, 
	                                           this.internalProjection); 
	                    }                       
	                } else {
	                    throw new TypeError("Unsupported geometry type: " + type);
	                }
	                // stop looking for different geometry types
	                break;
	            }
	        }

	        // construct feature (optionally with attributes)
	        var attributes;
	        if(this.extractAttributes) {
	            attributes = this.parseAttributes(node);
	        }
	        var feature = new OpenLayers.Feature.Vector(geometry, attributes);

	        var fid = node.getAttribute("id") || node.getAttribute("name");
	        if(fid != null) {
	            feature.fid = fid;
	        }

	        return feature;
	    },        
	    
	    /**
	     * Method: getStyle
	     * Retrieves a style from a style hash using styleUrl as the key
	     * If the styleUrl doesn't exist yet, we try to fetch it 
	     * Internet
	     * 
	     * Parameters: 
	     * styleUrl  - {String} URL of style
	     * options   - {Object} Hash of options 
	     *
	     * Returns:
	     * {Object}  - (reference to) Style hash
	     */
	    getStyle: function(styleUrl, options) {

	        var styleBaseUrl = OpenLayers.Util.removeTail(styleUrl);

	        var newOptions = OpenLayers.Util.extend({}, options);
	        newOptions.depth++;
	        newOptions.styleBaseUrl = styleBaseUrl;

	        // Fetch remote Style URLs (if not fetched before) 
	        if (!this.styles[styleUrl] 
	                && !OpenLayers.String.startsWith(styleUrl, "#") 
	                && newOptions.depth <= this.maxDepth
	                && !this.fetched[styleBaseUrl] ) {

	            var data = this.fetchLink(styleBaseUrl);
	            if (data) {
	                this.parseData(data, newOptions);
	            }

	        }

	        // return requested style
	        var style = OpenLayers.Util.extend({}, this.styles[styleUrl]);
	        return style;
	    },
	    
	    /**
	     * Property: parseGeometry
	     * Properties of this object are the functions that parse geometries based
	     *     on their type.
	     */
	    parseGeometry: {
	        
	        /**
	         * Method: parseGeometry.point
	         * Given a KML node representing a point geometry, create an OpenLayers
	         *     point geometry.
	         *
	         * Parameters:
	         * node - {DOMElement} A KML Point node.
	         *
	         * Returns:
	         * {<OpenLayers.Geometry.Point>} A point geometry.
	         */
	        point: function(node) {
	            var nodeList = this.getElementsByTagNameNS(node, this.internalns,
	                                                       "coordinates");
	            var coords = [];
	            if(nodeList.length > 0) {
	                var coordString = nodeList[0].firstChild.nodeValue;
	                coordString = coordString.replace(this.regExes.removeSpace, "");
	                coords = coordString.split(",");
	            }

	            var point = null;
	            if(coords.length > 1) {
	                // preserve third dimension
	                if(coords.length == 2) {
	                    coords[2] = null;
	                }
	                point = new OpenLayers.Geometry.Point(coords[0], coords[1],
	                                                      coords[2]);
	            } else {
	                throw "Bad coordinate string: " + coordString;
	            }
	            return point;
	        },
	        
	        /**
	         * Method: parseGeometry.linestring
	         * Given a KML node representing a linestring geometry, create an
	         *     OpenLayers linestring geometry.
	         *
	         * Parameters:
	         * node - {DOMElement} A KML LineString node.
	         *
	         * Returns:
	         * {<OpenLayers.Geometry.LineString>} A linestring geometry.
	         */
	        linestring: function(node, ring) {
	            var nodeList = this.getElementsByTagNameNS(node, this.internalns,
	                                                       "coordinates");
	            var line = null;
	            if(nodeList.length > 0) {
	                var coordString = this.getChildValue(nodeList[0]);

	                coordString = coordString.replace(this.regExes.trimSpace,
	                                                  "");
	                coordString = coordString.replace(this.regExes.trimComma,
	                                                  ",");
	                var pointList = coordString.split(this.regExes.splitSpace);
	                var numPoints = pointList.length;
	                var points = new Array(numPoints);
	                var coords, numCoords;
	                for(var i=0; i<numPoints; ++i) {
	                    coords = pointList[i].split(",");
	                    numCoords = coords.length;
	                    if(numCoords > 1) {
	                        if(coords.length == 2) {
	                            coords[2] = null;
	                        }
	                        points[i] = new OpenLayers.Geometry.Point(coords[0],
	                                                                  coords[1],
	                                                                  coords[2]);
	                    } else {
	                        throw "Bad LineString point coordinates: " +
	                              pointList[i];
	                    }
	                }
	                if(numPoints) {
	                    if(ring) {
	                        line = new OpenLayers.Geometry.LinearRing(points);
	                    } else {
	                        line = new OpenLayers.Geometry.LineString(points);
	                    }
	                } else {
	                    throw "Bad LineString coordinates: " + coordString;
	                }
	            }

	            return line;
	        },
	        
	        /**
	         * Method: parseGeometry.polygon
	         * Given a KML node representing a polygon geometry, create an
	         *     OpenLayers polygon geometry.
	         *
	         * Parameters:
	         * node - {DOMElement} A KML Polygon node.
	         *
	         * Returns:
	         * {<OpenLayers.Geometry.Polygon>} A polygon geometry.
	         */
	        polygon: function(node) {
	            var nodeList = this.getElementsByTagNameNS(node, this.internalns,
	                                                       "LinearRing");
	            var numRings = nodeList.length;
	            var components = new Array(numRings);
	            if(numRings > 0) {
	                // this assumes exterior ring first, inner rings after
	                var ring;
	                for(var i=0, len=nodeList.length; i<len; ++i) {
	                    ring = this.parseGeometry.linestring.apply(this,
	                                                        [nodeList[i], true]);
	                    if(ring) {
	                        components[i] = ring;
	                    } else {
	                        throw "Bad LinearRing geometry: " + i;
	                    }
	                }
	            }
	            return new OpenLayers.Geometry.Polygon(components);
	        },
	        
	        /**
	         * Method: parseGeometry.multigeometry
	         * Given a KML node representing a multigeometry, create an
	         *     OpenLayers geometry collection.
	         *
	         * Parameters:
	         * node - {DOMElement} A KML MultiGeometry node.
	         *
	         * Returns:
	         * {<OpenLayers.Geometry.Collection>} A geometry collection.
	         */
	        multigeometry: function(node) {
	            var child, parser;
	            var parts = [];
	            var children = node.childNodes;
	            for(var i=0, len=children.length; i<len; ++i ) {
	                child = children[i];
	                if(child.nodeType == 1) {
	                    var type = (child.prefix) ?
	                            child.nodeName.split(":")[1] :
	                            child.nodeName;
	                    var parser = this.parseGeometry[type.toLowerCase()];
	                    if(parser) {
	                        parts.push(parser.apply(this, [child]));
	                    }
	                }
	            }
	            return new OpenLayers.Geometry.Collection(parts);
	        }
	        
	    },

	    /**
	     * Method: parseAttributes
	     *
	     * Parameters:
	     * node - {DOMElement}
	     *
	     * Returns:
	     * {Object} An attributes object.
	     */
	    parseAttributes: function(node) {
	        var attributes = {};
	       
	        // Extended Data is parsed first.
	        var edNodes = node.getElementsByTagName("ExtendedData");
	        if (edNodes.length) {
	            attributes = this.parseExtendedData(edNodes[0]);
	        }
	        
	        // assume attribute nodes are type 1 children with a type 3 or 4 child
	        var child, grandchildren, grandchild;
	        var children = node.childNodes;

	        for(var i=0, len=children.length; i<len; ++i) {
	            child = children[i];
	            if(child.nodeType == 1) {
	                grandchildren = child.childNodes;
	                if(grandchildren.length >= 1 && grandchildren.length <= 3) {
	                    var grandchild;
	                    switch (grandchildren.length) {
	                        case 1:
	                            grandchild = grandchildren[0];
	                            break;
	                        case 2:
	                            var c1 = grandchildren[0];
	                            var c2 = grandchildren[1];
	                            grandchild = (c1.nodeType == 3 || c1.nodeType == 4) ?
	                                c1 : c2;
	                            break;
	                        case 3:
	                        default:
	                            grandchild = grandchildren[1];
	                            break;
	                    }
	                    if(grandchild.nodeType == 3 || grandchild.nodeType == 4) {
	                        var name = (child.prefix) ?
	                                child.nodeName.split(":")[1] :
	                                child.nodeName;
	                        var value = OpenLayers.Util.getXmlNodeValue(grandchild);
	                        if (value) {
	                            value = value.replace(this.regExes.trimSpace, "");
	                            attributes[name] = value;
	                        }
	                    }
	                } 
	            }
	        }
	        return attributes;
	    },

	    /**
	     * Method: parseExtendedData
	     * Parse ExtendedData from KML. Limited support for schemas/datatypes.
	     *     See http://code.google.com/apis/kml/documentation/kmlreference.html#extendeddata
	     *     for more information on extendeddata.
	     */
	    parseExtendedData: function(node) {
	        var attributes = {};
	        var i, len, data, key;
	        var dataNodes = node.getElementsByTagName("Data");
	        for (i = 0, len = dataNodes.length; i < len; i++) {
	            data = dataNodes[i];
	            key = data.getAttribute("name");
	            var ed = {};
	            var valueNode = data.getElementsByTagName("value");
	            if (valueNode.length) {
	                ed['value'] = this.getChildValue(valueNode[0]);
	            }
	            if (this.kvpAttributes) {
	                attributes[key] = ed['value'];
	            } else {
	                var nameNode = data.getElementsByTagName("displayName");
	                if (nameNode.length) {
	                    ed['displayName'] = this.getChildValue(nameNode[0]);
	                }
	                attributes[key] = ed;
	            } 
	        }
	        var simpleDataNodes = node.getElementsByTagName("SimpleData");
	        for (i = 0, len = simpleDataNodes.length; i < len; i++) {
	            var ed = {};
	            data = simpleDataNodes[i];
	            key = data.getAttribute("name");
	            ed['value'] = this.getChildValue(data);
	            if (this.kvpAttributes) {
	                attributes[key] = ed['value'];
	            } else {
	                ed['displayName'] = key;
	                attributes[key] = ed;
	            }
	        }
	        
	        return attributes;    
	    },
	    
	    /**
	     * Method: parseProperty
	     * Convenience method to find a node and return its value
	     *
	     * Parameters:
	     * xmlNode    - {<DOMElement>}
	     * namespace  - {String} namespace of the node to find
	     * tagName    - {String} name of the property to parse
	     * 
	     * Returns:
	     * {String} The value for the requested property (defaults to null)
	     */    
	    parseProperty: function(xmlNode, namespace, tagName) {
	        var value;
	        var nodeList = this.getElementsByTagNameNS(xmlNode, namespace, tagName);
	        try {
	            value = OpenLayers.Util.getXmlNodeValue(nodeList[0]);
	        } catch(e) {
	            value = null;
	        }
	     
	        return value;
	    },                                                              

	    /**
	     * APIMethod: write
	     * Accept Feature Collection, and return a string. 
	     * 
	     * Parameters:
	     * features - {Array(<OpenLayers.Feature.Vector>)} An array of features.
	     *
	     * Returns:
	     * {String} A KML string.
	     */
	    write: function(features) {
	        if(!(OpenLayers.Util.isArray(features))) {
	            features = [features];
	        }
	        var kml = this.createElementNS(this.kmlns, "kml");
	        var folder = this.createFolderXML();
	        for(var i=0, len=features.length; i<len; ++i) {
	            folder.appendChild(this.createPlacemarkXML(features[i]));
	        }
	        kml.appendChild(folder);
	        return OpenLayers.Format.XML.prototype.write.apply(this, [kml]);
	    },

	    /**
	     * Method: createFolderXML
	     * Creates and returns a KML folder node
	     * 
	     * Returns:
	     * {DOMElement}
	     */
	    createFolderXML: function() {
	        // Folder
	        var folder = this.createElementNS(this.kmlns, "Folder");

	        // Folder name
	        if (this.foldersName) {
	            var folderName = this.createElementNS(this.kmlns, "name");
	            var folderNameText = this.createTextNode(this.foldersName); 
	            folderName.appendChild(folderNameText);
	            folder.appendChild(folderName);
	        }

	        // Folder description
	        if (this.foldersDesc) {
	            var folderDesc = this.createElementNS(this.kmlns, "description");        
	            var folderDescText = this.createTextNode(this.foldersDesc); 
	            folderDesc.appendChild(folderDescText);
	            folder.appendChild(folderDesc);
	        }

	        return folder;
	    },

	    /**
	     * Method: createPlacemarkXML
	     * Creates and returns a KML placemark node representing the given feature. 
	     * 
	     * Parameters:
	     * feature - {<OpenLayers.Feature.Vector>}
	     * 
	     * Returns:
	     * {DOMElement}
	     */
	    createPlacemarkXML: function(feature) {        
	        // Placemark name
	        var placemarkName = this.createElementNS(this.kmlns, "name");
	        var label = (feature.style && feature.style.label) ? feature.style.label : feature.id;
	        var name = feature.attributes.name || label;
	        placemarkName.appendChild(this.createTextNode(name));

	        // Placemark description
	        var placemarkDesc = this.createElementNS(this.kmlns, "description");
	        var desc = feature.attributes.description || this.placemarksDesc;
	        placemarkDesc.appendChild(this.createTextNode(desc));
	        
	        // Placemark
	        var placemarkNode = this.createElementNS(this.kmlns, "Placemark");
	        if(feature.fid != null) {
	            placemarkNode.setAttribute("id", feature.fid);
	        }
	        placemarkNode.appendChild(placemarkName);
	        placemarkNode.appendChild(placemarkDesc);

	        // output attributes as extendedData
	        if (feature.attributes) {
	            var edNode = this.buildExtendedData(feature.attributes);
	            if (edNode) {
	                placemarkNode.appendChild(edNode);
	            }
	        }
	        
	        // Geometry node (Point, LineString, etc. nodes)
	        var geometryNode = this.buildGeometryNode(feature.geometry);
	        placemarkNode.appendChild(geometryNode);        
	        
	        return placemarkNode;
	    },    

	    /**
	     * Method: buildGeometryNode
	     * Builds and returns a KML geometry node with the given geometry.
	     * 
	     * Parameters:
	     * geometry - {<OpenLayers.Geometry>}
	     * 
	     * Returns:
	     * {DOMElement}
	     */
	    buildGeometryNode: function(geometry) {
	        var className = geometry.CLASS_NAME;
	        var type = className.substring(className.lastIndexOf(".") + 1);
	        var builder = this.buildGeometry[type.toLowerCase()];
	        var node = null;
	        if(builder) {
	            node = builder.apply(this, [geometry]);
	        }
	        return node;
	    },

	    /**
	     * Property: buildGeometry
	     * Object containing methods to do the actual geometry node building
	     *     based on geometry type.
	     */
	    buildGeometry: {
	        // TBD: Anybody care about namespace aliases here (these nodes have
	        //    no prefixes)?

	        /**
	         * Method: buildGeometry.point
	         * Given an OpenLayers point geometry, create a KML point.
	         *
	         * Parameters:
	         * geometry - {<OpenLayers.Geometry.Point>} A point geometry.
	         *
	         * Returns:
	         * {DOMElement} A KML point node.
	         */
	        point: function(geometry) {
	            var kml = this.createElementNS(this.kmlns, "Point");
	            kml.appendChild(this.buildCoordinatesNode(geometry));
	            return kml;
	        },
	        
	        /**
	         * Method: buildGeometry.multipoint
	         * Given an OpenLayers multipoint geometry, create a KML
	         *     GeometryCollection.
	         *
	         * Parameters:
	         * geometry - {<OpenLayers.Geometry.Point>} A multipoint geometry.
	         *
	         * Returns:
	         * {DOMElement} A KML GeometryCollection node.
	         */
	        multipoint: function(geometry) {
	            return this.buildGeometry.collection.apply(this, [geometry]);
	        },

	        /**
	         * Method: buildGeometry.linestring
	         * Given an OpenLayers linestring geometry, create a KML linestring.
	         *
	         * Parameters:
	         * geometry - {<OpenLayers.Geometry.LineString>} A linestring geometry.
	         *
	         * Returns:
	         * {DOMElement} A KML linestring node.
	         */
	        linestring: function(geometry) {
	            var kml = this.createElementNS(this.kmlns, "LineString");
	            kml.appendChild(this.buildCoordinatesNode(geometry));
	            return kml;
	        },
	        
	        /**
	         * Method: buildGeometry.multilinestring
	         * Given an OpenLayers multilinestring geometry, create a KML
	         *     GeometryCollection.
	         *
	         * Parameters:
	         * geometry - {<OpenLayers.Geometry.Point>} A multilinestring geometry.
	         *
	         * Returns:
	         * {DOMElement} A KML GeometryCollection node.
	         */
	        multilinestring: function(geometry) {
	            return this.buildGeometry.collection.apply(this, [geometry]);
	        },

	        /**
	         * Method: buildGeometry.linearring
	         * Given an OpenLayers linearring geometry, create a KML linearring.
	         *
	         * Parameters:
	         * geometry - {<OpenLayers.Geometry.LinearRing>} A linearring geometry.
	         *
	         * Returns:
	         * {DOMElement} A KML linearring node.
	         */
	        linearring: function(geometry) {
	            var kml = this.createElementNS(this.kmlns, "LinearRing");
	            kml.appendChild(this.buildCoordinatesNode(geometry));
	            return kml;
	        },
	        
	        /**
	         * Method: buildGeometry.polygon
	         * Given an OpenLayers polygon geometry, create a KML polygon.
	         *
	         * Parameters:
	         * geometry - {<OpenLayers.Geometry.Polygon>} A polygon geometry.
	         *
	         * Returns:
	         * {DOMElement} A KML polygon node.
	         */
	        polygon: function(geometry) {
	            var kml = this.createElementNS(this.kmlns, "Polygon");
	            var rings = geometry.components;
	            var ringMember, ringGeom, type;
	            for(var i=0, len=rings.length; i<len; ++i) {
	                type = (i==0) ? "outerBoundaryIs" : "innerBoundaryIs";
	                ringMember = this.createElementNS(this.kmlns, type);
	                ringGeom = this.buildGeometry.linearring.apply(this,
	                                                               [rings[i]]);
	                ringMember.appendChild(ringGeom);
	                kml.appendChild(ringMember);
	            }
	            return kml;
	        },
	        
	        /**
	         * Method: buildGeometry.multipolygon
	         * Given an OpenLayers multipolygon geometry, create a KML
	         *     GeometryCollection.
	         *
	         * Parameters:
	         * geometry - {<OpenLayers.Geometry.Point>} A multipolygon geometry.
	         *
	         * Returns:
	         * {DOMElement} A KML GeometryCollection node.
	         */
	        multipolygon: function(geometry) {
	            return this.buildGeometry.collection.apply(this, [geometry]);
	        },

	        /**
	         * Method: buildGeometry.collection
	         * Given an OpenLayers geometry collection, create a KML MultiGeometry.
	         *
	         * Parameters:
	         * geometry - {<OpenLayers.Geometry.Collection>} A geometry collection.
	         *
	         * Returns:
	         * {DOMElement} A KML MultiGeometry node.
	         */
	        collection: function(geometry) {
	            var kml = this.createElementNS(this.kmlns, "MultiGeometry");
	            var child;
	            for(var i=0, len=geometry.components.length; i<len; ++i) {
	                child = this.buildGeometryNode.apply(this,
	                                                     [geometry.components[i]]);
	                if(child) {
	                    kml.appendChild(child);
	                }
	            }
	            return kml;
	        }
	    },

	    /**
	     * Method: buildCoordinatesNode
	     * Builds and returns the KML coordinates node with the given geometry
	     * <coordinates>...</coordinates>
	     * 
	     * Parameters:
	     * geometry - {<OpenLayers.Geometry>}
	     * 
	     * Returns:
	     * {DOMElement}
	     */     
	    buildCoordinatesNode: function(geometry) {
	        var coordinatesNode = this.createElementNS(this.kmlns, "coordinates");
	        
	        var path;
	        var points = geometry.components;
	        if(points) {
	            // LineString or LinearRing
	            var point;
	            var numPoints = points.length;
	            var parts = new Array(numPoints);
	            for(var i=0; i<numPoints; ++i) {
	                point = points[i];
	                parts[i] = this.buildCoordinates(point);
	            }
	            path = parts.join(" ");
	        } else {
	            // Point
	            path = this.buildCoordinates(geometry);
	        }
	        
	        var txtNode = this.createTextNode(path);
	        coordinatesNode.appendChild(txtNode);
	        
	        return coordinatesNode;
	    },    
	    
	    /**
	     * Method: buildCoordinates
	     *
	     * Parameters:
	     * point - {<OpenLayers.Geometry.Point>}
	     *
	     * Returns
	     * {String} a coordinate pair
	     */
	    buildCoordinates: function(point) {
	        if (this.internalProjection && this.externalProjection) {
	            point = point.clone();
	            point.transform(this.internalProjection, 
	                               this.externalProjection);
	        }
	        return point.x + "," + point.y;                     
	    },

	    /**
	     * Method: buildExtendedData
	     *
	     * Parameters:
	     * attributes - {Object}
	     *
	     * Returns
	     * {DOMElement} A KML ExtendedData node or {null} if no attributes.
	     */
	    buildExtendedData: function(attributes) {
	        var extendedData = this.createElementNS(this.kmlns, "ExtendedData");
	        for (var attributeName in attributes) {
	            // empty, name, description, styleUrl attributes ignored
	            if (attributes[attributeName] && attributeName != "name" && attributeName != "description" && attributeName != "styleUrl") {
	                var data = this.createElementNS(this.kmlns, "Data");
	                data.setAttribute("name", attributeName);
	                var value = this.createElementNS(this.kmlns, "value");
	                if (typeof attributes[attributeName] == "object") {
	                    // cater for object attributes with 'value' properties
	                    // other object properties will output an empty node
	                    if (attributes[attributeName].value) {
	                        value.appendChild(this.createTextNode(attributes[attributeName].value));
	                    }
	                    if (attributes[attributeName].displayName) {
	                        var displayName = this.createElementNS(this.kmlns, "displayName");
	                        // displayName always written as CDATA
	                        displayName.appendChild(this.getXMLDoc().createCDATASection(attributes[attributeName].displayName));
	                        data.appendChild(displayName);
	                    }
	                } else {
	                    value.appendChild(this.createTextNode(attributes[attributeName]));
	                }
	                data.appendChild(value);
	                extendedData.appendChild(data);
	            }
	        }
	        if (this.isSimpleContent(extendedData)) {
	            return null;
	        } else {
	            return extendedData;
	        }
	    },
	    
	    CLASS_NAME: "OpenLayers.Format.KML" 
	});
	/* ======================================================================
	    OpenLayers/Format/JSON.js
	   ====================================================================== */

	/* Copyright (c) 2006-2015 by OpenLayers Contributors (see authors.txt for
	 * full list of contributors). Published under the 2-clause BSD license.
	 * See license.txt in the OpenLayers distribution or repository for the
	 * full text of the license. */

	/**
	 * Note:
	 * This work draws heavily from the public domain JSON serializer/deserializer
	 *     at http://www.json.org/json.js. Rewritten so that it doesn't modify
	 *     basic data prototypes.
	 */

	/**
	 * @requires OpenLayers/Format.js
	 */

	/**
	 * Class: OpenLayers.Format.JSON
	 * A parser to read/write JSON safely.  Create a new instance with the
	 *     <OpenLayers.Format.JSON> constructor.
	 *
	 * Inherits from:
	 *  - <OpenLayers.Format>
	 */
	OpenLayers.Format.JSON = OpenLayers.Class(OpenLayers.Format, {
	    
	    /**
	     * APIProperty: indent
	     * {String} For "pretty" printing, the indent string will be used once for
	     *     each indentation level.
	     */
	    indent: "    ",
	    
	    /**
	     * APIProperty: space
	     * {String} For "pretty" printing, the space string will be used after
	     *     the ":" separating a name/value pair.
	     */
	    space: " ",
	    
	    /**
	     * APIProperty: newline
	     * {String} For "pretty" printing, the newline string will be used at the
	     *     end of each name/value pair or array item.
	     */
	    newline: "\n",
	    
	    /**
	     * Property: level
	     * {Integer} For "pretty" printing, this is incremented/decremented during
	     *     serialization.
	     */
	    level: 0,

	    /**
	     * Property: pretty
	     * {Boolean} Serialize with extra whitespace for structure.  This is set
	     *     by the <write> method.
	     */
	    pretty: false,

	    /**
	     * Property: nativeJSON
	     * {Boolean} Does the browser support native json?
	     */
	    nativeJSON: (function() {
	        return !!(window.JSON && typeof JSON.parse == "function" && typeof JSON.stringify == "function");
	    })(),

	    /**
	     * Constructor: OpenLayers.Format.JSON
	     * Create a new parser for JSON.
	     *
	     * Parameters:
	     * options - {Object} An optional object whose properties will be set on
	     *     this instance.
	     */

	    /**
	     * APIMethod: read
	     * Deserialize a json string.
	     *
	     * Parameters:
	     * json - {String} A JSON string
	     * filter - {Function} A function which will be called for every key and
	     *     value at every level of the final result. Each value will be
	     *     replaced by the result of the filter function. This can be used to
	     *     reform generic objects into instances of classes, or to transform
	     *     date strings into Date objects.
	     *     
	     * Returns:
	     * {Object} An object, array, string, or number .
	     */
	    read: function(json, filter) {
	        var object;
	        if (this.nativeJSON) {
	            object = JSON.parse(json, filter);
	        } else try {
	            /**
	             * Parsing happens in three stages. In the first stage, we run the
	             *     text against a regular expression which looks for non-JSON
	             *     characters. We are especially concerned with '()' and 'new'
	             *     because they can cause invocation, and '=' because it can
	             *     cause mutation. But just to be safe, we will reject all
	             *     unexpected characters.
	             */
	            if (/^[\],:{}\s]*$/.test(json.replace(/\\["\\\/bfnrtu]/g, '@').
	                                replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, ']').
	                                replace(/(?:^|:|,)(?:\s*\[)+/g, ''))) {

	                /**
	                 * In the second stage we use the eval function to compile the
	                 *     text into a JavaScript structure. The '{' operator is
	                 *     subject to a syntactic ambiguity in JavaScript - it can
	                 *     begin a block or an object literal. We wrap the text in
	                 *     parens to eliminate the ambiguity.
	                 */
	                object = eval('(' + json + ')');

	                /**
	                 * In the optional third stage, we recursively walk the new
	                 *     structure, passing each name/value pair to a filter
	                 *     function for possible transformation.
	                 */
	                if(typeof filter === 'function') {
	                    function walk(k, v) {
	                        if(v && typeof v === 'object') {
	                            for(var i in v) {
	                                if(v.hasOwnProperty(i)) {
	                                    v[i] = walk(i, v[i]);
	                                }
	                            }
	                        }
	                        return filter(k, v);
	                    }
	                    object = walk('', object);
	                }
	            }
	        } catch(e) {
	            // Fall through if the regexp test fails.
	        }

	        if(this.keepData) {
	            this.data = object;
	        }

	        return object;
	    },

	    /**
	     * APIMethod: write
	     * Serialize an object into a JSON string.
	     *
	     * Parameters:
	     * value - {String} The object, array, string, number, boolean or date
	     *     to be serialized.
	     * pretty - {Boolean} Structure the output with newlines and indentation.
	     *     Default is false.
	     *
	     * Returns:
	     * {String} The JSON string representation of the input value.
	     */
	    write: function(value, pretty) {
	        this.pretty = !!pretty;
	        var json = null;
	        var type = typeof value;
	        if(this.serialize[type]) {
	            try {
	                json = (!this.pretty && this.nativeJSON) ?
	                    JSON.stringify(value) :
	                    this.serialize[type].apply(this, [value]);
	            } catch(err) {
	                OpenLayers.Console.error("Trouble serializing: " + err);
	            }
	        }
	        return json;
	    },
	    
	    /**
	     * Method: writeIndent
	     * Output an indentation string depending on the indentation level.
	     *
	     * Returns:
	     * {String} An appropriate indentation string.
	     */
	    writeIndent: function() {
	        var pieces = [];
	        if(this.pretty) {
	            for(var i=0; i<this.level; ++i) {
	                pieces.push(this.indent);
	            }
	        }
	        return pieces.join('');
	    },
	    
	    /**
	     * Method: writeNewline
	     * Output a string representing a newline if in pretty printing mode.
	     *
	     * Returns:
	     * {String} A string representing a new line.
	     */
	    writeNewline: function() {
	        return (this.pretty) ? this.newline : '';
	    },
	    
	    /**
	     * Method: writeSpace
	     * Output a string representing a space if in pretty printing mode.
	     *
	     * Returns:
	     * {String} A space.
	     */
	    writeSpace: function() {
	        return (this.pretty) ? this.space : '';
	    },

	    /**
	     * Property: serialize
	     * Object with properties corresponding to the serializable data types.
	     *     Property values are functions that do the actual serializing.
	     */
	    serialize: {
	        /**
	         * Method: serialize.object
	         * Transform an object into a JSON string.
	         *
	         * Parameters:
	         * object - {Object} The object to be serialized.
	         * 
	         * Returns:
	         * {String} A JSON string representing the object.
	         */
	        'object': function(object) {
	            // three special objects that we want to treat differently
	            if(object == null) {
	                return "null";
	            }
	            if(object.constructor == Date) {
	                return this.serialize.date.apply(this, [object]);
	            }
	            if(object.constructor == Array) {
	                return this.serialize.array.apply(this, [object]);
	            }
	            var pieces = ['{'];
	            this.level += 1;
	            var key, keyJSON, valueJSON;
	            
	            var addComma = false;
	            for(key in object) {
	                if(object.hasOwnProperty(key)) {
	                    // recursive calls need to allow for sub-classing
	                    keyJSON = OpenLayers.Format.JSON.prototype.write.apply(this,
	                                                    [key, this.pretty]);
	                    valueJSON = OpenLayers.Format.JSON.prototype.write.apply(this,
	                                                    [object[key], this.pretty]);
	                    if(keyJSON != null && valueJSON != null) {
	                        if(addComma) {
	                            pieces.push(',');
	                        }
	                        pieces.push(this.writeNewline(), this.writeIndent(),
	                                    keyJSON, ':', this.writeSpace(), valueJSON);
	                        addComma = true;
	                    }
	                }
	            }
	            
	            this.level -= 1;
	            pieces.push(this.writeNewline(), this.writeIndent(), '}');
	            return pieces.join('');
	        },
	        
	        /**
	         * Method: serialize.array
	         * Transform an array into a JSON string.
	         *
	         * Parameters:
	         * array - {Array} The array to be serialized
	         * 
	         * Returns:
	         * {String} A JSON string representing the array.
	         */
	        'array': function(array) {
	            var json;
	            var pieces = ['['];
	            this.level += 1;
	    
	            for(var i=0, len=array.length; i<len; ++i) {
	                // recursive calls need to allow for sub-classing
	                json = OpenLayers.Format.JSON.prototype.write.apply(this,
	                                                    [array[i], this.pretty]);
	                if(json != null) {
	                    if(i > 0) {
	                        pieces.push(',');
	                    }
	                    pieces.push(this.writeNewline(), this.writeIndent(), json);
	                }
	            }

	            this.level -= 1;    
	            pieces.push(this.writeNewline(), this.writeIndent(), ']');
	            return pieces.join('');
	        },
	        
	        /**
	         * Method: serialize.string
	         * Transform a string into a JSON string.
	         *
	         * Parameters:
	         * string - {String} The string to be serialized
	         * 
	         * Returns:
	         * {String} A JSON string representing the string.
	         */
	        'string': function(string) {
	            // If the string contains no control characters, no quote characters, and no
	            // backslash characters, then we can simply slap some quotes around it.
	            // Otherwise we must also replace the offending characters with safe
	            // sequences.    
	            var m = {
	                '\b': '\\b',
	                '\t': '\\t',
	                '\n': '\\n',
	                '\f': '\\f',
	                '\r': '\\r',
	                '"' : '\\"',
	                '\\': '\\\\'
	            };
	            if(/["\\\x00-\x1f]/.test(string)) {
	                return '"' + string.replace(/([\x00-\x1f\\"])/g, function(a, b) {
	                    var c = m[b];
	                    if(c) {
	                        return c;
	                    }
	                    c = b.charCodeAt();
	                    return '\\u00' +
	                        Math.floor(c / 16).toString(16) +
	                        (c % 16).toString(16);
	                }) + '"';
	            }
	            return '"' + string + '"';
	        },

	        /**
	         * Method: serialize.number
	         * Transform a number into a JSON string.
	         *
	         * Parameters:
	         * number - {Number} The number to be serialized.
	         *
	         * Returns:
	         * {String} A JSON string representing the number.
	         */
	        'number': function(number) {
	            return isFinite(number) ? String(number) : "null";
	        },
	        
	        /**
	         * Method: serialize.boolean
	         * Transform a boolean into a JSON string.
	         *
	         * Parameters:
	         * bool - {Boolean} The boolean to be serialized.
	         * 
	         * Returns:
	         * {String} A JSON string representing the boolean.
	         */
	        'boolean': function(bool) {
	            return String(bool);
	        },
	        
	        /**
	         * Method: serialize.object
	         * Transform a date into a JSON string.
	         *
	         * Parameters:
	         * date - {Date} The date to be serialized.
	         * 
	         * Returns:
	         * {String} A JSON string representing the date.
	         */
	        'date': function(date) {    
	            function format(number) {
	                // Format integers to have at least two digits.
	                return (number < 10) ? '0' + number : number;
	            }
	            return '"' + date.getFullYear() + '-' +
	                    format(date.getMonth() + 1) + '-' +
	                    format(date.getDate()) + 'T' +
	                    format(date.getHours()) + ':' +
	                    format(date.getMinutes()) + ':' +
	                    format(date.getSeconds()) + '"';
	        }
	    },

	    CLASS_NAME: "OpenLayers.Format.JSON" 

	});     
	/* ======================================================================
	    OpenLayers/Geometry/MultiLineString.js
	   ====================================================================== */

	/* Copyright (c) 2006-2015 by OpenLayers Contributors (see authors.txt for
	 * full list of contributors). Published under the 2-clause BSD license.
	 * See license.txt in the OpenLayers distribution or repository for the
	 * full text of the license. */

	/**
	 * @requires OpenLayers/Geometry/Collection.js
	 * @requires OpenLayers/Geometry/LineString.js
	 */

	/**
	 * Class: OpenLayers.Geometry.MultiLineString
	 * A MultiLineString is a geometry with multiple <OpenLayers.Geometry.LineString>
	 * components.
	 * 
	 * Inherits from:
	 *  - <OpenLayers.Geometry.Collection>
	 *  - <OpenLayers.Geometry> 
	 */
	OpenLayers.Geometry.MultiLineString = OpenLayers.Class(
	  OpenLayers.Geometry.Collection, {

	    /**
	     * Property: componentTypes
	     * {Array(String)} An array of class names representing the types of
	     * components that the collection can include.  A null value means the
	     * component types are not restricted.
	     */
	    componentTypes: ["OpenLayers.Geometry.LineString"],

	    /**
	     * Constructor: OpenLayers.Geometry.MultiLineString
	     * Constructor for a MultiLineString Geometry.
	     *
	     * Parameters: 
	     * components - {Array(<OpenLayers.Geometry.LineString>)} 
	     *
	     */
	    
	    /**
	     * Method: split
	     * Use this geometry (the source) to attempt to split a target geometry.
	     * 
	     * Parameters:
	     * geometry - {<OpenLayers.Geometry>} The target geometry.
	     * options - {Object} Properties of this object will be used to determine
	     *     how the split is conducted.
	     *
	     * Valid options:
	     * mutual - {Boolean} Split the source geometry in addition to the target
	     *     geometry.  Default is false.
	     * edge - {Boolean} Allow splitting when only edges intersect.  Default is
	     *     true.  If false, a vertex on the source must be within the tolerance
	     *     distance of the intersection to be considered a split.
	     * tolerance - {Number} If a non-null value is provided, intersections
	     *     within the tolerance distance of an existing vertex on the source
	     *     will be assumed to occur at the vertex.
	     * 
	     * Returns:
	     * {Array} A list of geometries (of this same type as the target) that
	     *     result from splitting the target with the source geometry.  The
	     *     source and target geometry will remain unmodified.  If no split
	     *     results, null will be returned.  If mutual is true and a split
	     *     results, return will be an array of two arrays - the first will be
	     *     all geometries that result from splitting the source geometry and
	     *     the second will be all geometries that result from splitting the
	     *     target geometry.
	     */
	    split: function(geometry, options) {
	        var results = null;
	        var mutual = options && options.mutual;
	        var splits, sourceLine, sourceLines, sourceSplit, targetSplit;
	        var sourceParts = [];
	        var targetParts = [geometry];
	        for(var i=0, len=this.components.length; i<len; ++i) {
	            sourceLine = this.components[i];
	            sourceSplit = false;
	            for(var j=0; j < targetParts.length; ++j) { 
	                splits = sourceLine.split(targetParts[j], options);
	                if(splits) {
	                    if(mutual) {
	                        sourceLines = splits[0];
	                        for(var k=0, klen=sourceLines.length; k<klen; ++k) {
	                            if(k===0 && sourceParts.length) {
	                                sourceParts[sourceParts.length-1].addComponent(
	                                    sourceLines[k]
	                                );
	                            } else {
	                                sourceParts.push(
	                                    new OpenLayers.Geometry.MultiLineString([
	                                        sourceLines[k]
	                                    ])
	                                );
	                            }
	                        }
	                        sourceSplit = true;
	                        splits = splits[1];
	                    }
	                    if(splits.length) {
	                        // splice in new target parts
	                        splits.unshift(j, 1);
	                        Array.prototype.splice.apply(targetParts, splits);
	                        break;
	                    }
	                }
	            }
	            if(!sourceSplit) {
	                // source line was not hit
	                if(sourceParts.length) {
	                    // add line to existing multi
	                    sourceParts[sourceParts.length-1].addComponent(
	                        sourceLine.clone()
	                    );
	                } else {
	                    // create a fresh multi
	                    sourceParts = [
	                        new OpenLayers.Geometry.MultiLineString(
	                            sourceLine.clone()
	                        )
	                    ];
	                }
	            }
	        }
	        if(sourceParts && sourceParts.length > 1) {
	            sourceSplit = true;
	        } else {
	            sourceParts = [];
	        }
	        if(targetParts && targetParts.length > 1) {
	            targetSplit = true;
	        } else {
	            targetParts = [];
	        }
	        if(sourceSplit || targetSplit) {
	            if(mutual) {
	                results = [sourceParts, targetParts];
	            } else {
	                results = targetParts;
	            }
	        }
	        return results;
	    },
	    
	    /**
	     * Method: splitWith
	     * Split this geometry (the target) with the given geometry (the source).
	     *
	     * Parameters:
	     * geometry - {<OpenLayers.Geometry>} A geometry used to split this
	     *     geometry (the source).
	     * options - {Object} Properties of this object will be used to determine
	     *     how the split is conducted.
	     *
	     * Valid options:
	     * mutual - {Boolean} Split the source geometry in addition to the target
	     *     geometry.  Default is false.
	     * edge - {Boolean} Allow splitting when only edges intersect.  Default is
	     *     true.  If false, a vertex on the source must be within the tolerance
	     *     distance of the intersection to be considered a split.
	     * tolerance - {Number} If a non-null value is provided, intersections
	     *     within the tolerance distance of an existing vertex on the source
	     *     will be assumed to occur at the vertex.
	     * 
	     * Returns:
	     * {Array} A list of geometries (of this same type as the target) that
	     *     result from splitting the target with the source geometry.  The
	     *     source and target geometry will remain unmodified.  If no split
	     *     results, null will be returned.  If mutual is true and a split
	     *     results, return will be an array of two arrays - the first will be
	     *     all geometries that result from splitting the source geometry and
	     *     the second will be all geometries that result from splitting the
	     *     target geometry.
	     */
	    splitWith: function(geometry, options) {
	        var results = null;
	        var mutual = options && options.mutual;
	        var splits, targetLine, sourceLines, sourceSplit, targetSplit, sourceParts, targetParts;
	        if(geometry instanceof OpenLayers.Geometry.LineString) {
	            targetParts = [];
	            sourceParts = [geometry];
	            for(var i=0, len=this.components.length; i<len; ++i) {
	                targetSplit = false;
	                targetLine = this.components[i];
	                for(var j=0; j<sourceParts.length; ++j) {
	                    splits = sourceParts[j].split(targetLine, options);
	                    if(splits) {
	                        if(mutual) {
	                            sourceLines = splits[0];
	                            if(sourceLines.length) {
	                                // splice in new source parts
	                                sourceLines.unshift(j, 1);
	                                Array.prototype.splice.apply(sourceParts, sourceLines);
	                                j += sourceLines.length - 2;
	                            }
	                            splits = splits[1];
	                            if(splits.length === 0) {
	                                splits = [targetLine.clone()];
	                            }
	                        }
	                        for(var k=0, klen=splits.length; k<klen; ++k) {
	                            if(k===0 && targetParts.length) {
	                                targetParts[targetParts.length-1].addComponent(
	                                    splits[k]
	                                );
	                            } else {
	                                targetParts.push(
	                                    new OpenLayers.Geometry.MultiLineString([
	                                        splits[k]
	                                    ])
	                                );
	                            }
	                        }
	                        targetSplit = true;                    
	                    }
	                }
	                if(!targetSplit) {
	                    // target component was not hit
	                    if(targetParts.length) {
	                        // add it to any existing multi-line
	                        targetParts[targetParts.length-1].addComponent(
	                            targetLine.clone()
	                        );
	                    } else {
	                        // or start with a fresh multi-line
	                        targetParts = [
	                            new OpenLayers.Geometry.MultiLineString([
	                                targetLine.clone()
	                            ])
	                        ];
	                    }
	                    
	                }
	            }
	        } else {
	            results = geometry.split(this);
	        }
	        if(sourceParts && sourceParts.length > 1) {
	            sourceSplit = true;
	        } else {
	            sourceParts = [];
	        }
	        if(targetParts && targetParts.length > 1) {
	            targetSplit = true;
	        } else {
	            targetParts = [];
	        }
	        if(sourceSplit || targetSplit) {
	            if(mutual) {
	                results = [sourceParts, targetParts];
	            } else {
	                results = targetParts;
	            }
	        }
	        return results;
	    },

	    CLASS_NAME: "OpenLayers.Geometry.MultiLineString"
	});
	/* ======================================================================
	    OpenLayers/Geometry/MultiPolygon.js
	   ====================================================================== */

	/* Copyright (c) 2006-2015 by OpenLayers Contributors (see authors.txt for
	 * full list of contributors). Published under the 2-clause BSD license.
	 * See license.txt in the OpenLayers distribution or repository for the
	 * full text of the license. */

	/**
	 * @requires OpenLayers/Geometry/Collection.js
	 * @requires OpenLayers/Geometry/Polygon.js
	 */

	/**
	 * Class: OpenLayers.Geometry.MultiPolygon
	 * MultiPolygon is a geometry with multiple <OpenLayers.Geometry.Polygon>
	 * components.  Create a new instance with the <OpenLayers.Geometry.MultiPolygon>
	 * constructor.
	 * 
	 * Inherits from:
	 *  - <OpenLayers.Geometry.Collection>
	 */
	OpenLayers.Geometry.MultiPolygon = OpenLayers.Class(
	  OpenLayers.Geometry.Collection, {

	    /**
	     * Property: componentTypes
	     * {Array(String)} An array of class names representing the types of
	     * components that the collection can include.  A null value means the
	     * component types are not restricted.
	     */
	    componentTypes: ["OpenLayers.Geometry.Polygon"],

	    /**
	     * Constructor: OpenLayers.Geometry.MultiPolygon
	     * Create a new MultiPolygon geometry
	     *
	     * Parameters:
	     * components - {Array(<OpenLayers.Geometry.Polygon>)} An array of polygons
	     *              used to generate the MultiPolygon
	     *
	     */

	    CLASS_NAME: "OpenLayers.Geometry.MultiPolygon"
	});
	/* ======================================================================
	    OpenLayers/Format/GeoJSON.js
	   ====================================================================== */

	/* Copyright (c) 2006-2015 by OpenLayers Contributors (see authors.txt for
	 * full list of contributors). Published under the 2-clause BSD license.
	 * See license.txt in the OpenLayers distribution or repository for the
	 * full text of the license. */

	/**
	 * @requires OpenLayers/Format/JSON.js
	 * @requires OpenLayers/Feature/Vector.js
	 * @requires OpenLayers/Geometry/Point.js
	 * @requires OpenLayers/Geometry/MultiPoint.js
	 * @requires OpenLayers/Geometry/LineString.js
	 * @requires OpenLayers/Geometry/MultiLineString.js
	 * @requires OpenLayers/Geometry/Polygon.js
	 * @requires OpenLayers/Geometry/MultiPolygon.js
	 * @requires OpenLayers/Console.js
	 */

	/**
	 * Class: OpenLayers.Format.GeoJSON
	 * Read and write GeoJSON. Create a new parser with the
	 *     <OpenLayers.Format.GeoJSON> constructor.
	 *
	 * Inherits from:
	 *  - <OpenLayers.Format.JSON>
	 */
	OpenLayers.Format.GeoJSON = OpenLayers.Class(OpenLayers.Format.JSON, {

	    /**
	     * APIProperty: ignoreExtraDims
	     * {Boolean} Ignore dimensions higher than 2 when reading geometry
	     * coordinates.
	     */ 
	    ignoreExtraDims: false,
	    
	    /**
	     * Constructor: OpenLayers.Format.GeoJSON
	     * Create a new parser for GeoJSON.
	     *
	     * Parameters:
	     * options - {Object} An optional object whose properties will be set on
	     *     this instance.
	     */

	    /**
	     * APIMethod: read
	     * Deserialize a GeoJSON string.
	     *
	     * Parameters:
	     * json - {String} A GeoJSON string
	     * type - {String} Optional string that determines the structure of
	     *     the output.  Supported values are "Geometry", "Feature", and
	     *     "FeatureCollection".  If absent or null, a default of
	     *     "FeatureCollection" is assumed.
	     * filter - {Function} A function which will be called for every key and
	     *     value at every level of the final result. Each value will be
	     *     replaced by the result of the filter function. This can be used to
	     *     reform generic objects into instances of classes, or to transform
	     *     date strings into Date objects.
	     *
	     * Returns: 
	     * {Object} The return depends on the value of the type argument. If type
	     *     is "FeatureCollection" (the default), the return will be an array
	     *     of <OpenLayers.Feature.Vector>. If type is "Geometry", the input json
	     *     must represent a single geometry, and the return will be an
	     *     <OpenLayers.Geometry>.  If type is "Feature", the input json must
	     *     represent a single feature, and the return will be an
	     *     <OpenLayers.Feature.Vector>.
	     */
	    read: function(json, type, filter) {
	        type = (type) ? type : "FeatureCollection";
	        var results = null;
	        var obj = null;
	        if (typeof json == "string") {
	            obj = OpenLayers.Format.JSON.prototype.read.apply(this,
	                                                              [json, filter]);
	        } else { 
	            obj = json;
	        }    
	        if(!obj) {
	            OpenLayers.Console.error("Bad JSON: " + json);
	        } else if(typeof(obj.type) != "string") {
	            OpenLayers.Console.error("Bad GeoJSON - no type: " + json);
	        } else if(this.isValidType(obj, type)) {
	            switch(type) {
	                case "Geometry":
	                    try {
	                        results = this.parseGeometry(obj);
	                    } catch(err) {
	                        OpenLayers.Console.error(err);
	                    }
	                    break;
	                case "Feature":
	                    try {
	                        results = this.parseFeature(obj);
	                        results.type = "Feature";
	                    } catch(err) {
	                        OpenLayers.Console.error(err);
	                    }
	                    break;
	                case "FeatureCollection":
	                    // for type FeatureCollection, we allow input to be any type
	                    results = [];
	                    switch(obj.type) {
	                        case "Feature":
	                            try {
	                                results.push(this.parseFeature(obj));
	                            } catch(err) {
	                                results = null;
	                                OpenLayers.Console.error(err);
	                            }
	                            break;
	                        case "FeatureCollection":
	                            for(var i=0, len=obj.features.length; i<len; ++i) {
	                                try {
	                                    results.push(this.parseFeature(obj.features[i]));
	                                } catch(err) {
	                                    results = null;
	                                    OpenLayers.Console.error(err);
	                                }
	                            }
	                            break;
	                        default:
	                            try {
	                                var geom = this.parseGeometry(obj);
	                                results.push(new OpenLayers.Feature.Vector(geom));
	                            } catch(err) {
	                                results = null;
	                                OpenLayers.Console.error(err);
	                            }
	                    }
	                break;
	            }
	        }
	        return results;
	    },
	    
	    /**
	     * Method: isValidType
	     * Check if a GeoJSON object is a valid representative of the given type.
	     *
	     * Returns:
	     * {Boolean} The object is valid GeoJSON object of the given type.
	     */
	    isValidType: function(obj, type) {
	        var valid = false;
	        switch(type) {
	            case "Geometry":
	                if(OpenLayers.Util.indexOf(
	                    ["Point", "MultiPoint", "LineString", "MultiLineString",
	                     "Polygon", "MultiPolygon", "Box", "GeometryCollection"],
	                    obj.type) == -1) {
	                    // unsupported geometry type
	                    OpenLayers.Console.error("Unsupported geometry type: " +
	                                              obj.type);
	                } else {
	                    valid = true;
	                }
	                break;
	            case "FeatureCollection":
	                // allow for any type to be converted to a feature collection
	                valid = true;
	                break;
	            default:
	                // for Feature types must match
	                if(obj.type == type) {
	                    valid = true;
	                } else {
	                    OpenLayers.Console.error("Cannot convert types from " +
	                                              obj.type + " to " + type);
	                }
	        }
	        return valid;
	    },
	    
	    /**
	     * Method: parseFeature
	     * Convert a feature object from GeoJSON into an
	     *     <OpenLayers.Feature.Vector>.
	     *
	     * Parameters:
	     * obj - {Object} An object created from a GeoJSON object
	     *
	     * Returns:
	     * {<OpenLayers.Feature.Vector>} A feature.
	     */
	    parseFeature: function(obj) {
	        var feature, geometry, attributes, bbox;
	        attributes = (obj.properties) ? obj.properties : {};
	        bbox = (obj.geometry && obj.geometry.bbox) || obj.bbox;
	        try {
	            geometry = this.parseGeometry(obj.geometry);
	        } catch(err) {
	            // deal with bad geometries
	            throw err;
	        }
	        feature = new OpenLayers.Feature.Vector(geometry, attributes);
	        if(bbox) {
	            feature.bounds = OpenLayers.Bounds.fromArray(bbox);
	        }
	        if(obj.id) {
	            feature.fid = obj.id;
	        }
	        return feature;
	    },
	    
	    /**
	     * Method: parseGeometry
	     * Convert a geometry object from GeoJSON into an <OpenLayers.Geometry>.
	     *
	     * Parameters:
	     * obj - {Object} An object created from a GeoJSON object
	     *
	     * Returns: 
	     * {<OpenLayers.Geometry>} A geometry.
	     */
	    parseGeometry: function(obj) {
	        if (obj == null) {
	            return null;
	        }
	        var geometry, collection = false;
	        if(obj.type == "GeometryCollection") {
	            if(!(OpenLayers.Util.isArray(obj.geometries))) {
	                throw "GeometryCollection must have geometries array: " + obj;
	            }
	            var numGeom = obj.geometries.length;
	            var components = new Array(numGeom);
	            for(var i=0; i<numGeom; ++i) {
	                components[i] = this.parseGeometry.apply(
	                    this, [obj.geometries[i]]
	                );
	            }
	            geometry = new OpenLayers.Geometry.Collection(components);
	            collection = true;
	        } else {
	            if(!(OpenLayers.Util.isArray(obj.coordinates))) {
	                throw "Geometry must have coordinates array: " + obj;
	            }
	            if(!this.parseCoords[obj.type.toLowerCase()]) {
	                throw "Unsupported geometry type: " + obj.type;
	            }
	            try {
	                geometry = this.parseCoords[obj.type.toLowerCase()].apply(
	                    this, [obj.coordinates]
	                );
	            } catch(err) {
	                // deal with bad coordinates
	                throw err;
	            }
	        }
	        // We don't reproject collections because the children are reprojected
	        // for us when they are created.
	        if (this.internalProjection && this.externalProjection && !collection) {
	            geometry.transform(this.externalProjection, 
	                               this.internalProjection); 
	        }                       
	        return geometry;
	    },
	    
	    /**
	     * Property: parseCoords
	     * Object with properties corresponding to the GeoJSON geometry types.
	     *     Property values are functions that do the actual parsing.
	     */
	    parseCoords: {
	        /**
	         * Method: parseCoords.point
	         * Convert a coordinate array from GeoJSON into an
	         *     <OpenLayers.Geometry>.
	         *
	         * Parameters:
	         * array - {Object} The coordinates array from the GeoJSON fragment.
	         *
	         * Returns:
	         * {<OpenLayers.Geometry>} A geometry.
	         */
	        "point": function(array) {
	            if (this.ignoreExtraDims == false && 
	                  array.length != 2) {
	                    throw "Only 2D points are supported: " + array;
	            }
	            return new OpenLayers.Geometry.Point(array[0], array[1]);
	        },
	        
	        /**
	         * Method: parseCoords.multipoint
	         * Convert a coordinate array from GeoJSON into an
	         *     <OpenLayers.Geometry>.
	         *
	         * Parameters:
	         * array - {Object} The coordinates array from the GeoJSON fragment.
	         *
	         * Returns:
	         * {<OpenLayers.Geometry>} A geometry.
	         */
	        "multipoint": function(array) {
	            var points = [];
	            var p = null;
	            for(var i=0, len=array.length; i<len; ++i) {
	                try {
	                    p = this.parseCoords["point"].apply(this, [array[i]]);
	                } catch(err) {
	                    throw err;
	                }
	                points.push(p);
	            }
	            return new OpenLayers.Geometry.MultiPoint(points);
	        },

	        /**
	         * Method: parseCoords.linestring
	         * Convert a coordinate array from GeoJSON into an
	         *     <OpenLayers.Geometry>.
	         *
	         * Parameters:
	         * array - {Object} The coordinates array from the GeoJSON fragment.
	         *
	         * Returns:
	         * {<OpenLayers.Geometry>} A geometry.
	         */
	        "linestring": function(array) {
	            var points = [];
	            var p = null;
	            for(var i=0, len=array.length; i<len; ++i) {
	                try {
	                    p = this.parseCoords["point"].apply(this, [array[i]]);
	                } catch(err) {
	                    throw err;
	                }
	                points.push(p);
	            }
	            return new OpenLayers.Geometry.LineString(points);
	        },
	        
	        /**
	         * Method: parseCoords.multilinestring
	         * Convert a coordinate array from GeoJSON into an
	         *     <OpenLayers.Geometry>.
	         *
	         * Parameters:
	         * array - {Object} The coordinates array from the GeoJSON fragment.
	         *
	         * Returns:
	         * {<OpenLayers.Geometry>} A geometry.
	         */
	        "multilinestring": function(array) {
	            var lines = [];
	            var l = null;
	            for(var i=0, len=array.length; i<len; ++i) {
	                try {
	                    l = this.parseCoords["linestring"].apply(this, [array[i]]);
	                } catch(err) {
	                    throw err;
	                }
	                lines.push(l);
	            }
	            return new OpenLayers.Geometry.MultiLineString(lines);
	        },
	        
	        /**
	         * Method: parseCoords.polygon
	         * Convert a coordinate array from GeoJSON into an
	         *     <OpenLayers.Geometry>.
	         *
	         * Returns:
	         * {<OpenLayers.Geometry>} A geometry.
	         */
	        "polygon": function(array) {
	            var rings = [];
	            var r, l;
	            for(var i=0, len=array.length; i<len; ++i) {
	                try {
	                    l = this.parseCoords["linestring"].apply(this, [array[i]]);
	                } catch(err) {
	                    throw err;
	                }
	                r = new OpenLayers.Geometry.LinearRing(l.components);
	                rings.push(r);
	            }
	            return new OpenLayers.Geometry.Polygon(rings);
	        },

	        /**
	         * Method: parseCoords.multipolygon
	         * Convert a coordinate array from GeoJSON into an
	         *     <OpenLayers.Geometry>.
	         *
	         * Parameters:
	         * array - {Object} The coordinates array from the GeoJSON fragment.
	         *
	         * Returns:
	         * {<OpenLayers.Geometry>} A geometry.
	         */
	        "multipolygon": function(array) {
	            var polys = [];
	            var p = null;
	            for(var i=0, len=array.length; i<len; ++i) {
	                try {
	                    p = this.parseCoords["polygon"].apply(this, [array[i]]);
	                } catch(err) {
	                    throw err;
	                }
	                polys.push(p);
	            }
	            return new OpenLayers.Geometry.MultiPolygon(polys);
	        },

	        /**
	         * Method: parseCoords.box
	         * Convert a coordinate array from GeoJSON into an
	         *     <OpenLayers.Geometry>.
	         *
	         * Parameters:
	         * array - {Object} The coordinates array from the GeoJSON fragment.
	         *
	         * Returns:
	         * {<OpenLayers.Geometry>} A geometry.
	         */
	        "box": function(array) {
	            if(array.length != 2) {
	                throw "GeoJSON box coordinates must have 2 elements";
	            }
	            return new OpenLayers.Geometry.Polygon([
	                new OpenLayers.Geometry.LinearRing([
	                    new OpenLayers.Geometry.Point(array[0][0], array[0][1]),
	                    new OpenLayers.Geometry.Point(array[1][0], array[0][1]),
	                    new OpenLayers.Geometry.Point(array[1][0], array[1][1]),
	                    new OpenLayers.Geometry.Point(array[0][0], array[1][1]),
	                    new OpenLayers.Geometry.Point(array[0][0], array[0][1])
	                ])
	            ]);
	        }

	    },

	    /**
	     * APIMethod: write
	     * Serialize a feature, geometry, array of features into a GeoJSON string.
	     *
	     * Parameters:
	     * obj - {Object} An <OpenLayers.Feature.Vector>, <OpenLayers.Geometry>,
	     *     or an array of features.
	     * pretty - {Boolean} Structure the output with newlines and indentation.
	     *     Default is false.
	     *
	     * Returns:
	     * {String} The GeoJSON string representation of the input geometry,
	     *     features, or array of features.
	     */
	    write: function(obj, pretty) {
	        var geojson = {
	            "type": null
	        };
	        if(OpenLayers.Util.isArray(obj)) {
	            geojson.type = "FeatureCollection";
	            var numFeatures = obj.length;
	            geojson.features = new Array(numFeatures);
	            for(var i=0; i<numFeatures; ++i) {
	                var element = obj[i];
	                if(!element instanceof OpenLayers.Feature.Vector) {
	                    var msg = "FeatureCollection only supports collections " +
	                              "of features: " + element;
	                    throw msg;
	                }
	                geojson.features[i] = this.extract.feature.apply(
	                    this, [element]
	                );
	            }
	        } else if (obj.CLASS_NAME.indexOf("OpenLayers.Geometry") == 0) {
	            geojson = this.extract.geometry.apply(this, [obj]);
	        } else if (obj instanceof OpenLayers.Feature.Vector) {
	            geojson = this.extract.feature.apply(this, [obj]);
	            if(obj.layer && obj.layer.projection) {
	                geojson.crs = this.createCRSObject(obj);
	            }
	        }
	        return OpenLayers.Format.JSON.prototype.write.apply(this,
	                                                            [geojson, pretty]);
	    },

	    /**
	     * Method: createCRSObject
	     * Create the CRS object for an object.
	     *
	     * Parameters:
	     * object - {<OpenLayers.Feature.Vector>} 
	     *
	     * Returns:
	     * {Object} An object which can be assigned to the crs property
	     * of a GeoJSON object.
	     */
	    createCRSObject: function(object) {
	       var proj = object.layer.projection.toString();
	       var crs = {};
	       if (proj.match(/epsg:/i)) {
	           var code = parseInt(proj.substring(proj.indexOf(":") + 1));
	           if (code == 4326) {
	               crs = {
	                   "type": "name",
	                   "properties": {
	                       "name": "urn:ogc:def:crs:OGC:1.3:CRS84"
	                   }
	               };
	           } else {    
	               crs = {
	                   "type": "name",
	                   "properties": {
	                       "name": "EPSG:" + code
	                   }
	               };
	           }    
	       }
	       return crs;
	    },
	    
	    /**
	     * Property: extract
	     * Object with properties corresponding to the GeoJSON types.
	     *     Property values are functions that do the actual value extraction.
	     */
	    extract: {
	        /**
	         * Method: extract.feature
	         * Return a partial GeoJSON object representing a single feature.
	         *
	         * Parameters:
	         * feature - {<OpenLayers.Feature.Vector>}
	         *
	         * Returns:
	         * {Object} An object representing the point.
	         */
	        'feature': function(feature) {
	            var geom = this.extract.geometry.apply(this, [feature.geometry]);
	            var json = {
	                "type": "Feature",
	                "properties": feature.attributes,
	                "geometry": geom
	            };
	            if (feature.fid != null) {
	                json.id = feature.fid;
	            }
	            return json;
	        },
	        
	        /**
	         * Method: extract.geometry
	         * Return a GeoJSON object representing a single geometry.
	         *
	         * Parameters:
	         * geometry - {<OpenLayers.Geometry>}
	         *
	         * Returns:
	         * {Object} An object representing the geometry.
	         */
	        'geometry': function(geometry) {
	            if (geometry == null) {
	                return null;
	            }
	            if (this.internalProjection && this.externalProjection) {
	                geometry = geometry.clone();
	                geometry.transform(this.internalProjection, 
	                                   this.externalProjection);
	            }                       
	            var geometryType = geometry.CLASS_NAME.split('.')[2];
	            var data = this.extract[geometryType.toLowerCase()].apply(this, [geometry]);
	            var json;
	            if(geometryType == "Collection") {
	                json = {
	                    "type": "GeometryCollection",
	                    "geometries": data
	                };
	            } else {
	                json = {
	                    "type": geometryType,
	                    "coordinates": data
	                };
	            }
	            
	            return json;
	        },

	        /**
	         * Method: extract.point
	         * Return an array of coordinates from a point.
	         *
	         * Parameters:
	         * point - {<OpenLayers.Geometry.Point>}
	         *
	         * Returns: 
	         * {Array} An array of coordinates representing the point.
	         */
	        'point': function(point) {
	            return [point.x, point.y];
	        },

	        /**
	         * Method: extract.multipoint
	         * Return an array of point coordinates from a multipoint.
	         *
	         * Parameters:
	         * multipoint - {<OpenLayers.Geometry.MultiPoint>}
	         *
	         * Returns:
	         * {Array} An array of point coordinate arrays representing
	         *     the multipoint.
	         */
	        'multipoint': function(multipoint) {
	            var array = [];
	            for(var i=0, len=multipoint.components.length; i<len; ++i) {
	                array.push(this.extract.point.apply(this, [multipoint.components[i]]));
	            }
	            return array;
	        },
	        
	        /**
	         * Method: extract.linestring
	         * Return an array of coordinate arrays from a linestring.
	         *
	         * Parameters:
	         * linestring - {<OpenLayers.Geometry.LineString>}
	         *
	         * Returns:
	         * {Array} An array of coordinate arrays representing
	         *     the linestring.
	         */
	        'linestring': function(linestring) {
	            var array = [];
	            for(var i=0, len=linestring.components.length; i<len; ++i) {
	                array.push(this.extract.point.apply(this, [linestring.components[i]]));
	            }
	            return array;
	        },

	        /**
	         * Method: extract.multilinestring
	         * Return an array of linestring arrays from a linestring.
	         * 
	         * Parameters:
	         * multilinestring - {<OpenLayers.Geometry.MultiLineString>}
	         * 
	         * Returns:
	         * {Array} An array of linestring arrays representing
	         *     the multilinestring.
	         */
	        'multilinestring': function(multilinestring) {
	            var array = [];
	            for(var i=0, len=multilinestring.components.length; i<len; ++i) {
	                array.push(this.extract.linestring.apply(this, [multilinestring.components[i]]));
	            }
	            return array;
	        },
	        
	        /**
	         * Method: extract.polygon
	         * Return an array of linear ring arrays from a polygon.
	         *
	         * Parameters:
	         * polygon - {<OpenLayers.Geometry.Polygon>}
	         * 
	         * Returns:
	         * {Array} An array of linear ring arrays representing the polygon.
	         */
	        'polygon': function(polygon) {
	            var array = [];
	            for(var i=0, len=polygon.components.length; i<len; ++i) {
	                array.push(this.extract.linestring.apply(this, [polygon.components[i]]));
	            }
	            return array;
	        },

	        /**
	         * Method: extract.multipolygon
	         * Return an array of polygon arrays from a multipolygon.
	         * 
	         * Parameters:
	         * multipolygon - {<OpenLayers.Geometry.MultiPolygon>}
	         * 
	         * Returns:
	         * {Array} An array of polygon arrays representing
	         *     the multipolygon
	         */
	        'multipolygon': function(multipolygon) {
	            var array = [];
	            for(var i=0, len=multipolygon.components.length; i<len; ++i) {
	                array.push(this.extract.polygon.apply(this, [multipolygon.components[i]]));
	            }
	            return array;
	        },
	        
	        /**
	         * Method: extract.collection
	         * Return an array of geometries from a geometry collection.
	         * 
	         * Parameters:
	         * collection - {<OpenLayers.Geometry.Collection>}
	         * 
	         * Returns:
	         * {Array} An array of geometry objects representing the geometry
	         *     collection.
	         */
	        'collection': function(collection) {
	            var len = collection.components.length;
	            var array = new Array(len);
	            for(var i=0; i<len; ++i) {
	                array[i] = this.extract.geometry.apply(
	                    this, [collection.components[i]]
	                );
	            }
	            return array;
	        }
	        

	    },

	    CLASS_NAME: "OpenLayers.Format.GeoJSON" 

	});     
	/* ======================================================================
	    OpenLayers/Control.js
	   ====================================================================== */

	/* Copyright (c) 2006-2015 by OpenLayers Contributors (see authors.txt for
	 * full list of contributors). Published under the 2-clause BSD license.
	 * See license.txt in the OpenLayers distribution or repository for the
	 * full text of the license. */

	/**
	 * @requires OpenLayers/BaseTypes/Class.js
	 */

	/**
	 * Class: OpenLayers.Control
	 * Controls affect the display or behavior of the map. They allow everything
	 * from panning and zooming to displaying a scale indicator. Controls by 
	 * default are added to the map they are contained within however it is
	 * possible to add a control to an external div by passing the div in the
	 * options parameter.
	 * 
	 * Example:
	 * The following example shows how to add many of the common controls
	 * to a map.
	 * 
	 * > var map = new OpenLayers.Map('map', { controls: [] });
	 * >
	 * > map.addControl(new OpenLayers.Control.PanZoomBar());
	 * > map.addControl(new OpenLayers.Control.LayerSwitcher({'ascending':false}));
	 * > map.addControl(new OpenLayers.Control.Permalink());
	 * > map.addControl(new OpenLayers.Control.Permalink('permalink'));
	 * > map.addControl(new OpenLayers.Control.MousePosition());
	 * > map.addControl(new OpenLayers.Control.OverviewMap());
	 * > map.addControl(new OpenLayers.Control.KeyboardDefaults());
	 *
	 * The next code fragment is a quick example of how to intercept 
	 * shift-mouse click to display the extent of the bounding box
	 * dragged out by the user.  Usually controls are not created
	 * in exactly this manner.  See the source for a more complete 
	 * example:
	 *
	 * > var control = new OpenLayers.Control();
	 * > OpenLayers.Util.extend(control, {
	 * >     draw: function () {
	 * >         // this Handler.Box will intercept the shift-mousedown
	 * >         // before Control.MouseDefault gets to see it
	 * >         this.box = new OpenLayers.Handler.Box( control, 
	 * >             {"done": this.notice},
	 * >             {keyMask: OpenLayers.Handler.MOD_SHIFT});
	 * >         this.box.activate();
	 * >     },
	 * >
	 * >     notice: function (bounds) {
	 * >         OpenLayers.Console.userError(bounds);
	 * >     }
	 * > }); 
	 * > map.addControl(control);
	 * 
	 */
	OpenLayers.Control = OpenLayers.Class({

	    /** 
	     * Property: id 
	     * {String} 
	     */
	    id: null,
	    
	    /** 
	     * Property: map 
	     * {<OpenLayers.Map>} this gets set in the addControl() function in
	     * OpenLayers.Map 
	     */
	    map: null,

	    /** 
	     * APIProperty: div 
	     * {DOMElement} The element that contains the control, if not present the 
	     *     control is placed inside the map.
	     */
	    div: null,

	    /** 
	     * APIProperty: type 
	     * {Number} Controls can have a 'type'. The type determines the type of
	     * interactions which are possible with them when they are placed in an
	     * <OpenLayers.Control.Panel>. 
	     */
	    type: null, 

	    /** 
	     * Property: allowSelection
	     * {Boolean} By default, controls do not allow selection, because
	     * it may interfere with map dragging. If this is true, OpenLayers
	     * will not prevent selection of the control.
	     * Default is false.
	     */
	    allowSelection: false,  

	    /** 
	     * Property: displayClass 
	     * {string}  This property is used for CSS related to the drawing of the
	     * Control. 
	     */
	    displayClass: "",
	    
	    /**
	    * APIProperty: title  
	    * {string}  This property is used for showing a tooltip over the  
	    * Control.  
	    */ 
	    title: "",

	    /**
	     * APIProperty: autoActivate
	     * {Boolean} Activate the control when it is added to a map.  Default is
	     *     false.
	     */
	    autoActivate: false,

	    /** 
	     * APIProperty: active 
	     * {Boolean} The control is active (read-only).  Use <activate> and 
	     *     <deactivate> to change control state.
	     */
	    active: null,

	    /**
	     * Property: handlerOptions
	     * {Object} Used to set non-default properties on the control's handler
	     */
	    handlerOptions: null,

	    /** 
	     * Property: handler 
	     * {<OpenLayers.Handler>} null
	     */
	    handler: null,

	    /**
	     * APIProperty: eventListeners
	     * {Object} If set as an option at construction, the eventListeners
	     *     object will be registered with <OpenLayers.Events.on>.  Object
	     *     structure must be a listeners object as shown in the example for
	     *     the events.on method.
	     */
	    eventListeners: null,

	    /** 
	     * APIProperty: events
	     * {<OpenLayers.Events>} Events instance for listeners and triggering
	     *     control specific events.
	     *
	     * Register a listener for a particular event with the following syntax:
	     * (code)
	     * control.events.register(type, obj, listener);
	     * (end)
	     *
	     * Listeners will be called with a reference to an event object.  The
	     *     properties of this event depends on exactly what happened.
	     *
	     * All event objects have at least the following properties:
	     * object - {Object} A reference to control.events.object (a reference
	     *      to the control).
	     * element - {DOMElement} A reference to control.events.element (which
	     *      will be null unless documented otherwise).
	     *
	     * Supported map event types:
	     * activate - Triggered when activated.
	     * deactivate - Triggered when deactivated.
	     */
	    events: null,

	    /**
	     * Constructor: OpenLayers.Control
	     * Create an OpenLayers Control.  The options passed as a parameter
	     * directly extend the control.  For example passing the following:
	     * 
	     * > var control = new OpenLayers.Control({div: myDiv});
	     *
	     * Overrides the default div attribute value of null.
	     * 
	     * Parameters:
	     * options - {Object} 
	     */
	    initialize: function (options) {
	        // We do this before the extend so that instances can override
	        // className in options.
	        this.displayClass = 
	            this.CLASS_NAME.replace("OpenLayers.", "ol").replace(/\./g, "");
	        
	        OpenLayers.Util.extend(this, options);
	        
	        this.events = new OpenLayers.Events(this);
	        if(this.eventListeners instanceof Object) {
	            this.events.on(this.eventListeners);
	        }
	        if (this.id == null) {
	            this.id = OpenLayers.Util.createUniqueID(this.CLASS_NAME + "_");
	        }
	    },

	    /**
	     * Method: destroy
	     * The destroy method is used to perform any clean up before the control
	     * is dereferenced.  Typically this is where event listeners are removed
	     * to prevent memory leaks.
	     */
	    destroy: function () {
	        if(this.events) {
	            if(this.eventListeners) {
	                this.events.un(this.eventListeners);
	            }
	            this.events.destroy();
	            this.events = null;
	        }
	        this.eventListeners = null;

	        // eliminate circular references
	        if (this.handler) {
	            this.handler.destroy();
	            this.handler = null;
	        }
	        if(this.handlers) {
	            for(var key in this.handlers) {
	                if(this.handlers.hasOwnProperty(key) &&
	                   typeof this.handlers[key].destroy == "function") {
	                    this.handlers[key].destroy();
	                }
	            }
	            this.handlers = null;
	        }
	        if (this.map) {
	            this.map.removeControl(this);
	            this.map = null;
	        }
	        this.div = null;
	    },

	    /** 
	     * Method: setMap
	     * Set the map property for the control. This is done through an accessor
	     * so that subclasses can override this and take special action once 
	     * they have their map variable set. 
	     *
	     * Parameters:
	     * map - {<OpenLayers.Map>} 
	     */
	    setMap: function(map) {
	        this.map = map;
	        if (this.handler) {
	            this.handler.setMap(map);
	        }
	    },
	  
	    /**
	     * Method: draw
	     * The draw method is called when the control is ready to be displayed
	     * on the page.  If a div has not been created one is created.  Controls
	     * with a visual component will almost always want to override this method 
	     * to customize the look of control. 
	     *
	     * Parameters:
	     * px - {<OpenLayers.Pixel>} The top-left pixel position of the control
	     *      or null.
	     *
	     * Returns:
	     * {DOMElement} A reference to the DIV DOMElement containing the control
	     */
	    draw: function (px) {
	        if (this.div == null) {
	            this.div = OpenLayers.Util.createDiv(this.id);
	            this.div.className = this.displayClass;
	            if (!this.allowSelection) {
	                this.div.className += " olControlNoSelect";
	                this.div.setAttribute("unselectable", "on", 0);
	                this.div.onselectstart = OpenLayers.Function.False; 
	            }    
	            if (this.title != "") {
	                this.div.title = this.title;
	            }
	        }
	        if (px != null) {
	            this.position = px.clone();
	        }
	        this.moveTo(this.position);
	        return this.div;
	    },

	    /**
	     * Method: moveTo
	     * Sets the left and top style attributes to the passed in pixel 
	     * coordinates.
	     *
	     * Parameters:
	     * px - {<OpenLayers.Pixel>}
	     */
	    moveTo: function (px) {
	        if ((px != null) && (this.div != null)) {
	            this.div.style.left = px.x + "px";
	            this.div.style.top = px.y + "px";
	        }
	    },

	    /**
	     * APIMethod: activate
	     * Explicitly activates a control and its associated
	     * handler if one has been set.  Controls can be
	     * deactivated by calling the deactivate() method.
	     * 
	     * Returns:
	     * {Boolean}  True if the control was successfully activated or
	     *            false if the control was already active.
	     */
	    activate: function () {
	        if (this.active) {
	            return false;
	        }
	        if (this.handler) {
	            this.handler.activate();
	        }
	        this.active = true;
	        if(this.map) {
	            OpenLayers.Element.addClass(
	                this.map.viewPortDiv,
	                this.displayClass.replace(/ /g, "") + "Active"
	            );
	        }
	        this.events.triggerEvent("activate");
	        return true;
	    },
	    
	    /**
	     * APIMethod: deactivate
	     * Deactivates a control and its associated handler if any.  The exact
	     * effect of this depends on the control itself.
	     * 
	     * Returns:
	     * {Boolean} True if the control was effectively deactivated or false
	     *           if the control was already inactive.
	     */
	    deactivate: function () {
	        if (this.active) {
	            if (this.handler) {
	                this.handler.deactivate();
	            }
	            this.active = false;
	            if(this.map) {
	                OpenLayers.Element.removeClass(
	                    this.map.viewPortDiv,
	                    this.displayClass.replace(/ /g, "") + "Active"
	                );
	            }
	            this.events.triggerEvent("deactivate");
	            return true;
	        }
	        return false;
	    },

	    CLASS_NAME: "OpenLayers.Control"
	});

	/**
	 * Constant: OpenLayers.Control.TYPE_BUTTON
	 */
	OpenLayers.Control.TYPE_BUTTON = 1;

	/**
	 * Constant: OpenLayers.Control.TYPE_TOGGLE
	 */
	OpenLayers.Control.TYPE_TOGGLE = 2;

	/**
	 * Constant: OpenLayers.Control.TYPE_TOOL
	 */
	OpenLayers.Control.TYPE_TOOL   = 3;
	/* ======================================================================
	    OpenLayers/Control/DrawFeature.js
	   ====================================================================== */

	/* Copyright (c) 2006-2015 by OpenLayers Contributors (see authors.txt for
	 * full list of contributors). Published under the 2-clause BSD license.
	 * See license.txt in the OpenLayers distribution or repository for the
	 * full text of the license. */


	/**
	 * @requires OpenLayers/Control.js
	 * @requires OpenLayers/Feature/Vector.js
	 */

	/**
	 * Class: OpenLayers.Control.DrawFeature
	 * The DrawFeature control draws point, line or polygon features on a vector
	 * layer when active.
	 *
	 * Inherits from:
	 *  - <OpenLayers.Control>
	 */
	OpenLayers.Control.DrawFeature = OpenLayers.Class(OpenLayers.Control, {
	    
	    /**
	     * Property: layer
	     * {<OpenLayers.Layer.Vector>}
	     */
	    layer: null,

	    /**
	     * Property: callbacks
	     * {Object} The functions that are sent to the handler for callback
	     */
	    callbacks: null,
	    
	    /** 
	     * APIProperty: events
	     * {<OpenLayers.Events>} Events instance for listeners and triggering
	     *     control specific events.
	     *
	     * Register a listener for a particular event with the following syntax:
	     * (code)
	     * control.events.register(type, obj, listener);
	     * (end)
	     *
	     * Supported event types (in addition to those from <OpenLayers.Control.events>):
	     * featureadded - Triggered when a feature is added
	     */
	    
	    /**
	     * APIProperty: multi
	     * {Boolean} Cast features to multi-part geometries before passing to the
	     *     layer.  Default is false.
	     */
	    multi: false,

	    /**
	     * APIProperty: featureAdded
	     * {Function} Called after each feature is added
	     */
	    featureAdded: function() {},

	    /**
	     * APIProperty: handlerOptions
	     * {Object} Used to set non-default properties on the control's handler
	     */
	    
	    /**
	     * Constructor: OpenLayers.Control.DrawFeature
	     * 
	     * Parameters:
	     * layer - {<OpenLayers.Layer.Vector>} 
	     * handler - {<OpenLayers.Handler>} 
	     * options - {Object} 
	     */
	    initialize: function(layer, handler, options) {
	        OpenLayers.Control.prototype.initialize.apply(this, [options]);
	        this.callbacks = OpenLayers.Util.extend(
	            {
	                done: this.drawFeature,
	                modify: function(vertex, feature) {
	                    this.layer.events.triggerEvent(
	                        "sketchmodified", {vertex: vertex, feature: feature}
	                    );
	                },
	                create: function(vertex, feature) {
	                    this.layer.events.triggerEvent(
	                        "sketchstarted", {vertex: vertex, feature: feature}
	                    );
	                }
	            },
	            this.callbacks
	        );
	        this.layer = layer;
	        this.handlerOptions = this.handlerOptions || {};
	        this.handlerOptions.layerOptions = OpenLayers.Util.applyDefaults(
	            this.handlerOptions.layerOptions, {
	                renderers: layer.renderers, rendererOptions: layer.rendererOptions
	            }
	        );
	        if (!("multi" in this.handlerOptions)) {
	            this.handlerOptions.multi = this.multi;
	        }
	        var sketchStyle = this.layer.styleMap && this.layer.styleMap.styles.temporary;
	        if(sketchStyle) {
	            this.handlerOptions.layerOptions = OpenLayers.Util.applyDefaults(
	                this.handlerOptions.layerOptions,
	                {styleMap: new OpenLayers.StyleMap({"default": sketchStyle})}
	            );
	        }
	        this.handler = new handler(this, this.callbacks, this.handlerOptions);
	    },

	    /**
	     * Method: drawFeature
	     */
	    drawFeature: function(geometry) {
	        var feature = new OpenLayers.Feature.Vector(geometry);
	        var proceed = this.layer.events.triggerEvent(
	            "sketchcomplete", {feature: feature}
	        );
	        if(proceed !== false) {
	            feature.state = OpenLayers.State.INSERT;
	            this.layer.addFeatures([feature]);
	            this.featureAdded(feature);
	            this.events.triggerEvent("featureadded",{feature : feature});
	        }
	    },
	    
	    /**
	     * APIMethod: insertXY
	     * Insert a point in the current sketch given x & y coordinates.
	     *
	     * Parameters:
	     * x - {Number} The x-coordinate of the point.
	     * y - {Number} The y-coordinate of the point.
	     */
	    insertXY: function(x, y) {
	        if (this.handler && this.handler.line) {
	            this.handler.insertXY(x, y);
	        }
	    },

	    /**
	     * APIMethod: insertDeltaXY
	     * Insert a point given offsets from the previously inserted point.
	     *
	     * Parameters:
	     * dx - {Number} The x-coordinate offset of the point.
	     * dy - {Number} The y-coordinate offset of the point.
	     */
	    insertDeltaXY: function(dx, dy) {
	        if (this.handler && this.handler.line) {
	            this.handler.insertDeltaXY(dx, dy);
	        }
	    },

	    /**
	     * APIMethod: insertDirectionLength
	     * Insert a point in the current sketch given a direction and a length.
	     *
	     * Parameters:
	     * direction - {Number} Degrees clockwise from the positive x-axis.
	     * length - {Number} Distance from the previously drawn point.
	     */
	    insertDirectionLength: function(direction, length) {
	        if (this.handler && this.handler.line) {
	            this.handler.insertDirectionLength(direction, length);
	        }
	    },

	    /**
	     * APIMethod: insertDeflectionLength
	     * Insert a point in the current sketch given a deflection and a length.
	     *     The deflection should be degrees clockwise from the previously 
	     *     digitized segment.
	     *
	     * Parameters:
	     * deflection - {Number} Degrees clockwise from the previous segment.
	     * length - {Number} Distance from the previously drawn point.
	     */
	    insertDeflectionLength: function(deflection, length) {
	        if (this.handler && this.handler.line) {
	            this.handler.insertDeflectionLength(deflection, length);
	        }
	    },
	    
	    /**
	     * APIMethod: undo
	     * Remove the most recently added point in the current sketch geometry.
	     *
	     * Returns: 
	     * {Boolean} An edit was undone.
	     */
	    undo: function() {
	        return this.handler.undo && this.handler.undo();
	    },
	    
	    /**
	     * APIMethod: redo
	     * Reinsert the most recently removed point resulting from an <undo> call.
	     *     The undo stack is deleted whenever a point is added by other means.
	     *
	     * Returns: 
	     * {Boolean} An edit was redone.
	     */
	    redo: function() {
	        return this.handler.redo && this.handler.redo();
	    },
	    
	    /**
	     * APIMethod: finishSketch
	     * Finishes the sketch without including the currently drawn point.
	     *     This method can be called to terminate drawing programmatically
	     *     instead of waiting for the user to end the sketch.
	     */
	    finishSketch: function() {
	        this.handler.finishGeometry();
	    },

	    /**
	     * APIMethod: cancel
	     * Cancel the current sketch.  This removes the current sketch and keeps
	     *     the drawing control active.
	     */
	    cancel: function() {
	        this.handler.cancel();
	    },

	    CLASS_NAME: "OpenLayers.Control.DrawFeature"
	});
	/* ======================================================================
	    OpenLayers/Control/MousePosition.js
	   ====================================================================== */

	/* Copyright (c) 2006-2015 by OpenLayers Contributors (see authors.txt for
	 * full list of contributors). Published under the 2-clause BSD license.
	 * See license.txt in the OpenLayers distribution or repository for the
	 * full text of the license. */


	/**
	 * @requires OpenLayers/Control.js
	 */

	/**
	 * Class: OpenLayers.Control.MousePosition
	 * The MousePosition control displays geographic coordinates of the mouse
	 * pointer, as it is moved about the map.
	 *
	 * You can use the <prefix>- or <suffix>-properties to provide more information
	 * about the displayed coordinates to the user:
	 *
	 * (code)
	 *     var mousePositionCtrl = new OpenLayers.Control.MousePosition({
	 *         prefix: '<a target="_blank" ' +
	 *             'href="http://spatialreference.org/ref/epsg/4326/">' +
	 *             'EPSG:4326</a> coordinates: '
	 *         }
	 *     );
	 * (end code)
	 *
	 * Inherits from:
	 *  - <OpenLayers.Control>
	 */
	OpenLayers.Control.MousePosition = OpenLayers.Class(OpenLayers.Control, {

	    /**
	     * APIProperty: autoActivate
	     * {Boolean} Activate the control when it is added to a map.  Default is
	     *     true.
	     */
	    autoActivate: true,

	    /**
	     * Property: element
	     * {DOMElement}
	     */
	    element: null,

	    /**
	     * APIProperty: prefix
	     * {String} A string to be prepended to the current pointers coordinates
	     *     when it is rendered.  Defaults to the empty string ''.
	     */
	    prefix: '',

	    /**
	     * APIProperty: separator
	     * {String} A string to be used to separate the two coordinates from each
	     *     other.  Defaults to the string ', ', which will result in a
	     *     rendered coordinate of e.g. '42.12, 21.22'.
	     */
	    separator: ', ',

	    /**
	     * APIProperty: suffix
	     * {String} A string to be appended to the current pointers coordinates
	     *     when it is rendered.  Defaults to the empty string ''.
	     */
	    suffix: '',

	    /**
	     * APIProperty: numDigits
	     * {Integer} The number of digits each coordinate shall have when being
	     *     rendered, Defaults to 5.
	     */
	    numDigits: 5,

	    /**
	     * APIProperty: granularity
	     * {Integer}
	     */
	    granularity: 10,

	    /**
	     * APIProperty: emptyString
	     * {String} Set this to some value to set when the mouse is outside the
	     *     map.
	     */
	    emptyString: null,

	    /**
	     * Property: lastXy
	     * {<OpenLayers.Pixel>}
	     */
	    lastXy: null,

	    /**
	     * APIProperty: displayProjection
	     * {<OpenLayers.Projection>} The projection in which the mouse position is
	     *     displayed.
	     */
	    displayProjection: null,

	    /**
	     * Constructor: OpenLayers.Control.MousePosition
	     *
	     * Parameters:
	     * options - {Object} Options for control.
	     */

	    /**
	     * Method: destroy
	     */
	     destroy: function() {
	         this.deactivate();
	         OpenLayers.Control.prototype.destroy.apply(this, arguments);
	     },

	    /**
	     * APIMethod: activate
	     */
	    activate: function() {
	        if (OpenLayers.Control.prototype.activate.apply(this, arguments)) {
	            this.map.events.register('mousemove', this, this.redraw);
	            this.map.events.register('mouseout', this, this.reset);
	            this.redraw();
	            return true;
	        } else {
	            return false;
	        }
	    },

	    /**
	     * APIMethod: deactivate
	     */
	    deactivate: function() {
	        if (OpenLayers.Control.prototype.deactivate.apply(this, arguments)) {
	            this.map.events.unregister('mousemove', this, this.redraw);
	            this.map.events.unregister('mouseout', this, this.reset);
	            this.element.innerHTML = "";
	            return true;
	        } else {
	            return false;
	        }
	    },

	    /**
	     * Method: draw
	     * {DOMElement}
	     */
	    draw: function() {
	        OpenLayers.Control.prototype.draw.apply(this, arguments);

	        if (!this.element) {
	            this.div.left = "";
	            this.div.top = "";
	            this.element = this.div;
	        }

	        return this.div;
	    },

	    /**
	     * Method: redraw
	     */
	    redraw: function(evt) {

	        var lonLat;

	        if (evt == null) {
	            this.reset();
	            return;
	        } else {
	            if (this.lastXy == null ||
	                Math.abs(evt.xy.x - this.lastXy.x) > this.granularity ||
	                Math.abs(evt.xy.y - this.lastXy.y) > this.granularity)
	            {
	                this.lastXy = evt.xy;
	                return;
	            }

	            lonLat = this.map.getLonLatFromPixel(evt.xy);
	            if (!lonLat) {
	                // map has not yet been properly initialized
	                return;
	            }
	            if (this.displayProjection) {
	                lonLat.transform(this.map.getProjectionObject(),
	                                 this.displayProjection );
	            }
	            this.lastXy = evt.xy;

	        }

	        var newHtml = this.formatOutput(lonLat);

	        if (newHtml != this.element.innerHTML) {
	            this.element.innerHTML = newHtml;
	        }
	    },

	    /**
	     * Method: reset
	     */
	    reset: function(evt) {
	        if (this.emptyString != null) {
	            this.element.innerHTML = this.emptyString;
	        }
	    },

	    /**
	     * Method: formatOutput
	     * Override to provide custom display output
	     *
	     * Parameters:
	     * lonLat - {<OpenLayers.LonLat>} Location to display
	     */
	    formatOutput: function(lonLat) {
	        var digits = parseInt(this.numDigits);
	        var newHtml =
	            this.prefix +
	            lonLat.lon.toFixed(digits) +
	            this.separator +
	            lonLat.lat.toFixed(digits) +
	            this.suffix;
	        return newHtml;
	    },

	    CLASS_NAME: "OpenLayers.Control.MousePosition"
	});
	/* ======================================================================
	    OpenLayers/Events/buttonclick.js
	   ====================================================================== */

	/* Copyright (c) 2006-2015 by OpenLayers Contributors (see authors.txt for
	 * full list of contributors). Published under the 2-clause BSD license.
	 * See license.txt in the OpenLayers distribution or repository for the
	 * full text of the license. */

	/**
	 * @requires OpenLayers/Events.js
	 */

	/**
	 * Class: OpenLayers.Events.buttonclick
	 * Extension event type for handling buttons on top of a dom element. This
	 *     event type fires "buttonclick" on its <target> when a button was
	 *     clicked. Buttons are detected by the "olButton" class.
	 *
	 * This event type makes sure that button clicks do not interfere with other
	 *     events that are registered on the same <element>.
	 *
	 * Event types provided by this extension:
	 * - *buttonclick* Triggered when a button is clicked. Listeners receive an
	 *     object with a *buttonElement* property referencing the dom element of
	 *     the clicked button, and an *buttonXY* property with the click position
	 *     relative to the button.
	 */
	OpenLayers.Events.buttonclick = OpenLayers.Class({
	    
	    /**
	     * Property: target
	     * {<OpenLayers.Events>} The events instance that the buttonclick event will
	     * be triggered on.
	     */
	    target: null,
	    
	    /**
	     * Property: events
	     * {Array} Events to observe and conditionally stop from propagating when
	     *     an element with the olButton class (or its olAlphaImg child) is
	     *     clicked.
	     */
	    events: [
	        'mousedown', 'mouseup', 'click', 'dblclick',
	        'touchstart', 'touchmove', 'touchend', 'keydown'
	    ],
	    
	    /**
	     * Property: startRegEx
	     * {RegExp} Regular expression to test Event.type for events that start
	     *     a buttonclick sequence.
	     */
	    startRegEx: /^mousedown|touchstart$/,

	    /**
	     * Property: cancelRegEx
	     * {RegExp} Regular expression to test Event.type for events that cancel
	     *     a buttonclick sequence.
	     */
	    cancelRegEx: /^touchmove$/,

	    /**
	     * Property: completeRegEx
	     * {RegExp} Regular expression to test Event.type for events that complete
	     *     a buttonclick sequence.
	     */
	    completeRegEx: /^mouseup|touchend$/,

	    /**
	     * Property: isDeviceTouchCapable
	     * {Boolean} Tells whether the browser detects touch events.
	     */
	    isDeviceTouchCapable: 'ontouchstart' in window ||
	        window.DocumentTouch && document instanceof window.DocumentTouch,
	    
	    /**
	     * Property: startEvt
	     * {Event} The event that started the click sequence
	     */
	    
	    /**
	     * Constructor: OpenLayers.Events.buttonclick
	     * Construct a buttonclick event type. Applications are not supposed to
	     *     create instances of this class - they are created on demand by
	     *     <OpenLayers.Events> instances.
	     *
	     * Parameters:
	     * target - {<OpenLayers.Events>} The events instance that the buttonclick
	     *     event will be triggered on.
	     */
	    initialize: function(target) {
	        this.target = target;
	        for (var i=this.events.length-1; i>=0; --i) {
	            this.target.register(this.events[i], this, this.buttonClick, {
	                extension: true
	            });
	        }
	    },
	    
	    /**
	     * Method: destroy
	     */
	    destroy: function() {
	        for (var i=this.events.length-1; i>=0; --i) {
	            this.target.unregister(this.events[i], this, this.buttonClick);
	        }
	        delete this.target;
	    },

	    /**
	     * Method: getPressedButton
	     * Get the pressed button, if any. Returns undefined if no button
	     * was pressed.
	     *
	     * Arguments:
	     * element - {DOMElement} The event target.
	     *
	     * Returns:
	     * {DOMElement} The button element, or undefined.
	     */
	    getPressedButton: function(element) {
	        var depth = 3, // limit the search depth
	            button;
	        do {
	            if(OpenLayers.Element.hasClass(element, "olButton")) {
	                // hit!
	                button = element;
	                break;
	            }
	            element = element.parentNode;
	        } while(--depth > 0 && element);
	        return button;
	    },
	    
	    /**
	     * Method: ignore
	     * Check for event target elements that should be ignored by OpenLayers.
	     *
	     * Parameters:
	     * element - {DOMElement} The event target.
	     */
	    ignore: function(element) {
	        var depth = 3,
	            ignore = false;
	        do {
	            if (element.nodeName.toLowerCase() === 'a') {
	                ignore = true;
	                break;
	            }
	            element = element.parentNode;
	        } while (--depth > 0 && element);
	        return ignore;
	    },

	    /**
	     * Method: buttonClick
	     * Check if a button was clicked, and fire the buttonclick event
	     *
	     * Parameters:
	     * evt - {Event}
	     */
	    buttonClick: function(evt) {
	        var propagate = true,
	            element = OpenLayers.Event.element(evt);

	        if (element &&
	           (OpenLayers.Event.isLeftClick(evt) &&
	            !this.isDeviceTouchCapable ||
	            !~evt.type.indexOf("mouse"))) {
	            // was a button pressed?
	            var button = this.getPressedButton(element);
	            if (button) {
	                if (evt.type === "keydown") {
	                    switch (evt.keyCode) {
	                    case OpenLayers.Event.KEY_RETURN:
	                    case OpenLayers.Event.KEY_SPACE:
	                        this.target.triggerEvent("buttonclick", {
	                            buttonElement: button
	                        });
	                        OpenLayers.Event.stop(evt);
	                        propagate = false;
	                        break;
	                    }
	                } else if (this.startEvt) {
	                    if (this.completeRegEx.test(evt.type)) {
	                        var pos = OpenLayers.Util.pagePosition(button);
	                        var viewportElement = OpenLayers.Util.getViewportElement();
	                        var scrollTop = window.pageYOffset || viewportElement.scrollTop;
	                        var scrollLeft = window.pageXOffset || viewportElement.scrollLeft;
	                        pos[0] = pos[0] - scrollLeft;
	                        pos[1] = pos[1] - scrollTop;
	                        
	                        this.target.triggerEvent("buttonclick", {
	                            buttonElement: button,
	                            buttonXY: {
	                                x: this.startEvt.clientX - pos[0],
	                                y: this.startEvt.clientY - pos[1]
	                            }
	                        });
	                    }
	                    if (this.cancelRegEx.test(evt.type)) {
	                        if (evt.touches && this.startEvt.touches &&
	                                (Math.abs(evt.touches[0].olClientX - this.startEvt.touches[0].olClientX) > 4 ||
	                                Math.abs(evt.touches[0].olClientY - this.startEvt.touches[0].olClientY)) > 4) {
	                            delete this.startEvt;
	                        }
	                    }
	                    OpenLayers.Event.stop(evt);
	                    propagate = false;
	                }
	                if (this.startRegEx.test(evt.type)) {
	                    this.startEvt = evt;
	                    OpenLayers.Event.stop(evt);
	                    propagate = false;
	                }
	            } else {
	                propagate = !this.ignore(OpenLayers.Event.element(evt));
	                delete this.startEvt;
	            }
	        }
	        return propagate;
	    }
	    
	});
	/* ======================================================================
	    OpenLayers/Control/Zoom.js
	   ====================================================================== */

	/* Copyright (c) 2006-2015 by OpenLayers Contributors (see authors.txt for
	 * full list of contributors). Published under the 2-clause BSD license.
	 * See license.txt in the OpenLayers distribution or repository for the
	 * full text of the license. */

	/**
	 * @requires OpenLayers/Control.js
	 * @requires OpenLayers/Events/buttonclick.js
	 */

	/**
	 * Class: OpenLayers.Control.Zoom
	 * The Zoom control is a pair of +/- links for zooming in and out.
	 *
	 * Inherits from:
	 *  - <OpenLayers.Control>
	 */
	OpenLayers.Control.Zoom = OpenLayers.Class(OpenLayers.Control, {
	    
	    /**
	     * APIProperty: zoomInText
	     * {String}
	     * Text for zoom-in link.  Default is "+".
	     */
	    zoomInText: "+",

	    /**
	     * APIProperty: zoomInId
	     * {String}
	     * Instead of having the control create a zoom in link, you can provide 
	     *     the identifier for an anchor element already added to the document.
	     *     By default, an element with id "olZoomInLink" will be searched for
	     *     and used if it exists.
	     */
	    zoomInId: "olZoomInLink",

	    /**
	     * APIProperty: zoomOutText
	     * {String}
	     * Text for zoom-out link.  Default is "\u2212".
	     */
	    zoomOutText: "\u2212",

	    /**
	     * APIProperty: zoomOutId
	     * {String}
	     * Instead of having the control create a zoom out link, you can provide 
	     *     the identifier for an anchor element already added to the document.
	     *     By default, an element with id "olZoomOutLink" will be searched for
	     *     and used if it exists.
	     */
	    zoomOutId: "olZoomOutLink",

	    /**
	     * Method: draw
	     *
	     * Returns:
	     * {DOMElement} A reference to the DOMElement containing the zoom links.
	     */
	    draw: function() {
	        var div = OpenLayers.Control.prototype.draw.apply(this),
	            links = this.getOrCreateLinks(div),
	            zoomIn = links.zoomIn,
	            zoomOut = links.zoomOut,
	            eventsInstance = this.map.events;
	        
	        if (zoomOut.parentNode !== div) {
	            eventsInstance = this.events;
	            eventsInstance.attachToElement(zoomOut.parentNode);
	        }
	        eventsInstance.register("buttonclick", this, this.onZoomClick);
	        
	        this.zoomInLink = zoomIn;
	        this.zoomOutLink = zoomOut;
	        return div;
	    },
	    
	    /**
	     * Method: getOrCreateLinks
	     * 
	     * Parameters:
	     * el - {DOMElement}
	     *
	     * Return: 
	     * {Object} Object with zoomIn and zoomOut properties referencing links.
	     */
	    getOrCreateLinks: function(el) {
	        var zoomIn = document.getElementById(this.zoomInId),
	            zoomOut = document.getElementById(this.zoomOutId);
	        if (!zoomIn) {
	            zoomIn = document.createElement("a");
	            zoomIn.href = "#zoomIn";
	            zoomIn.appendChild(document.createTextNode(this.zoomInText));
	            zoomIn.className = "olControlZoomIn";
	            el.appendChild(zoomIn);
	        }
	        OpenLayers.Element.addClass(zoomIn, "olButton");
	        if (!zoomOut) {
	            zoomOut = document.createElement("a");
	            zoomOut.href = "#zoomOut";
	            zoomOut.appendChild(document.createTextNode(this.zoomOutText));
	            zoomOut.className = "olControlZoomOut";
	            el.appendChild(zoomOut);
	        }
	        OpenLayers.Element.addClass(zoomOut, "olButton");
	        return {
	            zoomIn: zoomIn, zoomOut: zoomOut
	        };
	    },
	    
	    /**
	     * Method: onZoomClick
	     * Called when zoomin/out link is clicked.
	     */
	    onZoomClick: function(evt) {
	        var button = evt.buttonElement;
	        if (button === this.zoomInLink) {
	            this.map.zoomIn();
	        } else if (button === this.zoomOutLink) {
	            this.map.zoomOut();
	        }
	    },

	    /** 
	     * Method: destroy
	     * Clean up.
	     */
	    destroy: function() {
	        if (this.map) {
	            this.map.events.unregister("buttonclick", this, this.onZoomClick);
	        }
	        delete this.zoomInLink;
	        delete this.zoomOutLink;
	        OpenLayers.Control.prototype.destroy.apply(this);
	    },

	    CLASS_NAME: "OpenLayers.Control.Zoom"
	});
	/* ======================================================================
	    OpenLayers/Handler/Feature.js
	   ====================================================================== */

	/* Copyright (c) 2006-2015 by OpenLayers Contributors (see authors.txt for
	 * full list of contributors). Published under the 2-clause BSD license.
	 * See license.txt in the OpenLayers distribution or repository for the
	 * full text of the license. */


	/**
	 * @requires OpenLayers/Handler.js
	 */

	/**
	 * Class: OpenLayers.Handler.Feature 
	 * Handler to respond to mouse events related to a drawn feature.  Callbacks
	 *     with the following keys will be notified of the following events
	 *     associated with features: click, clickout, over, out, and dblclick.
	 *
	 * This handler stops event propagation for mousedown and mouseup if those
	 *     browser events target features that can be selected.
	 *
	 * Inherits from:
	 *  - <OpenLayers.Handler>
	 */
	OpenLayers.Handler.Feature = OpenLayers.Class(OpenLayers.Handler, {

	    /**
	     * Property: EVENTMAP
	     * {Object} A object mapping the browser events to objects with callback
	     *     keys for in and out.
	     */
	    EVENTMAP: {
	        'click': {'in': 'click', 'out': 'clickout'},
	        'mousemove': {'in': 'over', 'out': 'out'},
	        'dblclick': {'in': 'dblclick', 'out': null},
	        'mousedown': {'in': null, 'out': null},
	        'mouseup': {'in': null, 'out': null},
	        'touchstart': {'in': 'click', 'out': 'clickout'}
	    },

	    /**
	     * Property: feature
	     * {<OpenLayers.Feature.Vector>} The last feature that was hovered.
	     */
	    feature: null,

	    /**
	     * Property: lastFeature
	     * {<OpenLayers.Feature.Vector>} The last feature that was handled.
	     */
	    lastFeature: null,

	    /**
	     * Property: down
	     * {<OpenLayers.Pixel>} The location of the last mousedown.
	     */
	    down: null,

	    /**
	     * Property: up
	     * {<OpenLayers.Pixel>} The location of the last mouseup.
	     */
	    up: null,
	    
	    /**
	     * Property: clickTolerance
	     * {Number} The number of pixels the mouse can move between mousedown
	     *     and mouseup for the event to still be considered a click.
	     *     Dragging the map should not trigger the click and clickout callbacks
	     *     unless the map is moved by less than this tolerance. Defaults to 4.
	     */
	    clickTolerance: 4,

	    /**
	     * Property: geometryTypes
	     * To restrict dragging to a limited set of geometry types, send a list
	     * of strings corresponding to the geometry class names.
	     * 
	     * @type Array(String)
	     */
	    geometryTypes: null,

	    /**
	     * Property: stopClick
	     * {Boolean} If stopClick is set to true, handled clicks do not
	     *      propagate to other click listeners. Otherwise, handled clicks
	     *      do propagate. Unhandled clicks always propagate, whatever the
	     *      value of stopClick. Defaults to true.
	     */
	    stopClick: true,

	    /**
	     * Property: stopDown
	     * {Boolean} If stopDown is set to true, handled mousedowns do not
	     *      propagate to other mousedown listeners. Otherwise, handled
	     *      mousedowns do propagate. Unhandled mousedowns always propagate,
	     *      whatever the value of stopDown. Defaults to true.
	     */
	    stopDown: true,

	    /**
	     * Property: stopUp
	     * {Boolean} If stopUp is set to true, handled mouseups do not
	     *      propagate to other mouseup listeners. Otherwise, handled mouseups
	     *      do propagate. Unhandled mouseups always propagate, whatever the
	     *      value of stopUp. Defaults to false.
	     */
	    stopUp: false,
	    
	    /**
	     * Constructor: OpenLayers.Handler.Feature
	     *
	     * Parameters:
	     * control - {<OpenLayers.Control>} 
	     * layer - {<OpenLayers.Layer.Vector>}
	     * callbacks - {Object} An object with a 'over' property whos value is
	     *     a function to be called when the mouse is over a feature. The 
	     *     callback should expect to receive a single argument, the feature.
	     * options - {Object} 
	     */
	    initialize: function(control, layer, callbacks, options) {
	        OpenLayers.Handler.prototype.initialize.apply(this, [control, callbacks, options]);
	        this.layer = layer;
	    },

	    /**
	     * Method: touchstart
	     * Handle touchstart events
	     *
	     * Parameters:
	     * evt - {Event}
	     *
	     * Returns:
	     * {Boolean} Let the event propagate.
	     */
	    touchstart: function(evt) {
	        this.startTouch(); 
	        return OpenLayers.Event.isMultiTouch(evt) ?
	                true : this.mousedown(evt);
	    },

	    /**
	     * Method: touchmove
	     * Handle touchmove events. We just prevent the browser default behavior,
	     *    for Android Webkit not to select text when moving the finger after
	     *    selecting a feature.
	     *
	     * Parameters:
	     * evt - {Event}
	     */
	    touchmove: function(evt) {
	        OpenLayers.Event.preventDefault(evt);
	    },

	    /**
	     * Method: mousedown
	     * Handle mouse down.  Stop propagation if a feature is targeted by this
	     *     event (stops map dragging during feature selection).
	     * 
	     * Parameters:
	     * evt - {Event} 
	     */
	    mousedown: function(evt) {
	        // Feature selection is only done with a left click. Other handlers may stop the
	        // propagation of left-click mousedown events but not right-click mousedown events.
	        // This mismatch causes problems when comparing the location of the down and up
	        // events in the click function so it is important ignore right-clicks.
	        if (OpenLayers.Event.isLeftClick(evt) || OpenLayers.Event.isSingleTouch(evt)) {
	            this.down = evt.xy;
	        }
	        return this.handle(evt) ? !this.stopDown : true;
	    },
	    
	    /**
	     * Method: mouseup
	     * Handle mouse up.  Stop propagation if a feature is targeted by this
	     *     event.
	     * 
	     * Parameters:
	     * evt - {Event} 
	     */
	    mouseup: function(evt) {
	        this.up = evt.xy;
	        return this.handle(evt) ? !this.stopUp : true;
	    },

	    /**
	     * Method: click
	     * Handle click.  Call the "click" callback if click on a feature,
	     *     or the "clickout" callback if click outside any feature.
	     * 
	     * Parameters:
	     * evt - {Event} 
	     *
	     * Returns:
	     * {Boolean}
	     */
	    click: function(evt) {
	        return this.handle(evt) ? !this.stopClick : true;
	    },
	        
	    /**
	     * Method: mousemove
	     * Handle mouse moves.  Call the "over" callback if moving in to a feature,
	     *     or the "out" callback if moving out of a feature.
	     * 
	     * Parameters:
	     * evt - {Event} 
	     *
	     * Returns:
	     * {Boolean}
	     */
	    mousemove: function(evt) {
	        if (!this.callbacks['over'] && !this.callbacks['out']) {
	            return true;
	        }     
	        this.handle(evt);
	        return true;
	    },
	    
	    /**
	     * Method: dblclick
	     * Handle dblclick.  Call the "dblclick" callback if dblclick on a feature.
	     *
	     * Parameters:
	     * evt - {Event} 
	     *
	     * Returns:
	     * {Boolean}
	     */
	    dblclick: function(evt) {
	        return !this.handle(evt);
	    },

	    /**
	     * Method: geometryTypeMatches
	     * Return true if the geometry type of the passed feature matches
	     *     one of the geometry types in the geometryTypes array.
	     *
	     * Parameters:
	     * feature - {<OpenLayers.Vector.Feature>}
	     *
	     * Returns:
	     * {Boolean}
	     */
	    geometryTypeMatches: function(feature) {
	        return this.geometryTypes == null ||
	            OpenLayers.Util.indexOf(this.geometryTypes,
	                                    feature.geometry.CLASS_NAME) > -1;
	    },

	    /**
	     * Method: handle
	     *
	     * Parameters:
	     * evt - {Event}
	     *
	     * Returns:
	     * {Boolean} The event occurred over a relevant feature.
	     */
	    handle: function(evt) {
	        if(this.feature && !this.feature.layer) {
	            // feature has been destroyed
	            this.feature = null;
	        }
	        var type = evt.type;
	        var handled = false;
	        var previouslyIn = !!(this.feature); // previously in a feature
	        var click = (type == "click" || type == "dblclick" || type == "touchstart");
	        this.feature = this.layer.getFeatureFromEvent(evt);
	        if(this.feature && !this.feature.layer) {
	            // feature has been destroyed
	            this.feature = null;
	        }
	        if(this.lastFeature && !this.lastFeature.layer) {
	            // last feature has been destroyed
	            this.lastFeature = null;
	        }
	        if(this.feature) {
	            if(type === "touchstart") {
	                // stop the event to prevent Android Webkit from
	                // "flashing" the map div
	                OpenLayers.Event.preventDefault(evt);
	            }
	            var inNew = (this.feature != this.lastFeature);
	            if(this.geometryTypeMatches(this.feature)) {
	                // in to a feature
	                if(previouslyIn && inNew) {
	                    // out of last feature and in to another
	                    if(this.lastFeature) {
	                        this.triggerCallback(type, 'out', [this.lastFeature]);
	                    }
	                    this.triggerCallback(type, 'in', [this.feature]);
	                } else if(!previouslyIn || click) {
	                    // in feature for the first time
	                    this.triggerCallback(type, 'in', [this.feature]);
	                }
	                this.lastFeature = this.feature;
	                handled = true;
	            } else {
	                // not in to a feature
	                if(this.lastFeature && (previouslyIn && inNew || click)) {
	                    // out of last feature for the first time
	                    this.triggerCallback(type, 'out', [this.lastFeature]);
	                }
	                // next time the mouse goes in a feature whose geometry type
	                // doesn't match we don't want to call the 'out' callback
	                // again, so let's set this.feature to null so that
	                // previouslyIn will evaluate to false the next time
	                // we enter handle. Yes, a bit hackish...
	                this.feature = null;
	            }
	        } else if(this.lastFeature && (previouslyIn || click)) {
	            this.triggerCallback(type, 'out', [this.lastFeature]);
	        }
	        return handled;
	    },
	    
	    /**
	     * Method: triggerCallback
	     * Call the callback keyed in the event map with the supplied arguments.
	     *     For click and clickout, the <clickTolerance> is checked first.
	     *
	     * Parameters:
	     * type - {String}
	     */
	    triggerCallback: function(type, mode, args) {
	        var key = this.EVENTMAP[type][mode];
	        if(key) {
	            if(type == 'click' && this.up && this.down) {
	                // for click/clickout, only trigger callback if tolerance is met
	                var dpx = Math.sqrt(
	                    Math.pow(this.up.x - this.down.x, 2) +
	                    Math.pow(this.up.y - this.down.y, 2)
	                );
	                if(dpx <= this.clickTolerance) {
	                    this.callback(key, args);
	                }
	                // we're done with this set of events now: clear the cached
	                // positions so we can't trip over them later (this can occur
	                // if one of the up/down events gets eaten before it gets to us
	                // but we still get the click)
	                this.up = this.down = null;
	            } else {
	                this.callback(key, args);
	            }
	        }
	    },

	    /**
	     * Method: activate 
	     * Turn on the handler.  Returns false if the handler was already active.
	     *
	     * Returns:
	     * {Boolean}
	     */
	    activate: function() {
	        var activated = false;
	        if(OpenLayers.Handler.prototype.activate.apply(this, arguments)) {
	            this.moveLayerToTop();
	            this.map.events.on({
	                "removelayer": this.handleMapEvents,
	                "changelayer": this.handleMapEvents,
	                scope: this
	            });
	            activated = true;
	        }
	        return activated;
	    },
	    
	    /**
	     * Method: deactivate 
	     * Turn off the handler.  Returns false if the handler was already active.
	     *
	     * Returns: 
	     * {Boolean}
	     */
	    deactivate: function() {
	        var deactivated = false;
	        if(OpenLayers.Handler.prototype.deactivate.apply(this, arguments)) {
	            this.moveLayerBack();
	            this.feature = null;
	            this.lastFeature = null;
	            this.down = null;
	            this.up = null;
	            this.map.events.un({
	                "removelayer": this.handleMapEvents,
	                "changelayer": this.handleMapEvents,
	                scope: this
	            });
	            deactivated = true;
	        }
	        return deactivated;
	    },
	    
	    /**
	     * Method: handleMapEvents
	     * 
	     * Parameters:
	     * evt - {Object}
	     */
	    handleMapEvents: function(evt) {
	        if (evt.type == "removelayer" || evt.property == "order") {
	            this.moveLayerToTop();
	        }
	    },
	    
	    /**
	     * Method: moveLayerToTop
	     * Moves the layer for this handler to the top, so mouse events can reach
	     * it.
	     */
	    moveLayerToTop: function() {
	        var index = Math.max(this.map.Z_INDEX_BASE['Feature'] - 1,
	            this.layer.getZIndex()) + 1;
	        this.layer.setZIndex(index);
	        
	    },
	    
	    /**
	     * Method: moveLayerBack
	     * Moves the layer back to the position determined by the map's layers
	     * array.
	     */
	    moveLayerBack: function() {
	        var index = this.layer.getZIndex() - 1;
	        if (index >= this.map.Z_INDEX_BASE['Feature']) {
	            this.layer.setZIndex(index);
	        } else {
	            this.map.setLayerZIndex(this.layer,
	                this.map.getLayerIndex(this.layer));
	        }
	    },

	    CLASS_NAME: "OpenLayers.Handler.Feature"
	});
	/* ======================================================================
	    OpenLayers/Layer/Vector/RootContainer.js
	   ====================================================================== */

	/* Copyright (c) 2006-2015 by OpenLayers Contributors (see authors.txt for
	 * full list of contributors). Published under the 2-clause BSD license.
	 * See license.txt in the OpenLayers distribution or repository for the
	 * full text of the license. */

	/**
	 * @requires OpenLayers/Layer/Vector.js
	 */

	/**
	 * Class: OpenLayers.Layer.Vector.RootContainer
	 * A special layer type to combine multiple vector layers inside a single
	 *     renderer root container. This class is not supposed to be instantiated
	 *     from user space, it is a helper class for controls that require event
	 *     processing for multiple vector layers.
	 *
	 * Inherits from:
	 *  - <OpenLayers.Layer.Vector>
	 */
	OpenLayers.Layer.Vector.RootContainer = OpenLayers.Class(OpenLayers.Layer.Vector, {
	    
	    /**
	     * Property: displayInLayerSwitcher
	     * Set to false for this layer type
	     */
	    displayInLayerSwitcher: false,
	    
	    /**
	     * APIProperty: layers
	     * Layers that are attached to this container. Required config option.
	     */
	    layers: null,
	    
	    /**
	     * Constructor: OpenLayers.Layer.Vector.RootContainer
	     * Create a new root container for multiple vector layer. This constructor
	     * is not supposed to be used from user space, it is only to be used by
	     * controls that need feature selection across multiple vector layers.
	     *
	     * Parameters:
	     * name - {String} A name for the layer
	     * options - {Object} Optional object with non-default properties to set on
	     *           the layer.
	     * 
	     * Required options properties:
	     * layers - {Array(<OpenLayers.Layer.Vector>)} The layers managed by this
	     *     container
	     *
	     * Returns:
	     * {<OpenLayers.Layer.Vector.RootContainer>} A new vector layer root
	     *     container
	     */
	    
	    /**
	     * Method: display
	     */
	    display: function() {},
	    
	    /**
	     * Method: getFeatureFromEvent
	     * walk through the layers to find the feature returned by the event
	     * 
	     * Parameters:
	     * evt - {Object} event object with a feature property
	     * 
	     * Returns:
	     * {<OpenLayers.Feature.Vector>}
	     */
	    getFeatureFromEvent: function(evt) {
	        var layers = this.layers;
	        var feature;
	        for(var i=0; i<layers.length; i++) {
	            feature = layers[i].getFeatureFromEvent(evt);
	            if(feature) {
	                return feature;
	            }
	        }
	    },
	    
	    /**
	     * Method: setMap
	     * 
	     * Parameters:
	     * map - {<OpenLayers.Map>}
	     */
	    setMap: function(map) {
	        OpenLayers.Layer.Vector.prototype.setMap.apply(this, arguments);
	        this.collectRoots();
	        map.events.register("changelayer", this, this.handleChangeLayer);
	    },
	    
	    /**
	     * Method: removeMap
	     * 
	     * Parameters:
	     * map - {<OpenLayers.Map>}
	     */
	    removeMap: function(map) {
	        map.events.unregister("changelayer", this, this.handleChangeLayer);
	        this.resetRoots();
	        OpenLayers.Layer.Vector.prototype.removeMap.apply(this, arguments);
	    },
	    
	    /**
	     * Method: collectRoots
	     * Collects the root nodes of all layers this control is configured with
	     * and moveswien the nodes to this control's layer
	     */
	    collectRoots: function() {
	        var layer;
	        // walk through all map layers, because we want to keep the order
	        for(var i=0; i<this.map.layers.length; ++i) {
	            layer = this.map.layers[i];
	            if(OpenLayers.Util.indexOf(this.layers, layer) != -1) {
	                layer.renderer.moveRoot(this.renderer);
	            }
	        }
	    },
	    
	    /**
	     * Method: resetRoots
	     * Resets the root nodes back into the layers they belong to.
	     */
	    resetRoots: function() {
	        var layer;
	        for(var i=0; i<this.layers.length; ++i) {
	            layer = this.layers[i];
	            if(this.renderer && layer.renderer.getRenderLayerId() == this.id) {
	                this.renderer.moveRoot(layer.renderer);
	            }
	        }
	    },
	    
	    /**
	     * Method: handleChangeLayer
	     * Event handler for the map's changelayer event. We need to rebuild
	     * this container's layer dom if order of one of its layers changes.
	     * This handler is added with the setMap method, and removed with the
	     * removeMap method.
	     * 
	     * Parameters:
	     * evt - {Object}
	     */
	    handleChangeLayer: function(evt) {
	        var layer = evt.layer;
	        if(evt.property == "order" &&
	                        OpenLayers.Util.indexOf(this.layers, layer) != -1) {
	            this.resetRoots();
	            this.collectRoots();
	        }
	    },

	    CLASS_NAME: "OpenLayers.Layer.Vector.RootContainer"
	});
	/* ======================================================================
	    OpenLayers/Control/SelectFeature.js
	   ====================================================================== */

	/* Copyright (c) 2006-2015 by OpenLayers Contributors (see authors.txt for
	 * full list of contributors). Published under the 2-clause BSD license.
	 * See license.txt in the OpenLayers distribution or repository for the
	 * full text of the license. */


	/**
	 * @requires OpenLayers/Control.js
	 * @requires OpenLayers/Feature/Vector.js
	 * @requires OpenLayers/Handler/Feature.js
	 * @requires OpenLayers/Layer/Vector/RootContainer.js
	 */

	/**
	 * Class: OpenLayers.Control.SelectFeature
	 * The SelectFeature control selects vector features from a given layer on
	 * click or hover.
	 *
	 * Inherits from:
	 *  - <OpenLayers.Control>
	 */
	OpenLayers.Control.SelectFeature = OpenLayers.Class(OpenLayers.Control, {

	    /**
	     * APIProperty: events
	     * {<OpenLayers.Events>} Events instance for listeners and triggering
	     *     control specific events.
	     *
	     * Register a listener for a particular event with the following syntax:
	     * (code)
	     * control.events.register(type, obj, listener);
	     * (end)
	     *
	     * Supported event types (in addition to those from <OpenLayers.Control.events>):
	     * beforefeaturehighlighted - Triggered before a feature is highlighted
	     * featurehighlighted - Triggered when a feature is highlighted
	     * featureunhighlighted - Triggered when a feature is unhighlighted
	     * boxselectionstart - Triggered before box selection starts
	     * boxselectionend - Triggered after box selection ends
	     */

	    /**
	     * APIProperty: multipleKey
	     * {String} An event modifier ('altKey' or 'shiftKey') that temporarily sets
	     *     the <multiple> property to true.  Default is null.
	     */
	    multipleKey: null,

	    /**
	     * APIProperty: toggleKey
	     * {String} An event modifier ('altKey' or 'shiftKey') that temporarily sets
	     *     the <toggle> property to true.  Default is null.
	     */
	    toggleKey: null,

	    /**
	     * APIProperty: multiple
	     * {Boolean} Allow selection of multiple geometries.  Default is false.
	     */
	    multiple: false,

	    /**
	     * APIProperty: clickout
	     * {Boolean} Unselect features when clicking outside any feature.
	     *     Default is true.
	     */
	    clickout: true,

	    /**
	     * APIProperty: toggle
	     * {Boolean} Unselect a selected feature on click.  Default is false.  Only
	     *     has meaning if hover is false.
	     */
	    toggle: false,

	    /**
	     * APIProperty: hover
	     * {Boolean} Select on mouse over and deselect on mouse out.  If true, this
	     * ignores clicks and only listens to mouse moves.
	     */
	    hover: false,

	    /**
	     * APIProperty: highlightOnly
	     * {Boolean} If true do not actually select features (that is place them in
	     * the layer's selected features array), just highlight them. This property
	     * has no effect if hover is false. Defaults to false.
	     */
	    highlightOnly: false,

	    /**
	     * APIProperty: box
	     * {Boolean} Allow feature selection by drawing a box.
	     */
	    box: false,

	    /**
	     * APIProperty: onBeforeSelect
	     * {Function} Optional function to be called before a feature is selected.
	     *     The function should expect to be called with a feature.
	     */
	    onBeforeSelect: function() {},

	    /**
	     * APIProperty: onSelect
	     * {Function} Optional function to be called when a feature is selected.
	     *     The function should expect to be called with a feature.
	     */
	    onSelect: function() {},

	    /**
	     * APIProperty: onUnselect
	     * {Function} Optional function to be called when a feature is unselected.
	     *     The function should expect to be called with a feature.
	     */
	    onUnselect: function() {},

	    /**
	     * APIProperty: scope
	     * {Object} The scope to use with the onBeforeSelect, onSelect, onUnselect
	     *     callbacks. If null the scope will be this control.
	     */
	    scope: null,

	    /**
	     * APIProperty: geometryTypes
	     * {Array(String)} To restrict selecting to a limited set of geometry types,
	     *     send a list of strings corresponding to the geometry class names.
	     */
	    geometryTypes: null,

	    /**
	     * Property: layer
	     * {<OpenLayers.Layer.Vector>} The vector layer with a common renderer
	     * root for all layers this control is configured with (if an array of
	     * layers was passed to the constructor), or the vector layer the control
	     * was configured with (if a single layer was passed to the constructor).
	     */
	    layer: null,

	    /**
	     * Property: layers
	     * {Array(<OpenLayers.Layer.Vector>)} The layers this control will work on,
	     * or null if the control was configured with a single layer
	     */
	    layers: null,

	    /**
	     * APIProperty: callbacks
	     * {Object} The functions that are sent to the handlers.feature for callback
	     */
	    callbacks: null,

	    /**
	     * APIProperty: selectStyle
	     * {Object} Hash of styles
	     */
	    selectStyle: null,

	    /**
	     * APIProperty: renderIntent
	     * {String} key used to retrieve the select style from the layer's
	     * style map.
	     */
	    renderIntent: "select",

	    /**
	     * Property: handlers
	     * {Object} Object with references to multiple <OpenLayers.Handler>
	     *     instances.
	     */
	    handlers: null,

	    /**
	     * Constructor: OpenLayers.Control.SelectFeature
	     * Create a new control for selecting features.
	     *
	     * Parameters:
	     * layers - {<OpenLayers.Layer.Vector>}, or an array of vector layers. The
	     *     layer(s) this control will select features from.
	     * options - {Object}
	     */
	    initialize: function(layers, options) {
	        OpenLayers.Control.prototype.initialize.apply(this, [options]);

	        if(this.scope === null) {
	            this.scope = this;
	        }
	        this.initLayer(layers);
	        var callbacks = {
	            click: this.clickFeature,
	            clickout: this.clickoutFeature
	        };
	        if (this.hover) {
	            callbacks.over = this.overFeature;
	            callbacks.out = this.outFeature;
	        }

	        this.callbacks = OpenLayers.Util.extend(callbacks, this.callbacks);
	        this.handlers = {
	            feature: new OpenLayers.Handler.Feature(
	                this, this.layer, this.callbacks,
	                {geometryTypes: this.geometryTypes}
	            )
	        };

	        if (this.box) {
	            this.handlers.box = new OpenLayers.Handler.Box(
	                this, {done: this.selectBox},
	                {boxDivClassName: "olHandlerBoxSelectFeature"}
	            );
	        }
	    },

	    /**
	     * Method: initLayer
	     * Assign the layer property. If layers is an array, we need to use
	     *     a RootContainer.
	     *
	     * Parameters:
	     * layers - {<OpenLayers.Layer.Vector>}, or an array of vector layers.
	     */
	    initLayer: function(layers) {
	        if(OpenLayers.Util.isArray(layers)) {
	            this.layers = layers;
	            this.layer = new OpenLayers.Layer.Vector.RootContainer(
	                this.id + "_container", {
	                    layers: layers
	                }
	            );
	        } else {
	            this.layer = layers;
	        }
	    },

	    /**
	     * Method: destroy
	     */
	    destroy: function() {
	        if(this.active && this.layers) {
	            this.map.removeLayer(this.layer);
	        }
	        OpenLayers.Control.prototype.destroy.apply(this, arguments);
	        if(this.layers) {
	            this.layer.destroy();
	        }
	    },

	    /**
	     * Method: activate
	     * Activates the control.
	     *
	     * Returns:
	     * {Boolean} The control was effectively activated.
	     */
	    activate: function () {
	        if (!this.active) {
	            if(this.layers) {
	                this.map.addLayer(this.layer);
	            }
	            this.handlers.feature.activate();
	            if(this.box && this.handlers.box) {
	                this.handlers.box.activate();
	            }
	        }
	        return OpenLayers.Control.prototype.activate.apply(
	            this, arguments
	        );
	    },

	    /**
	     * Method: deactivate
	     * Deactivates the control.
	     *
	     * Returns:
	     * {Boolean} The control was effectively deactivated.
	     */
	    deactivate: function () {
	        if (this.active) {
	            this.handlers.feature.deactivate();
	            if(this.handlers.box) {
	                this.handlers.box.deactivate();
	            }
	            if(this.layers) {
	                this.map.removeLayer(this.layer);
	            }
	        }
	        return OpenLayers.Control.prototype.deactivate.apply(
	            this, arguments
	        );
	    },

	    /**
	     * Method: unselectAll
	     * Unselect all selected features.  To unselect all except for a single
	     *     feature, set the options.except property to the feature.
	     *
	     * Parameters:
	     * options - {Object} Optional configuration object.
	     */
	    unselectAll: function(options) {
	        // we'll want an option to suppress notification here
	        var layers = this.layers || [this.layer],
	            layer, feature, l, numExcept;
	        for(l=0; l<layers.length; ++l) {
	            layer = layers[l];
	            numExcept = 0;
	            //layer.selectedFeatures is null when layer is destroyed and
	            //one of it's preremovelayer listener calls setLayer
	            //with another layer on this control
	            if(layer.selectedFeatures != null) {
	                while(layer.selectedFeatures.length > numExcept) {
	                    feature = layer.selectedFeatures[numExcept];
	                    if(!options || options.except != feature) {
	                        this.unselect(feature);
	                    } else {
	                        ++numExcept;
	                    }
	                }
	            }
	        }
	    },

	    /**
	     * Method: clickFeature
	     * Called on click in a feature
	     * Only responds if this.hover is false.
	     *
	     * Parameters:
	     * feature - {<OpenLayers.Feature.Vector>}
	     */
	    clickFeature: function(feature) {
	        if(!this.hover) {
	            var selected = (OpenLayers.Util.indexOf(
	                feature.layer.selectedFeatures, feature) > -1);
	            if(selected) {
	                if(this.toggleSelect()) {
	                    this.unselect(feature);
	                } else if(!this.multipleSelect()) {
	                    this.unselectAll({except: feature});
	                }
	            } else {
	                if(!this.multipleSelect()) {
	                    this.unselectAll({except: feature});
	                }
	                this.select(feature);
	            }
	        }
	    },

	    /**
	     * Method: multipleSelect
	     * Allow for multiple selected features based on <multiple> property and
	     *     <multipleKey> event modifier.
	     *
	     * Returns:
	     * {Boolean} Allow for multiple selected features.
	     */
	    multipleSelect: function() {
	        return this.multiple || (this.handlers.feature.evt &&
	                                 this.handlers.feature.evt[this.multipleKey]);
	    },

	    /**
	     * Method: toggleSelect
	     * Event should toggle the selected state of a feature based on <toggle>
	     *     property and <toggleKey> event modifier.
	     *
	     * Returns:
	     * {Boolean} Toggle the selected state of a feature.
	     */
	    toggleSelect: function() {
	        return this.toggle || (this.handlers.feature.evt &&
	                               this.handlers.feature.evt[this.toggleKey]);
	    },

	    /**
	     * Method: clickoutFeature
	     * Called on click outside a previously clicked (selected) feature.
	     * Only responds if this.hover is false.
	     *
	     * Parameters:
	     * feature - {<OpenLayers.Vector.Feature>}
	     */
	    clickoutFeature: function(feature) {
	        if(!this.hover && this.clickout) {
	            this.unselectAll();
	        }
	    },

	    /**
	     * Method: overFeature
	     * Called on over a feature.
	     * Only responds if this.hover is true.
	     *
	     * Parameters:
	     * feature - {<OpenLayers.Feature.Vector>}
	     */
	    overFeature: function(feature) {
	        var layer = feature.layer;
	        if(this.hover) {
	            if(this.highlightOnly) {
	                this.highlight(feature);
	            } else if(OpenLayers.Util.indexOf(
	                layer.selectedFeatures, feature) == -1) {
	                this.select(feature);
	            }
	        }
	    },

	    /**
	     * Method: outFeature
	     * Called on out of a selected feature.
	     * Only responds if this.hover is true.
	     *
	     * Parameters:
	     * feature - {<OpenLayers.Feature.Vector>}
	     */
	    outFeature: function(feature) {
	        if(this.hover) {
	            if(this.highlightOnly) {
	                // we do nothing if we're not the last highlighter of the
	                // feature
	                if(feature._lastHighlighter == this.id) {
	                    // if another select control had highlighted the feature before
	                    // we did it ourself then we use that control to highlight the
	                    // feature as it was before we highlighted it, else we just
	                    // unhighlight it
	                    if(feature._prevHighlighter &&
	                       feature._prevHighlighter != this.id) {
	                        delete feature._lastHighlighter;
	                        var control = this.map.getControl(
	                            feature._prevHighlighter);
	                        if(control) {
	                            control.highlight(feature);
	                        }
	                    } else {
	                        this.unhighlight(feature);
	                    }
	                }
	            } else {
	                this.unselect(feature);
	            }
	        }
	    },

	    /**
	     * Method: highlight
	     * Redraw feature with the select style.
	     *
	     * Parameters:
	     * feature - {<OpenLayers.Feature.Vector>}
	     */
	    highlight: function(feature) {
	        var layer = feature.layer;
	        var cont = this.events.triggerEvent("beforefeaturehighlighted", {
	            feature : feature
	        });
	        if(cont !== false) {
	            feature._prevHighlighter = feature._lastHighlighter;
	            feature._lastHighlighter = this.id;
	            var style = this.selectStyle || this.renderIntent;
	            layer.drawFeature(feature, style);
	            this.events.triggerEvent("featurehighlighted", {feature : feature});
	        }
	    },

	    /**
	     * Method: unhighlight
	     * Redraw feature with the "default" style
	     *
	     * Parameters:
	     * feature - {<OpenLayers.Feature.Vector>}
	     */
	    unhighlight: function(feature) {
	        var layer = feature.layer;
	        // three cases:
	        // 1. there's no other highlighter, in that case _prev is undefined,
	        //    and we just need to undef _last
	        // 2. another control highlighted the feature after we did it, in
	        //    that case _last references this other control, and we just
	        //    need to undef _prev
	        // 3. another control highlighted the feature before we did it, in
	        //    that case _prev references this other control, and we need to
	        //    set _last to _prev and undef _prev
	        if(feature._prevHighlighter == undefined) {
	            delete feature._lastHighlighter;
	        } else if(feature._prevHighlighter == this.id) {
	            delete feature._prevHighlighter;
	        } else {
	            feature._lastHighlighter = feature._prevHighlighter;
	            delete feature._prevHighlighter;
	        }
	        layer.drawFeature(feature, feature.style || feature.layer.style ||
	            "default");
	        this.events.triggerEvent("featureunhighlighted", {feature : feature});
	    },

	    /**
	     * Method: select
	     * Add feature to the layer's selectedFeature array, render the feature as
	     * selected, and call the onSelect function.
	     *
	     * Parameters:
	     * feature - {<OpenLayers.Feature.Vector>}
	     */
	    select: function(feature) {
	        var cont = this.onBeforeSelect.call(this.scope, feature);
	        var layer = feature.layer;
	        if(cont !== false) {
	            cont = layer.events.triggerEvent("beforefeatureselected", {
	                feature: feature
	            });
	            if(cont !== false) {
	                layer.selectedFeatures.push(feature);
	                this.highlight(feature);
	                // if the feature handler isn't involved in the feature
	                // selection (because the box handler is used or the
	                // feature is selected programatically) we fake the
	                // feature handler to allow unselecting on click
	                if(!this.handlers.feature.lastFeature) {
	                    this.handlers.feature.lastFeature = layer.selectedFeatures[0];
	                }
	                layer.events.triggerEvent("featureselected", {feature: feature});
	                this.onSelect.call(this.scope, feature);
	            }
	        }
	    },

	    /**
	     * Method: unselect
	     * Remove feature from the layer's selectedFeature array, render the feature as
	     * normal, and call the onUnselect function.
	     *
	     * Parameters:
	     * feature - {<OpenLayers.Feature.Vector>}
	     */
	    unselect: function(feature) {
	        var layer = feature.layer;
	        // Store feature style for restoration later
	        this.unhighlight(feature);
	        OpenLayers.Util.removeItem(layer.selectedFeatures, feature);
	        layer.events.triggerEvent("featureunselected", {feature: feature});
	        this.onUnselect.call(this.scope, feature);
	    },

	    /**
	     * Method: selectBox
	     * Callback from the handlers.box set up when <box> selection is true
	     *     on.
	     *
	     * Parameters:
	     * position - {<OpenLayers.Bounds> || <OpenLayers.Pixel> }
	     */
	    selectBox: function(position) {
	        if (position instanceof OpenLayers.Bounds) {
	            var minXY = this.map.getLonLatFromPixel({
	                x: position.left,
	                y: position.bottom
	            });
	            var maxXY = this.map.getLonLatFromPixel({
	                x: position.right,
	                y: position.top
	            });
	            var bounds = new OpenLayers.Bounds(
	                minXY.lon, minXY.lat, maxXY.lon, maxXY.lat
	            );

	            // if multiple is false, first deselect currently selected features
	            if (!this.multipleSelect()) {
	                this.unselectAll();
	            }

	            // because we're using a box, we consider we want multiple selection
	            var prevMultiple = this.multiple;
	            this.multiple = true;
	            var layers = this.layers || [this.layer];
	            this.events.triggerEvent("boxselectionstart", {layers: layers});
	            var layer;
	            for(var l=0; l<layers.length; ++l) {
	                layer = layers[l];
	                for(var i=0, len = layer.features.length; i<len; ++i) {
	                    var feature = layer.features[i];
	                    // check if the feature is displayed
	                    if (!feature.getVisibility()) {
	                        continue;
	                    }

	                    if (this.geometryTypes == null || OpenLayers.Util.indexOf(
	                            this.geometryTypes, feature.geometry.CLASS_NAME) > -1) {
	                        if (bounds.toGeometry().intersects(feature.geometry)) {
	                            if (OpenLayers.Util.indexOf(layer.selectedFeatures, feature) == -1) {
	                                this.select(feature);
	                            }
	                        }
	                    }
	                }
	            }
	            this.multiple = prevMultiple;
	            this.events.triggerEvent("boxselectionend", {layers: layers});
	        }
	    },

	    /**
	     * Method: setMap
	     * Set the map property for the control.
	     *
	     * Parameters:
	     * map - {<OpenLayers.Map>}
	     */
	    setMap: function(map) {
	        this.handlers.feature.setMap(map);
	        if (this.box) {
	            this.handlers.box.setMap(map);
	        }
	        OpenLayers.Control.prototype.setMap.apply(this, arguments);
	    },

	    /**
	     * APIMethod: setLayer
	     * Attach a new layer to the control, overriding any existing layers.
	     *
	     * Parameters:
	     * layers - Array of {<OpenLayers.Layer.Vector>} or a single
	     *     {<OpenLayers.Layer.Vector>}
	     */
	    setLayer: function(layers) {
	        var isActive = this.active;
	        this.unselectAll();
	        this.deactivate();
	        if(this.layers) {
	            this.layer.destroy();
	            this.layers = null;
	        }
	        this.initLayer(layers);
	        this.handlers.feature.layer = this.layer;
	        if (isActive) {
	            this.activate();
	        }
	    },
	    
	    /**
	     * APIMethod: addLayer
	     * Add a layer to the control, making the existing layers still selectable
	     *
	     * Parameters:
	     * layer - element <OpenLayers.Layer.Vector> 
	     */
	    addLayer: function( layer ) {
	        var isActive = this.active;
	        this.deactivate();
	        if (this.layers == null) {
	            if (this.layer != null) {
	                this.layers = [this.layer];
	                this.layers.push(layer);
	            } else {
	                this.layers = [layer];
	            }
	        } else {	
	            this.layers.push(layer);
	        }
	        this.initLayer(this.layers);
	        this.handlers.feature.layer = this.layer;
	        if (isActive) {
	            this.activate();
	        }
	    },	    

	    CLASS_NAME: "OpenLayers.Control.SelectFeature"
	});
	/* ======================================================================
	    OpenLayers/Handler/Drag.js
	   ====================================================================== */

	/* Copyright (c) 2006-2015 by OpenLayers Contributors (see authors.txt for
	 * full list of contributors). Published under the 2-clause BSD license.
	 * See license.txt in the OpenLayers distribution or repository for the
	 * full text of the license. */

	/**
	 * @requires OpenLayers/Handler.js
	 */

	/**
	 * Class: OpenLayers.Handler.Drag
	 * The drag handler is used to deal with sequences of browser events related
	 *     to dragging.  The handler is used by controls that want to know when
	 *     a drag sequence begins, when a drag is happening, and when it has
	 *     finished.
	 *
	 * Controls that use the drag handler typically construct it with callbacks
	 *     for 'down', 'move', and 'done'.  Callbacks for these keys are called
	 *     when the drag begins, with each move, and when the drag is done.  In
	 *     addition, controls can have callbacks keyed to 'up' and 'out' if they
	 *     care to differentiate between the types of events that correspond with
	 *     the end of a drag sequence.  If no drag actually occurs (no mouse move)
	 *     the 'down' and 'up' callbacks will be called, but not the 'done'
	 *     callback.
	 *
	 * Create a new drag handler with the <OpenLayers.Handler.Drag> constructor.
	 *
	 * Inherits from:
	 *  - <OpenLayers.Handler>
	 */
	OpenLayers.Handler.Drag = OpenLayers.Class(OpenLayers.Handler, {
	  
	    /** 
	     * Property: started
	     * {Boolean} When a mousedown or touchstart event is received, we want to
	     * record it, but not set 'dragging' until the mouse moves after starting.
	     */
	    started: false,

	    /**
	     * Property: stopDown
	     * {Boolean} Stop propagation of mousedown events from getting to listeners
	     *     on the same element.  Default is true.
	     */
	    stopDown: true,

	    /** 
	     * Property: dragging 
	     * {Boolean} 
	     */
	    dragging: false,

	    /** 
	     * Property: last
	     * {<OpenLayers.Pixel>} The last pixel location of the drag.
	     */
	    last: null,

	    /** 
	     * Property: start
	     * {<OpenLayers.Pixel>} The first pixel location of the drag.
	     */
	    start: null,

	    /**
	     * Property: lastMoveEvt
	     * {Object} The last mousemove event that occurred. Used to
	     *     position the map correctly when our "delay drag"
	     *     timeout expired.
	     */
	    lastMoveEvt: null,

	    /**
	     * Property: oldOnselectstart
	     * {Function}
	     */
	    oldOnselectstart: null,
	    
	    /**
	     * Property: interval
	     * {Integer} In order to increase performance, an interval (in 
	     *     milliseconds) can be set to reduce the number of drag events 
	     *     called. If set, a new drag event will not be set until the 
	     *     interval has passed. 
	     *     Defaults to 0, meaning no interval. 
	     */
	    interval: 0,
	    
	    /**
	     * Property: timeoutId
	     * {String} The id of the timeout used for the mousedown interval.
	     *     This is "private", and should be left alone.
	     */
	    timeoutId: null,
	    
	    /**
	     * APIProperty: documentDrag
	     * {Boolean} If set to true, the handler will also handle mouse moves when
	     *     the cursor has moved out of the map viewport. Default is false.
	     */
	    documentDrag: false,
	    
	    /**
	     * Property: documentEvents
	     * {Boolean} Are we currently observing document events?
	     */
	    documentEvents: null,

	    /**
	     * Constructor: OpenLayers.Handler.Drag
	     * Returns OpenLayers.Handler.Drag
	     * 
	     * Parameters:
	     * control - {<OpenLayers.Control>} The control that is making use of
	     *     this handler.  If a handler is being used without a control, the
	     *     handlers setMap method must be overridden to deal properly with
	     *     the map.
	     * callbacks - {Object} An object containing a single function to be
	     *     called when the drag operation is finished. The callback should
	     *     expect to receive a single argument, the pixel location of the event.
	     *     Callbacks for 'move' and 'done' are supported. You can also speficy
	     *     callbacks for 'down', 'up', and 'out' to respond to those events.
	     * options - {Object} 
	     */
	    initialize: function(control, callbacks, options) {
	        OpenLayers.Handler.prototype.initialize.apply(this, arguments);
	        
	        if (this.documentDrag === true) {
	            var me = this;
	            this._docMove = function(evt) {
	                me.mousemove({
	                    xy: {x: evt.clientX, y: evt.clientY},
	                    element: document
	                });
	            };
	            this._docUp = function(evt) {
	                me.mouseup({xy: {x: evt.clientX, y: evt.clientY}});
	            };
	        }
	    },

	    
	    /**
	     * Method: dragstart
	     * This private method is factorized from mousedown and touchstart methods
	     *
	     * Parameters:
	     * evt - {Event} The event
	     *
	     * Returns:
	     * {Boolean} Let the event propagate.
	     */
	    dragstart: function (evt) {
	        var propagate = true;
	        this.dragging = false;
	        if (this.checkModifiers(evt) &&
	               this._pointerId == evt.pointerId &&
	               (OpenLayers.Event.isLeftClick(evt) ||
	                OpenLayers.Event.isSingleTouch(evt))) {
	            this.started = true;
	            this.start = evt.xy;
	            this.last = evt.xy;
	            OpenLayers.Element.addClass(
	                this.map.viewPortDiv, "olDragDown"
	            );
	            this.down(evt);
	            this.callback("down", [evt.xy]);

	            // prevent document dragging
	            OpenLayers.Event.preventDefault(evt);

	            if(!this.oldOnselectstart) {
	                this.oldOnselectstart = document.onselectstart ?
	                    document.onselectstart : OpenLayers.Function.True;
	            }
	            document.onselectstart = OpenLayers.Function.False;

	            propagate = !this.stopDown;
	        } else {
	            delete this._pointerId;
	            this.started = false;
	            this.start = null;
	            this.last = null;
	        }
	        return propagate;
	    },

	    /**
	     * Method: dragmove
	     * This private method is factorized from mousemove and touchmove methods
	     *
	     * Parameters:
	     * evt - {Event} The event
	     *
	     * Returns:
	     * {Boolean} Let the event propagate.
	     */
	    dragmove: function (evt) {
	        this.lastMoveEvt = evt;
	        if (this.started && this._pointerId == evt.pointerId &&
	            !this.timeoutId && (evt.xy.x != this.last.x ||
	                                evt.xy.y != this.last.y)) {
	            if(this.documentDrag === true && this.documentEvents) {
	                if(evt.element === document) {
	                    this.adjustXY(evt);
	                    // do setEvent manually because the documentEvents are not
	                    // registered with the map
	                    this.setEvent(evt);
	                } else {
	                    this.removeDocumentEvents();
	                }
	            }
	            if (this.interval > 0) {
	                this.timeoutId = setTimeout(
	                    OpenLayers.Function.bind(this.removeTimeout, this),
	                    this.interval);
	            }
	            this.dragging = true;

	            this.move(evt);
	            this.callback("move", [evt.xy]);
	            if(!this.oldOnselectstart) {
	                this.oldOnselectstart = document.onselectstart;
	                document.onselectstart = OpenLayers.Function.False;
	            }
	            this.last = evt.xy;
	        }
	        return true;
	    },

	    /**
	     * Method: dragend
	     * This private method is factorized from mouseup and touchend methods
	     *
	     * Parameters:
	     * evt - {Event} The event
	     *
	     * Returns:
	     * {Boolean} Let the event propagate.
	     */
	    dragend: function (evt) {
	        if (this.started && this._pointerId == evt.pointerId) {
	            if(this.documentDrag === true && this.documentEvents) {
	                this.adjustXY(evt);
	                this.removeDocumentEvents();
	            }
	            var dragged = (this.start != this.last);
	            this.started = false;
	            this.dragging = false;
	            delete this._pointerId;
	            OpenLayers.Element.removeClass(
	                this.map.viewPortDiv, "olDragDown"
	            );
	            this.up(evt);
	            this.callback("up", [evt.xy]);
	            if(dragged) {
	                this.callback("done", [evt.xy]);
	            }
	            document.onselectstart = this.oldOnselectstart;
	        }
	        return true;
	    },

	    /**
	     * The four methods below (down, move, up, and out) are used by subclasses
	     *     to do their own processing related to these mouse events.
	     */

	    /**
	     * Method: down
	     * This method is called during the handling of the mouse down event.
	     *     Subclasses can do their own processing here.
	     *
	     * Parameters:
	     * evt - {Event} The mouse down event
	     */
	    down: function(evt) {
	    },

	    /**
	     * Method: move
	     * This method is called during the handling of the mouse move event.
	     *     Subclasses can do their own processing here.
	     *
	     * Parameters:
	     * evt - {Event} The mouse move event
	     *
	     */
	    move: function(evt) {
	    },

	    /**
	     * Method: up
	     * This method is called during the handling of the mouse up event.
	     *     Subclasses can do their own processing here.
	     *
	     * Parameters:
	     * evt - {Event} The mouse up event
	     */
	    up: function(evt) {
	    },

	    /**
	     * Method: out
	     * This method is called during the handling of the mouse out event.
	     *     Subclasses can do their own processing here.
	     *
	     * Parameters:
	     * evt - {Event} The mouse out event
	     */
	    out: function(evt) {
	    },

	    /**
	     * The methods below are part of the magic of event handling.  Because
	     *     they are named like browser events, they are registered as listeners
	     *     for the events they represent.
	     */

	    /**
	     * Method: mousedown
	     * Handle mousedown events
	     *
	     * Parameters:
	     * evt - {Event}
	     *
	     * Returns:
	     * {Boolean} Let the event propagate.
	     */
	    mousedown: function(evt) {
	        return this.dragstart(evt);
	    },

	    /**
	     * Method: touchstart
	     * Handle touchstart events
	     *
	     * Parameters:
	     * evt - {Event}
	     *
	     * Returns:
	     * {Boolean} Let the event propagate.
	     */
	    touchstart: function(evt) {
	        this.startTouch();
	        // only allow the first pointer event to be monitored by noting its pointerId
	        // which is unique in the pointer model (and undefined in the touch model)
	        if (!("_pointerId" in this)) {
	            this._pointerId = evt.pointerId;
	        }
	        return this.dragstart(evt);
	    },

	    /**
	     * Method: mousemove
	     * Handle mousemove events
	     *
	     * Parameters:
	     * evt - {Event}
	     *
	     * Returns:
	     * {Boolean} Let the event propagate.
	     */
	    mousemove: function(evt) {
	        return this.dragmove(evt);
	    },

	    /**
	     * Method: touchmove
	     * Handle touchmove events
	     *
	     * Parameters:
	     * evt - {Event}
	     *
	     * Returns:
	     * {Boolean} Let the event propagate.
	     */
	    touchmove: function(evt) {
	        return this.dragmove(evt);
	    },

	    /**
	     * Method: removeTimeout
	     * Private. Called by mousemove() to remove the drag timeout.
	     */
	    removeTimeout: function() {
	        this.timeoutId = null;
	        // if timeout expires while we're still dragging (mouseup
	        // hasn't occurred) then call mousemove to move to the
	        // correct position
	        if(this.dragging) {
	            this.mousemove(this.lastMoveEvt);
	        }
	    },

	    /**
	     * Method: mouseup
	     * Handle mouseup events
	     *
	     * Parameters:
	     * evt - {Event}
	     *
	     * Returns:
	     * {Boolean} Let the event propagate.
	     */
	    mouseup: function(evt) {
	        return this.dragend(evt);
	    },

	    /**
	     * Method: touchend
	     * Handle touchend events
	     *
	     * Parameters:
	     * evt - {Event}
	     *
	     * Returns:
	     * {Boolean} Let the event propagate.
	     */
	    touchend: function(evt) {
	        // override evt.xy with last position since touchend does not have
	        // any touch position
	        evt.xy = this.last;
	        return this.dragend(evt);
	    },

	    /**
	     * Method: mouseout
	     * Handle mouseout events
	     *
	     * Parameters:
	     * evt - {Event}
	     *
	     * Returns:
	     * {Boolean} Let the event propagate.
	     */
	    mouseout: function (evt) {
	        if (this.started && OpenLayers.Util.mouseLeft(evt, this.map.viewPortDiv)) {
	            if(this.documentDrag === true) {
	                this.addDocumentEvents();
	            } else {
	                var dragged = (this.start != this.last);
	                this.started = false; 
	                this.dragging = false;
	                OpenLayers.Element.removeClass(
	                    this.map.viewPortDiv, "olDragDown"
	                );
	                this.out(evt);
	                this.callback("out", []);
	                if(dragged) {
	                    this.callback("done", [evt.xy]);
	                }
	                if(document.onselectstart) {
	                    document.onselectstart = this.oldOnselectstart;
	                }
	            }
	        }
	        return true;
	    },

	    /**
	     * Method: click
	     * The drag handler captures the click event.  If something else registers
	     *     for clicks on the same element, its listener will not be called 
	     *     after a drag.
	     * 
	     * Parameters: 
	     * evt - {Event} 
	     * 
	     * Returns:
	     * {Boolean} Let the event propagate.
	     */
	    click: function (evt) {
	        // let the click event propagate only if the mouse moved
	        return (this.start == this.last);
	    },

	    /**
	     * Method: activate
	     * Activate the handler.
	     * 
	     * Returns:
	     * {Boolean} The handler was successfully activated.
	     */
	    activate: function() {
	        var activated = false;
	        if(OpenLayers.Handler.prototype.activate.apply(this, arguments)) {
	            this.dragging = false;
	            activated = true;
	        }
	        return activated;
	    },

	    /**
	     * Method: deactivate 
	     * Deactivate the handler.
	     * 
	     * Returns:
	     * {Boolean} The handler was successfully deactivated.
	     */
	    deactivate: function() {
	        var deactivated = false;
	        if(OpenLayers.Handler.prototype.deactivate.apply(this, arguments)) {
	            this.started = false;
	            this.dragging = false;
	            this.start = null;
	            this.last = null;
	            deactivated = true;
	            OpenLayers.Element.removeClass(
	                this.map.viewPortDiv, "olDragDown"
	            );
	        }
	        return deactivated;
	    },
	    
	    /**
	     * Method: adjustXY
	     * Converts event coordinates that are relative to the document body to
	     * ones that are relative to the map viewport. The latter is the default in
	     * OpenLayers.
	     * 
	     * Parameters:
	     * evt - {Object}
	     */
	    adjustXY: function(evt) {
	        var pos = OpenLayers.Util.pagePosition(this.map.viewPortDiv);
	        evt.xy.x -= pos[0];
	        evt.xy.y -= pos[1];
	    },
	    
	    /**
	     * Method: addDocumentEvents
	     * Start observing document events when documentDrag is true and the mouse
	     * cursor leaves the map viewport while dragging.
	     */
	    addDocumentEvents: function() {
	        OpenLayers.Element.addClass(document.body, "olDragDown");
	        this.documentEvents = true;
	        OpenLayers.Event.observe(document, "mousemove", this._docMove);
	        OpenLayers.Event.observe(document, "mouseup", this._docUp);
	    },
	    
	    /**
	     * Method: removeDocumentEvents
	     * Stops observing document events when documentDrag is true and the mouse
	     * cursor re-enters the map viewport while dragging.
	     */
	    removeDocumentEvents: function() {
	        OpenLayers.Element.removeClass(document.body, "olDragDown");
	        this.documentEvents = false;
	        OpenLayers.Event.stopObserving(document, "mousemove", this._docMove);
	        OpenLayers.Event.stopObserving(document, "mouseup", this._docUp);
	    },

	    CLASS_NAME: "OpenLayers.Handler.Drag"
	});
	/* ======================================================================
	    OpenLayers/Handler/Box.js
	   ====================================================================== */

	/* Copyright (c) 2006-2015 by OpenLayers Contributors (see authors.txt for
	 * full list of contributors). Published under the 2-clause BSD license.
	 * See license.txt in the OpenLayers distribution or repository for the
	 * full text of the license. */

	/**
	 * @requires OpenLayers/Handler.js
	 * @requires OpenLayers/Handler/Drag.js
	 */

	/**
	 * Class: OpenLayers.Handler.Box
	 * Handler for dragging a rectangle across the map.  Box is displayed 
	 * on mouse down, moves on mouse move, and is finished on mouse up.
	 *
	 * Inherits from:
	 *  - <OpenLayers.Handler> 
	 */
	OpenLayers.Handler.Box = OpenLayers.Class(OpenLayers.Handler, {

	    /** 
	     * Property: dragHandler 
	     * {<OpenLayers.Handler.Drag>} 
	     */
	    dragHandler: null,

	    /**
	     * APIProperty: boxDivClassName
	     * {String} The CSS class to use for drawing the box. Default is
	     *     olHandlerBoxZoomBox
	     */
	    boxDivClassName: 'olHandlerBoxZoomBox',
	    
	    /**
	     * Property: boxOffsets
	     * {Object} Caches box offsets from css. This is used by the getBoxOffsets
	     * method.
	     */
	    boxOffsets: null,

	    /**
	     * Constructor: OpenLayers.Handler.Box
	     *
	     * Parameters:
	     * control - {<OpenLayers.Control>} 
	     * callbacks - {Object} An object with a properties whose values are
	     *     functions.  Various callbacks described below.
	     * options - {Object} 
	     *
	     * Named callbacks:
	     * start - Called when the box drag operation starts.
	     * done - Called when the box drag operation is finished.
	     *     The callback should expect to receive a single argument, the box 
	     *     bounds or a pixel. If the box dragging didn't span more than a 5 
	     *     pixel distance, a pixel will be returned instead of a bounds object.
	     */
	    initialize: function(control, callbacks, options) {
	        OpenLayers.Handler.prototype.initialize.apply(this, arguments);
	        this.dragHandler = new OpenLayers.Handler.Drag(
	            this, 
	            {
	                down: this.startBox, 
	                move: this.moveBox, 
	                out: this.removeBox,
	                up: this.endBox
	            }, 
	            {keyMask: this.keyMask}
	        );
	    },

	    /**
	     * Method: destroy
	     */
	    destroy: function() {
	        OpenLayers.Handler.prototype.destroy.apply(this, arguments);
	        if (this.dragHandler) {
	            this.dragHandler.destroy();
	            this.dragHandler = null;
	        }            
	    },

	    /**
	     * Method: setMap
	     */
	    setMap: function (map) {
	        OpenLayers.Handler.prototype.setMap.apply(this, arguments);
	        if (this.dragHandler) {
	            this.dragHandler.setMap(map);
	        }
	    },

	    /**
	    * Method: startBox
	    *
	    * Parameters:
	    * xy - {<OpenLayers.Pixel>}
	    */
	    startBox: function (xy) {
	        this.callback("start", []);
	        this.zoomBox = OpenLayers.Util.createDiv('zoomBox', {
	            x: -9999, y: -9999
	        });
	        this.zoomBox.className = this.boxDivClassName;                                         
	        this.zoomBox.style.zIndex = this.map.Z_INDEX_BASE["Popup"] - 1;
	        
	        this.map.viewPortDiv.appendChild(this.zoomBox);
	        
	        OpenLayers.Element.addClass(
	            this.map.viewPortDiv, "olDrawBox"
	        );
	    },

	    /**
	    * Method: moveBox
	    */
	    moveBox: function (xy) {
	        var startX = this.dragHandler.start.x;
	        var startY = this.dragHandler.start.y;
	        var deltaX = Math.abs(startX - xy.x);
	        var deltaY = Math.abs(startY - xy.y);

	        var offset = this.getBoxOffsets();
	        this.zoomBox.style.width = (deltaX + offset.width + 1) + "px";
	        this.zoomBox.style.height = (deltaY + offset.height + 1) + "px";
	        this.zoomBox.style.left = (xy.x < startX ?
	            startX - deltaX - offset.left : startX - offset.left) + "px";
	        this.zoomBox.style.top = (xy.y < startY ?
	            startY - deltaY - offset.top : startY - offset.top) + "px";
	    },

	    /**
	    * Method: endBox
	    */
	    endBox: function(end) {
	        var result;
	        if (Math.abs(this.dragHandler.start.x - end.x) > 5 ||    
	            Math.abs(this.dragHandler.start.y - end.y) > 5) {   
	            var start = this.dragHandler.start;
	            var top = Math.min(start.y, end.y);
	            var bottom = Math.max(start.y, end.y);
	            var left = Math.min(start.x, end.x);
	            var right = Math.max(start.x, end.x);
	            result = new OpenLayers.Bounds(left, bottom, right, top);
	        } else {
	            result = this.dragHandler.start.clone(); // i.e. OL.Pixel
	        } 
	        this.removeBox();

	        this.callback("done", [result]);
	    },

	    /**
	     * Method: removeBox
	     * Remove the zoombox from the screen and nullify our reference to it.
	     */
	    removeBox: function() {
	        this.map.viewPortDiv.removeChild(this.zoomBox);
	        this.zoomBox = null;
	        this.boxOffsets = null;
	        OpenLayers.Element.removeClass(
	            this.map.viewPortDiv, "olDrawBox"
	        );

	    },

	    /**
	     * Method: activate
	     */
	    activate: function () {
	        if (OpenLayers.Handler.prototype.activate.apply(this, arguments)) {
	            this.dragHandler.activate();
	            return true;
	        } else {
	            return false;
	        }
	    },

	    /**
	     * Method: deactivate
	     */
	    deactivate: function () {
	        if (OpenLayers.Handler.prototype.deactivate.apply(this, arguments)) {
	            if (this.dragHandler.deactivate()) {
	                if (this.zoomBox) {
	                    this.removeBox();
	                }
	            }
	            return true;
	        } else {
	            return false;
	        }
	    },
	    
	    /**
	     * Method: getBoxOffsets
	     * Determines border offsets for a box, according to the box model.
	     * 
	     * Returns:
	     * {Object} an object with the following offsets:
	     *     - left
	     *     - right
	     *     - top
	     *     - bottom
	     *     - width
	     *     - height
	     */
	    getBoxOffsets: function() {
	        if (!this.boxOffsets) {
	            // Determine the box model. If the testDiv's clientWidth is 3, then
	            // the borders are outside and we are dealing with the w3c box
	            // model. Otherwise, the browser uses the traditional box model and
	            // the borders are inside the box bounds, leaving us with a
	            // clientWidth of 1.
	            var testDiv = document.createElement("div");
	            //testDiv.style.visibility = "hidden";
	            testDiv.style.position = "absolute";
	            testDiv.style.border = "1px solid black";
	            testDiv.style.width = "3px";
	            document.body.appendChild(testDiv);
	            var w3cBoxModel = testDiv.clientWidth == 3;
	            document.body.removeChild(testDiv);
	            
	            var left = parseInt(OpenLayers.Element.getStyle(this.zoomBox,
	                "border-left-width"));
	            var right = parseInt(OpenLayers.Element.getStyle(
	                this.zoomBox, "border-right-width"));
	            var top = parseInt(OpenLayers.Element.getStyle(this.zoomBox,
	                "border-top-width"));
	            var bottom = parseInt(OpenLayers.Element.getStyle(
	                this.zoomBox, "border-bottom-width"));
	            this.boxOffsets = {
	                left: left,
	                right: right,
	                top: top,
	                bottom: bottom,
	                width: w3cBoxModel === false ? left + right : 0,
	                height: w3cBoxModel === false ? top + bottom : 0
	            };
	        }
	        return this.boxOffsets;
	    },
	  
	    CLASS_NAME: "OpenLayers.Handler.Box"
	});
	/* ======================================================================
	    OpenLayers/Control/ZoomBox.js
	   ====================================================================== */

	/* Copyright (c) 2006-2015 by OpenLayers Contributors (see authors.txt for
	 * full list of contributors). Published under the 2-clause BSD license.
	 * See license.txt in the OpenLayers distribution or repository for the
	 * full text of the license. */

	/**
	 * @requires OpenLayers/Control.js
	 * @requires OpenLayers/Handler/Box.js
	 */

	/**
	 * Class: OpenLayers.Control.ZoomBox
	 * The ZoomBox control enables zooming directly to a given extent, by drawing 
	 * a box on the map. The box is drawn by holding down shift, whilst dragging 
	 * the mouse.
	 *
	 * Inherits from:
	 *  - <OpenLayers.Control>
	 */
	OpenLayers.Control.ZoomBox = OpenLayers.Class(OpenLayers.Control, {
	    /**
	     * Property: type
	     * {OpenLayers.Control.TYPE}
	     */
	    type: OpenLayers.Control.TYPE_TOOL,

	    /**
	     * Property: out
	     * {Boolean} Should the control be used for zooming out?
	     */
	    out: false,

	    /**
	     * APIProperty: keyMask
	     * {Integer} Zoom only occurs if the keyMask matches the combination of 
	     *     keys down. Use bitwise operators and one or more of the
	     *     <OpenLayers.Handler> constants to construct a keyMask. Leave null if 
	     *     not used mask. Default is null.
	     */
	    keyMask: null,

	    /**
	     * APIProperty: alwaysZoom
	     * {Boolean} Always zoom in/out when box drawn, even if the zoom level does
	     * not change.
	     */
	    alwaysZoom: false,
	    
	    /**
	     * APIProperty: zoomOnClick
	     * {Boolean} Should we zoom when no box was dragged, i.e. the user only
	     * clicked? Default is true.
	     */
	    zoomOnClick: true,

	    /**
	     * Method: draw
	     */    
	    draw: function() {
	        this.handler = new OpenLayers.Handler.Box( this,
	                            {done: this.zoomBox}, {keyMask: this.keyMask} );
	    },

	    /**
	     * Method: zoomBox
	     *
	     * Parameters:
	     * position - {<OpenLayers.Bounds>} or {<OpenLayers.Pixel>}
	     */
	    zoomBox: function (position) {
	        if (position instanceof OpenLayers.Bounds) {
	            var bounds,
	                targetCenterPx = position.getCenterPixel();
	            if (!this.out) {
	                var minXY = this.map.getLonLatFromPixel({
	                    x: position.left,
	                    y: position.bottom
	                });
	                var maxXY = this.map.getLonLatFromPixel({
	                    x: position.right,
	                    y: position.top
	                });
	                bounds = new OpenLayers.Bounds(minXY.lon, minXY.lat,
	                                               maxXY.lon, maxXY.lat);
	            } else {
	                var pixWidth = position.right - position.left;
	                var pixHeight = position.bottom - position.top;
	                var zoomFactor = Math.min((this.map.size.h / pixHeight),
	                    (this.map.size.w / pixWidth));
	                var extent = this.map.getExtent();
	                var center = this.map.getLonLatFromPixel(targetCenterPx);
	                var xmin = center.lon - (extent.getWidth()/2)*zoomFactor;
	                var xmax = center.lon + (extent.getWidth()/2)*zoomFactor;
	                var ymin = center.lat - (extent.getHeight()/2)*zoomFactor;
	                var ymax = center.lat + (extent.getHeight()/2)*zoomFactor;
	                bounds = new OpenLayers.Bounds(xmin, ymin, xmax, ymax);
	            }
	            // always zoom in/out 
	            var lastZoom = this.map.getZoom(),
	                size = this.map.getSize(),
	                centerPx = {x: size.w / 2, y: size.h / 2},
	                zoom = this.map.getZoomForExtent(bounds),
	                oldRes = this.map.getResolution(),
	                newRes = this.map.getResolutionForZoom(zoom);
	            if (oldRes == newRes) {
	                this.map.setCenter(this.map.getLonLatFromPixel(targetCenterPx));
	            } else {
	              var zoomOriginPx = {
	                    x: (oldRes * targetCenterPx.x - newRes * centerPx.x) /
	                        (oldRes - newRes),
	                    y: (oldRes * targetCenterPx.y - newRes * centerPx.y) /
	                        (oldRes - newRes)
	                };
	                this.map.zoomTo(zoom, zoomOriginPx);
	            }
	            if (lastZoom == this.map.getZoom() && this.alwaysZoom == true){ 
	                this.map.zoomTo(lastZoom + (this.out ? -1 : 1)); 
	            }
	        } else if (this.zoomOnClick) { // it's a pixel
	            if (!this.out) {
	                this.map.zoomTo(this.map.getZoom() + 1, position);
	            } else {
	                this.map.zoomTo(this.map.getZoom() - 1, position);
	            }
	        }
	    },

	    CLASS_NAME: "OpenLayers.Control.ZoomBox"
	});
	/* ======================================================================
	    OpenLayers/Control/DragPan.js
	   ====================================================================== */

	/* Copyright (c) 2006-2015 by OpenLayers Contributors (see authors.txt for
	 * full list of contributors). Published under the 2-clause BSD license.
	 * See license.txt in the OpenLayers distribution or repository for the
	 * full text of the license. */

	/**
	 * @requires OpenLayers/Control.js
	 * @requires OpenLayers/Handler/Drag.js
	 */

	/**
	 * Class: OpenLayers.Control.DragPan
	 * The DragPan control pans the map with a drag of the mouse.
	 *
	 * Inherits from:
	 *  - <OpenLayers.Control>
	 */
	OpenLayers.Control.DragPan = OpenLayers.Class(OpenLayers.Control, {

	    /** 
	     * Property: type
	     * {OpenLayers.Control.TYPES}
	     */
	    type: OpenLayers.Control.TYPE_TOOL,
	    
	    /**
	     * Property: panned
	     * {Boolean} The map moved.
	     */
	    panned: false,
	    
	    /**
	     * Property: interval
	     * {Integer} The number of milliseconds that should ellapse before
	     *     panning the map again. Defaults to 0 milliseconds, which means that
	     *     no separate cycle is used for panning. In most cases you won't want
	     *     to change this value. For slow machines/devices larger values can be
	     *     tried out.
	     */
	    interval: 0,
	    
	    /**
	     * APIProperty: documentDrag
	     * {Boolean} If set to true, mouse dragging will continue even if the
	     *     mouse cursor leaves the map viewport. Default is false.
	     */
	    documentDrag: false,

	    /**
	     * Property: kinetic
	     * {<OpenLayers.Kinetic>} The OpenLayers.Kinetic object.
	     */
	    kinetic: null,

	    /**
	     * APIProperty: enableKinetic
	     * {Boolean} Set this option to enable "kinetic dragging". Can be
	     *     set to true or to an object. If set to an object this
	     *     object will be passed to the {<OpenLayers.Kinetic>}
	     *     constructor. Defaults to true.
	     *     To get kinetic dragging, ensure that OpenLayers/Kinetic.js is
	     *     included in your build config.
	     */
	    enableKinetic: true,

	    /**
	     * APIProperty: kineticInterval
	     * {Integer} Interval in milliseconds between 2 steps in the "kinetic
	     *     scrolling". Applies only if enableKinetic is set. Defaults
	     *     to 10 milliseconds.
	     */
	    kineticInterval: 10,


	    /**
	     * Method: draw
	     * Creates a Drag handler, using <panMap> and
	     * <panMapDone> as callbacks.
	     */    
	    draw: function() {
	        if (this.enableKinetic && OpenLayers.Kinetic) {
	            var config = {interval: this.kineticInterval};
	            if(typeof this.enableKinetic === "object") {
	                config = OpenLayers.Util.extend(config, this.enableKinetic);
	            }
	            this.kinetic = new OpenLayers.Kinetic(config);
	        }
	        this.handler = new OpenLayers.Handler.Drag(this, {
	                "move": this.panMap,
	                "done": this.panMapDone,
	                "down": this.panMapStart
	            }, {
	                interval: this.interval,
	                documentDrag: this.documentDrag
	            }
	        );
	    },

	    /**
	     * Method: panMapStart
	     */
	    panMapStart: function() {
	        if(this.kinetic) {
	            this.kinetic.begin();
	        }
	    },

	    /**
	    * Method: panMap
	    *
	    * Parameters:
	    * xy - {<OpenLayers.Pixel>} Pixel of the mouse position
	    */
	    panMap: function(xy) {
	        if(this.kinetic) {
	            this.kinetic.update(xy);
	        }
	        this.panned = true;
	        this.map.pan(
	            this.handler.last.x - xy.x,
	            this.handler.last.y - xy.y,
	            {dragging: true, animate: false}
	        );
	    },
	    
	    /**
	     * Method: panMapDone
	     * Finish the panning operation.  Only call setCenter (through <panMap>)
	     *     if the map has actually been moved.
	     *
	     * Parameters:
	     * xy - {<OpenLayers.Pixel>} Pixel of the mouse position
	     */
	    panMapDone: function(xy) {
	        if(this.panned) {
	            var res = null;
	            if (this.kinetic) {
	                res = this.kinetic.end(xy);
	            }
	            this.map.pan(
	                this.handler.last.x - xy.x,
	                this.handler.last.y - xy.y,
	                {dragging: !!res, animate: false}
	            );
	            if (res) {
	                var self = this;
	                this.kinetic.move(res, function(x, y, end) {
	                    self.map.pan(x, y, {dragging: !end, animate: false});
	                });
	            }
	            this.panned = false;
	        }
	    },

	    CLASS_NAME: "OpenLayers.Control.DragPan"
	});
	/* ======================================================================
	    OpenLayers/Handler/MouseWheel.js
	   ====================================================================== */

	/* Copyright (c) 2006-2015 by OpenLayers Contributors (see authors.txt for
	 * full list of contributors). Published under the 2-clause BSD license.
	 * See license.txt in the OpenLayers distribution or repository for the
	 * full text of the license. */

	/**
	 * @requires OpenLayers/Handler.js
	 */

	/**
	 * Class: OpenLayers.Handler.MouseWheel
	 * Handler for wheel up/down events.
	 * 
	 * Inherits from:
	 *  - <OpenLayers.Handler>
	 */
	OpenLayers.Handler.MouseWheel = OpenLayers.Class(OpenLayers.Handler, {
	    /** 
	     * Property: wheelListener 
	     * {function} 
	     */
	    wheelListener: null,

	    /**
	     * Property: interval
	     * {Integer} In order to increase server performance, an interval (in 
	     *     milliseconds) can be set to reduce the number of up/down events 
	     *     called. If set, a new up/down event will not be set until the 
	     *     interval has passed. 
	     *     Defaults to 0, meaning no interval. 
	     */
	    interval: 0,
	    
	    /**
	     * Property: maxDelta
	     * {Integer} Maximum delta to collect before breaking from the current
	     *    interval. In cumulative mode, this also limits the maximum delta
	     *    returned from the handler. Default is Number.POSITIVE_INFINITY.
	     */
	    maxDelta: Number.POSITIVE_INFINITY,
	    
	    /**
	     * Property: delta
	     * {Integer} When interval is set, delta collects the mousewheel z-deltas
	     *     of the events that occur within the interval.
	     *      See also the cumulative option
	     */
	    delta: 0,
	    
	    /**
	     * Property: cumulative
	     * {Boolean} When interval is set: true to collect all the mousewheel 
	     *     z-deltas, false to only record the delta direction (positive or
	     *     negative)
	     */
	    cumulative: true,
	    
	    /**
	     * Constructor: OpenLayers.Handler.MouseWheel
	     *
	     * Parameters:
	     * control - {<OpenLayers.Control>} 
	     * callbacks - {Object} An object containing a single function to be
	     *                          called when the drag operation is finished.
	     *                          The callback should expect to receive a single
	     *                          argument, the point geometry.
	     * options - {Object} 
	     */
	    initialize: function(control, callbacks, options) {
	        OpenLayers.Handler.prototype.initialize.apply(this, arguments);
	        this.wheelListener = OpenLayers.Function.bindAsEventListener(
	            this.onWheelEvent, this
	        );
	    },

	    /**
	     * Method: destroy
	     */    
	    destroy: function() {
	        OpenLayers.Handler.prototype.destroy.apply(this, arguments);
	        this.wheelListener = null;
	    },

	    /**
	     *  Mouse ScrollWheel code thanks to http://adomas.org/javascript-mouse-wheel/
	     */

	    /** 
	     * Method: onWheelEvent
	     * Catch the wheel event and handle it xbrowserly
	     * 
	     * Parameters:
	     * e - {Event} 
	     */
	    onWheelEvent: function(e){
	        
	        // make sure we have a map and check keyboard modifiers
	        if (!this.map || !this.checkModifiers(e)) {
	            return;
	        }
	        
	        // Ride up the element's DOM hierarchy to determine if it or any of 
	        //  its ancestors was: 
	        //   * specifically marked as scrollable (CSS overflow property)
	        //   * one of our layer divs or a div marked as scrollable
	        //     ('olScrollable' CSS class)
	        //   * the map div
	        //
	        var overScrollableDiv = false;
	        var allowScroll = false;
	        var overMapDiv = false;
	        
	        var elem = OpenLayers.Event.element(e);
	        while((elem != null) && !overMapDiv && !overScrollableDiv) {

	            if (!overScrollableDiv) {
	                try {
	                    var overflow;
	                    if (elem.currentStyle) {
	                        overflow = elem.currentStyle["overflow"];
	                    } else {
	                        var style = 
	                            document.defaultView.getComputedStyle(elem, null);
	                        overflow = style.getPropertyValue("overflow");
	                    }
	                    overScrollableDiv = ( overflow && 
	                        (overflow == "auto") || (overflow == "scroll") );
	                } catch(err) {
	                    //sometimes when scrolling in a popup, this causes 
	                    // obscure browser error
	                }
	            }

	            if (!allowScroll) {
	                allowScroll = OpenLayers.Element.hasClass(elem, 'olScrollable');
	                if (!allowScroll) {
	                    for (var i = 0, len = this.map.layers.length; i < len; i++) {
	                        // Are we in the layer div? Note that we have two cases
	                        // here: one is to catch EventPane layers, which have a
	                        // pane above the layer (layer.pane)
	                        var layer = this.map.layers[i];
	                        if (elem == layer.div || elem == layer.pane) {
	                            allowScroll = true;
	                            break;
	                        }
	                    }
	                }
	            }
	            overMapDiv = (elem == this.map.div);

	            elem = elem.parentNode;
	        }
	        
	        // Logic below is the following:
	        //
	        // If we are over a scrollable div or not over the map div:
	        //  * do nothing (let the browser handle scrolling)
	        //
	        //    otherwise 
	        // 
	        //    If we are over the layer div or a 'olScrollable' div:
	        //     * zoom/in out
	        //     then
	        //     * kill event (so as not to also scroll the page after zooming)
	        //
	        //       otherwise
	        //
	        //       Kill the event (dont scroll the page if we wheel over the 
	        //        layerswitcher or the pan/zoom control)
	        //
	        if (!overScrollableDiv && overMapDiv) {
	            if (allowScroll) {
	                var delta = 0;
	                
	                if (e.wheelDelta) {
	                    delta = e.wheelDelta;
	                    if (delta % 160 === 0) {
	                        // opera have steps of 160 instead of 120
	                        delta = delta * 0.75;
	                    }
	                    delta = delta / 120;
	                } else if (e.detail) {
	                    // detail in Firefox on OS X is 1/3 of Windows
	                    // so force delta 1 / -1
	                    delta = - (e.detail / Math.abs(e.detail));
	                }
	                this.delta += delta;

	                window.clearTimeout(this._timeoutId);
	                if(this.interval && Math.abs(this.delta) < this.maxDelta) {
	                    // store e because window.event might change during delay
	                    var evt = OpenLayers.Util.extend({}, e);
	                    this._timeoutId = window.setTimeout(
	                        OpenLayers.Function.bind(function(){
	                            this.wheelZoom(evt);
	                        }, this),
	                        this.interval
	                    );
	                } else {
	                    this.wheelZoom(e);
	                }
	            }
	            OpenLayers.Event.stop(e);
	        }
	    },

	    /**
	     * Method: wheelZoom
	     * Given the wheel event, we carry out the appropriate zooming in or out,
	     *     based on the 'wheelDelta' or 'detail' property of the event.
	     * 
	     * Parameters:
	     * e - {Event}
	     */
	    wheelZoom: function(e) {
	        var delta = this.delta;
	        this.delta = 0;
	        
	        if (delta) {
	            e.xy = this.map.events.getMousePosition(e);
	            if (delta < 0) {
	                this.callback("down",
	                    [e, this.cumulative ? Math.max(-this.maxDelta, delta) : -1]);
	            } else {
	                this.callback("up",
	                    [e, this.cumulative ? Math.min(this.maxDelta, delta) : 1]);
	            }
	        }
	    },
	    
	    /**
	     * Method: activate 
	     */
	    activate: function (evt) {
	        if (OpenLayers.Handler.prototype.activate.apply(this, arguments)) {
	            //register mousewheel events specifically on the window and document
	            var wheelListener = this.wheelListener;
	            OpenLayers.Event.observe(window, "DOMMouseScroll", wheelListener);
	            OpenLayers.Event.observe(window, "mousewheel", wheelListener);
	            OpenLayers.Event.observe(document, "mousewheel", wheelListener);
	            return true;
	        } else {
	            return false;
	        }
	    },

	    /**
	     * Method: deactivate 
	     */
	    deactivate: function (evt) {
	        if (OpenLayers.Handler.prototype.deactivate.apply(this, arguments)) {
	            // unregister mousewheel events specifically on the window and document
	            var wheelListener = this.wheelListener;
	            OpenLayers.Event.stopObserving(window, "DOMMouseScroll", wheelListener);
	            OpenLayers.Event.stopObserving(window, "mousewheel", wheelListener);
	            OpenLayers.Event.stopObserving(document, "mousewheel", wheelListener);
	            return true;
	        } else {
	            return false;
	        }
	    },

	    CLASS_NAME: "OpenLayers.Handler.MouseWheel"
	});
	/* ======================================================================
	    OpenLayers/Handler/Click.js
	   ====================================================================== */

	/* Copyright (c) 2006-2015 by OpenLayers Contributors (see authors.txt for
	 * full list of contributors). Published under the 2-clause BSD license.
	 * See license.txt in the OpenLayers distribution or repository for the
	 * full text of the license. */

	/**
	 * @requires OpenLayers/Handler.js
	 */

	/**
	 * Class: OpenLayers.Handler.Click
	 * A handler for mouse clicks.  The intention of this handler is to give
	 *     controls more flexibility with handling clicks.  Browsers trigger
	 *     click events twice for a double-click.  In addition, the mousedown,
	 *     mousemove, mouseup sequence fires a click event.  With this handler,
	 *     controls can decide whether to ignore clicks associated with a double
	 *     click.  By setting a <pixelTolerance>, controls can also ignore clicks
	 *     that include a drag.  Create a new instance with the
	 *     <OpenLayers.Handler.Click> constructor.
	 * 
	 * Inherits from:
	 *  - <OpenLayers.Handler> 
	 */
	OpenLayers.Handler.Click = OpenLayers.Class(OpenLayers.Handler, {
	    /**
	     * APIProperty: delay
	     * {Number} Number of milliseconds between clicks before the event is
	     *     considered a double-click.
	     */
	    delay: 300,
	    
	    /**
	     * APIProperty: single
	     * {Boolean} Handle single clicks.  Default is true.  If false, clicks
	     * will not be reported.  If true, single-clicks will be reported.
	     */
	    single: true,
	    
	    /**
	     * APIProperty: double
	     * {Boolean} Handle double-clicks.  Default is false.
	     */
	    'double': false,
	    
	    /**
	     * APIProperty: pixelTolerance
	     * {Number} Maximum number of pixels between mouseup and mousedown for an
	     *     event to be considered a click.  Default is 0.  If set to an
	     *     integer value, clicks with a drag greater than the value will be
	     *     ignored.  This property can only be set when the handler is
	     *     constructed.
	     */
	    pixelTolerance: 0,
	        
	    /**
	     * APIProperty: dblclickTolerance
	     * {Number} Maximum distance in pixels between clicks for a sequence of 
	     *     events to be considered a double click.  Default is 13.  If the
	     *     distance between two clicks is greater than this value, a double-
	     *     click will not be fired.
	     */
	    dblclickTolerance: 13,
	        
	    /**
	     * APIProperty: stopSingle
	     * {Boolean} Stop other listeners from being notified of clicks.  Default
	     *     is false.  If true, any listeners registered before this one for 
	     *     click or rightclick events will not be notified.
	     */
	    stopSingle: false,
	    
	    /**
	     * APIProperty: stopDouble
	     * {Boolean} Stop other listeners from being notified of double-clicks.
	     *     Default is false.  If true, any click listeners registered before
	     *     this one will not be notified of *any* double-click events.
	     * 
	     * The one caveat with stopDouble is that given a map with two click
	     *     handlers, one with stopDouble true and the other with stopSingle
	     *     true, the stopSingle handler should be activated last to get
	     *     uniform cross-browser performance.  Since IE triggers one click
	     *     with a dblclick and FF triggers two, if a stopSingle handler is
	     *     activated first, all it gets in IE is a single click when the
	     *     second handler stops propagation on the dblclick.
	     */
	    stopDouble: false,

	    /**
	     * Property: timerId
	     * {Number} The id of the timeout waiting to clear the <delayedCall>.
	     */
	    timerId: null,
	    
	    /**
	     * Property: down
	     * {Object} Object that store relevant information about the last
	     *     mousedown or touchstart. Its 'xy' OpenLayers.Pixel property gives
	     *     the average location of the mouse/touch event. Its 'touches'
	     *     property records clientX/clientY of each touches.
	     */
	    down: null,

	    /**
	     * Property: last
	     * {Object} Object that store relevant information about the last
	     *     mousemove or touchmove. Its 'xy' OpenLayers.Pixel property gives
	     *     the average location of the mouse/touch event. Its 'touches'
	     *     property records clientX/clientY of each touches.
	     */
	    last: null,

	    /** 
	     * Property: first
	     * {Object} When waiting for double clicks, this object will store 
	     *     information about the first click in a two click sequence.
	     */
	    first: null,

	    /**
	     * Property: rightclickTimerId
	     * {Number} The id of the right mouse timeout waiting to clear the 
	     *     <delayedEvent>.
	     */
	    rightclickTimerId: null,
	    
	    /**
	     * Constructor: OpenLayers.Handler.Click
	     * Create a new click handler.
	     * 
	     * Parameters:
	     * control - {<OpenLayers.Control>} The control that is making use of
	     *     this handler.  If a handler is being used without a control, the
	     *     handler's setMap method must be overridden to deal properly with
	     *     the map.
	     * callbacks - {Object} An object with keys corresponding to callbacks
	     *     that will be called by the handler. The callbacks should
	     *     expect to receive a single argument, the click event.
	     *     Callbacks for 'click' and 'dblclick' are supported.
	     * options - {Object} Optional object whose properties will be set on the
	     *     handler.
	     */
	    
	    /**
	     * Method: touchstart
	     * Handle touchstart.
	     *
	     * Returns:
	     * {Boolean} Continue propagating this event.
	     */
	    touchstart: function(evt) {
	        this.startTouch();
	        this.down = this.getEventInfo(evt);
	        this.last = this.getEventInfo(evt);
	        return true;
	    },
	    
	    /**
	     * Method: touchmove
	     *    Store position of last move, because touchend event can have
	     *    an empty "touches" property.
	     *
	     * Returns:
	     * {Boolean} Continue propagating this event.
	     */
	    touchmove: function(evt) {
	        this.last = this.getEventInfo(evt);
	        return true;
	    },

	    /**
	     * Method: touchend
	     *   Correctly set event xy property, and add lastTouches to have
	     *   touches property from last touchstart or touchmove
	     *
	     * Returns:
	     * {Boolean} Continue propagating this event.
	     */
	    touchend: function(evt) {
	        // touchstart may not have been allowed to propagate
	        if (this.down) {
	            evt.xy = this.last.xy;
	            evt.lastTouches = this.last.touches;
	            this.handleSingle(evt);
	            this.down = null;
	        }
	        return true;
	    },

	    /**
	     * Method: mousedown
	     * Handle mousedown.
	     *
	     * Returns:
	     * {Boolean} Continue propagating this event.
	     */
	    mousedown: function(evt) {
	        this.down = this.getEventInfo(evt);
	        this.last = this.getEventInfo(evt);
	        return true;
	    },

	    /**
	     * Method: mouseup
	     * Handle mouseup.  Installed to support collection of right mouse events.
	     * 
	     * Returns:
	     * {Boolean} Continue propagating this event.
	     */
	    mouseup: function (evt) {
	        var propagate = true;

	        // Collect right mouse clicks from the mouseup
	        //  IE - ignores the second right click in mousedown so using
	        //  mouseup instead
	        if (this.checkModifiers(evt) && this.control.handleRightClicks &&
	           OpenLayers.Event.isRightClick(evt)) {
	            propagate = this.rightclick(evt);
	        }

	        return propagate;
	    },
	    
	    /**
	     * Method: rightclick
	     * Handle rightclick.  For a dblrightclick, we get two clicks so we need 
	     *     to always register for dblrightclick to properly handle single 
	     *     clicks.
	     *     
	     * Returns:
	     * {Boolean} Continue propagating this event.
	     */
	    rightclick: function(evt) {
	        if(this.passesTolerance(evt)) {
	           if(this.rightclickTimerId != null) {
	                //Second click received before timeout this must be 
	                // a double click
	                this.clearTimer();
	                this.callback('dblrightclick', [evt]);
	                return !this.stopDouble;
	            } else { 
	                //Set the rightclickTimerId, send evt only if double is 
	                // true else trigger single
	                var clickEvent = this['double'] ?
	                    OpenLayers.Util.extend({}, evt) : 
	                    this.callback('rightclick', [evt]);

	                var delayedRightCall = OpenLayers.Function.bind(
	                    this.delayedRightCall, 
	                    this, 
	                    clickEvent
	                );
	                this.rightclickTimerId = window.setTimeout(
	                    delayedRightCall, this.delay
	                );
	            } 
	        }
	        return !this.stopSingle;
	    },
	    
	    /**
	     * Method: delayedRightCall
	     * Sets <rightclickTimerId> to null.  And optionally triggers the 
	     *     rightclick callback if evt is set.
	     */
	    delayedRightCall: function(evt) {
	        this.rightclickTimerId = null;
	        if (evt) {
	           this.callback('rightclick', [evt]);
	        }
	    },
	    
	    /**
	     * Method: click
	     * Handle click events from the browser.  This is registered as a listener
	     *     for click events and should not be called from other events in this
	     *     handler.
	     *
	     * Returns:
	     * {Boolean} Continue propagating this event.
	     */
	    click: function(evt) {
	        if (!this.last) {
	            this.last = this.getEventInfo(evt);
	        }
	        this.handleSingle(evt);
	        return !this.stopSingle;
	    },

	    /**
	     * Method: dblclick
	     * Handle dblclick.  For a dblclick, we get two clicks in some browsers
	     *     (FF) and one in others (IE).  So we need to always register for
	     *     dblclick to properly handle single clicks.  This method is registered
	     *     as a listener for the dblclick browser event.  It should *not* be
	     *     called by other methods in this handler.
	     *     
	     * Returns:
	     * {Boolean} Continue propagating this event.
	     */
	    dblclick: function(evt) {
	        this.handleDouble(evt);
	        return !this.stopDouble;
	    },
	    
	    /** 
	     * Method: handleDouble
	     * Handle double-click sequence.
	     */
	    handleDouble: function(evt) {
	        if (this.passesDblclickTolerance(evt)) {
	            if (this["double"]) {
	                this.callback("dblclick", [evt]);
	            }
	            // to prevent a dblclick from firing the click callback in IE
	            this.clearTimer();
	        }
	    },
	    
	    /** 
	     * Method: handleSingle
	     * Handle single click sequence.
	     */
	    handleSingle: function(evt) {
	        if (this.passesTolerance(evt)) {
	            if (this.timerId != null) {
	                // already received a click
	                if (this.last.touches && this.last.touches.length === 1) {
	                    // touch device, no dblclick event - this may be a double
	                    if (this["double"]) {
	                        // on Android don't let the browser zoom on the page
	                        OpenLayers.Event.preventDefault(evt);
	                    }
	                    this.handleDouble(evt);
	                }
	                // if we're not in a touch environment we clear the click timer
	                // if we've got a second touch, we'll get two touchend events
	                if (!this.last.touches || this.last.touches.length !== 2) {
	                    this.clearTimer();
	                }
	            } else {
	                // remember the first click info so we can compare to the second
	                this.first = this.getEventInfo(evt);
	                // set the timer, send evt only if single is true
	                //use a clone of the event object because it will no longer 
	                //be a valid event object in IE in the timer callback
	                var clickEvent = this.single ?
	                    OpenLayers.Util.extend({}, evt) : null;
	                this.queuePotentialClick(clickEvent);
	            }
	        }
	    },
	    
	    /** 
	     * Method: queuePotentialClick
	     * This method is separated out largely to make testing easier (so we
	     *     don't have to override window.setTimeout)
	     */
	    queuePotentialClick: function(evt) {
	        this.timerId = window.setTimeout(
	            OpenLayers.Function.bind(this.delayedCall, this, evt),
	            this.delay
	        );
	    },

	    /**
	     * Method: passesTolerance
	     * Determine whether the event is within the optional pixel tolerance.  Note
	     *     that the pixel tolerance check only works if mousedown events get to
	     *     the listeners registered here.  If they are stopped by other elements,
	     *     the <pixelTolerance> will have no effect here (this method will always
	     *     return true).
	     *
	     * Returns:
	     * {Boolean} The click is within the pixel tolerance (if specified).
	     */
	    passesTolerance: function(evt) {
	        var passes = true;
	        if (this.pixelTolerance != null && this.down && this.down.xy) {
	            passes = this.pixelTolerance >= this.down.xy.distanceTo(evt.xy);
	            // for touch environments, we also enforce that all touches
	            // start and end within the given tolerance to be considered a click
	            if (passes && this.touch && 
	                this.down.touches.length === this.last.touches.length) {
	                // the touchend event doesn't come with touches, so we check
	                // down and last
	                for (var i=0, ii=this.down.touches.length; i<ii; ++i) {
	                    if (this.getTouchDistance(
	                            this.down.touches[i], 
	                            this.last.touches[i]
	                        ) > this.pixelTolerance) {
	                        passes = false;
	                        break;
	                    }
	                }
	            }
	        }
	        return passes;
	    },
	    
	    /** 
	     * Method: getTouchDistance
	     *
	     * Returns:
	     * {Boolean} The pixel displacement between two touches.
	     */
	    getTouchDistance: function(from, to) {
	        return Math.sqrt(
	            Math.pow(from.clientX - to.clientX, 2) +
	            Math.pow(from.clientY - to.clientY, 2)
	        );
	    },
	    
	    /**
	     * Method: passesDblclickTolerance
	     * Determine whether the event is within the optional double-cick pixel 
	     *     tolerance.
	     *
	     * Returns:
	     * {Boolean} The click is within the double-click pixel tolerance.
	     */
	    passesDblclickTolerance: function(evt) {
	        var passes = true;
	        if (this.down && this.first) {
	            passes = this.down.xy.distanceTo(this.first.xy) <= this.dblclickTolerance;
	        }
	        return passes;
	    },

	    /**
	     * Method: clearTimer
	     * Clear the timer and set <timerId> to null.
	     */
	    clearTimer: function() {
	        if (this.timerId != null) {
	            window.clearTimeout(this.timerId);
	            this.timerId = null;
	        }
	        if (this.rightclickTimerId != null) {
	            window.clearTimeout(this.rightclickTimerId);
	            this.rightclickTimerId = null;
	        }
	    },
	    
	    /**
	     * Method: delayedCall
	     * Sets <timerId> to null.  And optionally triggers the click callback if
	     *     evt is set.
	     */
	    delayedCall: function(evt) {
	        this.timerId = null;
	        if (evt) {
	            this.callback("click", [evt]);
	        }
	    },

	    /**
	     * Method: getEventInfo
	     * This method allows us to store event information without storing the
	     *     actual event.  In touch devices (at least), the same event is 
	     *     modified between touchstart, touchmove, and touchend.
	     *
	     * Returns:
	     * {Object} An object with event related info.
	     */
	    getEventInfo: function(evt) {
	        var touches;
	        if (evt.touches) {
	            var len = evt.touches.length;
	            touches = new Array(len);
	            var touch;
	            for (var i=0; i<len; i++) {
	                touch = evt.touches[i];
	                touches[i] = {
	                    clientX: touch.olClientX,
	                    clientY: touch.olClientY
	                };
	            }
	        }
	        return {
	            xy: evt.xy,
	            touches: touches
	        };
	    },

	    /**
	     * APIMethod: deactivate
	     * Deactivate the handler.
	     *
	     * Returns:
	     * {Boolean} The handler was successfully deactivated.
	     */
	    deactivate: function() {
	        var deactivated = false;
	        if(OpenLayers.Handler.prototype.deactivate.apply(this, arguments)) {
	            this.clearTimer();
	            this.down = null;
	            this.first = null;
	            this.last = null;
	            deactivated = true;
	        }
	        return deactivated;
	    },

	    CLASS_NAME: "OpenLayers.Handler.Click"
	});
	/* ======================================================================
	    OpenLayers/Control/Navigation.js
	   ====================================================================== */

	/* Copyright (c) 2006-2015 by OpenLayers Contributors (see authors.txt for
	 * full list of contributors). Published under the 2-clause BSD license.
	 * See license.txt in the OpenLayers distribution or repository for the
	 * full text of the license. */

	/**
	 * @requires OpenLayers/Control/ZoomBox.js
	 * @requires OpenLayers/Control/DragPan.js
	 * @requires OpenLayers/Handler/MouseWheel.js
	 * @requires OpenLayers/Handler/Click.js
	 */

	/**
	 * Class: OpenLayers.Control.Navigation
	 * The navigation control handles map browsing with mouse events (dragging,
	 *     double-clicking, and scrolling the wheel).  Create a new navigation 
	 *     control with the <OpenLayers.Control.Navigation> control.  
	 * 
	 *     Note that this control is added to the map by default (if no controls 
	 *     array is sent in the options object to the <OpenLayers.Map> 
	 *     constructor).
	 * 
	 * Inherits:
	 *  - <OpenLayers.Control>
	 */
	OpenLayers.Control.Navigation = OpenLayers.Class(OpenLayers.Control, {

	    /** 
	     * Property: dragPan
	     * {<OpenLayers.Control.DragPan>} 
	     */
	    dragPan: null,

	    /**
	     * APIProperty: dragPanOptions
	     * {Object} Options passed to the DragPan control.
	     */
	    dragPanOptions: null,

	    /**
	     * Property: pinchZoom
	     * {<OpenLayers.Control.PinchZoom>}
	     */
	    pinchZoom: null,

	    /**
	     * APIProperty: pinchZoomOptions
	     * {Object} Options passed to the PinchZoom control.
	     */
	    pinchZoomOptions: null,

	    /**
	     * APIProperty: documentDrag
	     * {Boolean} Allow panning of the map by dragging outside map viewport.
	     *     Default is false.
	     */
	    documentDrag: false,

	    /** 
	     * Property: zoomBox
	     * {<OpenLayers.Control.ZoomBox>}
	     */
	    zoomBox: null,

	    /**
	     * APIProperty: zoomBoxEnabled
	     * {Boolean} Whether the user can draw a box to zoom
	     */
	    zoomBoxEnabled: true, 

	    /**
	     * APIProperty: zoomWheelEnabled
	     * {Boolean} Whether the mousewheel should zoom the map
	     */
	    zoomWheelEnabled: true,
	    
	    /**
	     * Property: mouseWheelOptions
	     * {Object} Options passed to the MouseWheel control (only useful if
	     *     <zoomWheelEnabled> is set to true). Default is no options for maps
	     *     with fractionalZoom set to true, otherwise
	     *     {cumulative: false, interval: 50, maxDelta: 6} 
	     */
	    mouseWheelOptions: null,

	    /**
	     * APIProperty: handleRightClicks
	     * {Boolean} Whether or not to handle right clicks. Default is false.
	     */
	    handleRightClicks: false,

	    /**
	     * APIProperty: zoomBoxKeyMask
	     * {Integer} <OpenLayers.Handler> key code of the key, which has to be
	     *    pressed, while drawing the zoom box with the mouse on the screen. 
	     *    You should probably set handleRightClicks to true if you use this
	     *    with MOD_CTRL, to disable the context menu for machines which use
	     *    CTRL-Click as a right click.
	     * Default: <OpenLayers.Handler.MOD_SHIFT>
	     */
	    zoomBoxKeyMask: OpenLayers.Handler.MOD_SHIFT,
	    
	    /**
	     * APIProperty: autoActivate
	     * {Boolean} Activate the control when it is added to a map.  Default is
	     *     true.
	     */
	    autoActivate: true,

	    /**
	     * Constructor: OpenLayers.Control.Navigation
	     * Create a new navigation control
	     * 
	     * Parameters:
	     * options - {Object} An optional object whose properties will be set on
	     *                    the control
	     */
	    initialize: function(options) {
	        this.handlers = {};
	        OpenLayers.Control.prototype.initialize.apply(this, arguments);
	    },

	    /**
	     * Method: destroy
	     * The destroy method is used to perform any clean up before the control
	     * is dereferenced.  Typically this is where event listeners are removed
	     * to prevent memory leaks.
	     */
	    destroy: function() {
	        this.deactivate();

	        if (this.dragPan) {
	            this.dragPan.destroy();
	        }
	        this.dragPan = null;

	        if (this.zoomBox) {
	            this.zoomBox.destroy();
	        }
	        this.zoomBox = null;

	        if (this.pinchZoom) {
	            this.pinchZoom.destroy();
	        }
	        this.pinchZoom = null;

	        OpenLayers.Control.prototype.destroy.apply(this,arguments);
	    },
	    
	    /**
	     * Method: activate
	     */
	    activate: function() {
	        this.dragPan.activate();
	        if (this.zoomWheelEnabled) {
	            this.handlers.wheel.activate();
	        }    
	        this.handlers.click.activate();
	        if (this.zoomBoxEnabled) {
	            this.zoomBox.activate();
	        }
	        if (this.pinchZoom) {
	            this.pinchZoom.activate();
	        }
	        return OpenLayers.Control.prototype.activate.apply(this,arguments);
	    },

	    /**
	     * Method: deactivate
	     */
	    deactivate: function() {
	        if (this.pinchZoom) {
	            this.pinchZoom.deactivate();
	        }
	        this.zoomBox.deactivate();
	        this.dragPan.deactivate();
	        this.handlers.click.deactivate();
	        this.handlers.wheel.deactivate();
	        return OpenLayers.Control.prototype.deactivate.apply(this,arguments);
	    },
	    
	    /**
	     * Method: draw
	     */
	    draw: function() {
	        // disable right mouse context menu for support of right click events
	        if (this.handleRightClicks) {
	            this.map.viewPortDiv.oncontextmenu = OpenLayers.Function.False;
	        }

	        var clickCallbacks = { 
	            'click': this.defaultClick,
	            'dblclick': this.defaultDblClick, 
	            'dblrightclick': this.defaultDblRightClick 
	        };
	        var clickOptions = {
	            'double': true, 
	            'stopDouble': true
	        };
	        this.handlers.click = new OpenLayers.Handler.Click(
	            this, clickCallbacks, clickOptions
	        );
	        this.dragPan = new OpenLayers.Control.DragPan(
	            OpenLayers.Util.extend({
	                map: this.map,
	                documentDrag: this.documentDrag
	            }, this.dragPanOptions)
	        );
	        this.zoomBox = new OpenLayers.Control.ZoomBox(
	                    {map: this.map, keyMask: this.zoomBoxKeyMask});
	        this.dragPan.draw();
	        this.zoomBox.draw();
	        var wheelOptions = this.map.fractionalZoom ? {} : {
	            cumulative: false,
	            interval: 50,
	            maxDelta: 6
	        };
	        this.handlers.wheel = new OpenLayers.Handler.MouseWheel(
	            this, {up : this.wheelUp, down: this.wheelDown},
	            OpenLayers.Util.extend(wheelOptions, this.mouseWheelOptions)
	        );
	        if (OpenLayers.Control.PinchZoom) {
	            this.pinchZoom = new OpenLayers.Control.PinchZoom(
	                OpenLayers.Util.extend(
	                    {map: this.map}, this.pinchZoomOptions));
	        }
	    },

	    /**
	     * Method: defaultClick
	     *
	     * Parameters:
	     * evt - {Event}
	     */
	    defaultClick: function (evt) {
	        if (evt.lastTouches && evt.lastTouches.length == 2) {
	            this.map.zoomOut();
	        }
	    },

	    /**
	     * Method: defaultDblClick 
	     * 
	     * Parameters:
	     * evt - {Event} 
	     */
	    defaultDblClick: function (evt) {
	        this.map.zoomTo(this.map.zoom + 1, evt.xy);
	    },

	    /**
	     * Method: defaultDblRightClick 
	     * 
	     * Parameters:
	     * evt - {Event} 
	     */
	    defaultDblRightClick: function (evt) {
	        this.map.zoomTo(this.map.zoom - 1, evt.xy);
	    },
	    
	    /**
	     * Method: wheelChange  
	     *
	     * Parameters:
	     * evt - {Event}
	     * deltaZ - {Integer}
	     */
	    wheelChange: function(evt, deltaZ) {
	        if (!this.map.fractionalZoom) {
	            deltaZ =  Math.round(deltaZ);
	        }
	        var currentZoom = this.map.getZoom(),
	            newZoom = currentZoom + deltaZ;
	        newZoom = Math.max(newZoom, 0);
	        newZoom = Math.min(newZoom, this.map.getNumZoomLevels());
	        if (newZoom === currentZoom) {
	            return;
	        }
	        this.map.zoomTo(newZoom, evt.xy);
	    },

	    /** 
	     * Method: wheelUp
	     * User spun scroll wheel up
	     * 
	     * Parameters:
	     * evt - {Event}
	     * delta - {Integer}
	     */
	    wheelUp: function(evt, delta) {
	        this.wheelChange(evt, delta || 1);
	    },

	    /** 
	     * Method: wheelDown
	     * User spun scroll wheel down
	     * 
	     * Parameters:
	     * evt - {Event}
	     * delta - {Integer}
	     */
	    wheelDown: function(evt, delta) {
	        this.wheelChange(evt, delta || -1);
	    },
	    
	    /**
	     * Method: disableZoomBox
	     */
	    disableZoomBox : function() {
	        this.zoomBoxEnabled = false;
	        this.zoomBox.deactivate();       
	    },
	    
	    /**
	     * Method: enableZoomBox
	     */
	    enableZoomBox : function() {
	        this.zoomBoxEnabled = true;
	        if (this.active) {
	            this.zoomBox.activate();
	        }    
	    },
	    
	    /**
	     * Method: disableZoomWheel
	     */
	    
	    disableZoomWheel : function() {
	        this.zoomWheelEnabled = false;
	        this.handlers.wheel.deactivate();       
	    },
	    
	    /**
	     * Method: enableZoomWheel
	     */
	    
	    enableZoomWheel : function() {
	        this.zoomWheelEnabled = true;
	        if (this.active) {
	            this.handlers.wheel.activate();
	        }    
	    },

	    CLASS_NAME: "OpenLayers.Control.Navigation"
	});
	/* ======================================================================
	    OpenLayers/Handler/Keyboard.js
	   ====================================================================== */

	/* Copyright (c) 2006-2015 by OpenLayers Contributors (see authors.txt for
	 * full list of contributors). Published under the 2-clause BSD license.
	 * See license.txt in the OpenLayers distribution or repository for the
	 * full text of the license. */

	/**
	 * @requires OpenLayers/Handler.js
	 * @requires OpenLayers/Events.js
	 */

	/**
	 * Class: OpenLayers.handler.Keyboard
	 * A handler for keyboard events.  Create a new instance with the
	 *     <OpenLayers.Handler.Keyboard> constructor.
	 * 
	 * Inherits from:
	 *  - <OpenLayers.Handler> 
	 */
	OpenLayers.Handler.Keyboard = OpenLayers.Class(OpenLayers.Handler, {

	    /* http://www.quirksmode.org/js/keys.html explains key x-browser
	        key handling quirks in pretty nice detail */

	    /** 
	     * Constant: KEY_EVENTS
	     * keydown, keypress, keyup
	     */
	    KEY_EVENTS: ["keydown", "keyup"],

	    /** 
	    * Property: eventListener
	    * {Function}
	    */
	    eventListener: null,

	    /**
	     * Property: observeElement
	     * {DOMElement|String} The DOM element on which we listen for
	     *     key events. Default to the document.
	     */
	    observeElement: null,

	    /**
	     * Constructor: OpenLayers.Handler.Keyboard
	     * Returns a new keyboard handler.
	     * 
	     * Parameters:
	     * control - {<OpenLayers.Control>} The control that is making use of
	     *     this handler.  If a handler is being used without a control, the
	     *     handlers setMap method must be overridden to deal properly with
	     *     the map.
	     * callbacks - {Object} An object containing a single function to be
	     *     called when the drag operation is finished. The callback should
	     *     expect to receive a single argument, the pixel location of the event.
	     *     Callbacks for 'keydown', 'keypress', and 'keyup' are supported.
	     * options - {Object} Optional object whose properties will be set on the
	     *     handler.
	     */
	    initialize: function(control, callbacks, options) {
	        OpenLayers.Handler.prototype.initialize.apply(this, arguments);
	        // cache the bound event listener method so it can be unobserved later
	        this.eventListener = OpenLayers.Function.bindAsEventListener(
	            this.handleKeyEvent, this
	        );
	    },
	    
	    /**
	     * Method: destroy
	     */
	    destroy: function() {
	        this.deactivate();
	        this.eventListener = null;
	        OpenLayers.Handler.prototype.destroy.apply(this, arguments);
	    },

	    /**
	     * Method: activate
	     */
	    activate: function() {
	        if (OpenLayers.Handler.prototype.activate.apply(this, arguments)) {
	            this.observeElement = this.observeElement || document;
	            for (var i=0, len=this.KEY_EVENTS.length; i<len; i++) {
	                OpenLayers.Event.observe(
	                    this.observeElement, this.KEY_EVENTS[i], this.eventListener);
	            }
	            return true;
	        } else {
	            return false;
	        }
	    },

	    /**
	     * Method: deactivate
	     */
	    deactivate: function() {
	        var deactivated = false;
	        if (OpenLayers.Handler.prototype.deactivate.apply(this, arguments)) {
	            for (var i=0, len=this.KEY_EVENTS.length; i<len; i++) {
	                OpenLayers.Event.stopObserving(
	                    this.observeElement, this.KEY_EVENTS[i], this.eventListener);
	            }
	            deactivated = true;
	        }
	        return deactivated;
	    },

	    /**
	     * Method: handleKeyEvent 
	     */
	    handleKeyEvent: function (evt) {
	        if (this.checkModifiers(evt)) {
	            this.callback(evt.type, [evt]);
	        }
	    },

	    CLASS_NAME: "OpenLayers.Handler.Keyboard"
	});
	/* ======================================================================
	    OpenLayers/Control/KeyboardDefaults.js
	   ====================================================================== */

	/* Copyright (c) 2006-2015 by OpenLayers Contributors (see authors.txt for
	 * full list of contributors). Published under the 2-clause BSD license.
	 * See license.txt in the OpenLayers distribution or repository for the
	 * full text of the license. */

	/**
	 * @requires OpenLayers/Control.js
	 * @requires OpenLayers/Handler/Keyboard.js
	 * @requires OpenLayers/Events.js
	 */

	/**
	 * Class: OpenLayers.Control.KeyboardDefaults
	 * The KeyboardDefaults control adds panning and zooming functions, controlled
	 * with the keyboard. By default arrow keys pan, +/- keys zoom & Page Up/Page
	 * Down/Home/End scroll by three quarters of a page.
	 * 
	 * This control has no visible appearance.
	 *
	 * Inherits from:
	 *  - <OpenLayers.Control>
	 */
	OpenLayers.Control.KeyboardDefaults = OpenLayers.Class(OpenLayers.Control, {

	    /**
	     * APIProperty: autoActivate
	     * {Boolean} Activate the control when it is added to a map.  Default is
	     *     true.
	     */
	    autoActivate: true,

	    /**
	     * APIProperty: slideFactor
	     * Pixels to slide by.
	     */
	    slideFactor: 75,

	    /**
	     * APIProperty: observeElement
	     * {DOMelement|String} The DOM element to handle keys for. You
	     *     can use the map div here, to have the navigation keys
	     *     work when the map div has the focus. If undefined the
	     *     document is used.
	     */
	    observeElement: null,

	    /**
	     * Constructor: OpenLayers.Control.KeyboardDefaults
	     */
	        
	    /**
	     * Method: draw
	     * Create handler.
	     */
	    draw: function() {
	        var observeElement = this.observeElement || document;
	        this.handler = new OpenLayers.Handler.Keyboard( this,
	                {"keydown": this.defaultKeyPress},
	                {observeElement: observeElement}
	        );
	    },
	    
	    /**
	     * Method: defaultKeyPress
	     * When handling the key event, we only use evt.keyCode. This holds 
	     * some drawbacks, though we get around them below. When interpretting
	     * the keycodes below (including the comments associated with them),
	     * consult the URL below. For instance, the Safari browser returns
	     * "IE keycodes", and so is supported by any keycode labeled "IE".
	     * 
	     * Very informative URL:
	     *    http://unixpapa.com/js/key.html
	     *
	     * Parameters:
	     * evt - {Event} 
	     */
	    defaultKeyPress: function (evt) {
	        var size, handled = true;

	        var target = OpenLayers.Event.element(evt);
	        if (target  &&
	            (target.tagName == 'INPUT' ||
	             target.tagName == 'TEXTAREA' ||
	             target.tagName == 'SELECT')) {
	            return;
	        }

	        switch (evt.keyCode) {
	            case OpenLayers.Event.KEY_LEFT:
	                this.map.pan(-this.slideFactor, 0);
	                break;
	            case OpenLayers.Event.KEY_RIGHT: 
	                this.map.pan(this.slideFactor, 0);
	                break;
	            case OpenLayers.Event.KEY_UP:
	                this.map.pan(0, -this.slideFactor);
	                break;
	            case OpenLayers.Event.KEY_DOWN:
	                this.map.pan(0, this.slideFactor);
	                break;
	            
	            case 33: // Page Up. Same in all browsers.
	                size = this.map.getSize();
	                this.map.pan(0, -0.75*size.h);
	                break;
	            case 34: // Page Down. Same in all browsers.
	                size = this.map.getSize();
	                this.map.pan(0, 0.75*size.h);
	                break; 
	            case 35: // End. Same in all browsers.
	                size = this.map.getSize();
	                this.map.pan(0.75*size.w, 0);
	                break; 
	            case 36: // Home. Same in all browsers.
	                size = this.map.getSize();
	                this.map.pan(-0.75*size.w, 0);
	                break; 

	            case 43:  // +/= (ASCII), keypad + (ASCII, Opera)
	            case 61:  // +/= (Mozilla, Opera, some ASCII)
	            case 187: // +/= (IE)
	            case 107: // keypad + (IE, Mozilla)
	                this.map.zoomIn();
	                break; 
	            case 45:  // -/_ (ASCII, Opera), keypad - (ASCII, Opera)
	            case 109: // -/_ (Mozilla), keypad - (Mozilla, IE)
	            case 189: // -/_ (IE)
	            case 95:  // -/_ (some ASCII)
	                this.map.zoomOut();
	                break; 
	            default:
	                handled = false;
	        }
	        if (handled) {
	            // prevent browser default not to move the page
	            // when moving the page with the keyboard
	            OpenLayers.Event.stop(evt);
	        }
	    },

	    CLASS_NAME: "OpenLayers.Control.KeyboardDefaults"
	});
	/* ======================================================================
	    OpenLayers/Control/Measure.js
	   ====================================================================== */

	/* Copyright (c) 2006-2015 by OpenLayers Contributors (see authors.txt for
	 * full list of contributors). Published under the 2-clause BSD license.
	 * See license.txt in the OpenLayers distribution or repository for the
	 * full text of the license. */

	/**
	 * @requires OpenLayers/Control.js
	 * @requires OpenLayers/Feature/Vector.js
	 */

	/**
	 * Class: OpenLayers.Control.Measure
	 * Allows for drawing of features for measurements.
	 *
	 * Inherits from:
	 *  - <OpenLayers.Control>
	 */
	OpenLayers.Control.Measure = OpenLayers.Class(OpenLayers.Control, {

	    /**
	     * APIProperty: events
	     * {<OpenLayers.Events>} Events instance for listeners and triggering
	     *     control specific events.
	     *
	     * Register a listener for a particular event with the following syntax:
	     * (code)
	     * control.events.register(type, obj, listener);
	     * (end)
	     *
	     * Supported event types (in addition to those from <OpenLayers.Control.events>):
	     * measure - Triggered when a measurement sketch is complete.  Listeners
	     *      will receive an event with measure, units, order, and geometry
	     *      properties.
	     * measurepartial - Triggered when a new point is added to the
	     *      measurement sketch or if the <immediate> property is true and the
	     *      measurement sketch is modified.  Listeners receive an event with measure,
	     *      units, order, and geometry.
	     */

	    /**
	     * APIProperty: handlerOptions
	     * {Object} Used to set non-default properties on the control's handler
	     */

	    /**
	     * Property: callbacks
	     * {Object} The functions that are sent to the handler for callback
	     */
	    callbacks: null,

	    /**
	     * APIProperty: displaySystem
	     * {String} Display system for output measurements.  Supported values
	     *     are 'english', 'metric', and 'geographic'.  Default is 'metric'.
	     */
	    displaySystem: 'metric',

	    /**
	     * APIProperty: geodesic
	     * {Boolean} Calculate geodesic metrics instead of planar metrics.  This
	     *     requires that geometries can be transformed into Geographic/WGS84
	     *     (if that is not already the map projection).  Default is false.
	     */
	    geodesic: false,

	    /**
	     * Property: displaySystemUnits
	     * {Object} Units for various measurement systems.  Values are arrays
	     *     of unit abbreviations (from OpenLayers.INCHES_PER_UNIT) in decreasing
	     *     order of length.
	     */
	    displaySystemUnits: {
	        geographic: ['dd'],
	        english: ['mi', 'ft', 'in'],
	        metric: ['km', 'm']
	    },

	    /**
	     * Property: delay
	     * {Number} Number of milliseconds between clicks before the event is
	     *     considered a double-click.  The "measurepartial" event will not
	     *     be triggered if the sketch is completed within this time.  This
	     *     is required for IE where creating a browser reflow (if a listener
	     *     is modifying the DOM by displaying the measurement values) messes
	     *     with the dblclick listener in the sketch handler.
	     */
	    partialDelay: 300,

	    /**
	     * Property: delayedTrigger
	     * {Number} Timeout id of trigger for measurepartial.
	     */
	    delayedTrigger: null,

	    /**
	     * APIProperty: persist
	     * {Boolean} Keep the temporary measurement sketch drawn after the
	     *     measurement is complete.  The geometry will persist until a new
	     *     measurement is started, the control is deactivated, or <cancel> is
	     *     called.
	     */
	    persist: false,

	    /**
	     * APIProperty: immediate
	     * {Boolean} Activates the immediate measurement so that the "measurepartial"
	     *     event is also fired once the measurement sketch is modified.
	     *     Default is false.
	     */
	    immediate : false,

	    /**
	     * Constructor: OpenLayers.Control.Measure
	     *
	     * Parameters:
	     * handler - {<OpenLayers.Handler>}
	     * options - {Object}
	     */
	    initialize: function(handler, options) {
	        OpenLayers.Control.prototype.initialize.apply(this, [options]);
	        var callbacks = {done: this.measureComplete,
	            point: this.measurePartial};
	        if (this.immediate){
	            callbacks.modify = this.measureImmediate;
	        }
	        this.callbacks = OpenLayers.Util.extend(callbacks, this.callbacks);

	        // let the handler options override, so old code that passes 'persist'
	        // directly to the handler does not need an update
	        this.handlerOptions = OpenLayers.Util.extend(
	            {persist: this.persist}, this.handlerOptions
	        );
	        this.handler = new handler(this, this.callbacks, this.handlerOptions);
	    },

	    /**
	     * APIMethod: deactivate
	     */
	    deactivate: function() {
	        this.cancelDelay();
	        return OpenLayers.Control.prototype.deactivate.apply(this, arguments);
	    },

	    /**
	     * APIMethod: cancel
	     * Stop the control from measuring.  If <persist> is true, the temporary
	     *     sketch will be erased.
	     */
	    cancel: function() {
	        this.cancelDelay();
	        this.handler.cancel();
	    },

	    /**
	     * APIMethod: setImmediate
	     * Sets the <immediate> property. Changes the activity of immediate
	     * measurement.
	     */
	    setImmediate: function(immediate) {
	        this.immediate = immediate;
	        if (this.immediate){
	            this.callbacks.modify = this.measureImmediate;
	        } else {
	            delete this.callbacks.modify;
	        }
	    },

	    /**
	     * Method: updateHandler
	     *
	     * Parameters:
	     * handler - {Function} One of the sketch handler constructors.
	     * options - {Object} Options for the handler.
	     */
	    updateHandler: function(handler, options) {
	        var active = this.active;
	        if(active) {
	            this.deactivate();
	        }
	        this.handler = new handler(this, this.callbacks, options);
	        if(active) {
	            this.activate();
	        }
	    },

	    /**
	     * Method: measureComplete
	     * Called when the measurement sketch is done.
	     *
	     * Parameters:
	     * geometry - {<OpenLayers.Geometry>}
	     */
	    measureComplete: function(geometry) {
	        this.cancelDelay();
	        this.measure(geometry, "measure");
	    },

	    /**
	     * Method: measurePartial
	     * Called each time a new point is added to the measurement sketch.
	     *
	     * Parameters:
	     * point - {<OpenLayers.Geometry.Point>} The last point added.
	     * geometry - {<OpenLayers.Geometry>} The sketch geometry.
	     */
	    measurePartial: function(point, geometry) {
	        this.cancelDelay();
	        geometry = geometry.clone();
	        // when we're wating for a dblclick, we have to trigger measurepartial
	        // after some delay to deal with reflow issues in IE
	        if (this.handler.freehandMode(this.handler.evt)) {
	            // no dblclick in freehand mode
	            this.measure(geometry, "measurepartial");
	        } else {
	            this.delayedTrigger = window.setTimeout(
	                OpenLayers.Function.bind(function() {
	                    this.delayedTrigger = null;
	                    this.measure(geometry, "measurepartial");
	                }, this),
	                this.partialDelay
	            );
	        }
	    },

	    /**
	     * Method: measureImmediate
	     * Called each time the measurement sketch is modified.
	     *
	     * Parameters:
	     * point - {<OpenLayers.Geometry.Point>} The point at the mouse position.
	     * feature - {<OpenLayers.Feature.Vector>} The sketch feature.
	     * drawing - {Boolean} Indicates whether we're currently drawing.
	     */
	    measureImmediate : function(point, feature, drawing) {
	        if (drawing && !this.handler.freehandMode(this.handler.evt)) {
	            this.cancelDelay();
	            this.measure(feature.geometry, "measurepartial");
	        }
	    },

	    /**
	     * Method: cancelDelay
	     * Cancels the delay measurement that measurePartial began.
	     */
	    cancelDelay: function() {
	        if (this.delayedTrigger !== null) {
	            window.clearTimeout(this.delayedTrigger);
	            this.delayedTrigger = null;
	        }
	    },

	    /**
	     * Method: measure
	     *
	     * Parameters:
	     * geometry - {<OpenLayers.Geometry>}
	     * eventType - {String}
	     */
	    measure: function(geometry, eventType) {
	        var stat, order;
	        if(geometry.CLASS_NAME.indexOf('LineString') > -1) {
	            stat = this.getBestLength(geometry);
	            order = 1;
	        } else {
	            stat = this.getBestArea(geometry);
	            order = 2;
	        }
	        this.events.triggerEvent(eventType, {
	            measure: stat[0],
	            units: stat[1],
	            order: order,
	            geometry: geometry
	        });
	    },

	    /**
	     * Method: getBestArea
	     * Based on the <displaySystem> returns the area of a geometry.
	     *
	     * Parameters:
	     * geometry - {<OpenLayers.Geometry>}
	     *
	     * Returns:
	     * {Array([Float, String])}  Returns a two item array containing the
	     *     area and the units abbreviation.
	     */
	    getBestArea: function(geometry) {
	        var units = this.displaySystemUnits[this.displaySystem];
	        var unit, area;
	        for(var i=0, len=units.length; i<len; ++i) {
	            unit = units[i];
	            area = this.getArea(geometry, unit);
	            if(area > 1) {
	                break;
	            }
	        }
	        return [area, unit];
	    },

	    /**
	     * Method: getArea
	     *
	     * Parameters:
	     * geometry - {<OpenLayers.Geometry>}
	     * units - {String} Unit abbreviation
	     *
	     * Returns:
	     * {Float} The geometry area in the given units.
	     */
	    getArea: function(geometry, units) {
	        var area, geomUnits;
	        if(this.geodesic) {
	            area = geometry.getGeodesicArea(this.map.getProjectionObject());
	            geomUnits = "m";
	        } else {
	            area = geometry.getArea();
	            geomUnits = this.map.getUnits();
	        }
	        var inPerDisplayUnit = OpenLayers.INCHES_PER_UNIT[units];
	        if(inPerDisplayUnit) {
	            var inPerMapUnit = OpenLayers.INCHES_PER_UNIT[geomUnits];
	            area *= Math.pow((inPerMapUnit / inPerDisplayUnit), 2);
	        }
	        return area;
	    },

	    /**
	     * Method: getBestLength
	     * Based on the <displaySystem> returns the length of a geometry.
	     *
	     * Parameters:
	     * geometry - {<OpenLayers.Geometry>}
	     *
	     * Returns:
	     * {Array([Float, String])}  Returns a two item array containing the
	     *     length and the units abbreviation.
	     */
	    getBestLength: function(geometry) {
	        var units = this.displaySystemUnits[this.displaySystem];
	        var unit, length;
	        for(var i=0, len=units.length; i<len; ++i) {
	            unit = units[i];
	            length = this.getLength(geometry, unit);
	            if(length > 1) {
	                break;
	            }
	        }
	        return [length, unit];
	    },

	    /**
	     * Method: getLength
	     *
	     * Parameters:
	     * geometry - {<OpenLayers.Geometry>}
	     * units - {String} Unit abbreviation
	     *
	     * Returns:
	     * {Float} The geometry length in the given units.
	     */
	    getLength: function(geometry, units) {
	        var length, geomUnits;
	        if(this.geodesic) {
	            length = geometry.getGeodesicLength(this.map.getProjectionObject());
	            geomUnits = "m";
	        } else {
	            length = geometry.getLength();
	            geomUnits = this.map.getUnits();
	        }
	        var inPerDisplayUnit = OpenLayers.INCHES_PER_UNIT[units];
	        if(inPerDisplayUnit) {
	            var inPerMapUnit = OpenLayers.INCHES_PER_UNIT[geomUnits];
	            length *= (inPerMapUnit / inPerDisplayUnit);
	        }
	        return length;
	    },

	    CLASS_NAME: "OpenLayers.Control.Measure"
	});
	/* ======================================================================
	    OpenLayers/Control/LayerSwitcher.js
	   ====================================================================== */

	/* Copyright (c) 2006-2015 by OpenLayers Contributors (see authors.txt for
	 * full list of contributors). Published under the 2-clause BSD license.
	 * See license.txt in the OpenLayers distribution or repository for the
	 * full text of the license. */

	/**
	 * @requires OpenLayers/Control.js
	 * @requires OpenLayers/Lang.js
	 * @requires OpenLayers/Util.js
	 * @requires OpenLayers/Events/buttonclick.js
	 */

	/**
	 * Class: OpenLayers.Control.LayerSwitcher
	 * The LayerSwitcher control displays a table of contents for the map. This
	 * allows the user interface to switch between BaseLasyers and to show or hide
	 * Overlays. By default the switcher is shown minimized on the right edge of
	 * the map, the user may expand it by clicking on the handle.
	 *
	 * To create the LayerSwitcher outside of the map, pass the Id of a html div
	 * as the first argument to the constructor.
	 *
	 * Inherits from:
	 *  - <OpenLayers.Control>
	 */
	OpenLayers.Control.LayerSwitcher = OpenLayers.Class(OpenLayers.Control, {

	    /**  
	     * Property: layerStates 
	     * {Array(Object)} Basically a copy of the "state" of the map's layers 
	     *     the last time the control was drawn. We have this in order to avoid
	     *     unnecessarily redrawing the control.
	     */
	    layerStates: null,

	  // DOM Elements

	    /**
	     * Property: layersDiv
	     * {DOMElement}
	     */
	    layersDiv: null,

	    /**
	     * Property: baseLayersDiv
	     * {DOMElement}
	     */
	    baseLayersDiv: null,

	    /**
	     * Property: baseLayers
	     * {Array(Object)}
	     */
	    baseLayers: null,


	    /**
	     * Property: dataLbl
	     * {DOMElement}
	     */
	    dataLbl: null,

	    /**
	     * Property: dataLayersDiv
	     * {DOMElement}
	     */
	    dataLayersDiv: null,

	    /**
	     * Property: dataLayers
	     * {Array(Object)}
	     */
	    dataLayers: null,


	    /**
	     * Property: minimizeDiv
	     * {DOMElement}
	     */
	    minimizeDiv: null,

	    /**
	     * Property: maximizeDiv
	     * {DOMElement}
	     */
	    maximizeDiv: null,

	    /**
	     * APIProperty: ascending
	     * {Boolean}
	     */
	    ascending: true,

	    /**
	     * Constructor: OpenLayers.Control.LayerSwitcher
	     *
	     * Parameters:
	     * options - {Object}
	     */
	    initialize: function(options) {
	        OpenLayers.Control.prototype.initialize.apply(this, arguments);
	        this.layerStates = [];
	    },

	    /**
	     * APIMethod: destroy
	     */
	    destroy: function() {

	        //clear out layers info and unregister their events
	        this.clearLayersArray("base");
	        this.clearLayersArray("data");

	        this.map.events.un({
	            buttonclick: this.onButtonClick,
	            addlayer: this.redraw,
	            changelayer: this.redraw,
	            removelayer: this.redraw,
	            changebaselayer: this.redraw,
	            scope: this
	        });
	        this.events.unregister("buttonclick", this, this.onButtonClick);

	        OpenLayers.Control.prototype.destroy.apply(this, arguments);
	    },

	    /**
	     * Method: setMap
	     *
	     * Properties:
	     * map - {<OpenLayers.Map>}
	     */
	    setMap: function(map) {
	        OpenLayers.Control.prototype.setMap.apply(this, arguments);

	        this.map.events.on({
	            addlayer: this.redraw,
	            changelayer: this.redraw,
	            removelayer: this.redraw,
	            changebaselayer: this.redraw,
	            scope: this
	        });
	        if (this.outsideViewport) {
	            this.events.attachToElement(this.div);
	            this.events.register("buttonclick", this, this.onButtonClick);
	        } else {
	            this.map.events.register("buttonclick", this, this.onButtonClick);
	        }
	    },

	    /**
	     * Method: draw
	     *
	     * Returns:
	     * {DOMElement} A reference to the DIV DOMElement containing the
	     *     switcher tabs.
	     */
	    draw: function() {
	        OpenLayers.Control.prototype.draw.apply(this);

	        // create layout divs
	        this.loadContents();

	        // set mode to minimize
	        if(!this.outsideViewport) {
	            this.minimizeControl();
	        }

	        // populate div with current info
	        this.redraw();

	        return this.div;
	    },

	    /**
	     * Method: onButtonClick
	     *
	     * Parameters:
	     * evt - {Event}
	     */
	    onButtonClick: function(evt) {
	        var button = evt.buttonElement;
	        if (button === this.minimizeDiv) {
	            this.minimizeControl();
	        } else if (button === this.maximizeDiv) {
	            this.maximizeControl();
	        } else if (button._layerSwitcher === this.id) {
	            if (button["for"]) {
	                button = document.getElementById(button["for"]);
	            }
	            if (!button.disabled) {
	                if (button.type == "radio") {
	                    button.checked = true;
	                    this.map.setBaseLayer(this.map.getLayer(button._layer));
	                } else {
	                    button.checked = !button.checked;
	                    this.updateMap();
	                }
	            }
	        }
	    },

	    /**
	     * Method: clearLayersArray
	     * User specifies either "base" or "data". we then clear all the
	     *     corresponding listeners, the div, and reinitialize a new array.
	     *
	     * Parameters:
	     * layersType - {String}
	     */
	    clearLayersArray: function(layersType) {
	        this[layersType + "LayersDiv"].innerHTML = "";
	        this[layersType + "Layers"] = [];
	    },


	    /**
	     * Method: checkRedraw
	     * Checks if the layer state has changed since the last redraw() call.
	     *
	     * Returns:
	     * {Boolean} The layer state changed since the last redraw() call.
	     */
	    checkRedraw: function() {
	        if ( !this.layerStates.length ||
	             (this.map.layers.length != this.layerStates.length) ) {
	            return true;
	        }

	        for (var i = 0, len = this.layerStates.length; i < len; i++) {
	            var layerState = this.layerStates[i];
	            var layer = this.map.layers[i];
	            if ( (layerState.name != layer.name) ||
	                 (layerState.inRange != layer.inRange) ||
	                 (layerState.id != layer.id) ||
	                 (layerState.visibility != layer.visibility) ) {
	                return true;
	            }
	        }

	        return false;
	    },

	    /**
	     * Method: redraw
	     * Goes through and takes the current state of the Map and rebuilds the
	     *     control to display that state. Groups base layers into a
	     *     radio-button group and lists each data layer with a checkbox.
	     *
	     * Returns:
	     * {DOMElement} A reference to the DIV DOMElement containing the control
	     */
	    redraw: function() {
	        //if the state hasn't changed since last redraw, no need
	        // to do anything. Just return the existing div.
	        if (!this.checkRedraw()) {
	            return this.div;
	        }

	        //clear out previous layers
	        this.clearLayersArray("base");
	        this.clearLayersArray("data");

	        var containsOverlays = false;
	        var containsBaseLayers = false;

	        // Save state -- for checking layer if the map state changed.
	        // We save this before redrawing, because in the process of redrawing
	        // we will trigger more visibility changes, and we want to not redraw
	        // and enter an infinite loop.
	        var len = this.map.layers.length;
	        this.layerStates = new Array(len);
	        for (var i=0; i <len; i++) {
	            var layer = this.map.layers[i];
	            this.layerStates[i] = {
	                'name': layer.name,
	                'visibility': layer.visibility,
	                'inRange': layer.inRange,
	                'id': layer.id
	            };
	        }

	        var layers = this.map.layers.slice();
	        if (!this.ascending) { layers.reverse(); }
	        for(var i=0, len=layers.length; i<len; i++) {
	            var layer = layers[i];
	            var baseLayer = layer.isBaseLayer;

	            if (layer.displayInLayerSwitcher) {

	                if (baseLayer) {
	                    containsBaseLayers = true;
	                } else {
	                    containsOverlays = true;
	                }

	                // only check a baselayer if it is *the* baselayer, check data
	                //  layers if they are visible
	                var checked = (baseLayer) ? (layer == this.map.baseLayer)
	                                          : layer.getVisibility();

	                // create input element
	                var inputElem = document.createElement("input"),
	                    // The input shall have an id attribute so we can use
	                    // labels to interact with them.
	                    inputId = OpenLayers.Util.createUniqueID(
	                        this.id + "_input_"
	                    );

	                inputElem.id = inputId;
	                inputElem.name = (baseLayer) ? this.id + "_baseLayers" : layer.name;
	                inputElem.type = (baseLayer) ? "radio" : "checkbox";
	                inputElem.value = layer.name;
	                inputElem.checked = checked;
	                inputElem.defaultChecked = checked;
	                inputElem.className = "olButton";
	                inputElem._layer = layer.id;
	                inputElem._layerSwitcher = this.id;

	                if (!baseLayer && !layer.inRange) {
	                    inputElem.disabled = true;
	                }

	                // create span
	                var labelSpan = document.createElement("label");
	                // this isn't the DOM attribute 'for', but an arbitrary name we
	                // use to find the appropriate input element in <onButtonClick>
	                labelSpan["for"] = inputElem.id;
	                OpenLayers.Element.addClass(labelSpan, "labelSpan olButton");
	                labelSpan._layer = layer.id;
	                labelSpan._layerSwitcher = this.id;
	                if (!baseLayer && !layer.inRange) {
	                    labelSpan.style.color = "gray";
	                }
	                labelSpan.innerHTML = layer.name;
	                labelSpan.style.verticalAlign = (baseLayer) ? "bottom"
	                                                            : "baseline";
	                // create line break
	                var br = document.createElement("br");


	                var groupArray = (baseLayer) ? this.baseLayers
	                                             : this.dataLayers;
	                groupArray.push({
	                    'layer': layer,
	                    'inputElem': inputElem,
	                    'labelSpan': labelSpan
	                });


	                var groupDiv = (baseLayer) ? this.baseLayersDiv
	                                           : this.dataLayersDiv;
	                groupDiv.appendChild(inputElem);
	                groupDiv.appendChild(labelSpan);
	                groupDiv.appendChild(br);
	            }
	        }

	        // if no overlays, dont display the overlay label
	        this.dataLbl.style.display = (containsOverlays) ? "" : "none";

	        // if no baselayers, dont display the baselayer label
	        this.baseLbl.style.display = (containsBaseLayers) ? "" : "none";

	        return this.div;
	    },

	    /**
	     * Method: updateMap
	     * Cycles through the loaded data and base layer input arrays and makes
	     *     the necessary calls to the Map object such that that the map's
	     *     visual state corresponds to what the user has selected in
	     *     the control.
	     */
	    updateMap: function() {

	        // set the newly selected base layer
	        for(var i=0, len=this.baseLayers.length; i<len; i++) {
	            var layerEntry = this.baseLayers[i];
	            if (layerEntry.inputElem.checked) {
	                this.map.setBaseLayer(layerEntry.layer, false);
	            }
	        }

	        // set the correct visibilities for the overlays
	        for(var i=0, len=this.dataLayers.length; i<len; i++) {
	            var layerEntry = this.dataLayers[i];
	            layerEntry.layer.setVisibility(layerEntry.inputElem.checked);
	        }

	    },

	    /**
	     * Method: maximizeControl
	     * Set up the labels and divs for the control
	     *
	     * Parameters:
	     * e - {Event}
	     */
	    maximizeControl: function(e) {

	        // set the div's width and height to empty values, so
	        // the div dimensions can be controlled by CSS
	        this.div.style.width = "";
	        this.div.style.height = "";

	        this.showControls(false);

	        if (e != null) {
	            OpenLayers.Event.stop(e);
	        }
	    },

	    /**
	     * Method: minimizeControl
	     * Hide all the contents of the control, shrink the size,
	     *     add the maximize icon
	     *
	     * Parameters:
	     * e - {Event}
	     */
	    minimizeControl: function(e) {

	        // to minimize the control we set its div's width
	        // and height to 0px, we cannot just set "display"
	        // to "none" because it would hide the maximize
	        // div
	        this.div.style.width = "0px";
	        this.div.style.height = "0px";

	        this.showControls(true);

	        if (e != null) {
	            OpenLayers.Event.stop(e);
	        }
	    },

	    /**
	     * Method: showControls
	     * Hide/Show all LayerSwitcher controls depending on whether we are
	     *     minimized or not
	     *
	     * Parameters:
	     * minimize - {Boolean}
	     */
	    showControls: function(minimize) {

	        this.maximizeDiv.style.display = minimize ? "" : "none";
	        this.minimizeDiv.style.display = minimize ? "none" : "";

	        this.layersDiv.style.display = minimize ? "none" : "";
	    },

	    /**
	     * Method: loadContents
	     * Set up the labels and divs for the control
	     */
	    loadContents: function() {

	        // layers list div
	        this.layersDiv = document.createElement("div");
	        this.layersDiv.id = this.id + "_layersDiv";
	        OpenLayers.Element.addClass(this.layersDiv, "layersDiv");

	        this.baseLbl = document.createElement("div");
	        this.baseLbl.innerHTML = OpenLayers.i18n("Base Layer");
	        OpenLayers.Element.addClass(this.baseLbl, "baseLbl");

	        this.baseLayersDiv = document.createElement("div");
	        OpenLayers.Element.addClass(this.baseLayersDiv, "baseLayersDiv");

	        this.dataLbl = document.createElement("div");
	        this.dataLbl.innerHTML = OpenLayers.i18n("Overlays");
	        OpenLayers.Element.addClass(this.dataLbl, "dataLbl");

	        this.dataLayersDiv = document.createElement("div");
	        OpenLayers.Element.addClass(this.dataLayersDiv, "dataLayersDiv");

	        if (this.ascending) {
	            this.layersDiv.appendChild(this.baseLbl);
	            this.layersDiv.appendChild(this.baseLayersDiv);
	            this.layersDiv.appendChild(this.dataLbl);
	            this.layersDiv.appendChild(this.dataLayersDiv);
	        } else {
	            this.layersDiv.appendChild(this.dataLbl);
	            this.layersDiv.appendChild(this.dataLayersDiv);
	            this.layersDiv.appendChild(this.baseLbl);
	            this.layersDiv.appendChild(this.baseLayersDiv);
	        }

	        this.div.appendChild(this.layersDiv);

	        // maximize button div
	        var img = OpenLayers.Util.getImageLocation('layer-switcher-maximize.png');
	        this.maximizeDiv = OpenLayers.Util.createAlphaImageDiv(
	                                    "OpenLayers_Control_MaximizeDiv",
	                                    null,
	                                    null,
	                                    img,
	                                    "absolute");
	        OpenLayers.Element.addClass(this.maximizeDiv, "maximizeDiv olButton");
	        this.maximizeDiv.style.display = "none";

	        this.div.appendChild(this.maximizeDiv);

	        // minimize button div
	        var img = OpenLayers.Util.getImageLocation('layer-switcher-minimize.png');
	        this.minimizeDiv = OpenLayers.Util.createAlphaImageDiv(
	                                    "OpenLayers_Control_MinimizeDiv",
	                                    null,
	                                    null,
	                                    img,
	                                    "absolute");
	        OpenLayers.Element.addClass(this.minimizeDiv, "minimizeDiv olButton");
	        this.minimizeDiv.style.display = "none";

	        this.div.appendChild(this.minimizeDiv);
	    },

	    CLASS_NAME: "OpenLayers.Control.LayerSwitcher"
	});
	/* ======================================================================
	    OpenLayers/Handler/Pinch.js
	   ====================================================================== */

	/* Copyright (c) 2006-2015 by OpenLayers Contributors (see authors.txt for
	 * full list of contributors). Published under the 2-clause BSD license.
	 * See license.txt in the OpenLayers distribution or repository for the
	 * full text of the license. */

	/**
	 * @requires OpenLayers/Handler.js
	 */

	/**
	 * Class: OpenLayers.Handler.Pinch
	 * The pinch handler is used to deal with sequences of browser events related
	 *     to pinch gestures. The handler is used by controls that want to know
	 *     when a pinch sequence begins, when a pinch is happening, and when it has
	 *     finished.
	 *
	 * Controls that use the pinch handler typically construct it with callbacks
	 *     for 'start', 'move', and 'done'.  Callbacks for these keys are
	 *     called when the pinch begins, with each change, and when the pinch is
	 *     done.
	 *
	 * Create a new pinch handler with the <OpenLayers.Handler.Pinch> constructor.
	 *
	 * Inherits from:
	 *  - <OpenLayers.Handler>
	 */
	OpenLayers.Handler.Pinch = OpenLayers.Class(OpenLayers.Handler, {

	    /**
	     * Property: started
	     * {Boolean} When a touchstart event is received, we want to record it,
	     *     but not set 'pinching' until the touchmove get started after
	     *     starting.
	     */
	    started: false,

	    /**
	     * Property: stopDown
	     * {Boolean} Stop propagation of touchstart events from getting to
	     *     listeners on the same element. Default is false.
	     */
	    stopDown: false,

	    /**
	     * Property: pinching
	     * {Boolean}
	     */
	    pinching: false,

	    /**
	     * Property: last
	     * {Object} Object that store informations related to pinch last touch.
	     */
	    last: null,

	    /**
	     * Property: start
	     * {Object} Object that store informations related to pinch touchstart.
	     */
	    start: null,

	    /**
	     * Constructor: OpenLayers.Handler.Pinch
	     * Returns OpenLayers.Handler.Pinch
	     *
	     * Parameters:
	     * control - {<OpenLayers.Control>} The control that is making use of
	     *     this handler.  If a handler is being used without a control, the
	     *     handlers setMap method must be overridden to deal properly with
	     *     the map.
	     * callbacks - {Object} An object containing functions to be called when
	     *     the pinch operation start, change, or is finished. The callbacks
	     *     should expect to receive an object argument, which contains
	     *     information about scale, distance, and position of touch points.
	     * options - {Object}
	     */

	    /**
	     * Method: touchstart
	     * Handle touchstart events
	     *
	     * Parameters:
	     * evt - {Event}
	     *
	     * Returns:
	     * {Boolean} Let the event propagate.
	     */
	    touchstart: function(evt) {
	        var propagate = true;
	        this.pinching = false;
	        if (OpenLayers.Event.isMultiTouch(evt)) {
	            this.started = true;
	            this.last = this.start = {
	                distance: this.getDistance(evt.touches),
	                delta: 0,
	                scale: 1
	            };
	            this.callback("start", [evt, this.start]);
	            propagate = !this.stopDown;
	        } else if (this.started) {
	            // Some webkit versions send fake single-touch events during
	            // multitouch, which cause the drag handler to trigger
	            return false;
	        } else {
	            this.started = false;
	            this.start = null;
	            this.last = null;
	        }
	        // prevent document dragging
	        OpenLayers.Event.preventDefault(evt);
	        return propagate;
	    },

	    /**
	     * Method: touchmove
	     * Handle touchmove events
	     *
	     * Parameters:
	     * evt - {Event}
	     *
	     * Returns:
	     * {Boolean} Let the event propagate.
	     */
	    touchmove: function(evt) {
	        if (this.started && OpenLayers.Event.isMultiTouch(evt)) {
	            this.pinching = true;
	            var current = this.getPinchData(evt);
	            this.callback("move", [evt, current]);
	            this.last = current;
	            // prevent document dragging
	            OpenLayers.Event.stop(evt);
	        } else if (this.started) {
	            // Some webkit versions send fake single-touch events during
	            // multitouch, which cause the drag handler to trigger
	            return false;
	        }
	        return true;
	    },

	    /**
	     * Method: touchend
	     * Handle touchend events
	     *
	     * Parameters:
	     * evt - {Event}
	     *
	     * Returns:
	     * {Boolean} Let the event propagate.
	     */
	    touchend: function(evt) {
	        if (this.started && !OpenLayers.Event.isMultiTouch(evt)) {
	            this.started = false;
	            this.pinching = false;
	            this.callback("done", [evt, this.start, this.last]);
	            this.start = null;
	            this.last = null;
	            return false;
	        }
	        return true;
	    },

	    /**
	     * Method: activate
	     * Activate the handler.
	     *
	     * Returns:
	     * {Boolean} The handler was successfully activated.
	     */
	    activate: function() {
	        var activated = false;
	        if (OpenLayers.Handler.prototype.activate.apply(this, arguments)) {
	            this.pinching = false;
	            activated = true;
	        }
	        return activated;
	    },

	    /**
	     * Method: deactivate
	     * Deactivate the handler.
	     *
	     * Returns:
	     * {Boolean} The handler was successfully deactivated.
	     */
	    deactivate: function() {
	        var deactivated = false;
	        if (OpenLayers.Handler.prototype.deactivate.apply(this, arguments)) {
	            this.started = false;
	            this.pinching = false;
	            this.start = null;
	            this.last = null;
	            deactivated = true;
	        }
	        return deactivated;
	    },

	    /**
	     * Method: getDistance
	     * Get the distance in pixels between two touches.
	     *
	     * Parameters:
	     * touches - {Array(Object)}
	     *
	     * Returns:
	     * {Number} The distance in pixels.
	     */
	    getDistance: function(touches) {
	        var t0 = touches[0];
	        var t1 = touches[1];
	        return Math.sqrt(
	            Math.pow(t0.olClientX - t1.olClientX, 2) +
	            Math.pow(t0.olClientY - t1.olClientY, 2)
	        );
	    },


	    /**
	     * Method: getPinchData
	     * Get informations about the pinch event.
	     *
	     * Parameters:
	     * evt - {Event}
	     *
	     * Returns:
	     * {Object} Object that contains data about the current pinch.
	     */
	    getPinchData: function(evt) {
	        var distance = this.getDistance(evt.touches);
	        var scale = distance / this.start.distance;
	        return {
	            distance: distance,
	            delta: this.last.distance - distance,
	            scale: scale
	        };
	    },

	    CLASS_NAME: "OpenLayers.Handler.Pinch"
	});

	/* ======================================================================
	    OpenLayers/Control/PinchZoom.js
	   ====================================================================== */

	/* Copyright (c) 2006-2015 by OpenLayers Contributors (see authors.txt for
	 * full list of contributors). Published under the 2-clause BSD license.
	 * See license.txt in the OpenLayers distribution or repository for the
	 * full text of the license. */

	/**
	 * @requires OpenLayers/Handler/Pinch.js
	 */

	/**
	 * Class: OpenLayers.Control.PinchZoom
	 *
	 * Inherits:
	 *  - <OpenLayers.Control>
	 */
	OpenLayers.Control.PinchZoom = OpenLayers.Class(OpenLayers.Control, {

	    /** 
	     * Property: type
	     * {OpenLayers.Control.TYPES}
	     */
	    type: OpenLayers.Control.TYPE_TOOL,

	    /**
	     * Property: pinchOrigin
	     * {Object} Cached object representing the pinch start (in pixels).
	     */
	    pinchOrigin: null,    
	    
	    /**
	     * Property: currentCenter
	     * {Object} Cached object representing the latest pinch center (in pixels).
	     */
	    currentCenter: null,    

	    /**
	     * APIProperty: autoActivate
	     * {Boolean} Activate the control when it is added to a map.  Default is
	     *     true.
	     */
	    autoActivate: true,

	    /**
	     * APIProperty: preserveCenter
	     * {Boolean} Set this to true if you don't want the map center to change
	     *     while pinching. For example you may want to set preserveCenter to
	     *     true when the user location is being watched and you want to preserve
	     *     the user location at the center of the map even if he zooms in or
	     *     out using pinch. This property's value can be changed any time on an
	     *     existing instance. Default is false.
	     */
	    preserveCenter: false,
	    
	    /**
	     * APIProperty: handlerOptions
	     * {Object} Used to set non-default properties on the pinch handler
	     */

	    /**
	     * Constructor: OpenLayers.Control.PinchZoom
	     * Create a control for zooming with pinch gestures.  This works on devices
	     *     with multi-touch support.
	     *
	     * Parameters:
	     * options - {Object} An optional object whose properties will be set on
	     *                    the control
	     */
	    initialize: function(options) {
	        OpenLayers.Control.prototype.initialize.apply(this, arguments);
	        this.handler = new OpenLayers.Handler.Pinch(this, {
	            start: this.pinchStart,
	            move: this.pinchMove,
	            done: this.pinchDone
	        }, this.handlerOptions);
	    },
	    
	    /**
	     * Method: pinchStart
	     *
	     * Parameters:
	     * evt - {Event}
	     * pinchData - {Object} pinch data object related to the current touchmove
	     *     of the pinch gesture. This give us the current scale of the pinch.
	     */
	    pinchStart: function(evt, pinchData) {
	        var xy = (this.preserveCenter) ?
	            this.map.getPixelFromLonLat(this.map.getCenter()) : evt.xy;
	        this.pinchOrigin = xy;
	        this.currentCenter = xy;
	    },
	    
	    /**
	     * Method: pinchMove
	     *
	     * Parameters:
	     * evt - {Event}
	     * pinchData - {Object} pinch data object related to the current touchmove
	     *     of the pinch gesture. This give us the current scale of the pinch.
	     */
	    pinchMove: function(evt, pinchData) {
	        var scale = pinchData.scale;
	        var containerOrigin = this.map.layerContainerOriginPx;
	        var pinchOrigin = this.pinchOrigin;
	        var current = (this.preserveCenter) ?
	            this.map.getPixelFromLonLat(this.map.getCenter()) : evt.xy;

	        var dx = Math.round((containerOrigin.x + current.x - pinchOrigin.x) + (scale - 1) * (containerOrigin.x - pinchOrigin.x));
	        var dy = Math.round((containerOrigin.y + current.y - pinchOrigin.y) + (scale - 1) * (containerOrigin.y - pinchOrigin.y));

	        this.map.applyTransform(dx, dy, scale);
	        this.currentCenter = current;
	    },

	    /**
	     * Method: pinchDone
	     *
	     * Parameters:
	     * evt - {Event}
	     * start - {Object} pinch data object related to the touchstart event that
	     *     started the pinch gesture.
	     * last - {Object} pinch data object related to the last touchmove event
	     *     of the pinch gesture. This give us the final scale of the pinch.
	     */
	    pinchDone: function(evt, start, last) {
	        this.map.applyTransform();
	        var zoom = this.map.getZoomForResolution(this.map.getResolution() / last.scale, true);
	        if (zoom !== this.map.getZoom() || !this.currentCenter.equals(this.pinchOrigin)) {
	            var resolution = this.map.getResolutionForZoom(zoom);

	            var location = this.map.getLonLatFromPixel(this.pinchOrigin);
	            var zoomPixel = this.currentCenter;        
	            var size = this.map.getSize();

	            location.lon += resolution * ((size.w / 2) - zoomPixel.x);
	            location.lat -= resolution * ((size.h / 2) - zoomPixel.y);

	            // Force a reflow before calling setCenter. This is to work
	            // around an issue occurring in iOS.
	            //
	            // See https://github.com/openlayers/ol2/pull/351.
	            //
	            // Without a reflow setting the layer container div's top left
	            // style properties to "0px" - as done in Map.moveTo when zoom
	            // is changed - won't actually correctly reposition the layer
	            // container div.
	            //
	            // Also, we need to use a statement that the Google Closure
	            // compiler won't optimize away.
	            this.map.div.clientWidth = this.map.div.clientWidth;

	            this.map.setCenter(location, zoom);
	        }
	    },

	    CLASS_NAME: "OpenLayers.Control.PinchZoom"

	});
	/* ======================================================================
	    OpenLayers/Control/TouchNavigation.js
	   ====================================================================== */

	/* Copyright (c) 2006-2015 by OpenLayers Contributors (see authors.txt for
	 * full list of contributors). Published under the 2-clause BSD license.
	 * See license.txt in the OpenLayers distribution or repository for the
	 * full text of the license. */

	/**
	 * @requires OpenLayers/Control/DragPan.js
	 * @requires OpenLayers/Control/PinchZoom.js
	 * @requires OpenLayers/Handler/Click.js
	 */

	/**
	 * Class: OpenLayers.Control.TouchNavigation
	 * The navigation control handles map browsing with touch events (dragging,
	 *     double-tapping, tap with two fingers, and pinch zoom).  Create a new 
	 *     control with the <OpenLayers.Control.TouchNavigation> constructor.
	 *
	 * If youâre only targeting touch enabled devices with your mapping application,
	 *     you can create a map with only a TouchNavigation control. The 
	 *     <OpenLayers.Control.Navigation> control is mobile ready by default, but 
	 *     you can generate a smaller build of the library by only including this
	 *     touch navigation control if you aren't concerned about mouse interaction.
	 *
	 * Inherits:
	 *  - <OpenLayers.Control>
	 */
	OpenLayers.Control.TouchNavigation = OpenLayers.Class(OpenLayers.Control, {

	    /**
	     * Property: dragPan
	     * {<OpenLayers.Control.DragPan>}
	     */
	    dragPan: null,

	    /**
	     * APIProperty: dragPanOptions
	     * {Object} Options passed to the DragPan control.
	     */
	    dragPanOptions: null,

	    /**
	     * Property: pinchZoom
	     * {<OpenLayers.Control.PinchZoom>}
	     */
	    pinchZoom: null,

	    /**
	     * APIProperty: pinchZoomOptions
	     * {Object} Options passed to the PinchZoom control.
	     */
	    pinchZoomOptions: null,

	    /**
	     * APIProperty: clickHandlerOptions
	     * {Object} Options passed to the Click handler.
	     */
	    clickHandlerOptions: null,

	    /**
	     * APIProperty: documentDrag
	     * {Boolean} Allow panning of the map by dragging outside map viewport.
	     *     Default is false.
	     */
	    documentDrag: false,

	    /**
	     * APIProperty: autoActivate
	     * {Boolean} Activate the control when it is added to a map.  Default is
	     *     true.
	     */
	    autoActivate: true,

	    /**
	     * Constructor: OpenLayers.Control.TouchNavigation
	     * Create a new navigation control
	     *
	     * Parameters:
	     * options - {Object} An optional object whose properties will be set on
	     *                    the control
	     */
	    initialize: function(options) {
	        this.handlers = {};
	        OpenLayers.Control.prototype.initialize.apply(this, arguments);
	    },

	    /**
	     * Method: destroy
	     * The destroy method is used to perform any clean up before the control
	     * is dereferenced.  Typically this is where event listeners are removed
	     * to prevent memory leaks.
	     */
	    destroy: function() {
	        this.deactivate();
	        if(this.dragPan) {
	            this.dragPan.destroy();
	        }
	        this.dragPan = null;
	        if (this.pinchZoom) {
	            this.pinchZoom.destroy();
	            delete this.pinchZoom;
	        }
	        OpenLayers.Control.prototype.destroy.apply(this,arguments);
	    },

	    /**
	     * Method: activate
	     */
	    activate: function() {
	        if(OpenLayers.Control.prototype.activate.apply(this,arguments)) {
	            this.dragPan.activate();
	            this.handlers.click.activate();
	            this.pinchZoom.activate();
	            return true;
	        }
	        return false;
	    },

	    /**
	     * Method: deactivate
	     */
	    deactivate: function() {
	        if(OpenLayers.Control.prototype.deactivate.apply(this,arguments)) {
	            this.dragPan.deactivate();
	            this.handlers.click.deactivate();
	            this.pinchZoom.deactivate();
	            return true;
	        }
	        return false;
	    },
	    
	    /**
	     * Method: draw
	     */
	    draw: function() {
	        var clickCallbacks = {
	            click: this.defaultClick,
	            dblclick: this.defaultDblClick
	        };
	        var clickOptions = OpenLayers.Util.extend({
	            "double": true,
	            stopDouble: true,
	            pixelTolerance: 2
	        }, this.clickHandlerOptions);
	        this.handlers.click = new OpenLayers.Handler.Click(
	            this, clickCallbacks, clickOptions
	        );
	        this.dragPan = new OpenLayers.Control.DragPan(
	            OpenLayers.Util.extend({
	                map: this.map,
	                documentDrag: this.documentDrag
	            }, this.dragPanOptions)
	        );
	        this.dragPan.draw();
	        this.pinchZoom = new OpenLayers.Control.PinchZoom(
	            OpenLayers.Util.extend({map: this.map}, this.pinchZoomOptions)
	        );
	    },

	    /**
	     * Method: defaultClick
	     *
	     * Parameters:
	     * evt - {Event}
	     */
	    defaultClick: function (evt) {
	        if(evt.lastTouches && evt.lastTouches.length == 2) {
	            this.map.zoomOut();
	        }
	    },

	    /**
	     * Method: defaultDblClick
	     *
	     * Parameters:
	     * evt - {Event}
	     */
	    defaultDblClick: function (evt) {
	        this.map.zoomTo(this.map.zoom + 1, evt.xy);
	    },

	    CLASS_NAME: "OpenLayers.Control.TouchNavigation"
	});
	/* ======================================================================
	    OpenLayers/Control/ModifyFeature.js
	   ====================================================================== */

	/* Copyright (c) 2006-2015 by OpenLayers Contributors (see authors.txt for
	 * full list of contributors). Published under the 2-clause BSD license.
	 * See license.txt in the OpenLayers distribution or repository for the
	 * full text of the license. */

	/**
	 * @requires OpenLayers/Control.js
	 * @requires OpenLayers/Handler/Drag.js
	 * @requires OpenLayers/Handler/Keyboard.js
	 */

	/**
	 * Class: OpenLayers.Control.ModifyFeature
	 * Control to modify features.  When activated, a click renders the vertices
	 *     of a feature - these vertices can then be dragged.  By default, the
	 *     delete key will delete the vertex under the mouse.  New features are
	 *     added by dragging "virtual vertices" between vertices.  Create a new
	 *     control with the <OpenLayers.Control.ModifyFeature> constructor.
	 *
	 * Inherits From:
	 *  - <OpenLayers.Control>
	 */
	OpenLayers.Control.ModifyFeature = OpenLayers.Class(OpenLayers.Control, {

	    /**
	     * APIProperty: bySegment
	     * {Boolean} If set to true, one segment at a time will be editable (the
	     *     one under the mouse cursor on hover). This supports editing much
	     *     larger geometries. This requires the rbush library
	     *     (https://github.com/mourner/rbush) for spatial indexing. Default is
	     *     false.
	     */
	    bySegment: false,

	    /**
	     * APIProperty: documentDrag
	     * {Boolean} If set to true, dragging vertices will continue even if the
	     *     mouse cursor leaves the map viewport. Default is false.
	     */
	    documentDrag: false,

	    /**
	     * APIProperty: geometryTypes
	     * {Array(String)} To restrict modification to a limited set of geometry
	     *     types, send a list of strings corresponding to the geometry class
	     *     names.
	     */
	    geometryTypes: null,

	    /**
	     * APIProperty: clickout
	     * {Boolean} Unselect features when clicking outside any feature.
	     *     Default is true.
	     */
	    clickout: true,

	    /**
	     * APIProperty: toggle
	     * {Boolean} Unselect a selected feature on click.
	     *      Default is true.
	     */
	    toggle: true,

	    /**
	     * APIProperty: standalone
	     * {Boolean} Set to true to create a control without SelectFeature
	     *     capabilities. Default is false.  If standalone is true, to modify
	     *     a feature, call the <selectFeature> method with the target feature.
	     *     Note that you must call the <unselectFeature> method to finish
	     *     feature modification in standalone mode (before starting to modify
	     *     another feature).
	     */
	    standalone: false,

	    /**
	     * Property: layer
	     * {<OpenLayers.Layer.Vector>}
	     */
	    layer: null,

	    /**
	     * Property: feature
	     * {<OpenLayers.Feature.Vector>} Feature currently available for modification.
	     */
	    feature: null,

	    /**
	     * Property: vertex
	     * {<OpenLayers.Feature.Vector>} Vertex currently being modified.
	     */
	    vertex: null,

	    /**
	     * Property: vertices
	     * {Array(<OpenLayers.Feature.Vector>)} Verticies currently available
	     *     for dragging.
	     */
	    vertices: null,

	    /**
	     * Property: virtualVertices
	     * {Array(<OpenLayers.Feature.Vector>)} Virtual vertices in the middle
	     *     of each edge.
	     */
	    virtualVertices: null,

	    /**
	     * Property: handlers
	     * {Object}
	     */
	    handlers: null,

	    /**
	     * APIProperty: deleteCodes
	     * {Array(Integer)} Keycodes for deleting verticies.  Set to null to disable
	     *     vertex deltion by keypress.  If non-null, keypresses with codes
	     *     in this array will delete vertices under the mouse. Default
	     *     is 46 and 68, the 'delete' and lowercase 'd' keys.
	     */
	    deleteCodes: null,

	    /**
	     * APIProperty: virtualStyle
	     * {Object} A symbolizer to be used for virtual vertices.
	     */
	    virtualStyle: null,

	    /**
	     * APIProperty: vertexRenderIntent
	     * {String} The renderIntent to use for vertices. If no <virtualStyle> is
	     * provided, this renderIntent will also be used for virtual vertices, with
	     * a fillOpacity and strokeOpacity of 0.3. Default is null, which means
	     * that the layer's default style will be used for vertices.
	     */
	    vertexRenderIntent: null,

	    /**
	     * APIProperty: mode
	     * {Integer} Bitfields specifying the modification mode. Defaults to
	     *      OpenLayers.Control.ModifyFeature.RESHAPE. To set the mode to a
	     *      combination of options, use the | operator. For example, to allow
	     *      the control to both resize and rotate features, use the following
	     *      syntax
	     * (code)
	     * control.mode = OpenLayers.Control.ModifyFeature.RESIZE |
	     *                OpenLayers.Control.ModifyFeature.ROTATE;
	     *  (end)
	     */
	    mode: null,

	    /**
	     * APIProperty: createVertices
	     * {Boolean} Create new vertices by dragging the virtual vertices
	     *     in the middle of each edge. Default is true.
	     */
	    createVertices: true,

	    /**
	     * Property: modified
	     * {Boolean} The currently selected feature has been modified.
	     */
	    modified: false,

	    /**
	     * Property: radiusHandle
	     * {<OpenLayers.Feature.Vector>} A handle for rotating/resizing a feature.
	     */
	    radiusHandle: null,

	    /**
	     * Property: dragHandle
	     * {<OpenLayers.Feature.Vector>} A handle for dragging a feature.
	     */
	    dragHandle: null,

	    /**
	     * APIProperty: onModificationStart
	     * {Function} *Deprecated*.  Register for "beforefeaturemodified" instead.
	     *     The "beforefeaturemodified" event is triggered on the layer before
	     *     any modification begins.
	     *
	     * Optional function to be called when a feature is selected
	     *     to be modified. The function should expect to be called with a
	     *     feature.  This could be used for example to allow to lock the
	     *     feature on server-side.
	     */
	    onModificationStart: function() {},

	    /**
	     * APIProperty: onModification
	     * {Function} *Deprecated*.  Register for "featuremodified" instead.
	     *     The "featuremodified" event is triggered on the layer with each
	     *     feature modification.
	     *
	     * Optional function to be called when a feature has been
	     *     modified.  The function should expect to be called with a feature.
	     */
	    onModification: function() {},

	    /**
	     * APIProperty: onModificationEnd
	     * {Function} *Deprecated*.  Register for "afterfeaturemodified" instead.
	     *     The "afterfeaturemodified" event is triggered on the layer after
	     *     a feature has been modified.
	     *
	     * Optional function to be called when a feature is finished
	     *     being modified.  The function should expect to be called with a
	     *     feature.
	     */
	    onModificationEnd: function() {},

	    /**
	     * Constructor: OpenLayers.Control.ModifyFeature
	     * Create a new modify feature control.
	     *
	     * Parameters:
	     * layer - {<OpenLayers.Layer.Vector>} Layer that contains features that
	     *     will be modified.
	     * options - {Object} Optional object whose properties will be set on the
	     *     control.
	     */
	    initialize: function(layer, options) {
	        options = options || {};
	        this.layer = layer;
	        this.vertices = [];
	        this.virtualVertices = [];
	        this.virtualStyle = OpenLayers.Util.extend({},
	            this.layer.style ||
	            this.layer.styleMap.createSymbolizer(null, options.vertexRenderIntent)
	        );
	        this.virtualStyle.fillOpacity = 0.3;
	        this.virtualStyle.strokeOpacity = 0.3;
	        this.deleteCodes = [46, 68];
	        this.mode = OpenLayers.Control.ModifyFeature.RESHAPE;
	        OpenLayers.Control.prototype.initialize.apply(this, [options]);
	        if(!(OpenLayers.Util.isArray(this.deleteCodes))) {
	            this.deleteCodes = [this.deleteCodes];
	        }

	        // configure the drag handler
	        var dragCallbacks = {
	            down: function(pixel) {
	                this.vertex = null;
	                var feature = this.layer.getFeatureFromEvent(
	                        this.handlers.drag.evt);
	                if (feature) {
	                    this.dragStart(feature);
	                } else if (this.clickout) {
	                    this._unselect = this.feature;
	                }
	            },
	            move: function(pixel) {
	                delete this._unselect;
	                if (this.vertex) {
	                    this.dragVertex(this.vertex, pixel);
	                }
	            },
	            up: function() {
	                this.handlers.drag.stopDown = false;
	                if (this._unselect) {
	                    this.unselectFeature(this._unselect);
	                    delete this._unselect;
	                }
	            },
	            done: function(pixel) {
	                if (this.vertex) {
	                    this.dragComplete(this.vertex);
	                }
	            }
	        };
	        var _self = this;
	        var dragOptions = {
	            documentDrag: this.documentDrag,
	            setEvent: function(evt) {
	                var feature = _self.feature;
	                _self._lastVertex = feature ?
	                                  feature.layer.getFeatureFromEvent(evt) : null;
	                OpenLayers.Handler.Drag.prototype.setEvent.apply(
	                                                               this, arguments);
	            },
	            stopDown: false
	        };

	        // configure the keyboard handler
	        var keyboardOptions = {
	            keydown: this.handleKeypress
	        };
	        this.handlers = {
	            keyboard: new OpenLayers.Handler.Keyboard(this, keyboardOptions),
	            drag: new OpenLayers.Handler.Drag(this, dragCallbacks, dragOptions)
	        };

	        if (this.bySegment) {
	            if (!window.rbush) {
	                throw new Error("The rbush library is required");
	            }
	            if (!OpenLayers.Control.ModifyFeature.BySegment) {
	                throw new Error("OpenLayers.Control.ModifyFeature.BySegment is missing from the build");
	            } else {
	                OpenLayers.Util.extend(this, OpenLayers.Control.ModifyFeature.BySegment);
	            }
	        }
	    },

	    /**
	     * Method: createVirtualVertex
	     * Create a virtual vertex in the middle of the segment.
	     *
	     * Parameters:
	     * point1 - {<OpenLayers.Geometry.Point>} First point of the segment.
	     * point2 - {<OpenLayers.Geometry.Point>} Second point of the segment.
	     *
	     * Returns:
	     * {<OpenLayers.Feature.Vector>} The virtual vertex created.
	     */
	    createVirtualVertex: function(point1, point2) {
	        var x = (point1.x + point2.x) / 2;
	        var y = (point1.y + point2.y) / 2;
	        var point = new OpenLayers.Feature.Vector(
	            new OpenLayers.Geometry.Point(x, y),
	            null, this.virtualStyle
	        );
	        point._sketch = true;
	        return point;
	    },

	    /**
	     * APIMethod: destroy
	     * Take care of things that are not handled in superclass.
	     */
	    destroy: function() {
	        if (this.map) {
	            this.map.events.un({
	                "removelayer": this.handleMapEvents,
	                "changelayer": this.handleMapEvents,
	                scope: this
	            });
	        }
	        this.layer = null;
	        OpenLayers.Control.prototype.destroy.apply(this, []);
	    },

	    /**
	     * APIMethod: activate
	     * Activate the control.
	     *
	     * Returns:
	     * {Boolean} Successfully activated the control.
	     */
	    activate: function() {
	        if (OpenLayers.Control.prototype.activate.apply(this, arguments)) {
	            this.moveLayerToTop();
	            this.map.events.on({
	                "removelayer": this.handleMapEvents,
	                "changelayer": this.handleMapEvents,
	                scope: this
	            });
	            this._lastVertex = null;
	            return this.handlers.keyboard.activate() &&
	                    this.handlers.drag.activate();
	        }
	        return false;
	    },

	    /**
	     * APIMethod: deactivate
	     * Deactivate the control.
	     *
	     * Returns:
	     * {Boolean} Successfully deactivated the control.
	     */
	    deactivate: function() {
	        var deactivated = false;
	        // the return from the controls is unimportant in this case
	        if(OpenLayers.Control.prototype.deactivate.apply(this, arguments)) {
	            this.moveLayerBack();
	            this.map.events.un({
	                "removelayer": this.handleMapEvents,
	                "changelayer": this.handleMapEvents,
	                scope: this
	            });
	            this.layer.removeFeatures(this.vertices, {silent: true});
	            this.layer.removeFeatures(this.virtualVertices, {silent: true});
	            this.vertices = [];
	            this.handlers.drag.deactivate();
	            this.handlers.keyboard.deactivate();
	            var feature = this.feature;
	            if (feature && feature.geometry && feature.layer) {
	                this.unselectFeature(feature);
	            }
	            deactivated = true;
	        }
	        return deactivated;
	    },

	    /**
	     * Method: beforeSelectFeature
	     * Called before a feature is selected.
	     *
	     * Parameters:
	     * feature - {<OpenLayers.Feature.Vector>} The feature about to be selected.
	     */
	    beforeSelectFeature: function(feature) {
	        return this.layer.events.triggerEvent(
	            "beforefeaturemodified", {feature: feature}
	        );
	    },

	    /**
	     * APIMethod: selectFeature
	     * Select a feature for modification in standalone mode. In non-standalone
	     * mode, this method is called when a feature is selected by clicking.
	     * Register a listener to the beforefeaturemodified event and return false
	     * to prevent feature modification.
	     *
	     * Parameters:
	     * feature - {<OpenLayers.Feature.Vector>} the selected feature.
	     */
	    selectFeature: function(feature) {
	        var indexOf = OpenLayers.Util.indexOf;

	        if (this.feature === feature ||
	           (this.geometryTypes && indexOf(this.geometryTypes,
	           feature.geometry.CLASS_NAME) == -1)) {
	            return;
	        }
	        if (this.beforeSelectFeature(feature) !== false) {
	            if (this.feature) {
	                this.unselectFeature(this.feature);
	            }
	            this.feature = feature;

	            if(indexOf(this.layer.selectedFeatures, feature) == -1){
	                this.layer.selectedFeatures.push(feature);
	            }

	            this.layer.drawFeature(feature, 'select');
	            this.modified = false;
	            this.resetVertices();
	            this.onModificationStart(this.feature);
	        }
	        // keep track of geometry modifications
	        var modified = feature.modified;
	        if (feature.geometry && !(modified && modified.geometry)) {
	            this._originalGeometry = feature.geometry.clone();
	        }
	    },

	    /**
	     * APIMethod: unselectFeature
	     * Called when the select feature control unselects a feature.
	     *
	     * Parameters:
	     * feature - {<OpenLayers.Feature.Vector>} The unselected feature.
	     */
	    unselectFeature: function(feature) {
	        this.layer.removeFeatures(this.vertices, {silent: true});
	        this.vertices = [];
	        this.layer.destroyFeatures(this.virtualVertices, {silent: true});
	        this.virtualVertices = [];
	        if(this.dragHandle) {
	            this.layer.destroyFeatures([this.dragHandle], {silent: true});
	            delete this.dragHandle;
	        }
	        if(this.radiusHandle) {
	            this.layer.destroyFeatures([this.radiusHandle], {silent: true});
	            delete this.radiusHandle;
	        }
	        this.layer.drawFeature(this.feature, 'default');
	        this.feature = null;
	        OpenLayers.Util.removeItem(this.layer.selectedFeatures, feature);
	        this.onModificationEnd(feature);
	        this.layer.events.triggerEvent("afterfeaturemodified", {
	            feature: feature,
	            modified: this.modified
	        });
	        this.modified = false;
	    },


	    /**
	     * Method: dragStart
	     * Called by the drag handler before a feature is dragged.  This method is
	     *     used to differentiate between points and vertices
	     *     of higher order geometries.
	     *
	     * Parameters:
	     * feature - {<OpenLayers.Feature.Vector>} The point or vertex about to be
	     *     dragged.
	     */
	    dragStart: function(feature) {
	        var isPoint = feature.geometry.CLASS_NAME ==
	                'OpenLayers.Geometry.Point';
	        if (!this.standalone &&
	                ((!feature._sketch && isPoint) || !feature._sketch)) {
	            if (this.toggle && this.feature === feature) {
	                // mark feature for unselection
	                this._unselect = feature;
	            }
	            this.selectFeature(feature);
	        }
	        if (this.feature &&
	                (feature._sketch || isPoint && feature === this.feature)) {
	            // feature is a drag or virtual handle or point
	            this.vertex = feature;
	            this.handlers.drag.stopDown = true;
	        }
	    },

	    /**
	     * Method: dragVertex
	     * Called by the drag handler with each drag move of a vertex.
	     *
	     * Parameters:
	     * vertex - {<OpenLayers.Feature.Vector>} The vertex being dragged.
	     * pixel - {<OpenLayers.Pixel>} Pixel location of the mouse event.
	     */
	    dragVertex: function(vertex, pixel) {
	        var pos = this.map.getLonLatFromViewPortPx(pixel);
	        var geom = vertex.geometry;
	        geom.move(pos.lon - geom.x, pos.lat - geom.y);
	        this.modified = true;
	        /**
	         * Five cases:
	         * 1) dragging a simple point
	         * 2) dragging a virtual vertex
	         * 3) dragging a drag handle
	         * 4) dragging a real vertex
	         * 5) dragging a radius handle
	         */
	        if(this.feature.geometry.CLASS_NAME == "OpenLayers.Geometry.Point") {
	            // dragging a simple point
	            this.layer.events.triggerEvent("vertexmodified", {
	                vertex: vertex.geometry,
	                feature: this.feature,
	                pixel: pixel
	            });
	        } else {
	            if(vertex._index) {
	                if (vertex._index == -1) {
	                    vertex._index = OpenLayers.Util.indexOf(vertex.geometry.parent.components, vertex._next);
	                }
	                // dragging a virtual vertex
	                vertex.geometry.parent.addComponent(vertex.geometry,
	                                                    vertex._index);
	                // move from virtual to real vertex
	                delete vertex._index;
	                OpenLayers.Util.removeItem(this.virtualVertices, vertex);
	                this.vertices.push(vertex);
	            } else if(vertex == this.dragHandle) {
	                // dragging a drag handle
	                this.layer.removeFeatures(this.vertices, {silent: true});
	                this.vertices = [];
	                if(this.radiusHandle) {
	                    this.layer.destroyFeatures([this.radiusHandle], {silent: true});
	                    this.radiusHandle = null;
	                }
	            } else if(vertex !== this.radiusHandle) {
	                // dragging a real vertex
	                this.layer.events.triggerEvent("vertexmodified", {
	                    vertex: vertex.geometry,
	                    feature: this.feature,
	                    pixel: pixel
	                });
	            }
	            // dragging a radius handle - no special treatment
	            if(this.virtualVertices.length > 0) {
	                this.layer.destroyFeatures(this.virtualVertices, {silent: true});
	                this.virtualVertices = [];
	            }
	            this.layer.drawFeature(this.feature, this.standalone ? undefined :
	                                            'select');
	        }
	        // keep the vertex on top so it gets the mouseout after dragging
	        // this should be removed in favor of an option to draw under or
	        // maintain node z-index
	        this.layer.drawFeature(vertex);
	    },

	    /**
	     * Method: dragComplete
	     * Called by the drag handler when the feature dragging is complete.
	     *
	     * Parameters:
	     * vertex - {<OpenLayers.Feature.Vector>} The vertex being dragged.
	     */
	    dragComplete: function(vertex) {
	        this.resetVertices();
	        this.setFeatureState();
	        this.onModification(this.feature);
	        this.layer.events.triggerEvent("featuremodified",
	                                       {feature: this.feature});
	    },

	    /**
	     * Method: setFeatureState
	     * Called when the feature is modified.  If the current state is not
	     *     INSERT or DELETE, the state is set to UPDATE.
	     */
	    setFeatureState: function() {
	        if(this.feature.state != OpenLayers.State.INSERT &&
	           this.feature.state != OpenLayers.State.DELETE) {
	            this.feature.state = OpenLayers.State.UPDATE;
	            if (this.modified && this._originalGeometry) {
	                var feature = this.feature;
	                feature.modified = OpenLayers.Util.extend(feature.modified, {
	                    geometry: this._originalGeometry
	                });
	                delete this._originalGeometry;
	            }
	        }
	    },

	    /**
	     * Method: resetVertices
	     */
	    resetVertices: function() {
	        if(this.vertices.length > 0) {
	            this.layer.removeFeatures(this.vertices, {silent: true});
	            this.vertices = [];
	        }
	        if(this.virtualVertices.length > 0) {
	            this.layer.removeFeatures(this.virtualVertices, {silent: true});
	            this.virtualVertices = [];
	        }
	        if(this.dragHandle) {
	            this.layer.destroyFeatures([this.dragHandle], {silent: true});
	            this.dragHandle = null;
	        }
	        if(this.radiusHandle) {
	            this.layer.destroyFeatures([this.radiusHandle], {silent: true});
	            this.radiusHandle = null;
	        }
	        if(this.feature &&
	           this.feature.geometry.CLASS_NAME != "OpenLayers.Geometry.Point") {
	            if((this.mode & OpenLayers.Control.ModifyFeature.DRAG)) {
	                this.collectDragHandle();
	            }
	            if((this.mode & (OpenLayers.Control.ModifyFeature.ROTATE |
	                             OpenLayers.Control.ModifyFeature.RESIZE))) {
	                this.collectRadiusHandle();
	            }
	            if(this.mode & OpenLayers.Control.ModifyFeature.RESHAPE){
	                // Don't collect vertices when we're resizing
	                if (!(this.mode & OpenLayers.Control.ModifyFeature.RESIZE)){
	                    this.collectVertices();
	                }
	            }
	        }
	    },

	    /**
	     * Method: handleKeypress
	     * Called by the feature handler on keypress.  This is used to delete
	     *     vertices. If the <deleteCode> property is set, vertices will
	     *     be deleted when a feature is selected for modification and
	     *     the mouse is over a vertex.
	     *
	     * Parameters:
	     * evt - {Event} Keypress event.
	     */
	    handleKeypress: function(evt) {
	        var code = evt.keyCode;

	        // check for delete key
	        if(this.feature &&
	           OpenLayers.Util.indexOf(this.deleteCodes, code) != -1) {
	            var vertex = this._lastVertex;
	            if (vertex &&
	                    OpenLayers.Util.indexOf(this.vertices, vertex) != -1 &&
	                    !this.handlers.drag.dragging && vertex.geometry.parent) {
	                // remove the vertex
	                vertex.geometry.parent.removeComponent(vertex.geometry);
	                this.layer.events.triggerEvent("vertexremoved", {
	                    vertex: vertex.geometry,
	                    feature: this.feature,
	                    pixel: evt.xy
	                });
	                this.layer.drawFeature(this.feature, this.standalone ?
	                                       undefined : 'select');
	                this.modified = true;
	                this.resetVertices();
	                this.setFeatureState();
	                this.onModification(this.feature);
	                this.layer.events.triggerEvent("featuremodified",
	                                               {feature: this.feature});
	            }
	        }
	    },

	    /**
	     * Method: collectVertices
	     * Collect the vertices from the modifiable feature's geometry and push
	     *     them on to the control's vertices array.
	     */
	    collectVertices: function() {
	        this.vertices = [];
	        this.virtualVertices = [];
	        var control = this;
	        function collectComponentVertices(geometry) {
	            var i, vertex, component, len;
	            if(geometry.CLASS_NAME == "OpenLayers.Geometry.Point") {
	                vertex = new OpenLayers.Feature.Vector(geometry);
	                vertex._sketch = true;
	                vertex.renderIntent = control.vertexRenderIntent;
	                control.vertices.push(vertex);
	            } else {
	                var numVert = geometry.components.length;
	                if(geometry.CLASS_NAME == "OpenLayers.Geometry.LinearRing") {
	                    numVert -= 1;
	                }
	                for(i=0; i<numVert; ++i) {
	                    component = geometry.components[i];
	                    if(component.CLASS_NAME == "OpenLayers.Geometry.Point") {
	                        vertex = new OpenLayers.Feature.Vector(component);
	                        vertex._sketch = true;
	                        vertex.renderIntent = control.vertexRenderIntent;
	                        control.vertices.push(vertex);
	                    } else {
	                        collectComponentVertices(component);
	                    }
	                }

	                // add virtual vertices in the middle of each edge
	                if (control.createVertices && geometry.CLASS_NAME != "OpenLayers.Geometry.MultiPoint") {
	                    for(i=0, len=geometry.components.length; i<len-1; ++i) {
	                        var prevVertex = geometry.components[i];
	                        var nextVertex = geometry.components[i + 1];
	                        if(prevVertex.CLASS_NAME == "OpenLayers.Geometry.Point" &&
	                           nextVertex.CLASS_NAME == "OpenLayers.Geometry.Point") {
	                            var point = control.createVirtualVertex.call(control, prevVertex, nextVertex);
	                            // set the virtual parent and intended index
	                            point.geometry.parent = geometry;
	                            point._index = i + 1;
	                            control.virtualVertices.push(point);
	                        }
	                    }
	                }
	            }
	        }
	        collectComponentVertices.call(this, this.feature.geometry);
	        this.layer.addFeatures(this.virtualVertices, {silent: true});
	        this.layer.addFeatures(this.vertices, {silent: true});
	    },

	    /**
	     * Method: collectDragHandle
	     * Collect the drag handle for the selected geometry.
	     */
	    collectDragHandle: function() {
	        var geometry = this.feature.geometry;
	        var center = geometry.getBounds().getCenterLonLat();
	        var originGeometry = new OpenLayers.Geometry.Point(
	            center.lon, center.lat
	        );
	        var origin = new OpenLayers.Feature.Vector(originGeometry);
	        originGeometry.move = function(x, y) {
	            OpenLayers.Geometry.Point.prototype.move.call(this, x, y);
	            geometry.move(x, y);
	        };
	        origin._sketch = true;
	        this.dragHandle = origin;
	        this.dragHandle.renderIntent = this.vertexRenderIntent;
	        this.layer.addFeatures([this.dragHandle], {silent: true});
	    },

	    /**
	     * Method: collectRadiusHandle
	     * Collect the radius handle for the selected geometry.
	     */
	    collectRadiusHandle: function() {
	        var geometry = this.feature.geometry;
	        var bounds = geometry.getBounds();
	        var center = bounds.getCenterLonLat();
	        var originGeometry = new OpenLayers.Geometry.Point(
	            center.lon, center.lat
	        );
	        var radiusGeometry = new OpenLayers.Geometry.Point(
	            bounds.right, bounds.bottom
	        );
	        var radius = new OpenLayers.Feature.Vector(radiusGeometry);
	        var resize = (this.mode & OpenLayers.Control.ModifyFeature.RESIZE);
	        var reshape = (this.mode & OpenLayers.Control.ModifyFeature.RESHAPE);
	        var rotate = (this.mode & OpenLayers.Control.ModifyFeature.ROTATE);

	        radiusGeometry.move = function(x, y) {
	            OpenLayers.Geometry.Point.prototype.move.call(this, x, y);
	            var dx1 = this.x - originGeometry.x;
	            var dy1 = this.y - originGeometry.y;
	            var dx0 = dx1 - x;
	            var dy0 = dy1 - y;
	            if(rotate) {
	                var a0 = Math.atan2(dy0, dx0);
	                var a1 = Math.atan2(dy1, dx1);
	                var angle = a1 - a0;
	                angle *= 180 / Math.PI;
	                geometry.rotate(angle, originGeometry);
	            }
	            if(resize) {
	                var scale, ratio;
	                // 'resize' together with 'reshape' implies that the aspect
	                // ratio of the geometry will not be preserved whilst resizing
	                if (reshape) {
	                    scale = dy1 / dy0;
	                    ratio = (dx1 / dx0) / scale;
	                } else {
	                    var l0 = Math.sqrt((dx0 * dx0) + (dy0 * dy0));
	                    var l1 = Math.sqrt((dx1 * dx1) + (dy1 * dy1));
	                    scale = l1 / l0;
	                }
	                geometry.resize(scale, originGeometry, ratio);
	            }
	        };
	        radius._sketch = true;
	        this.radiusHandle = radius;
	        this.radiusHandle.renderIntent = this.vertexRenderIntent;
	        this.layer.addFeatures([this.radiusHandle], {silent: true});
	    },

	    /**
	     * Method: setMap
	     * Set the map property for the control and all handlers.
	     *
	     * Parameters:
	     * map - {<OpenLayers.Map>} The control's map.
	     */
	    setMap: function(map) {
	        this.handlers.drag.setMap(map);
	        OpenLayers.Control.prototype.setMap.apply(this, arguments);
	    },

	    /**
	     * Method: handleMapEvents
	     *
	     * Parameters:
	     * evt - {Object}
	     */
	    handleMapEvents: function(evt) {
	        if (evt.type == "removelayer" || evt.property == "order") {
	            this.moveLayerToTop();
	        }
	    },

	    /**
	     * Method: moveLayerToTop
	     * Moves the layer for this handler to the top, so mouse events can reach
	     * it.
	     */
	    moveLayerToTop: function() {
	        var index = Math.max(this.map.Z_INDEX_BASE['Feature'] - 1,
	            this.layer.getZIndex()) + 1;
	        this.layer.setZIndex(index);

	    },

	    /**
	     * Method: moveLayerBack
	     * Moves the layer back to the position determined by the map's layers
	     * array.
	     */
	    moveLayerBack: function() {
	        var index = this.layer.getZIndex() - 1;
	        if (index >= this.map.Z_INDEX_BASE['Feature']) {
	            this.layer.setZIndex(index);
	        } else {
	            this.map.setLayerZIndex(this.layer,
	                this.map.getLayerIndex(this.layer));
	        }
	    },

	    CLASS_NAME: "OpenLayers.Control.ModifyFeature"
	});

	/**
	 * Constant: RESHAPE
	 * {Integer} Constant used to make the control work in reshape mode
	 */
	OpenLayers.Control.ModifyFeature.RESHAPE = 1;
	/**
	 * Constant: RESIZE
	 * {Integer} Constant used to make the control work in resize mode
	 */
	OpenLayers.Control.ModifyFeature.RESIZE = 2;
	/**
	 * Constant: ROTATE
	 * {Integer} Constant used to make the control work in rotate mode
	 */
	OpenLayers.Control.ModifyFeature.ROTATE = 4;
	/**
	 * Constant: DRAG
	 * {Integer} Constant used to make the control work in drag mode
	 */
	OpenLayers.Control.ModifyFeature.DRAG = 8;
	/* ======================================================================
	    OpenLayers/Strategy.js
	   ====================================================================== */

	/* Copyright (c) 2006-2015 by OpenLayers Contributors (see authors.txt for
	 * full list of contributors). Published under the 2-clause BSD license.
	 * See license.txt in the OpenLayers distribution or repository for the
	 * full text of the license. */

	/**
	 * @requires OpenLayers/BaseTypes/Class.js
	 */

	/**
	 * Class: OpenLayers.Strategy
	 * Abstract vector layer strategy class.  Not to be instantiated directly.  Use
	 *     one of the strategy subclasses instead.
	 */
	OpenLayers.Strategy = OpenLayers.Class({
	    
	    /**
	     * Property: layer
	     * {<OpenLayers.Layer.Vector>} The layer this strategy belongs to.
	     */
	    layer: null,
	    
	    /**
	     * Property: options
	     * {Object} Any options sent to the constructor.
	     */
	    options: null,

	    /** 
	     * Property: active 
	     * {Boolean} The control is active.
	     */
	    active: null,

	    /**
	     * Property: autoActivate
	     * {Boolean} The creator of the strategy can set autoActivate to false
	     *      to fully control when the protocol is activated and deactivated.
	     *      Defaults to true.
	     */
	    autoActivate: true,

	    /**
	     * Property: autoDestroy
	     * {Boolean} The creator of the strategy can set autoDestroy to false
	     *      to fully control when the strategy is destroyed. Defaults to
	     *      true.
	     */
	    autoDestroy: true,

	    /**
	     * Constructor: OpenLayers.Strategy
	     * Abstract class for vector strategies.  Create instances of a subclass.
	     *
	     * Parameters:
	     * options - {Object} Optional object whose properties will be set on the
	     *     instance.
	     */
	    initialize: function(options) {
	        OpenLayers.Util.extend(this, options);
	        this.options = options;
	        // set the active property here, so that user cannot override it
	        this.active = false;
	    },
	    
	    /**
	     * APIMethod: destroy
	     * Clean up the strategy.
	     */
	    destroy: function() {
	        this.deactivate();
	        this.layer = null;
	        this.options = null;
	    },

	    /**
	     * Method: setLayer
	     * Called to set the <layer> property.
	     *
	     * Parameters:
	     * layer - {<OpenLayers.Layer.Vector>}
	     */
	    setLayer: function(layer) {
	        this.layer = layer;
	    },
	    
	    /**
	     * Method: activate
	     * Activate the strategy.  Register any listeners, do appropriate setup.
	     *
	     * Returns:
	     * {Boolean} True if the strategy was successfully activated or false if
	     *      the strategy was already active.
	     */
	    activate: function() {
	        if (!this.active) {
	            this.active = true;
	            return true;
	        }
	        return false;
	    },
	    
	    /**
	     * Method: deactivate
	     * Deactivate the strategy.  Unregister any listeners, do appropriate
	     *     tear-down.
	     *
	     * Returns:
	     * {Boolean} True if the strategy was successfully deactivated or false if
	     *      the strategy was already inactive.
	     */
	    deactivate: function() {
	        if (this.active) {
	            this.active = false;
	            return true;
	        }
	        return false;
	    },
	   
	    CLASS_NAME: "OpenLayers.Strategy" 
	});
	/* ======================================================================
	    OpenLayers/Strategy/Fixed.js
	   ====================================================================== */

	/* Copyright (c) 2006-2015 by OpenLayers Contributors (see authors.txt for
	 * full list of contributors). Published under the 2-clause BSD license.
	 * See license.txt in the OpenLayers distribution or repository for the
	 * full text of the license. */

	/**
	 * @requires OpenLayers/Strategy.js
	 */

	/**
	 * Class: OpenLayers.Strategy.Fixed
	 * A simple strategy that requests features once and never requests new data.
	 *
	 * Inherits from:
	 *  - <OpenLayers.Strategy>
	 */
	OpenLayers.Strategy.Fixed = OpenLayers.Class(OpenLayers.Strategy, {
	    
	    /**
	     * APIProperty: preload
	     * {Boolean} Load data before layer made visible. Enabling this may result
	     *   in considerable overhead if your application loads many data layers
	     *   that are not visible by default. Default is false.
	     */
	    preload: false,

	    /**
	     * Constructor: OpenLayers.Strategy.Fixed
	     * Create a new Fixed strategy.
	     *
	     * Parameters:
	     * options - {Object} Optional object whose properties will be set on the
	     *     instance.
	     */

	    /**
	     * Method: activate
	     * Activate the strategy: load data or add listener to load when visible
	     *
	     * Returns:
	     * {Boolean} True if the strategy was successfully activated or false if
	     *      the strategy was already active.
	     */
	    activate: function() {
	        var activated = OpenLayers.Strategy.prototype.activate.apply(this, arguments);
	        if(activated) {
	            this.layer.events.on({
	                "refresh": this.load,
	                scope: this
	            });
	            if(this.layer.visibility == true || this.preload) {
	                this.load();
	            } else {
	                this.layer.events.on({
	                    "visibilitychanged": this.load,
	                    scope: this
	                });
	            }
	        }
	        return activated;
	    },
	    
	    /**
	     * Method: deactivate
	     * Deactivate the strategy.  Undo what is done in <activate>.
	     * 
	     * Returns:
	     * {Boolean} The strategy was successfully deactivated.
	     */
	    deactivate: function() {
	        var deactivated = OpenLayers.Strategy.prototype.deactivate.call(this);
	        if(deactivated) {
	            this.layer.events.un({
	                "refresh": this.load,
	                "visibilitychanged": this.load,
	                scope: this
	            });
	        }
	        return deactivated;
	    },

	    /**
	     * Method: load
	     * Tells protocol to load data and unhooks the visibilitychanged event
	     *
	     * Parameters:
	     * options - {Object} options to pass to protocol read.
	     */
	    load: function(options) {
	        var layer = this.layer;
	        layer.events.triggerEvent("loadstart", {filter: layer.filter});
	        layer.protocol.read(OpenLayers.Util.applyDefaults({
	            callback: this.merge,
	            filter: layer.filter,
	            scope: this
	        }, options));
	        layer.events.un({
	            "visibilitychanged": this.load,
	            scope: this
	        });
	    },

	    /**
	     * Method: merge
	     * Add all features to the layer.
	     *     If the layer projection differs from the map projection, features
	     *     will be transformed from the layer projection to the map projection.
	     *
	     * Parameters:
	     * resp - {<OpenLayers.Protocol.Response>} The response object passed
	     *      by the protocol.
	     */
	    merge: function(resp) {
	        var layer = this.layer;
	        layer.destroyFeatures();
	        var features = resp.features;
	        if (features && features.length > 0) {
	            var remote = layer.projection;
	            var local = layer.map.getProjectionObject();
	            if(!local.equals(remote)) {
	                var geom;
	                for(var i=0, len=features.length; i<len; ++i) {
	                    geom = features[i].geometry;
	                    if(geom) {
	                        geom.transform(remote, local);
	                    }
	                }
	            }
	            layer.addFeatures(features);
	        }
	        layer.events.triggerEvent("loadend", {response: resp});
	    },

	    CLASS_NAME: "OpenLayers.Strategy.Fixed"
	});
	/* ======================================================================
	    OpenLayers/Handler/Point.js
	   ====================================================================== */

	/* Copyright (c) 2006-2015 by OpenLayers Contributors (see authors.txt for
	 * full list of contributors). Published under the 2-clause BSD license.
	 * See license.txt in the OpenLayers distribution or repository for the
	 * full text of the license. */


	/**
	 * @requires OpenLayers/Handler.js
	 * @requires OpenLayers/Geometry/Point.js
	 */

	/**
	 * Class: OpenLayers.Handler.Point
	 * Handler to draw a point on the map. Point is displayed on activation,
	 *     moves on mouse move, and is finished on mouse up. The handler triggers
	 *     callbacks for 'done', 'cancel', and 'modify'. The modify callback is
	 *     called with each change in the sketch and will receive the latest point
	 *     drawn.  Create a new instance with the <OpenLayers.Handler.Point>
	 *     constructor.
	 * 
	 * Inherits from:
	 *  - <OpenLayers.Handler>
	 */
	OpenLayers.Handler.Point = OpenLayers.Class(OpenLayers.Handler, {
	    
	    /**
	     * Property: point
	     * {<OpenLayers.Feature.Vector>} The currently drawn point
	     */
	    point: null,

	    /**
	     * Property: layer
	     * {<OpenLayers.Layer.Vector>} The temporary drawing layer
	     */
	    layer: null,
	    
	    /**
	     * APIProperty: multi
	     * {Boolean} Cast features to multi-part geometries before passing to the
	     *     layer.  Default is false.
	     */
	    multi: false,
	    
	    /**
	     * APIProperty: citeCompliant
	     * {Boolean} If set to true, coordinates of features drawn in a map extent
	     * crossing the date line won't exceed the world bounds. Default is false.
	     */
	    citeCompliant: false,
	    
	    /**
	     * Property: mouseDown
	     * {Boolean} The mouse is down
	     */
	    mouseDown: false,

	    /**
	     * Property: stoppedDown
	     * {Boolean} Indicate whether the last mousedown stopped the event
	     * propagation.
	     */
	    stoppedDown: null,

	    /**
	     * Property: lastDown
	     * {<OpenLayers.Pixel>} Location of the last mouse down
	     */
	    lastDown: null,

	    /**
	     * Property: lastUp
	     * {<OpenLayers.Pixel>}
	     */
	    lastUp: null,

	    /**
	     * APIProperty: persist
	     * {Boolean} Leave the feature rendered until destroyFeature is called.
	     *     Default is false.  If set to true, the feature remains rendered until
	     *     destroyFeature is called, typically by deactivating the handler or
	     *     starting another drawing.
	     */
	    persist: false,

	    /**
	     * APIProperty: stopDown
	     * {Boolean} Stop event propagation on mousedown. Must be false to
	     *     allow "pan while drawing". Defaults to false.
	     */
	    stopDown: false,

	    /**
	     * APIPropery: stopUp
	     * {Boolean} Stop event propagation on mouse. Must be false to
	     *     allow "pan while dragging". Defaults to fase.
	     */
	    stopUp: false,

	    /**
	     * Property: layerOptions
	     * {Object} Any optional properties to be set on the sketch layer.
	     */
	    layerOptions: null,
	    
	    /**
	     * APIProperty: pixelTolerance
	     * {Number} Maximum number of pixels between down and up (mousedown
	     *     and mouseup, or touchstart and touchend) for the handler to
	     *     add a new point. If set to an integer value, if the
	     *     displacement between down and up is great to this value
	     *     no point will be added. Default value is 5.
	     */
	    pixelTolerance: 5,

	    /**
	     * Property: lastTouchPx
	     * {<OpenLayers.Pixel>} The last pixel used to know the distance between
	     * two touches (for double touch).
	     */
	    lastTouchPx: null,

	    /**
	     * Constructor: OpenLayers.Handler.Point
	     * Create a new point handler.
	     *
	     * Parameters:
	     * control - {<OpenLayers.Control>} The control that owns this handler
	     * callbacks - {Object} An object with a properties whose values are
	     *     functions.  Various callbacks described below.
	     * options - {Object} An optional object with properties to be set on the
	     *           handler
	     *
	     * Named callbacks:
	     * create - Called when a sketch is first created.  Callback called with
	     *     the creation point geometry and sketch feature.
	     * modify - Called with each move of a vertex with the vertex (point)
	     *     geometry and the sketch feature.
	     * done - Called when the point drawing is finished.  The callback will
	     *     receive a single argument, the point geometry.
	     * cancel - Called when the handler is deactivated while drawing.  The
	     *     cancel callback will receive a geometry.
	     */
	    initialize: function(control, callbacks, options) {
	        if(!(options && options.layerOptions && options.layerOptions.styleMap)) {
	            this.style = OpenLayers.Util.extend(OpenLayers.Feature.Vector.style['default'], {});
	        }

	        OpenLayers.Handler.prototype.initialize.apply(this, arguments);
	    },
	    
	    /**
	     * APIMethod: activate
	     * turn on the handler
	     */
	    activate: function() {
	        if(!OpenLayers.Handler.prototype.activate.apply(this, arguments)) {
	            return false;
	        }
	        // create temporary vector layer for rendering geometry sketch
	        // TBD: this could be moved to initialize/destroy - setting visibility here
	        var options = OpenLayers.Util.extend({
	            displayInLayerSwitcher: false,
	            // indicate that the temp vector layer will never be out of range
	            // without this, resolution properties must be specified at the
	            // map-level for this temporary layer to init its resolutions
	            // correctly
	            calculateInRange: OpenLayers.Function.True,
	            wrapDateLine: this.citeCompliant
	        }, this.layerOptions);
	        this.layer = new OpenLayers.Layer.Vector(this.CLASS_NAME, options);
	        this.map.addLayer(this.layer);
	        return true;
	    },
	    
	    /**
	     * Method: createFeature
	     * Add temporary features
	     *
	     * Parameters:
	     * pixel - {<OpenLayers.Pixel>} A pixel location on the map.
	     */
	    createFeature: function(pixel) {
	        var lonlat = this.layer.getLonLatFromViewPortPx(pixel); 
	        var geometry = new OpenLayers.Geometry.Point(
	            lonlat.lon, lonlat.lat
	        );
	        this.point = new OpenLayers.Feature.Vector(geometry);
	        this.callback("create", [this.point.geometry, this.point]);
	        this.point.geometry.clearBounds();
	        this.layer.addFeatures([this.point], {silent: true});
	    },

	    /**
	     * APIMethod: deactivate
	     * turn off the handler
	     */
	    deactivate: function() {
	        if(!OpenLayers.Handler.prototype.deactivate.apply(this, arguments)) {
	            return false;
	        }
	        this.cancel();
	        // If a layer's map property is set to null, it means that that layer
	        // isn't added to the map. Since we ourself added the layer to the map
	        // in activate(), we can assume that if this.layer.map is null it means
	        // that the layer has been destroyed (as a result of map.destroy() for
	        // example.
	        if (this.layer.map != null) {
	            this.destroyFeature(true);
	            this.layer.destroy(false);
	        }
	        this.layer = null;
	        return true;
	    },
	    
	    /**
	     * Method: destroyFeature
	     * Destroy the temporary geometries
	     *
	     * Parameters:
	     * force - {Boolean} Destroy even if persist is true.
	     */
	    destroyFeature: function(force) {
	        if(this.layer && (force || !this.persist)) {
	            this.layer.destroyFeatures();
	        }
	        this.point = null;
	    },

	    /**
	     * Method: destroyPersistedFeature
	     * Destroy the persisted feature.
	     */
	    destroyPersistedFeature: function() {
	        var layer = this.layer;
	        if(layer && layer.features.length > 1) {
	            this.layer.features[0].destroy();
	        }
	    },

	    /**
	     * Method: finalize
	     * Finish the geometry and call the "done" callback.
	     *
	     * Parameters:
	     * cancel - {Boolean} Call cancel instead of done callback.  Default
	     *          is false.
	     */
	    finalize: function(cancel) {
	        var key = cancel ? "cancel" : "done";
	        this.mouseDown = false;
	        this.lastDown = null;
	        this.lastUp = null;
	        this.lastTouchPx = null;
	        this.callback(key, [this.geometryClone()]);
	        this.destroyFeature(cancel);
	    },

	    /**
	     * APIMethod: cancel
	     * Finish the geometry and call the "cancel" callback.
	     */
	    cancel: function() {
	        this.finalize(true);
	    },

	    /**
	     * Method: click
	     * Handle clicks.  Clicks are stopped from propagating to other listeners
	     *     on map.events or other dom elements.
	     * 
	     * Parameters:
	     * evt - {Event} The browser event
	     *
	     * Returns: 
	     * {Boolean} Allow event propagation
	     */
	    click: function(evt) {
	        OpenLayers.Event.stop(evt);
	        return false;
	    },

	    /**
	     * Method: dblclick
	     * Handle double-clicks.  Double-clicks are stopped from propagating to other
	     *     listeners on map.events or other dom elements.
	     * 
	     * Parameters:
	     * evt - {Event} The browser event
	     *
	     * Returns: 
	     * {Boolean} Allow event propagation
	     */
	    dblclick: function(evt) {
	        OpenLayers.Event.stop(evt);
	        return false;
	    },
	    
	    /**
	     * Method: modifyFeature
	     * Modify the existing geometry given a pixel location.
	     *
	     * Parameters:
	     * pixel - {<OpenLayers.Pixel>} A pixel location on the map.
	     */
	    modifyFeature: function(pixel) {
	        if(!this.point) {
	            this.createFeature(pixel);
	        }
	        var lonlat = this.layer.getLonLatFromViewPortPx(pixel); 
	        this.point.geometry.x = lonlat.lon;
	        this.point.geometry.y = lonlat.lat;
	        this.callback("modify", [this.point.geometry, this.point, false]);
	        this.point.geometry.clearBounds();
	        this.drawFeature();
	    },

	    /**
	     * Method: drawFeature
	     * Render features on the temporary layer.
	     */
	    drawFeature: function() {
	        this.layer.drawFeature(this.point, this.style);
	    },
	    
	    /**
	     * Method: getGeometry
	     * Return the sketch geometry.  If <multi> is true, this will return
	     *     a multi-part geometry.
	     *
	     * Returns:
	     * {<OpenLayers.Geometry.Point>}
	     */
	    getGeometry: function() {
	        var geometry = this.point && this.point.geometry;
	        if(geometry && this.multi) {
	            geometry = new OpenLayers.Geometry.MultiPoint([geometry]);
	        }
	        return geometry;
	    },

	    /**
	     * Method: geometryClone
	     * Return a clone of the relevant geometry.
	     *
	     * Returns:
	     * {<OpenLayers.Geometry>}
	     */
	    geometryClone: function() {
	        var geom = this.getGeometry();
	        return geom && geom.clone();
	    },

	    /**
	     * Method: mousedown
	     * Handle mousedown.
	     * 
	     * Parameters:
	     * evt - {Event} The browser event
	     *
	     * Returns: 
	     * {Boolean} Allow event propagation
	     */
	    mousedown: function(evt) {
	        return this.down(evt);
	    },

	    /**
	     * Method: touchstart
	     * Handle touchstart.
	     * 
	     * Parameters:
	     * evt - {Event} The browser event
	     *
	     * Returns: 
	     * {Boolean} Allow event propagation
	     */
	    touchstart: function(evt) {
	        this.startTouch();
	        this.lastTouchPx = evt.xy;
	        return this.down(evt);
	    },

	    /**
	     * Method: mousemove
	     * Handle mousemove.
	     * 
	     * Parameters:
	     * evt - {Event} The browser event
	     *
	     * Returns: 
	     * {Boolean} Allow event propagation
	     */
	    mousemove: function(evt) {
	        return this.move(evt);
	    },

	    /**
	     * Method: touchmove
	     * Handle touchmove.
	     * 
	     * Parameters:
	     * evt - {Event} The browser event
	     *
	     * Returns: 
	     * {Boolean} Allow event propagation
	     */
	    touchmove: function(evt) {
	        this.lastTouchPx = evt.xy;
	        return this.move(evt);
	    },

	    /**
	     * Method: mouseup
	     * Handle mouseup.
	     * 
	     * Parameters:
	     * evt - {Event} The browser event
	     *
	     * Returns: 
	     * {Boolean} Allow event propagation
	     */
	    mouseup: function(evt) {
	        return this.up(evt);
	    },

	    /**
	     * Method: touchend
	     * Handle touchend.
	     * 
	     * Parameters:
	     * evt - {Event} The browser event
	     *
	     * Returns: 
	     * {Boolean} Allow event propagation
	     */
	    touchend: function(evt) {
	        evt.xy = this.lastTouchPx;
	        return this.up(evt);
	    },
	  
	    /**
	     * Method: down
	     * Handle mousedown and touchstart.  Adjust the geometry and redraw.
	     * Return determines whether to propagate the event on the map.
	     * 
	     * Parameters:
	     * evt - {Event} The browser event
	     *
	     * Returns: 
	     * {Boolean} Allow event propagation
	     */
	    down: function(evt) {
	        this.mouseDown = true;
	        this.lastDown = evt.xy;
	        if(!this.touch) { // no point displayed until up on touch devices
	            this.modifyFeature(evt.xy);
	        }
	        this.stoppedDown = this.stopDown;
	        return !this.stopDown;
	    },

	    /**
	     * Method: move
	     * Handle mousemove and touchmove.  Adjust the geometry and redraw.
	     * Return determines whether to propagate the event on the map.
	     * 
	     * Parameters:
	     * evt - {Event} The browser event
	     *
	     * Returns: 
	     * {Boolean} Allow event propagation
	     */
	    move: function (evt) {
	        if(!this.touch // no point displayed until up on touch devices
	           && (!this.mouseDown || this.stoppedDown)) {
	            this.modifyFeature(evt.xy);
	        }
	        return true;
	    },

	    /**
	     * Method: up
	     * Handle mouseup and touchend.  Send the latest point in the geometry to the control.
	     * Return determines whether to propagate the event on the map.
	     *
	     * Parameters:
	     * evt - {Event} The browser event
	     *
	     * Returns: 
	     * {Boolean} Allow event propagation
	     */
	    up: function (evt) {
	        this.mouseDown = false;
	        this.stoppedDown = this.stopDown;

	        // check keyboard modifiers
	        if(!this.checkModifiers(evt)) {
	            return true;
	        }
	        // ignore double-clicks
	        if (this.lastUp && this.lastUp.equals(evt.xy)) {
	            return true;
	        }
	        if (this.lastDown && this.passesTolerance(this.lastDown, evt.xy,
	                                                  this.pixelTolerance)) {
	            if (this.touch) {
	                this.modifyFeature(evt.xy);
	            }
	            if(this.persist) {
	                this.destroyPersistedFeature();
	            }
	            this.lastUp = evt.xy;
	            this.finalize();
	            return !this.stopUp;
	        } else {
	            return true;
	        }
	    },

	    /**
	     * Method: mouseout
	     * Handle mouse out.  For better user experience reset mouseDown
	     * and stoppedDown when the mouse leaves the map viewport.
	     *
	     * Parameters:
	     * evt - {Event} The browser event
	     */
	    mouseout: function(evt) {
	        if(OpenLayers.Util.mouseLeft(evt, this.map.viewPortDiv)) {
	            this.stoppedDown = this.stopDown;
	            this.mouseDown = false;
	        }
	    },

	    /**
	     * Method: passesTolerance
	     * Determine whether the event is within the optional pixel tolerance.
	     *
	     * Returns:
	     * {Boolean} The event is within the pixel tolerance (if specified).
	     */
	    passesTolerance: function(pixel1, pixel2, tolerance) {
	        var passes = true;

	        if (tolerance != null && pixel1 && pixel2) {
	            var dist = pixel1.distanceTo(pixel2);
	            if (dist > tolerance) {
	                passes = false;
	            }
	        }
	        return passes;
	    },
	    
	    CLASS_NAME: "OpenLayers.Handler.Point"
	});
	/* ======================================================================
	    OpenLayers/Handler/Path.js
	   ====================================================================== */

	/* Copyright (c) 2006-2015 by OpenLayers Contributors (see authors.txt for
	 * full list of contributors). Published under the 2-clause BSD license.
	 * See license.txt in the OpenLayers distribution or repository for the
	 * full text of the license. */


	/**
	 * @requires OpenLayers/Handler/Point.js
	 * @requires OpenLayers/Geometry/Point.js
	 * @requires OpenLayers/Geometry/LineString.js
	 */

	/**
	 * Class: OpenLayers.Handler.Path
	 * Handler to draw a path on the map.  Path is displayed on mouse down,
	 * moves on mouse move, and is finished on mouse up.
	 *
	 * Inherits from:
	 *  - <OpenLayers.Handler.Point>
	 */
	OpenLayers.Handler.Path = OpenLayers.Class(OpenLayers.Handler.Point, {
	    
	    /**
	     * Property: line
	     * {<OpenLayers.Feature.Vector>}
	     */
	    line: null,

	    /**
	     * APIProperty: maxVertices
	     * {Number} The maximum number of vertices which can be drawn by this
	     * handler. When the number of vertices reaches maxVertices, the
	     * geometry is automatically finalized. Default is null.
	     */
	    maxVertices: null,

	    /**
	     * Property: doubleTouchTolerance
	     * {Number} Maximum number of pixels between two touches for
	     *     the gesture to be considered a "finalize feature" action.
	     *     Default is 20.
	     */
	    doubleTouchTolerance: 20,

	    /**
	     * Property: freehand
	     * {Boolean} In freehand mode, the handler starts the path on mouse down,
	     * adds a point for every mouse move, and finishes the path on mouse up.
	     * Outside of freehand mode, a point is added to the path on every mouse
	     * click and double-click finishes the path.
	     */
	    freehand: false,
	    
	    /**
	     * Property: freehandToggle
	     * {String} If set, freehandToggle is checked on mouse events and will set
	     * the freehand mode to the opposite of this.freehand.  To disallow
	     * toggling between freehand and non-freehand mode, set freehandToggle to
	     * null.  Acceptable toggle values are 'shiftKey', 'ctrlKey', and 'altKey'.
	     */
	    freehandToggle: 'shiftKey',

	    /**
	     * Property: timerId
	     * {Integer} The timer used to test the double touch.
	     */
	    timerId: null,

	    /**
	     * Property: redoStack
	     * {Array} Stack containing points removed with <undo>.
	     */
	    redoStack: null,

	    /**
	     * Constructor: OpenLayers.Handler.Path
	     * Create a new path hander
	     *
	     * Parameters:
	     * control - {<OpenLayers.Control>} The control that owns this handler
	     * callbacks - {Object} An object with a properties whose values are
	     *     functions.  Various callbacks described below.
	     * options - {Object} An optional object with properties to be set on the
	     *           handler
	     *
	     * Named callbacks:
	     * create - Called when a sketch is first created.  Callback called with
	     *     the creation point geometry and sketch feature.
	     * modify - Called with each move of a vertex with the vertex (point)
	     *     geometry and the sketch feature.
	     * point - Called as each point is added.  Receives the new point geometry.
	     * done - Called when the point drawing is finished.  The callback will
	     *     receive a single argument, the linestring geometry.
	     * cancel - Called when the handler is deactivated while drawing.  The
	     *     cancel callback will receive a geometry.
	     */

	    /**
	     * Method: createFeature
	     * Add temporary geometries
	     *
	     * Parameters:
	     * pixel - {<OpenLayers.Pixel>} The initial pixel location for the new
	     *     feature.
	     */
	    createFeature: function(pixel) {
	        var lonlat = this.layer.getLonLatFromViewPortPx(pixel); 
	        var geometry = new OpenLayers.Geometry.Point(
	            lonlat.lon, lonlat.lat
	        );
	        this.point = new OpenLayers.Feature.Vector(geometry);
	        this.line = new OpenLayers.Feature.Vector(
	            new OpenLayers.Geometry.LineString([this.point.geometry])
	        );
	        this.callback("create", [this.point.geometry, this.getSketch()]);
	        this.point.geometry.clearBounds();
	        this.layer.addFeatures([this.line, this.point], {silent: true});
	    },
	        
	    /**
	     * Method: destroyFeature
	     * Destroy temporary geometries
	     *
	     * Parameters:
	     * force - {Boolean} Destroy even if persist is true.
	     */
	    destroyFeature: function(force) {
	        OpenLayers.Handler.Point.prototype.destroyFeature.call(
	            this, force);
	        this.line = null;
	    },

	    /**
	     * Method: destroyPersistedFeature
	     * Destroy the persisted feature.
	     */
	    destroyPersistedFeature: function() {
	        var layer = this.layer;
	        if(layer && layer.features.length > 2) {
	            this.layer.features[0].destroy();
	        }
	    },

	    /**
	     * Method: removePoint
	     * Destroy the temporary point.
	     */
	    removePoint: function() {
	        if(this.point) {
	            this.layer.removeFeatures([this.point]);
	        }
	    },
	    
	    /**
	     * Method: addPoint
	     * Add point to geometry.  Send the point index to override
	     * the behavior of LinearRing that disregards adding duplicate points.
	     *
	     * Parameters:
	     * pixel - {<OpenLayers.Pixel>} The pixel location for the new point.
	     */
	    addPoint: function(pixel) {
	        this.layer.removeFeatures([this.point]);
	        var lonlat = this.layer.getLonLatFromViewPortPx(pixel); 
	        this.point = new OpenLayers.Feature.Vector(
	            new OpenLayers.Geometry.Point(lonlat.lon, lonlat.lat)
	        );
	        this.line.geometry.addComponent(
	            this.point.geometry, this.line.geometry.components.length
	        );
	        this.layer.addFeatures([this.point]);
	        this.callback("point", [this.point.geometry, this.getGeometry()]);
	        this.callback("modify", [this.point.geometry, this.getSketch()]);
	        this.drawFeature();
	        delete this.redoStack;
	    },
	    
	    /**
	     * Method: insertXY
	     * Insert a point in the current sketch given x & y coordinates.  The new
	     *     point is inserted immediately before the most recently drawn point.
	     *
	     * Parameters:
	     * x - {Number} The x-coordinate of the point.
	     * y - {Number} The y-coordinate of the point.
	     */
	    insertXY: function(x, y) {
	        this.line.geometry.addComponent(
	            new OpenLayers.Geometry.Point(x, y), 
	            this.getCurrentPointIndex()
	        );
	        this.drawFeature();
	        delete this.redoStack;
	    },

	    /**
	     * Method: insertDeltaXY
	     * Insert a point given offsets from the previously inserted point.
	     *
	     * Parameters:
	     * dx - {Number} The x-coordinate offset of the point.
	     * dy - {Number} The y-coordinate offset of the point.
	     */
	    insertDeltaXY: function(dx, dy) {
	        var previousIndex = this.getCurrentPointIndex() - 1;
	        var p0 = this.line.geometry.components[previousIndex];
	        if (p0 && !isNaN(p0.x) && !isNaN(p0.y)) {
	            this.insertXY(p0.x + dx, p0.y + dy);
	        }
	    },

	    /**
	     * Method: insertDirectionLength
	     * Insert a point in the current sketch given a direction and a length.
	     *
	     * Parameters:
	     * direction - {Number} Degrees clockwise from the positive x-axis.
	     * length - {Number} Distance from the previously drawn point.
	     */
	    insertDirectionLength: function(direction, length) {
	        direction *= Math.PI / 180;
	        var dx = length * Math.cos(direction);
	        var dy = length * Math.sin(direction);
	        this.insertDeltaXY(dx, dy);
	    },

	    /**
	     * Method: insertDeflectionLength
	     * Insert a point in the current sketch given a deflection and a length.
	     *     The deflection should be degrees clockwise from the previously 
	     *     digitized segment.
	     *
	     * Parameters:
	     * deflection - {Number} Degrees clockwise from the previous segment.
	     * length - {Number} Distance from the previously drawn point.
	     */
	    insertDeflectionLength: function(deflection, length) {
	        var previousIndex = this.getCurrentPointIndex() - 1;
	        if (previousIndex > 0) {
	            var p1 = this.line.geometry.components[previousIndex];
	            var p0 = this.line.geometry.components[previousIndex-1];
	            var theta = Math.atan2(p1.y - p0.y, p1.x - p0.x);
	            this.insertDirectionLength(
	                (theta * 180 / Math.PI) + deflection, length
	            );
	        }
	    },

	    /**
	     * Method: getCurrentPointIndex
	     * 
	     * Returns:
	     * {Number} The index of the most recently drawn point.
	     */
	    getCurrentPointIndex: function() {
	        return this.line.geometry.components.length - 1;
	    },
	    
	    
	    /**
	     * Method: undo
	     * Remove the most recently added point in the sketch geometry.
	     *
	     * Returns: 
	     * {Boolean} A point was removed.
	     */
	    undo: function() {
	        var geometry = this.line.geometry;
	        var components = geometry.components;
	        var index = this.getCurrentPointIndex() - 1;
	        var target = components[index];
	        var undone = geometry.removeComponent(target);
	        if (undone) {
	            // On touch devices, set the current ("mouse location") point to
	            // match the last digitized point.
	            if (this.touch && index > 0) {
	                components = geometry.components; // safety
	                var lastpt = components[index - 1];
	                var curptidx = this.getCurrentPointIndex();
	                var curpt = components[curptidx];
	                curpt.x = lastpt.x;
	                curpt.y = lastpt.y;
	            }
	            if (!this.redoStack) {
	                this.redoStack = [];
	            }
	            this.redoStack.push(target);
	            this.drawFeature();
	        }
	        return undone;
	    },
	    
	    /**
	     * Method: redo
	     * Reinsert the most recently removed point resulting from an <undo> call.
	     *     The undo stack is deleted whenever a point is added by other means.
	     *
	     * Returns: 
	     * {Boolean} A point was added.
	     */
	    redo: function() {
	        var target = this.redoStack && this.redoStack.pop();
	        if (target) {
	            this.line.geometry.addComponent(target, this.getCurrentPointIndex());
	            this.drawFeature();
	        }
	        return !!target;
	    },
	    
	    /**
	     * Method: freehandMode
	     * Determine whether to behave in freehand mode or not.
	     *
	     * Returns:
	     * {Boolean}
	     */
	    freehandMode: function(evt) {
	        return (this.freehandToggle && evt[this.freehandToggle]) ?
	                    !this.freehand : this.freehand;
	    },

	    /**
	     * Method: modifyFeature
	     * Modify the existing geometry given the new point
	     *
	     * Parameters:
	     * pixel - {<OpenLayers.Pixel>} The updated pixel location for the latest
	     *     point.
	     * drawing - {Boolean} Indicate if we're currently drawing.
	     */
	    modifyFeature: function(pixel, drawing) {
	        if(!this.line) {
	            this.createFeature(pixel);
	        }
	        var lonlat = this.layer.getLonLatFromViewPortPx(pixel); 
	        this.point.geometry.x = lonlat.lon;
	        this.point.geometry.y = lonlat.lat;
	        this.callback("modify", [this.point.geometry, this.getSketch(), drawing]);
	        this.point.geometry.clearBounds();
	        this.drawFeature();
	    },

	    /**
	     * Method: drawFeature
	     * Render geometries on the temporary layer.
	     */
	    drawFeature: function() {
	        this.layer.drawFeature(this.line, this.style);
	        this.layer.drawFeature(this.point, this.style);
	    },

	    /**
	     * Method: getSketch
	     * Return the sketch feature.
	     *
	     * Returns:
	     * {<OpenLayers.Feature.Vector>}
	     */
	    getSketch: function() {
	        return this.line;
	    },

	    /**
	     * Method: getGeometry
	     * Return the sketch geometry.  If <multi> is true, this will return
	     *     a multi-part geometry.
	     *
	     * Returns:
	     * {<OpenLayers.Geometry.LineString>}
	     */
	    getGeometry: function() {
	        var geometry = this.line && this.line.geometry;
	        if(geometry && this.multi) {
	            geometry = new OpenLayers.Geometry.MultiLineString([geometry]);
	        }
	        return geometry;
	    },

	    /**
	     * method: touchstart
	     * handle touchstart.
	     *
	     * parameters:
	     * evt - {event} the browser event
	     *
	     * returns:
	     * {boolean} allow event propagation
	     */
	    touchstart: function(evt) {
	        if (this.timerId &&
	            this.passesTolerance(this.lastTouchPx, evt.xy,
	                                 this.doubleTouchTolerance)) {
	            // double-tap, finalize the geometry
	            this.finishGeometry();
	            window.clearTimeout(this.timerId);
	            this.timerId = null;
	            return false;
	        } else {
	            if (this.timerId) {
	                window.clearTimeout(this.timerId);
	                this.timerId = null;
	            }
	            this.timerId = window.setTimeout(
	                OpenLayers.Function.bind(function() {
	                    this.timerId = null;
	                }, this), 300);
	            return OpenLayers.Handler.Point.prototype.touchstart.call(this, evt);
	        }
	    },

	    /**
	     * Method: down
	     * Handle mousedown and touchstart.  Add a new point to the geometry and
	     * render it. Return determines whether to propagate the event on the map.
	     * 
	     * Parameters:
	     * evt - {Event} The browser event
	     *
	     * Returns: 
	     * {Boolean} Allow event propagation
	     */
	    down: function(evt) {
	        var stopDown = this.stopDown;
	        if(this.freehandMode(evt)) {
	            stopDown = true;
	            if (this.touch) {
	                this.modifyFeature(evt.xy, !!this.lastUp);
	                OpenLayers.Event.stop(evt);
	            }
	        }
	        if (!this.touch && (!this.lastDown ||
	                            !this.passesTolerance(this.lastDown, evt.xy,
	                                                  this.pixelTolerance))) {
	            this.modifyFeature(evt.xy, !!this.lastUp);
	        }
	        this.mouseDown = true;
	        this.lastDown = evt.xy;
	        this.stoppedDown = stopDown;
	        return !stopDown;
	    },

	    /**
	     * Method: move
	     * Handle mousemove and touchmove.  Adjust the geometry and redraw.
	     * Return determines whether to propagate the event on the map.
	     * 
	     * Parameters:
	     * evt - {Event} The browser event
	     *
	     * Returns: 
	     * {Boolean} Allow event propagation
	     */
	    move: function (evt) {
	        if(this.stoppedDown && this.freehandMode(evt)) {
	            if(this.persist) {
	                this.destroyPersistedFeature();
	            }
	            if(this.maxVertices && this.line &&
	                    this.line.geometry.components.length === this.maxVertices) {
	                this.removePoint();
	                this.finalize();
	            } else {
	                this.addPoint(evt.xy);
	            }
	            return false;
	        }
	        if (!this.touch && (!this.mouseDown || this.stoppedDown)) {
	            this.modifyFeature(evt.xy, !!this.lastUp);
	        }
	        return true;
	    },
	    
	    /**
	     * Method: up
	     * Handle mouseup and touchend.  Send the latest point in the geometry to
	     * the control. Return determines whether to propagate the event on the map.
	     * 
	     * Parameters:
	     * evt - {Event} The browser event
	     *
	     * Returns: 
	     * {Boolean} Allow event propagation
	     */
	    up: function (evt) {
	        if (this.mouseDown && (!this.lastUp || !this.lastUp.equals(evt.xy))) {
	            if(this.stoppedDown && this.freehandMode(evt)) {
	                if (this.persist) {
	                    this.destroyPersistedFeature();
	                }
	                this.removePoint();
	                this.finalize();
	            } else {
	                if (this.passesTolerance(this.lastDown, evt.xy,
	                                         this.pixelTolerance)) {
	                    if (this.touch) {
	                        this.modifyFeature(evt.xy);
	                    }
	                    if(this.lastUp == null && this.persist) {
	                        this.destroyPersistedFeature();
	                    }
	                    this.addPoint(evt.xy);
	                    this.lastUp = evt.xy;
	                    if(this.line.geometry.components.length === this.maxVertices + 1) {
	                        this.finishGeometry();
	                    }
	                }
	            }
	        }
	        this.stoppedDown = this.stopDown;
	        this.mouseDown = false;
	        return !this.stopUp;
	    },

	    /**
	     * APIMethod: finishGeometry
	     * Finish the geometry and send it back to the control.
	     */
	    finishGeometry: function() {
	        var index = this.line.geometry.components.length - 1;
	        this.line.geometry.removeComponent(this.line.geometry.components[index]);
	        this.removePoint();
	        this.finalize();
	    },
	  
	    /**
	     * Method: dblclick 
	     * Handle double-clicks.
	     * 
	     * Parameters:
	     * evt - {Event} The browser event
	     *
	     * Returns: 
	     * {Boolean} Allow event propagation
	     */
	    dblclick: function(evt) {
	        if(!this.freehandMode(evt)) {
	            this.finishGeometry();
	        }
	        return false;
	    },

	    CLASS_NAME: "OpenLayers.Handler.Path"
	});
	/* ======================================================================
	    OpenLayers/Handler/Polygon.js
	   ====================================================================== */

	/* Copyright (c) 2006-2015 by OpenLayers Contributors (see authors.txt for
	 * full list of contributors). Published under the 2-clause BSD license.
	 * See license.txt in the OpenLayers distribution or repository for the
	 * full text of the license. */


	/**
	 * @requires OpenLayers/Handler/Path.js
	 * @requires OpenLayers/Geometry/Polygon.js
	 */

	/**
	 * Class: OpenLayers.Handler.Polygon
	 * Handler to draw a polygon on the map.  Polygon is displayed on mouse down,
	 * moves on mouse move, and is finished on mouse up.
	 *
	 * Inherits from:
	 *  - <OpenLayers.Handler.Path>
	 *  - <OpenLayers.Handler>
	 */
	OpenLayers.Handler.Polygon = OpenLayers.Class(OpenLayers.Handler.Path, {
	    
	    /** 
	     * APIProperty: holeModifier
	     * {String} Key modifier to trigger hole digitizing.  Acceptable values are
	     *     "altKey", "shiftKey", or "ctrlKey".  If not set, no hole digitizing
	     *     will take place.  Default is null.
	     */
	    holeModifier: null,
	    
	    /**
	     * Property: drawingHole
	     * {Boolean} Currently drawing an interior ring.
	     */
	    drawingHole: false,
	    
	    /**
	     * Property: polygon
	     * {<OpenLayers.Feature.Vector>}
	     */
	    polygon: null,

	    /**
	     * Constructor: OpenLayers.Handler.Polygon
	     * Create a Polygon Handler.
	     *
	     * Parameters:
	     * control - {<OpenLayers.Control>} The control that owns this handler
	     * callbacks - {Object} An object with a properties whose values are
	     *     functions.  Various callbacks described below.
	     * options - {Object} An optional object with properties to be set on the
	     *           handler
	     *
	     * Named callbacks:
	     * create - Called when a sketch is first created.  Callback called with
	     *     the creation point geometry and sketch feature.
	     * modify - Called with each move of a vertex with the vertex (point)
	     *     geometry and the sketch feature.
	     * point - Called as each point is added.  Receives the new point geometry.
	     * done - Called when the point drawing is finished.  The callback will
	     *     receive a single argument, the polygon geometry.
	     * cancel - Called when the handler is deactivated while drawing.  The
	     *     cancel callback will receive a geometry.
	     */
	    
	    /**
	     * Method: createFeature
	     * Add temporary geometries
	     *
	     * Parameters:
	     * pixel - {<OpenLayers.Pixel>} The initial pixel location for the new
	     *     feature.
	     */
	    createFeature: function(pixel) {
	        var lonlat = this.layer.getLonLatFromViewPortPx(pixel);
	        var geometry = new OpenLayers.Geometry.Point(
	            lonlat.lon, lonlat.lat
	        );
	        this.point = new OpenLayers.Feature.Vector(geometry);
	        this.line = new OpenLayers.Feature.Vector(
	            new OpenLayers.Geometry.LinearRing([this.point.geometry])
	        );
	        this.polygon = new OpenLayers.Feature.Vector(
	            new OpenLayers.Geometry.Polygon([this.line.geometry])
	        );
	        this.callback("create", [this.point.geometry, this.getSketch()]);
	        this.point.geometry.clearBounds();
	        this.layer.addFeatures([this.polygon, this.point], {silent: true});
	    },

	    /**
	     * Method: addPoint
	     * Add point to geometry.
	     *
	     * Parameters:
	     * pixel - {<OpenLayers.Pixel>} The pixel location for the new point.
	     */
	    addPoint: function(pixel) {
	        if(!this.drawingHole && this.holeModifier &&
	           this.evt && this.evt[this.holeModifier]) {
	            var geometry = this.point.geometry;
	            var features = this.control.layer.features;
	            var candidate, polygon;
	            // look for intersections, last drawn gets priority
	            for (var i=features.length-1; i>=0; --i) {
	                candidate = features[i].geometry;
	                if ((candidate instanceof OpenLayers.Geometry.Polygon || 
	                    candidate instanceof OpenLayers.Geometry.MultiPolygon) && 
	                    candidate.intersects(geometry)) {
	                    polygon = features[i];
	                    this.control.layer.removeFeatures([polygon], {silent: true});
	                    this.control.layer.events.registerPriority(
	                        "sketchcomplete", this, this.finalizeInteriorRing
	                    );
	                    this.control.layer.events.registerPriority(
	                        "sketchmodified", this, this.enforceTopology
	                    );
	                    polygon.geometry.addComponent(this.line.geometry);
	                    this.polygon = polygon;
	                    this.drawingHole = true;
	                    break;
	                }
	            }
	        }
	        OpenLayers.Handler.Path.prototype.addPoint.apply(this, arguments);
	    },

	    /**
	     * Method: getCurrentPointIndex
	     * 
	     * Returns:
	     * {Number} The index of the most recently drawn point.
	     */
	    getCurrentPointIndex: function() {
	        return this.line.geometry.components.length - 2;
	    },

	    /**
	     * Method: enforceTopology
	     * Simple topology enforcement for drawing interior rings.  Ensures vertices
	     *     of interior rings are contained by exterior ring.  Other topology 
	     *     rules are enforced in <finalizeInteriorRing> to allow drawing of 
	     *     rings that intersect only during the sketch (e.g. a "C" shaped ring
	     *     that nearly encloses another ring).
	     */
	    enforceTopology: function(event) {
	        var point = event.vertex;
	        var components = this.line.geometry.components;
	        // ensure that vertices of interior ring are contained by exterior ring
	        if (!this.polygon.geometry.intersects(point)) {
	            var last = components[components.length-3];
	            point.x = last.x;
	            point.y = last.y;
	        }
	    },

	    /**
	     * Method: finishGeometry
	     * Finish the geometry and send it back to the control.
	     */
	    finishGeometry: function() {
	        var index = this.line.geometry.components.length - 2;
	        this.line.geometry.removeComponent(this.line.geometry.components[index]);
	        this.removePoint();
	        this.finalize();
	    },

	    /**
	     * Method: finalizeInteriorRing
	     * Enforces that new ring has some area and doesn't contain vertices of any
	     *     other rings.
	     */
	    finalizeInteriorRing: function() {
	        var ring = this.line.geometry;
	        // ensure that ring has some area
	        var modified = (ring.getArea() !== 0);
	        if (modified) {
	            // ensure that new ring doesn't intersect any other rings
	            var rings = this.polygon.geometry.components;
	            for (var i=rings.length-2; i>=0; --i) {
	                if (ring.intersects(rings[i])) {
	                    modified = false;
	                    break;
	                }
	            }
	            if (modified) {
	                // ensure that new ring doesn't contain any other rings
	                var target;
	                outer: for (var i=rings.length-2; i>0; --i) {
	                    var points = rings[i].components;
	                    for (var j=0, jj=points.length; j<jj; ++j) {
	                        if (ring.containsPoint(points[j])) {
	                            modified = false;
	                            break outer;
	                        }
	                    }
	                }
	            }
	        }
	        if (modified) {
	            if (this.polygon.state !== OpenLayers.State.INSERT) {
	                this.polygon.state = OpenLayers.State.UPDATE;
	            }
	        } else {
	            this.polygon.geometry.removeComponent(ring);
	        }
	        this.restoreFeature();
	        return false;
	    },

	    /**
	     * APIMethod: cancel
	     * Finish the geometry and call the "cancel" callback.
	     */
	    cancel: function() {
	        if (this.drawingHole) {
	            this.polygon.geometry.removeComponent(this.line.geometry);
	            this.restoreFeature(true);
	        }
	        return OpenLayers.Handler.Path.prototype.cancel.apply(this, arguments);
	    },
	    
	    /**
	     * Method: restoreFeature
	     * Move the feature from the sketch layer to the target layer.
	     *
	     * Properties: 
	     * cancel - {Boolean} Cancel drawing.  If falsey, the "sketchcomplete" event
	     *     will be fired.
	     */
	    restoreFeature: function(cancel) {
	        this.control.layer.events.unregister(
	            "sketchcomplete", this, this.finalizeInteriorRing
	        );
	        this.control.layer.events.unregister(
	            "sketchmodified", this, this.enforceTopology
	        );
	        this.layer.removeFeatures([this.polygon], {silent: true});
	        this.control.layer.addFeatures([this.polygon], {silent: true});
	        this.drawingHole = false;
	        if (!cancel) {
	            // Re-trigger "sketchcomplete" so other listeners can do their
	            // business.  While this is somewhat sloppy (if a listener is 
	            // registered with registerPriority - not common - between the start
	            // and end of a single ring drawing - very uncommon - it will be 
	            // called twice).
	            // TODO: In 3.0, collapse sketch handlers into geometry specific
	            // drawing controls.
	            this.control.layer.events.triggerEvent(
	                "sketchcomplete", {feature : this.polygon}
	            );
	        }
	    },

	    /**
	     * Method: destroyFeature
	     * Destroy temporary geometries
	     *
	     * Parameters:
	     * force - {Boolean} Destroy even if persist is true.
	     */
	    destroyFeature: function(force) {
	        OpenLayers.Handler.Path.prototype.destroyFeature.call(
	            this, force);
	        this.polygon = null;
	    },

	    /**
	     * Method: drawFeature
	     * Render geometries on the temporary layer.
	     */
	    drawFeature: function() {
	        this.layer.drawFeature(this.polygon, this.style);
	        this.layer.drawFeature(this.point, this.style);
	    },
	    
	    /**
	     * Method: getSketch
	     * Return the sketch feature.
	     *
	     * Returns:
	     * {<OpenLayers.Feature.Vector>}
	     */
	    getSketch: function() {
	        return this.polygon;
	    },

	    /**
	     * Method: getGeometry
	     * Return the sketch geometry.  If <multi> is true, this will return
	     *     a multi-part geometry.
	     *
	     * Returns:
	     * {<OpenLayers.Geometry.Polygon>}
	     */
	    getGeometry: function() {
	        var geometry = this.polygon && this.polygon.geometry;
	        if(geometry && this.multi) {
	            geometry = new OpenLayers.Geometry.MultiPolygon([geometry]);
	        }
	        return geometry;
	    },

	    CLASS_NAME: "OpenLayers.Handler.Polygon"
	});
	/* ======================================================================
	    OpenLayers/Handler/RegularPolygon.js
	   ====================================================================== */

	/* Copyright (c) 2006-2015 by OpenLayers Contributors (see authors.txt for
	 * full list of contributors). Published under the 2-clause BSD license.
	 * See license.txt in the OpenLayers distribution or repository for the
	 * full text of the license. */


	/**
	 * @requires OpenLayers/Handler/Drag.js
	 */

	/**
	 * Class: OpenLayers.Handler.RegularPolygon
	 * Handler to draw a regular polygon on the map.  Polygon is displayed on mouse
	 *     down, moves or is modified on mouse move, and is finished on mouse up.
	 *     The handler triggers callbacks for 'done' and 'cancel'.  Create a new
	 *     instance with the <OpenLayers.Handler.RegularPolygon> constructor.
	 * 
	 * Inherits from:
	 *  - <OpenLayers.Handler.Drag>
	 */
	OpenLayers.Handler.RegularPolygon = OpenLayers.Class(OpenLayers.Handler.Drag, {
	    
	    /**
	     * APIProperty: sides
	     * {Integer} Number of sides for the regular polygon.  Needs to be greater
	     *     than 2.  Defaults to 4.
	     */
	    sides: 4,

	    /**
	     * APIProperty: radius
	     * {Float} Optional radius in map units of the regular polygon.  If this is
	     *     set to some non-zero value, a polygon with a fixed radius will be
	     *     drawn and dragged with mose movements.  If this property is not
	     *     set, dragging changes the radius of the polygon.  Set to null by
	     *     default.
	     */
	    radius: null,
	    
	    /**
	     * APIProperty: snapAngle
	     * {Float} If set to a non-zero value, the handler will snap the polygon
	     *     rotation to multiples of the snapAngle.  Value is an angle measured
	     *     in degrees counterclockwise from the positive x-axis.  
	     */
	    snapAngle: null,
	    
	    /**
	     * APIProperty: snapToggle
	     * {String} If set, snapToggle is checked on mouse events and will set
	     *     the snap mode to the opposite of what it currently is.  To disallow
	     *     toggling between snap and non-snap mode, set freehandToggle to
	     *     null.  Acceptable toggle values are 'shiftKey', 'ctrlKey', and
	     *     'altKey'. Snap mode is only possible if this.snapAngle is set to a
	     *     non-zero value.
	     */
	    snapToggle: 'shiftKey',
	    
	    /**
	     * Property: layerOptions
	     * {Object} Any optional properties to be set on the sketch layer.
	     */
	    layerOptions: null,

	    /**
	     * APIProperty: persist
	     * {Boolean} Leave the feature rendered until clear is called.  Default
	     *     is false.  If set to true, the feature remains rendered until
	     *     clear is called, typically by deactivating the handler or starting
	     *     another drawing.
	     */
	    persist: false,

	    /**
	     * APIProperty: irregular
	     * {Boolean} Draw an irregular polygon instead of a regular polygon.
	     *     Default is false.  If true, the initial mouse down will represent
	     *     one corner of the polygon bounds and with each mouse movement, the
	     *     polygon will be stretched so the opposite corner of its bounds
	     *     follows the mouse position.  This property takes precedence over
	     *     the radius property.  If set to true, the radius property will
	     *     be ignored.
	     */
	    irregular: false,

	    /**
	     * APIProperty: citeCompliant
	     * {Boolean} If set to true, coordinates of features drawn in a map extent
	     * crossing the date line won't exceed the world bounds. Default is false.
	     */
	    citeCompliant: false,

	    /**
	     * Property: angle
	     * {Float} The angle from the origin (mouse down) to the current mouse
	     *     position, in radians.  This is measured counterclockwise from the
	     *     positive x-axis.
	     */
	    angle: null,

	    /**
	     * Property: fixedRadius
	     * {Boolean} The polygon has a fixed radius.  True if a radius is set before
	     *     drawing begins.  False otherwise.
	     */
	    fixedRadius: false,

	    /**
	     * Property: feature
	     * {<OpenLayers.Feature.Vector>} The currently drawn polygon feature
	     */
	    feature: null,

	    /**
	     * Property: layer
	     * {<OpenLayers.Layer.Vector>} The temporary drawing layer
	     */
	    layer: null,

	    /**
	     * Property: origin
	     * {<OpenLayers.Geometry.Point>} Location of the first mouse down
	     */
	    origin: null,

	    /**
	     * Constructor: OpenLayers.Handler.RegularPolygon
	     * Create a new regular polygon handler.
	     *
	     * Parameters:
	     * control - {<OpenLayers.Control>} The control that owns this handler
	     * callbacks - {Object} An object with a properties whose values are
	     *     functions.  Various callbacks described below.
	     * options - {Object} An object with properties to be set on the handler.
	     *     If the options.sides property is not specified, the number of sides
	     *     will default to 4.
	     *
	     * Named callbacks:
	     * create - Called when a sketch is first created.  Callback called with
	     *     the creation point geometry and sketch feature.
	     * done - Called when the sketch drawing is finished.  The callback will
	     *     receive a single argument, the sketch geometry.
	     * cancel - Called when the handler is deactivated while drawing.  The
	     *     cancel callback will receive a geometry.
	     */
	    initialize: function(control, callbacks, options) {
	        if(!(options && options.layerOptions && options.layerOptions.styleMap)) {
	            this.style = OpenLayers.Util.extend(OpenLayers.Feature.Vector.style['default'], {});
	        }

	        OpenLayers.Handler.Drag.prototype.initialize.apply(this,
	                                                [control, callbacks, options]);
	        this.options = (options) ? options : {};
	    },
	    
	    /**
	     * APIMethod: setOptions
	     * 
	     * Parameters:
	     * newOptions - {Object} 
	     */
	    setOptions: function (newOptions) {
	        OpenLayers.Util.extend(this.options, newOptions);
	        OpenLayers.Util.extend(this, newOptions);
	    },
	    
	    /**
	     * APIMethod: activate
	     * Turn on the handler.
	     *
	     * Returns:
	     * {Boolean} The handler was successfully activated
	     */
	    activate: function() {
	        var activated = false;
	        if(OpenLayers.Handler.Drag.prototype.activate.apply(this, arguments)) {
	            // create temporary vector layer for rendering geometry sketch
	            var options = OpenLayers.Util.extend({
	                displayInLayerSwitcher: false,
	                // indicate that the temp vector layer will never be out of range
	                // without this, resolution properties must be specified at the
	                // map-level for this temporary layer to init its resolutions
	                // correctly
	                calculateInRange: OpenLayers.Function.True,
	                wrapDateLine: this.citeCompliant
	            }, this.layerOptions);
	            this.layer = new OpenLayers.Layer.Vector(this.CLASS_NAME, options);
	            this.map.addLayer(this.layer);
	            activated = true;
	        }
	        return activated;
	    },

	    /**
	     * APIMethod: deactivate
	     * Turn off the handler.
	     *
	     * Returns:
	     * {Boolean} The handler was successfully deactivated
	     */
	    deactivate: function() {
	        var deactivated = false;
	        if(OpenLayers.Handler.Drag.prototype.deactivate.apply(this, arguments)) {
	            // call the cancel callback if mid-drawing
	            if(this.dragging) {
	                this.cancel();
	            }
	            // If a layer's map property is set to null, it means that that
	            // layer isn't added to the map. Since we ourself added the layer
	            // to the map in activate(), we can assume that if this.layer.map
	            // is null it means that the layer has been destroyed (as a result
	            // of map.destroy() for example.
	            if (this.layer.map != null) {
	                this.layer.destroy(false);
	                if (this.feature) {
	                    this.feature.destroy();
	                }
	            }
	            this.layer = null;
	            this.feature = null;
	            deactivated = true;
	        }
	        return deactivated;
	    },
	    
	    /**
	     * Method: down
	     * Start drawing a new feature
	     *
	     * Parameters:
	     * evt - {Event} The drag start event
	     */
	    down: function(evt) {
	        this.fixedRadius = !!(this.radius);
	        var maploc = this.layer.getLonLatFromViewPortPx(evt.xy); 
	        this.origin = new OpenLayers.Geometry.Point(maploc.lon, maploc.lat);
	        // create the new polygon
	        if(!this.fixedRadius || this.irregular) {
	            // smallest radius should not be less one pixel in map units
	            // VML doesn't behave well with smaller
	            this.radius = this.map.getResolution();
	        }
	        if(this.persist) {
	            this.clear();
	        }
	        this.feature = new OpenLayers.Feature.Vector();
	        this.createGeometry();
	        this.callback("create", [this.origin, this.feature]);
	        this.layer.addFeatures([this.feature], {silent: true});
	        this.layer.drawFeature(this.feature, this.style);
	    },
	    
	    /**
	     * Method: move
	     * Respond to drag move events
	     *
	     * Parameters:
	     * evt - {Evt} The move event
	     */
	    move: function(evt) {
	        var maploc = this.layer.getLonLatFromViewPortPx(evt.xy); 
	        var point = new OpenLayers.Geometry.Point(maploc.lon, maploc.lat);
	        if(this.irregular) {
	            var ry = Math.sqrt(2) * Math.abs(point.y - this.origin.y) / 2;
	            this.radius = Math.max(this.map.getResolution() / 2, ry);
	        } else if(this.fixedRadius) {
	            this.origin = point;
	        } else {
	            this.calculateAngle(point, evt);
	            this.radius = Math.max(this.map.getResolution() / 2,
	                                   point.distanceTo(this.origin));
	        }
	        this.modifyGeometry();
	        if(this.irregular) {
	            var dx = point.x - this.origin.x;
	            var dy = point.y - this.origin.y;
	            var ratio;
	            if(dy == 0) {
	                ratio = dx / (this.radius * Math.sqrt(2));
	            } else {
	                ratio = dx / dy;
	            }
	            this.feature.geometry.resize(1, this.origin, ratio);
	            this.feature.geometry.move(dx / 2, dy / 2);
	        }
	        this.layer.drawFeature(this.feature, this.style);
	    },

	    /**
	     * Method: up
	     * Finish drawing the feature
	     *
	     * Parameters:
	     * evt - {Event} The mouse up event
	     */
	    up: function(evt) {
	        this.finalize();
	        // the mouseup method of superclass doesn't call the
	        // "done" callback if there's been no move between
	        // down and up
	        if (this.start == this.last) {
	            this.callback("done", [evt.xy]);
	        }
	    },

	    /**
	     * Method: out
	     * Finish drawing the feature.
	     *
	     * Parameters:
	     * evt - {Event} The mouse out event
	     */
	    out: function(evt) {
	        this.finalize();
	    },

	    /**
	     * Method: createGeometry
	     * Create the new polygon geometry.  This is called at the start of the
	     *     drag and at any point during the drag if the number of sides
	     *     changes.
	     */
	    createGeometry: function() {
	        this.angle = Math.PI * ((1/this.sides) - (1/2));
	        if(this.snapAngle) {
	            this.angle += this.snapAngle * (Math.PI / 180);
	        }
	        this.feature.geometry = OpenLayers.Geometry.Polygon.createRegularPolygon(
	            this.origin, this.radius, this.sides, this.snapAngle
	        );
	    },
	    
	    /**
	     * Method: modifyGeometry
	     * Modify the polygon geometry in place.
	     */
	    modifyGeometry: function() {
	        var angle, point;
	        var ring = this.feature.geometry.components[0];
	        // if the number of sides ever changes, create a new geometry
	        if(ring.components.length != (this.sides + 1)) {
	            this.createGeometry();
	            ring = this.feature.geometry.components[0];
	        }
	        for(var i=0; i<this.sides; ++i) {
	            point = ring.components[i];
	            angle = this.angle + (i * 2 * Math.PI / this.sides);
	            point.x = this.origin.x + (this.radius * Math.cos(angle));
	            point.y = this.origin.y + (this.radius * Math.sin(angle));
	            point.clearBounds();
	        }
	    },
	    
	    /**
	     * Method: calculateAngle
	     * Calculate the angle based on settings.
	     *
	     * Parameters:
	     * point - {<OpenLayers.Geometry.Point>}
	     * evt - {Event}
	     */
	    calculateAngle: function(point, evt) {
	        var alpha = Math.atan2(point.y - this.origin.y,
	                               point.x - this.origin.x);
	        if(this.snapAngle && (this.snapToggle && !evt[this.snapToggle])) {
	            var snapAngleRad = (Math.PI / 180) * this.snapAngle;
	            this.angle = Math.round(alpha / snapAngleRad) * snapAngleRad;
	        } else {
	            this.angle = alpha;
	        }
	    },

	    /**
	     * APIMethod: cancel
	     * Finish the geometry and call the "cancel" callback.
	     */
	    cancel: function() {
	        // the polygon geometry gets cloned in the callback method
	        this.callback("cancel", null);
	        this.finalize();
	    },

	    /**
	     * Method: finalize
	     * Finish the geometry and call the "done" callback.
	     */
	    finalize: function() {
	        this.origin = null;
	        this.radius = this.options.radius;
	    },

	    /**
	     * APIMethod: clear
	     * Clear any rendered features on the temporary layer.  This is called
	     *     when the handler is deactivated, canceled, or done (unless persist
	     *     is true).
	     */
	    clear: function() {
	        if (this.layer) {
	            this.layer.renderer.clear();
	            this.layer.destroyFeatures();
	        }
	    },
	    
	    /**
	     * Method: callback
	     * Trigger the control's named callback with the given arguments
	     *
	     * Parameters:
	     * name - {String} The key for the callback that is one of the properties
	     *     of the handler's callbacks object.
	     * args - {Array} An array of arguments with which to call the callback
	     *     (defined by the control).
	     */
	    callback: function (name, args) {
	        // override the callback method to always send the polygon geometry
	        if (this.callbacks[name]) {
	            this.callbacks[name].apply(this.control,
	                                       [this.feature.geometry.clone()]);
	        }
	        // since sketch features are added to the temporary layer
	        // they must be cleared here if done or cancel
	        if(!this.persist && (name == "done" || name == "cancel")) {
	            this.clear();
	        }
	    },

	    CLASS_NAME: "OpenLayers.Handler.RegularPolygon"
	});


	/*** EXPORTS FROM exports-loader ***/


	/*** EXPORTS FROM exports-loader ***/
	module.exports = OpenLayers;

/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
					value: true
	});

	var _OpenLayers = __webpack_require__(20);

	var _OpenLayers2 = _interopRequireDefault(_OpenLayers);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Class: OpenLayers.Control.UndoRedo
	 * Instance of this class can be used to undo and redo vector edits.
	 */

	exports.default = _OpenLayers2.default.Class(_OpenLayers2.default.Control, {
					/**
	     * APIProperty: currentEditIndex
	     * {integer} - sequence number for editing the feature[s] 
	     */
					currentEditIndex: 0,
					/**
	     * Property: undoFeatures
	     * {array} - stack of the edit features
	     */
					undoFeatures: [],
					/**
	     * Property: redoFeatures
	     * {array} - stack of the undo features
	     */
					redoFeatures: [],
					/**
	     * Property: isEditMulty
	     * {boolean} - true if in one action multiple features are edited 
	     */
					isEditMulty: false,

					/**
	     * varructor: UndoRedo
	     * Parameters:
	     * layers - array of {<OpenLayers.Layers.Vector>}
	     */
					initialize: function initialize(layers) {
									console.log('initialize', this, layers);
									if (!(layers instanceof Array)) {
													layers = [layers];
									}
									for (var i = 0; i < layers.length; i++) {
													console.log('registering handlers');
													layers[i].events.register("sketchstarted", this, this.onSketchStarted);
													layers[i].events.register("featureadded", this, this.onInsert);
													layers[i].events.register("beforefeatureremoved", this, this.onDevare);
													layers[i].events.register("beforefeaturemodified", this, this.onUpdate);
													layers[i].events.register("afterfeaturemodified", this, this.onUpdateCompvared);
									}
					},

					/**
	     * Method: onEdit
	     * on any edit operation performed this has to be triggered
	     * i.e. on insert, devare, update 
	     * Parameters: 
	     * feature - {<OpenLayers.Feature.Vector>}
	     * editType - {string} edit type done "Insert","Devare","Update"
	     * component - {string} layer or any other identifier
	     * Returns: 
	     */
					onEdit: function onEdit(feature, editType, component) {
									console.log("Updating undo stack as there is - " + editType, feature, component);
									if (component == undefined) {
													component = feature.layer.name;
									}
									if (this.undoFeatures[this.currentEditIndex] == undefined) {
													this.undoFeatures[this.currentEditIndex] = {};
													this.undoFeatures[this.currentEditIndex][component] = { "Insert": [], "Update": [], "Devare": [] };
									}
									if (feature.fid == undefined) {
													feature.fid = feature.id;
									}
									this.undoFeatures[this.currentEditIndex][component][editType].push(feature);
									this.redoFeatures.splice(0, this.redoFeatures.length);
					},

					/** 
	     * Method: onSketchStarted
	     * event handler for sketchstarted
	     */
					onSketchStarted: function onSketchStarted(event) {
									this.increaseEditIndex();
									console.log("currentEditIndex: " + this.currentEditIndex);
									return true;
					},

					/**
	     * Method: onInsert
	     * event handler for featureadded 
	     */
					onInsert: function onInsert(event) {
									var feature = event.feature.clone();
									if (event.feature.fid == undefined) {
													event.feature.fid = event.feature.id;
									}
									feature.fid = event.feature.fid;
									feature.state = event.feature.state;
									feature.layer = event.feature.layer;
									this.onEdit(feature, "Insert", feature.layer.name);
									return true;
					},

					/**
	     * Method: onDevare
	     * event handler for beforefeatureremoved 
	     */
					onDevare: function onDevare(event) {
									this.increaseEditIndex();
									this.onEdit(event.feature, "Devare", event.feature.layer.name);
									return true;
					},

					/**
	     * Method: onUpdate
	     * event handler for beforefeaturemodified
	     */
					onUpdate: function onUpdate(event) {
									this.increaseEditIndex();
									console.log("old feature geometry: ", event.feature.geometry);
									var feature = event.feature.clone();
									feature.fid = event.feature.fid;
									feature.state = event.feature.state;
									feature.layer = event.feature.layer;
									this.onEdit(feature, "Update", feature.layer.name);
					},

					/**
	     * Method: onUpdateCompvared
	     * event handler for afterfeaturemodified
	     */
					onUpdateCompvared: function onUpdateCompvared(event) {
									console.log("onUpdateCompvared", event.modified);
									if (!event.modified) {
													this.getUndoData();
									}
					},

					/**
	     * Method: increaseEditIndex
	     * increase the editIndex
	     */
					increaseEditIndex: function increaseEditIndex() {
									if (this.currentEditIndex < this.undoFeatures.length) {
													this.currentEditIndex += 1;
									}
					},

					/**
	     * Method: getUndoData
	     * returns the last edited data
	     */
					getUndoData: function getUndoData() {
									var data = this.undoFeatures.pop();
									if (data) {
													this.currentEditIndex -= 1;
									}
									return data;
					},

					/**
	        * Method: getRedoData
	     * returns the last redo data
	     */
					getRedoData: function getRedoData() {
									var data = this.redoFeatures.pop();
									if (data) {
													this.currentEditIndex += 1;
									}
									return data;
					},

					/**
	     * APIMethod: resetEditIndex
	     * reset the editIndex to 0 and empty both undo and redo stack
	     */
					resetEditIndex: function resetEditIndex() {
									this.currentEditIndex = 0;
									this.undoFeatures.splice(0, this.undoFeatures.length);
									this.redoFeatures.splice(0, this.redoFeatures.length);
					},

					/**
	     * APIMethod: undo
	     * perform undo operation 
	     */
					undo: function undo() {
									var data = this.getUndoData();
									console.log("undo data :", data);
									if (data) {
													for (var component in data) {
																	console.log("component: " + component);
																	var layer = this.map.getLayersByName(component)[0];
																	console.log("got layer, name: " + layer.name);
																	for (var editType in data[component]) {
																					console.log("editType : " + editType);
																					for (var i = 0; i < data[component][editType].length; i++) {
																									var feature = data[component][editType][i];
																									console.log("features before undo: " + layer.features.length, feature);
																									switch (editType) {
																													case "Insert":
																																	//layer.drawFeature(feature, {display : "none"});
																																	var insertedFeature = layer.getFeatureByFid(feature.fid);
																																	console.log("undo Insert", insertedFeature, feature, feature.fid);
																																	layer.eraseFeatures(insertedFeature);
																																	console.log('after erase', insertedFeature, layer.features.length);
																																	_OpenLayers2.default.Util.removeItem(layer.features, insertedFeature);
																																	console.log('OpenLayers.Util.removeItem', insertedFeature, layer.features.length);
																																	break;
																													case "Devare":
																																	console.log("undo Devare", feature);
																																	// layer.features.push(feature);
																																	// layer.drawFeature(feature);
																																	layer.addFeatures([feature], { silent: true });
																																	break;
																													case "Update":
																																	console.log("undo Update");
																																	var updatedFeature = layer.getFeatureByFid(feature.fid);
																																	console.log("old feature geometry: ", feature.geometry);
																																	console.log("updated feature geometry: ", updatedFeature.geometry);
																																	//layer.drawFeature(updatedFeature, {display : "none"});
																																	layer.eraseFeatures(updatedFeature);
																																	_OpenLayers2.default.Util.removeItem(layer.features, updatedFeature);
																																	//layer.removeFeatures(updatedFeature);
																																	console.log("old feature geometry: " + feature.geometry);
																																	//layer.features.push(feature);
																																	//layer.drawFeature(feature);
																																	layer.addFeatures([feature], { silent: true });
																																	data[component][editType][i] = updatedFeature;
																																	break;
																													default:
																																	console.log("unknown");
																																	break;
																									}
																									console.log("features after undo: " + layer.features.length, feature);
																					}
																	}
													}
													this.redoFeatures.push(data);
									}
					},

					/**
	     * APIMethod:  redo
	     * perform redo operation
	     */
					redo: function redo() {
									var data = this.getRedoData();
									console.log("redo data :", data);
									if (data) {
													for (var component in data) {
																	console.log("component: " + component);
																	var layer = this.map.getLayersByName(component)[0];
																	console.log("got layer, name: " + layer.name);
																	for (var editType in data[component]) {
																					console.log("editType : " + editType);
																					for (var i = 0; i < data[component][editType].length; i++) {
																									var feature = data[component][editType][i];
																									console.log("features before redo: " + layer.features.length);
																									switch (editType) {
																													case "Insert":
																																	console.log("redo Insert", feature);
																																	// layer.features.push(feature);
																																	// layer.drawFeature(feature);
																																	layer.addFeatures([feature], { silent: true });
																																	break;
																													case "Devare":
																																	console.log("redo Devare");
																																	var devareFeature = layer.getFeatureByFid(feature.fid);
																																	layer.eraseFeatures(devareFeature);
																																	_OpenLayers2.default.Util.removeItem(layer.features, devareFeature);
																																	break;
																													case "Update":
																																	console.log("redo Update");
																																	var oldFeature = layer.getFeatureByFid(feature.fid);
																																	console.log("old feature id: " + oldFeature.id);
																																	layer.eraseFeatures(oldFeature);
																																	_OpenLayers2.default.Util.removeItem(layer.features, oldFeature);
																																	console.log("updated feature id: " + oldFeature.id);
																																	//layer.features.push(feature);
																																	//layer.drawFeature(feature);
																																	layer.addFeatures([feature], { silent: true });
																																	data[component][editType][i] = oldFeature;
																																	break;
																													default:
																																	break;
																									}
																					}
																	}
													}
													this.undoFeatures.push(data);
									}
					},

					CLASS_NAME: "OpenLayers.Control.UndoRedo"
	});

	/*** EXPORTS FROM exports-loader ***/

/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	// https://d3js.org/d3-scale/ Version 1.0.3. Copyright 2016 Mike Bostock.
	(function (global, factory) {
	   true ? factory(exports, __webpack_require__(23), __webpack_require__(24), __webpack_require__(25), __webpack_require__(27), __webpack_require__(28), __webpack_require__(29), __webpack_require__(26)) :
	  typeof define === 'function' && define.amd ? define(['exports', 'd3-array', 'd3-collection', 'd3-interpolate', 'd3-format', 'd3-time', 'd3-time-format', 'd3-color'], factory) :
	  (factory((global.d3 = global.d3 || {}),global.d3,global.d3,global.d3,global.d3,global.d3,global.d3,global.d3));
	}(this, function (exports,d3Array,d3Collection,d3Interpolate,d3Format,d3Time,d3TimeFormat,d3Color) { 'use strict';

	  var array = Array.prototype;

	  var map$1 = array.map;
	  var slice = array.slice;

	  var implicit = {name: "implicit"};

	  function ordinal(range) {
	    var index = d3Collection.map(),
	        domain = [],
	        unknown = implicit;

	    range = range == null ? [] : slice.call(range);

	    function scale(d) {
	      var key = d + "", i = index.get(key);
	      if (!i) {
	        if (unknown !== implicit) return unknown;
	        index.set(key, i = domain.push(d));
	      }
	      return range[(i - 1) % range.length];
	    }

	    scale.domain = function(_) {
	      if (!arguments.length) return domain.slice();
	      domain = [], index = d3Collection.map();
	      var i = -1, n = _.length, d, key;
	      while (++i < n) if (!index.has(key = (d = _[i]) + "")) index.set(key, domain.push(d));
	      return scale;
	    };

	    scale.range = function(_) {
	      return arguments.length ? (range = slice.call(_), scale) : range.slice();
	    };

	    scale.unknown = function(_) {
	      return arguments.length ? (unknown = _, scale) : unknown;
	    };

	    scale.copy = function() {
	      return ordinal()
	          .domain(domain)
	          .range(range)
	          .unknown(unknown);
	    };

	    return scale;
	  }

	  function band() {
	    var scale = ordinal().unknown(undefined),
	        domain = scale.domain,
	        ordinalRange = scale.range,
	        range = [0, 1],
	        step,
	        bandwidth,
	        round = false,
	        paddingInner = 0,
	        paddingOuter = 0,
	        align = 0.5;

	    delete scale.unknown;

	    function rescale() {
	      var n = domain().length,
	          reverse = range[1] < range[0],
	          start = range[reverse - 0],
	          stop = range[1 - reverse];
	      step = (stop - start) / Math.max(1, n - paddingInner + paddingOuter * 2);
	      if (round) step = Math.floor(step);
	      start += (stop - start - step * (n - paddingInner)) * align;
	      bandwidth = step * (1 - paddingInner);
	      if (round) start = Math.round(start), bandwidth = Math.round(bandwidth);
	      var values = d3Array.range(n).map(function(i) { return start + step * i; });
	      return ordinalRange(reverse ? values.reverse() : values);
	    }

	    scale.domain = function(_) {
	      return arguments.length ? (domain(_), rescale()) : domain();
	    };

	    scale.range = function(_) {
	      return arguments.length ? (range = [+_[0], +_[1]], rescale()) : range.slice();
	    };

	    scale.rangeRound = function(_) {
	      return range = [+_[0], +_[1]], round = true, rescale();
	    };

	    scale.bandwidth = function() {
	      return bandwidth;
	    };

	    scale.step = function() {
	      return step;
	    };

	    scale.round = function(_) {
	      return arguments.length ? (round = !!_, rescale()) : round;
	    };

	    scale.padding = function(_) {
	      return arguments.length ? (paddingInner = paddingOuter = Math.max(0, Math.min(1, _)), rescale()) : paddingInner;
	    };

	    scale.paddingInner = function(_) {
	      return arguments.length ? (paddingInner = Math.max(0, Math.min(1, _)), rescale()) : paddingInner;
	    };

	    scale.paddingOuter = function(_) {
	      return arguments.length ? (paddingOuter = Math.max(0, Math.min(1, _)), rescale()) : paddingOuter;
	    };

	    scale.align = function(_) {
	      return arguments.length ? (align = Math.max(0, Math.min(1, _)), rescale()) : align;
	    };

	    scale.copy = function() {
	      return band()
	          .domain(domain())
	          .range(range)
	          .round(round)
	          .paddingInner(paddingInner)
	          .paddingOuter(paddingOuter)
	          .align(align);
	    };

	    return rescale();
	  }

	  function pointish(scale) {
	    var copy = scale.copy;

	    scale.padding = scale.paddingOuter;
	    delete scale.paddingInner;
	    delete scale.paddingOuter;

	    scale.copy = function() {
	      return pointish(copy());
	    };

	    return scale;
	  }

	  function point() {
	    return pointish(band().paddingInner(1));
	  }

	  function constant(x) {
	    return function() {
	      return x;
	    };
	  }

	  function number(x) {
	    return +x;
	  }

	  var unit = [0, 1];

	  function deinterpolate(a, b) {
	    return (b -= (a = +a))
	        ? function(x) { return (x - a) / b; }
	        : constant(b);
	  }

	  function deinterpolateClamp(deinterpolate) {
	    return function(a, b) {
	      var d = deinterpolate(a = +a, b = +b);
	      return function(x) { return x <= a ? 0 : x >= b ? 1 : d(x); };
	    };
	  }

	  function reinterpolateClamp(reinterpolate) {
	    return function(a, b) {
	      var r = reinterpolate(a = +a, b = +b);
	      return function(t) { return t <= 0 ? a : t >= 1 ? b : r(t); };
	    };
	  }

	  function bimap(domain, range, deinterpolate, reinterpolate) {
	    var d0 = domain[0], d1 = domain[1], r0 = range[0], r1 = range[1];
	    if (d1 < d0) d0 = deinterpolate(d1, d0), r0 = reinterpolate(r1, r0);
	    else d0 = deinterpolate(d0, d1), r0 = reinterpolate(r0, r1);
	    return function(x) { return r0(d0(x)); };
	  }

	  function polymap(domain, range, deinterpolate, reinterpolate) {
	    var j = Math.min(domain.length, range.length) - 1,
	        d = new Array(j),
	        r = new Array(j),
	        i = -1;

	    // Reverse descending domains.
	    if (domain[j] < domain[0]) {
	      domain = domain.slice().reverse();
	      range = range.slice().reverse();
	    }

	    while (++i < j) {
	      d[i] = deinterpolate(domain[i], domain[i + 1]);
	      r[i] = reinterpolate(range[i], range[i + 1]);
	    }

	    return function(x) {
	      var i = d3Array.bisect(domain, x, 1, j) - 1;
	      return r[i](d[i](x));
	    };
	  }

	  function copy(source, target) {
	    return target
	        .domain(source.domain())
	        .range(source.range())
	        .interpolate(source.interpolate())
	        .clamp(source.clamp());
	  }

	  // deinterpolate(a, b)(x) takes a domain value x in [a,b] and returns the corresponding parameter t in [0,1].
	  // reinterpolate(a, b)(t) takes a parameter t in [0,1] and returns the corresponding domain value x in [a,b].
	  function continuous(deinterpolate$$, reinterpolate) {
	    var domain = unit,
	        range = unit,
	        interpolate = d3Interpolate.interpolate,
	        clamp = false,
	        piecewise,
	        output,
	        input;

	    function rescale() {
	      piecewise = Math.min(domain.length, range.length) > 2 ? polymap : bimap;
	      output = input = null;
	      return scale;
	    }

	    function scale(x) {
	      return (output || (output = piecewise(domain, range, clamp ? deinterpolateClamp(deinterpolate$$) : deinterpolate$$, interpolate)))(+x);
	    }

	    scale.invert = function(y) {
	      return (input || (input = piecewise(range, domain, deinterpolate, clamp ? reinterpolateClamp(reinterpolate) : reinterpolate)))(+y);
	    };

	    scale.domain = function(_) {
	      return arguments.length ? (domain = map$1.call(_, number), rescale()) : domain.slice();
	    };

	    scale.range = function(_) {
	      return arguments.length ? (range = slice.call(_), rescale()) : range.slice();
	    };

	    scale.rangeRound = function(_) {
	      return range = slice.call(_), interpolate = d3Interpolate.interpolateRound, rescale();
	    };

	    scale.clamp = function(_) {
	      return arguments.length ? (clamp = !!_, rescale()) : clamp;
	    };

	    scale.interpolate = function(_) {
	      return arguments.length ? (interpolate = _, rescale()) : interpolate;
	    };

	    return rescale();
	  }

	  function tickFormat(domain, count, specifier) {
	    var start = domain[0],
	        stop = domain[domain.length - 1],
	        step = d3Array.tickStep(start, stop, count == null ? 10 : count),
	        precision;
	    specifier = d3Format.formatSpecifier(specifier == null ? ",f" : specifier);
	    switch (specifier.type) {
	      case "s": {
	        var value = Math.max(Math.abs(start), Math.abs(stop));
	        if (specifier.precision == null && !isNaN(precision = d3Format.precisionPrefix(step, value))) specifier.precision = precision;
	        return d3Format.formatPrefix(specifier, value);
	      }
	      case "":
	      case "e":
	      case "g":
	      case "p":
	      case "r": {
	        if (specifier.precision == null && !isNaN(precision = d3Format.precisionRound(step, Math.max(Math.abs(start), Math.abs(stop))))) specifier.precision = precision - (specifier.type === "e");
	        break;
	      }
	      case "f":
	      case "%": {
	        if (specifier.precision == null && !isNaN(precision = d3Format.precisionFixed(step))) specifier.precision = precision - (specifier.type === "%") * 2;
	        break;
	      }
	    }
	    return d3Format.format(specifier);
	  }

	  function linearish(scale) {
	    var domain = scale.domain;

	    scale.ticks = function(count) {
	      var d = domain();
	      return d3Array.ticks(d[0], d[d.length - 1], count == null ? 10 : count);
	    };

	    scale.tickFormat = function(count, specifier) {
	      return tickFormat(domain(), count, specifier);
	    };

	    scale.nice = function(count) {
	      var d = domain(),
	          i = d.length - 1,
	          n = count == null ? 10 : count,
	          start = d[0],
	          stop = d[i],
	          step = d3Array.tickStep(start, stop, n);

	      if (step) {
	        step = d3Array.tickStep(Math.floor(start / step) * step, Math.ceil(stop / step) * step, n);
	        d[0] = Math.floor(start / step) * step;
	        d[i] = Math.ceil(stop / step) * step;
	        domain(d);
	      }

	      return scale;
	    };

	    return scale;
	  }

	  function linear() {
	    var scale = continuous(deinterpolate, d3Interpolate.interpolateNumber);

	    scale.copy = function() {
	      return copy(scale, linear());
	    };

	    return linearish(scale);
	  }

	  function identity() {
	    var domain = [0, 1];

	    function scale(x) {
	      return +x;
	    }

	    scale.invert = scale;

	    scale.domain = scale.range = function(_) {
	      return arguments.length ? (domain = map$1.call(_, number), scale) : domain.slice();
	    };

	    scale.copy = function() {
	      return identity().domain(domain);
	    };

	    return linearish(scale);
	  }

	  function nice(domain, interval) {
	    domain = domain.slice();

	    var i0 = 0,
	        i1 = domain.length - 1,
	        x0 = domain[i0],
	        x1 = domain[i1],
	        t;

	    if (x1 < x0) {
	      t = i0, i0 = i1, i1 = t;
	      t = x0, x0 = x1, x1 = t;
	    }

	    domain[i0] = interval.floor(x0);
	    domain[i1] = interval.ceil(x1);
	    return domain;
	  }

	  function deinterpolate$1(a, b) {
	    return (b = Math.log(b / a))
	        ? function(x) { return Math.log(x / a) / b; }
	        : constant(b);
	  }

	  function reinterpolate(a, b) {
	    return a < 0
	        ? function(t) { return -Math.pow(-b, t) * Math.pow(-a, 1 - t); }
	        : function(t) { return Math.pow(b, t) * Math.pow(a, 1 - t); };
	  }

	  function pow10(x) {
	    return isFinite(x) ? +("1e" + x) : x < 0 ? 0 : x;
	  }

	  function powp(base) {
	    return base === 10 ? pow10
	        : base === Math.E ? Math.exp
	        : function(x) { return Math.pow(base, x); };
	  }

	  function logp(base) {
	    return base === Math.E ? Math.log
	        : base === 10 && Math.log10
	        || base === 2 && Math.log2
	        || (base = Math.log(base), function(x) { return Math.log(x) / base; });
	  }

	  function reflect(f) {
	    return function(x) {
	      return -f(-x);
	    };
	  }

	  function log() {
	    var scale = continuous(deinterpolate$1, reinterpolate).domain([1, 10]),
	        domain = scale.domain,
	        base = 10,
	        logs = logp(10),
	        pows = powp(10);

	    function rescale() {
	      logs = logp(base), pows = powp(base);
	      if (domain()[0] < 0) logs = reflect(logs), pows = reflect(pows);
	      return scale;
	    }

	    scale.base = function(_) {
	      return arguments.length ? (base = +_, rescale()) : base;
	    };

	    scale.domain = function(_) {
	      return arguments.length ? (domain(_), rescale()) : domain();
	    };

	    scale.ticks = function(count) {
	      var d = domain(),
	          u = d[0],
	          v = d[d.length - 1],
	          r;

	      if (r = v < u) i = u, u = v, v = i;

	      var i = logs(u),
	          j = logs(v),
	          p,
	          k,
	          t,
	          n = count == null ? 10 : +count,
	          z = [];

	      if (!(base % 1) && j - i < n) {
	        i = Math.round(i) - 1, j = Math.round(j) + 1;
	        if (u > 0) for (; i < j; ++i) {
	          for (k = 1, p = pows(i); k < base; ++k) {
	            t = p * k;
	            if (t < u) continue;
	            if (t > v) break;
	            z.push(t);
	          }
	        } else for (; i < j; ++i) {
	          for (k = base - 1, p = pows(i); k >= 1; --k) {
	            t = p * k;
	            if (t < u) continue;
	            if (t > v) break;
	            z.push(t);
	          }
	        }
	      } else {
	        z = d3Array.ticks(i, j, Math.min(j - i, n)).map(pows);
	      }

	      return r ? z.reverse() : z;
	    };

	    scale.tickFormat = function(count, specifier) {
	      if (specifier == null) specifier = base === 10 ? ".0e" : ",";
	      if (typeof specifier !== "function") specifier = d3Format.format(specifier);
	      if (count === Infinity) return specifier;
	      if (count == null) count = 10;
	      var k = Math.max(1, base * count / scale.ticks().length); // TODO fast estimate?
	      return function(d) {
	        var i = d / pows(Math.round(logs(d)));
	        if (i * base < base - 0.5) i *= base;
	        return i <= k ? specifier(d) : "";
	      };
	    };

	    scale.nice = function() {
	      return domain(nice(domain(), {
	        floor: function(x) { return pows(Math.floor(logs(x))); },
	        ceil: function(x) { return pows(Math.ceil(logs(x))); }
	      }));
	    };

	    scale.copy = function() {
	      return copy(scale, log().base(base));
	    };

	    return scale;
	  }

	  function raise(x, exponent) {
	    return x < 0 ? -Math.pow(-x, exponent) : Math.pow(x, exponent);
	  }

	  function pow() {
	    var exponent = 1,
	        scale = continuous(deinterpolate, reinterpolate),
	        domain = scale.domain;

	    function deinterpolate(a, b) {
	      return (b = raise(b, exponent) - (a = raise(a, exponent)))
	          ? function(x) { return (raise(x, exponent) - a) / b; }
	          : constant(b);
	    }

	    function reinterpolate(a, b) {
	      b = raise(b, exponent) - (a = raise(a, exponent));
	      return function(t) { return raise(a + b * t, 1 / exponent); };
	    }

	    scale.exponent = function(_) {
	      return arguments.length ? (exponent = +_, domain(domain())) : exponent;
	    };

	    scale.copy = function() {
	      return copy(scale, pow().exponent(exponent));
	    };

	    return linearish(scale);
	  }

	  function sqrt() {
	    return pow().exponent(0.5);
	  }

	  function quantile$1() {
	    var domain = [],
	        range = [],
	        thresholds = [];

	    function rescale() {
	      var i = 0, n = Math.max(1, range.length);
	      thresholds = new Array(n - 1);
	      while (++i < n) thresholds[i - 1] = d3Array.quantile(domain, i / n);
	      return scale;
	    }

	    function scale(x) {
	      if (!isNaN(x = +x)) return range[d3Array.bisect(thresholds, x)];
	    }

	    scale.invertExtent = function(y) {
	      var i = range.indexOf(y);
	      return i < 0 ? [NaN, NaN] : [
	        i > 0 ? thresholds[i - 1] : domain[0],
	        i < thresholds.length ? thresholds[i] : domain[domain.length - 1]
	      ];
	    };

	    scale.domain = function(_) {
	      if (!arguments.length) return domain.slice();
	      domain = [];
	      for (var i = 0, n = _.length, d; i < n; ++i) if (d = _[i], d != null && !isNaN(d = +d)) domain.push(d);
	      domain.sort(d3Array.ascending);
	      return rescale();
	    };

	    scale.range = function(_) {
	      return arguments.length ? (range = slice.call(_), rescale()) : range.slice();
	    };

	    scale.quantiles = function() {
	      return thresholds.slice();
	    };

	    scale.copy = function() {
	      return quantile$1()
	          .domain(domain)
	          .range(range);
	    };

	    return scale;
	  }

	  function quantize() {
	    var x0 = 0,
	        x1 = 1,
	        n = 1,
	        domain = [0.5],
	        range = [0, 1];

	    function scale(x) {
	      if (x <= x) return range[d3Array.bisect(domain, x, 0, n)];
	    }

	    function rescale() {
	      var i = -1;
	      domain = new Array(n);
	      while (++i < n) domain[i] = ((i + 1) * x1 - (i - n) * x0) / (n + 1);
	      return scale;
	    }

	    scale.domain = function(_) {
	      return arguments.length ? (x0 = +_[0], x1 = +_[1], rescale()) : [x0, x1];
	    };

	    scale.range = function(_) {
	      return arguments.length ? (n = (range = slice.call(_)).length - 1, rescale()) : range.slice();
	    };

	    scale.invertExtent = function(y) {
	      var i = range.indexOf(y);
	      return i < 0 ? [NaN, NaN]
	          : i < 1 ? [x0, domain[0]]
	          : i >= n ? [domain[n - 1], x1]
	          : [domain[i - 1], domain[i]];
	    };

	    scale.copy = function() {
	      return quantize()
	          .domain([x0, x1])
	          .range(range);
	    };

	    return linearish(scale);
	  }

	  function threshold() {
	    var domain = [0.5],
	        range = [0, 1],
	        n = 1;

	    function scale(x) {
	      if (x <= x) return range[d3Array.bisect(domain, x, 0, n)];
	    }

	    scale.domain = function(_) {
	      return arguments.length ? (domain = slice.call(_), n = Math.min(domain.length, range.length - 1), scale) : domain.slice();
	    };

	    scale.range = function(_) {
	      return arguments.length ? (range = slice.call(_), n = Math.min(domain.length, range.length - 1), scale) : range.slice();
	    };

	    scale.invertExtent = function(y) {
	      var i = range.indexOf(y);
	      return [domain[i - 1], domain[i]];
	    };

	    scale.copy = function() {
	      return threshold()
	          .domain(domain)
	          .range(range);
	    };

	    return scale;
	  }

	  var durationSecond = 1000;
	  var durationMinute = durationSecond * 60;
	  var durationHour = durationMinute * 60;
	  var durationDay = durationHour * 24;
	  var durationWeek = durationDay * 7;
	  var durationMonth = durationDay * 30;
	  var durationYear = durationDay * 365;
	  function date(t) {
	    return new Date(t);
	  }

	  function number$1(t) {
	    return t instanceof Date ? +t : +new Date(+t);
	  }

	  function calendar(year, month, week, day, hour, minute, second, millisecond, format) {
	    var scale = continuous(deinterpolate, d3Interpolate.interpolateNumber),
	        invert = scale.invert,
	        domain = scale.domain;

	    var formatMillisecond = format(".%L"),
	        formatSecond = format(":%S"),
	        formatMinute = format("%I:%M"),
	        formatHour = format("%I %p"),
	        formatDay = format("%a %d"),
	        formatWeek = format("%b %d"),
	        formatMonth = format("%B"),
	        formatYear = format("%Y");

	    var tickIntervals = [
	      [second,  1,      durationSecond],
	      [second,  5,  5 * durationSecond],
	      [second, 15, 15 * durationSecond],
	      [second, 30, 30 * durationSecond],
	      [minute,  1,      durationMinute],
	      [minute,  5,  5 * durationMinute],
	      [minute, 15, 15 * durationMinute],
	      [minute, 30, 30 * durationMinute],
	      [  hour,  1,      durationHour  ],
	      [  hour,  3,  3 * durationHour  ],
	      [  hour,  6,  6 * durationHour  ],
	      [  hour, 12, 12 * durationHour  ],
	      [   day,  1,      durationDay   ],
	      [   day,  2,  2 * durationDay   ],
	      [  week,  1,      durationWeek  ],
	      [ month,  1,      durationMonth ],
	      [ month,  3,  3 * durationMonth ],
	      [  year,  1,      durationYear  ]
	    ];

	    function tickFormat(date) {
	      return (second(date) < date ? formatMillisecond
	          : minute(date) < date ? formatSecond
	          : hour(date) < date ? formatMinute
	          : day(date) < date ? formatHour
	          : month(date) < date ? (week(date) < date ? formatDay : formatWeek)
	          : year(date) < date ? formatMonth
	          : formatYear)(date);
	    }

	    function tickInterval(interval, start, stop, step) {
	      if (interval == null) interval = 10;

	      // If a desired tick count is specified, pick a reasonable tick interval
	      // based on the extent of the domain and a rough estimate of tick size.
	      // Otherwise, assume interval is already a time interval and use it.
	      if (typeof interval === "number") {
	        var target = Math.abs(stop - start) / interval,
	            i = d3Array.bisector(function(i) { return i[2]; }).right(tickIntervals, target);
	        if (i === tickIntervals.length) {
	          step = d3Array.tickStep(start / durationYear, stop / durationYear, interval);
	          interval = year;
	        } else if (i) {
	          i = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i];
	          step = i[1];
	          interval = i[0];
	        } else {
	          step = d3Array.tickStep(start, stop, interval);
	          interval = millisecond;
	        }
	      }

	      return step == null ? interval : interval.every(step);
	    }

	    scale.invert = function(y) {
	      return new Date(invert(y));
	    };

	    scale.domain = function(_) {
	      return arguments.length ? domain(map$1.call(_, number$1)) : domain().map(date);
	    };

	    scale.ticks = function(interval, step) {
	      var d = domain(),
	          t0 = d[0],
	          t1 = d[d.length - 1],
	          r = t1 < t0,
	          t;
	      if (r) t = t0, t0 = t1, t1 = t;
	      t = tickInterval(interval, t0, t1, step);
	      t = t ? t.range(t0, t1 + 1) : []; // inclusive stop
	      return r ? t.reverse() : t;
	    };

	    scale.tickFormat = function(count, specifier) {
	      return specifier == null ? tickFormat : format(specifier);
	    };

	    scale.nice = function(interval, step) {
	      var d = domain();
	      return (interval = tickInterval(interval, d[0], d[d.length - 1], step))
	          ? domain(nice(d, interval))
	          : scale;
	    };

	    scale.copy = function() {
	      return copy(scale, calendar(year, month, week, day, hour, minute, second, millisecond, format));
	    };

	    return scale;
	  }

	  function time() {
	    return calendar(d3Time.timeYear, d3Time.timeMonth, d3Time.timeWeek, d3Time.timeDay, d3Time.timeHour, d3Time.timeMinute, d3Time.timeSecond, d3Time.timeMillisecond, d3TimeFormat.timeFormat).domain([new Date(2000, 0, 1), new Date(2000, 0, 2)]);
	  }

	  function utcTime() {
	    return calendar(d3Time.utcYear, d3Time.utcMonth, d3Time.utcWeek, d3Time.utcDay, d3Time.utcHour, d3Time.utcMinute, d3Time.utcSecond, d3Time.utcMillisecond, d3TimeFormat.utcFormat).domain([Date.UTC(2000, 0, 1), Date.UTC(2000, 0, 2)]);
	  }

	  function colors(s) {
	    return s.match(/.{6}/g).map(function(x) {
	      return "#" + x;
	    });
	  }

	  var category10 = colors("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf");

	  var category20b = colors("393b795254a36b6ecf9c9ede6379398ca252b5cf6bcedb9c8c6d31bd9e39e7ba52e7cb94843c39ad494ad6616be7969c7b4173a55194ce6dbdde9ed6");

	  var category20c = colors("3182bd6baed69ecae1c6dbefe6550dfd8d3cfdae6bfdd0a231a35474c476a1d99bc7e9c0756bb19e9ac8bcbddcdadaeb636363969696bdbdbdd9d9d9");

	  var category20 = colors("1f77b4aec7e8ff7f0effbb782ca02c98df8ad62728ff98969467bdc5b0d58c564bc49c94e377c2f7b6d27f7f7fc7c7c7bcbd22dbdb8d17becf9edae5");

	  var cubehelix$1 = d3Interpolate.interpolateCubehelixLong(d3Color.cubehelix(300, 0.5, 0.0), d3Color.cubehelix(-240, 0.5, 1.0));

	  var warm = d3Interpolate.interpolateCubehelixLong(d3Color.cubehelix(-100, 0.75, 0.35), d3Color.cubehelix(80, 1.50, 0.8));

	  var cool = d3Interpolate.interpolateCubehelixLong(d3Color.cubehelix(260, 0.75, 0.35), d3Color.cubehelix(80, 1.50, 0.8));

	  var rainbow = d3Color.cubehelix();

	  function rainbow$1(t) {
	    if (t < 0 || t > 1) t -= Math.floor(t);
	    var ts = Math.abs(t - 0.5);
	    rainbow.h = 360 * t - 100;
	    rainbow.s = 1.5 - 1.5 * ts;
	    rainbow.l = 0.8 - 0.9 * ts;
	    return rainbow + "";
	  }

	  function ramp(range) {
	    var n = range.length;
	    return function(t) {
	      return range[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
	    };
	  }

	  var viridis = ramp(colors("44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725"));

	  var magma = ramp(colors("00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf"));

	  var inferno = ramp(colors("00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4"));

	  var plasma = ramp(colors("0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921"));

	  function sequential(interpolator) {
	    var x0 = 0,
	        x1 = 1,
	        clamp = false;

	    function scale(x) {
	      var t = (x - x0) / (x1 - x0);
	      return interpolator(clamp ? Math.max(0, Math.min(1, t)) : t);
	    }

	    scale.domain = function(_) {
	      return arguments.length ? (x0 = +_[0], x1 = +_[1], scale) : [x0, x1];
	    };

	    scale.clamp = function(_) {
	      return arguments.length ? (clamp = !!_, scale) : clamp;
	    };

	    scale.interpolator = function(_) {
	      return arguments.length ? (interpolator = _, scale) : interpolator;
	    };

	    scale.copy = function() {
	      return sequential(interpolator).domain([x0, x1]).clamp(clamp);
	    };

	    return linearish(scale);
	  }

	  exports.scaleBand = band;
	  exports.scalePoint = point;
	  exports.scaleIdentity = identity;
	  exports.scaleLinear = linear;
	  exports.scaleLog = log;
	  exports.scaleOrdinal = ordinal;
	  exports.scaleImplicit = implicit;
	  exports.scalePow = pow;
	  exports.scaleSqrt = sqrt;
	  exports.scaleQuantile = quantile$1;
	  exports.scaleQuantize = quantize;
	  exports.scaleThreshold = threshold;
	  exports.scaleTime = time;
	  exports.scaleUtc = utcTime;
	  exports.schemeCategory10 = category10;
	  exports.schemeCategory20b = category20b;
	  exports.schemeCategory20c = category20c;
	  exports.schemeCategory20 = category20;
	  exports.interpolateCubehelixDefault = cubehelix$1;
	  exports.interpolateRainbow = rainbow$1;
	  exports.interpolateWarm = warm;
	  exports.interpolateCool = cool;
	  exports.interpolateViridis = viridis;
	  exports.interpolateMagma = magma;
	  exports.interpolateInferno = inferno;
	  exports.interpolatePlasma = plasma;
	  exports.scaleSequential = sequential;

	  Object.defineProperty(exports, '__esModule', { value: true });

	}));

/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	// https://d3js.org/d3-array/ Version 1.0.1. Copyright 2016 Mike Bostock.
	(function (global, factory) {
	   true ? factory(exports) :
	  typeof define === 'function' && define.amd ? define(['exports'], factory) :
	  (factory((global.d3 = global.d3 || {})));
	}(this, function (exports) { 'use strict';

	  function ascending(a, b) {
	    return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
	  }

	  function bisector(compare) {
	    if (compare.length === 1) compare = ascendingComparator(compare);
	    return {
	      left: function(a, x, lo, hi) {
	        if (lo == null) lo = 0;
	        if (hi == null) hi = a.length;
	        while (lo < hi) {
	          var mid = lo + hi >>> 1;
	          if (compare(a[mid], x) < 0) lo = mid + 1;
	          else hi = mid;
	        }
	        return lo;
	      },
	      right: function(a, x, lo, hi) {
	        if (lo == null) lo = 0;
	        if (hi == null) hi = a.length;
	        while (lo < hi) {
	          var mid = lo + hi >>> 1;
	          if (compare(a[mid], x) > 0) hi = mid;
	          else lo = mid + 1;
	        }
	        return lo;
	      }
	    };
	  }

	  function ascendingComparator(f) {
	    return function(d, x) {
	      return ascending(f(d), x);
	    };
	  }

	  var ascendingBisect = bisector(ascending);
	  var bisectRight = ascendingBisect.right;
	  var bisectLeft = ascendingBisect.left;

	  function descending(a, b) {
	    return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
	  }

	  function number(x) {
	    return x === null ? NaN : +x;
	  }

	  function variance(array, f) {
	    var n = array.length,
	        m = 0,
	        a,
	        d,
	        s = 0,
	        i = -1,
	        j = 0;

	    if (f == null) {
	      while (++i < n) {
	        if (!isNaN(a = number(array[i]))) {
	          d = a - m;
	          m += d / ++j;
	          s += d * (a - m);
	        }
	      }
	    }

	    else {
	      while (++i < n) {
	        if (!isNaN(a = number(f(array[i], i, array)))) {
	          d = a - m;
	          m += d / ++j;
	          s += d * (a - m);
	        }
	      }
	    }

	    if (j > 1) return s / (j - 1);
	  }

	  function deviation(array, f) {
	    var v = variance(array, f);
	    return v ? Math.sqrt(v) : v;
	  }

	  function extent(array, f) {
	    var i = -1,
	        n = array.length,
	        a,
	        b,
	        c;

	    if (f == null) {
	      while (++i < n) if ((b = array[i]) != null && b >= b) { a = c = b; break; }
	      while (++i < n) if ((b = array[i]) != null) {
	        if (a > b) a = b;
	        if (c < b) c = b;
	      }
	    }

	    else {
	      while (++i < n) if ((b = f(array[i], i, array)) != null && b >= b) { a = c = b; break; }
	      while (++i < n) if ((b = f(array[i], i, array)) != null) {
	        if (a > b) a = b;
	        if (c < b) c = b;
	      }
	    }

	    return [a, c];
	  }

	  var array = Array.prototype;

	  var slice = array.slice;
	  var map = array.map;

	  function constant(x) {
	    return function() {
	      return x;
	    };
	  }

	  function identity(x) {
	    return x;
	  }

	  function range(start, stop, step) {
	    start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;

	    var i = -1,
	        n = Math.max(0, Math.ceil((stop - start) / step)) | 0,
	        range = new Array(n);

	    while (++i < n) {
	      range[i] = start + i * step;
	    }

	    return range;
	  }

	  var e10 = Math.sqrt(50);
	  var e5 = Math.sqrt(10);
	  var e2 = Math.sqrt(2);
	  function ticks(start, stop, count) {
	    var step = tickStep(start, stop, count);
	    return range(
	      Math.ceil(start / step) * step,
	      Math.floor(stop / step) * step + step / 2, // inclusive
	      step
	    );
	  }

	  function tickStep(start, stop, count) {
	    var step0 = Math.abs(stop - start) / Math.max(0, count),
	        step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)),
	        error = step0 / step1;
	    if (error >= e10) step1 *= 10;
	    else if (error >= e5) step1 *= 5;
	    else if (error >= e2) step1 *= 2;
	    return stop < start ? -step1 : step1;
	  }

	  function sturges(values) {
	    return Math.ceil(Math.log(values.length) / Math.LN2) + 1;
	  }

	  function histogram() {
	    var value = identity,
	        domain = extent,
	        threshold = sturges;

	    function histogram(data) {
	      var i,
	          n = data.length,
	          x,
	          values = new Array(n);

	      for (i = 0; i < n; ++i) {
	        values[i] = value(data[i], i, data);
	      }

	      var xz = domain(values),
	          x0 = xz[0],
	          x1 = xz[1],
	          tz = threshold(values, x0, x1);

	      // Convert number of thresholds into uniform thresholds.
	      if (!Array.isArray(tz)) tz = ticks(x0, x1, tz);

	      // Remove any thresholds outside the domain.
	      var m = tz.length;
	      while (tz[0] <= x0) tz.shift(), --m;
	      while (tz[m - 1] >= x1) tz.pop(), --m;

	      var bins = new Array(m + 1),
	          bin;

	      // Initialize bins.
	      for (i = 0; i <= m; ++i) {
	        bin = bins[i] = [];
	        bin.x0 = i > 0 ? tz[i - 1] : x0;
	        bin.x1 = i < m ? tz[i] : x1;
	      }

	      // Assign data to bins by value, ignoring any outside the domain.
	      for (i = 0; i < n; ++i) {
	        x = values[i];
	        if (x0 <= x && x <= x1) {
	          bins[bisectRight(tz, x, 0, m)].push(data[i]);
	        }
	      }

	      return bins;
	    }

	    histogram.value = function(_) {
	      return arguments.length ? (value = typeof _ === "function" ? _ : constant(_), histogram) : value;
	    };

	    histogram.domain = function(_) {
	      return arguments.length ? (domain = typeof _ === "function" ? _ : constant([_[0], _[1]]), histogram) : domain;
	    };

	    histogram.thresholds = function(_) {
	      return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? constant(slice.call(_)) : constant(_), histogram) : threshold;
	    };

	    return histogram;
	  }

	  function quantile(array, p, f) {
	    if (f == null) f = number;
	    if (!(n = array.length)) return;
	    if ((p = +p) <= 0 || n < 2) return +f(array[0], 0, array);
	    if (p >= 1) return +f(array[n - 1], n - 1, array);
	    var n,
	        h = (n - 1) * p,
	        i = Math.floor(h),
	        a = +f(array[i], i, array),
	        b = +f(array[i + 1], i + 1, array);
	    return a + (b - a) * (h - i);
	  }

	  function freedmanDiaconis(values, min, max) {
	    values = map.call(values, number).sort(ascending);
	    return Math.ceil((max - min) / (2 * (quantile(values, 0.75) - quantile(values, 0.25)) * Math.pow(values.length, -1 / 3)));
	  }

	  function scott(values, min, max) {
	    return Math.ceil((max - min) / (3.5 * deviation(values) * Math.pow(values.length, -1 / 3)));
	  }

	  function max(array, f) {
	    var i = -1,
	        n = array.length,
	        a,
	        b;

	    if (f == null) {
	      while (++i < n) if ((b = array[i]) != null && b >= b) { a = b; break; }
	      while (++i < n) if ((b = array[i]) != null && b > a) a = b;
	    }

	    else {
	      while (++i < n) if ((b = f(array[i], i, array)) != null && b >= b) { a = b; break; }
	      while (++i < n) if ((b = f(array[i], i, array)) != null && b > a) a = b;
	    }

	    return a;
	  }

	  function mean(array, f) {
	    var s = 0,
	        n = array.length,
	        a,
	        i = -1,
	        j = n;

	    if (f == null) {
	      while (++i < n) if (!isNaN(a = number(array[i]))) s += a; else --j;
	    }

	    else {
	      while (++i < n) if (!isNaN(a = number(f(array[i], i, array)))) s += a; else --j;
	    }

	    if (j) return s / j;
	  }

	  function median(array, f) {
	    var numbers = [],
	        n = array.length,
	        a,
	        i = -1;

	    if (f == null) {
	      while (++i < n) if (!isNaN(a = number(array[i]))) numbers.push(a);
	    }

	    else {
	      while (++i < n) if (!isNaN(a = number(f(array[i], i, array)))) numbers.push(a);
	    }

	    return quantile(numbers.sort(ascending), 0.5);
	  }

	  function merge(arrays) {
	    var n = arrays.length,
	        m,
	        i = -1,
	        j = 0,
	        merged,
	        array;

	    while (++i < n) j += arrays[i].length;
	    merged = new Array(j);

	    while (--n >= 0) {
	      array = arrays[n];
	      m = array.length;
	      while (--m >= 0) {
	        merged[--j] = array[m];
	      }
	    }

	    return merged;
	  }

	  function min(array, f) {
	    var i = -1,
	        n = array.length,
	        a,
	        b;

	    if (f == null) {
	      while (++i < n) if ((b = array[i]) != null && b >= b) { a = b; break; }
	      while (++i < n) if ((b = array[i]) != null && a > b) a = b;
	    }

	    else {
	      while (++i < n) if ((b = f(array[i], i, array)) != null && b >= b) { a = b; break; }
	      while (++i < n) if ((b = f(array[i], i, array)) != null && a > b) a = b;
	    }

	    return a;
	  }

	  function pairs(array) {
	    var i = 0, n = array.length - 1, p = array[0], pairs = new Array(n < 0 ? 0 : n);
	    while (i < n) pairs[i] = [p, p = array[++i]];
	    return pairs;
	  }

	  function permute(array, indexes) {
	    var i = indexes.length, permutes = new Array(i);
	    while (i--) permutes[i] = array[indexes[i]];
	    return permutes;
	  }

	  function scan(array, compare) {
	    if (!(n = array.length)) return;
	    var i = 0,
	        n,
	        j = 0,
	        xi,
	        xj = array[j];

	    if (!compare) compare = ascending;

	    while (++i < n) if (compare(xi = array[i], xj) < 0 || compare(xj, xj) !== 0) xj = xi, j = i;

	    if (compare(xj, xj) === 0) return j;
	  }

	  function shuffle(array, i0, i1) {
	    var m = (i1 == null ? array.length : i1) - (i0 = i0 == null ? 0 : +i0),
	        t,
	        i;

	    while (m) {
	      i = Math.random() * m-- | 0;
	      t = array[m + i0];
	      array[m + i0] = array[i + i0];
	      array[i + i0] = t;
	    }

	    return array;
	  }

	  function sum(array, f) {
	    var s = 0,
	        n = array.length,
	        a,
	        i = -1;

	    if (f == null) {
	      while (++i < n) if (a = +array[i]) s += a; // Note: zero and null are equivalent.
	    }

	    else {
	      while (++i < n) if (a = +f(array[i], i, array)) s += a;
	    }

	    return s;
	  }

	  function transpose(matrix) {
	    if (!(n = matrix.length)) return [];
	    for (var i = -1, m = min(matrix, length), transpose = new Array(m); ++i < m;) {
	      for (var j = -1, n, row = transpose[i] = new Array(n); ++j < n;) {
	        row[j] = matrix[j][i];
	      }
	    }
	    return transpose;
	  }

	  function length(d) {
	    return d.length;
	  }

	  function zip() {
	    return transpose(arguments);
	  }

	  exports.bisect = bisectRight;
	  exports.bisectRight = bisectRight;
	  exports.bisectLeft = bisectLeft;
	  exports.ascending = ascending;
	  exports.bisector = bisector;
	  exports.descending = descending;
	  exports.deviation = deviation;
	  exports.extent = extent;
	  exports.histogram = histogram;
	  exports.thresholdFreedmanDiaconis = freedmanDiaconis;
	  exports.thresholdScott = scott;
	  exports.thresholdSturges = sturges;
	  exports.max = max;
	  exports.mean = mean;
	  exports.median = median;
	  exports.merge = merge;
	  exports.min = min;
	  exports.pairs = pairs;
	  exports.permute = permute;
	  exports.quantile = quantile;
	  exports.range = range;
	  exports.scan = scan;
	  exports.shuffle = shuffle;
	  exports.sum = sum;
	  exports.ticks = ticks;
	  exports.tickStep = tickStep;
	  exports.transpose = transpose;
	  exports.variance = variance;
	  exports.zip = zip;

	  Object.defineProperty(exports, '__esModule', { value: true });

	}));

/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	// https://d3js.org/d3-collection/ Version 1.0.1. Copyright 2016 Mike Bostock.
	(function (global, factory) {
	   true ? factory(exports) :
	  typeof define === 'function' && define.amd ? define(['exports'], factory) :
	  (factory((global.d3 = global.d3 || {})));
	}(this, function (exports) { 'use strict';

	  var prefix = "$";

	  function Map() {}

	  Map.prototype = map.prototype = {
	    constructor: Map,
	    has: function(key) {
	      return (prefix + key) in this;
	    },
	    get: function(key) {
	      return this[prefix + key];
	    },
	    set: function(key, value) {
	      this[prefix + key] = value;
	      return this;
	    },
	    remove: function(key) {
	      var property = prefix + key;
	      return property in this && delete this[property];
	    },
	    clear: function() {
	      for (var property in this) if (property[0] === prefix) delete this[property];
	    },
	    keys: function() {
	      var keys = [];
	      for (var property in this) if (property[0] === prefix) keys.push(property.slice(1));
	      return keys;
	    },
	    values: function() {
	      var values = [];
	      for (var property in this) if (property[0] === prefix) values.push(this[property]);
	      return values;
	    },
	    entries: function() {
	      var entries = [];
	      for (var property in this) if (property[0] === prefix) entries.push({key: property.slice(1), value: this[property]});
	      return entries;
	    },
	    size: function() {
	      var size = 0;
	      for (var property in this) if (property[0] === prefix) ++size;
	      return size;
	    },
	    empty: function() {
	      for (var property in this) if (property[0] === prefix) return false;
	      return true;
	    },
	    each: function(f) {
	      for (var property in this) if (property[0] === prefix) f(this[property], property.slice(1), this);
	    }
	  };

	  function map(object, f) {
	    var map = new Map;

	    // Copy constructor.
	    if (object instanceof Map) object.each(function(value, key) { map.set(key, value); });

	    // Index array by numeric index or specified key function.
	    else if (Array.isArray(object)) {
	      var i = -1,
	          n = object.length,
	          o;

	      if (f == null) while (++i < n) map.set(i, object[i]);
	      else while (++i < n) map.set(f(o = object[i], i, object), o);
	    }

	    // Convert object to map.
	    else if (object) for (var key in object) map.set(key, object[key]);

	    return map;
	  }

	  function nest() {
	    var keys = [],
	        sortKeys = [],
	        sortValues,
	        rollup,
	        nest;

	    function apply(array, depth, createResult, setResult) {
	      if (depth >= keys.length) return rollup != null
	          ? rollup(array) : (sortValues != null
	          ? array.sort(sortValues)
	          : array);

	      var i = -1,
	          n = array.length,
	          key = keys[depth++],
	          keyValue,
	          value,
	          valuesByKey = map(),
	          values,
	          result = createResult();

	      while (++i < n) {
	        if (values = valuesByKey.get(keyValue = key(value = array[i]) + "")) {
	          values.push(value);
	        } else {
	          valuesByKey.set(keyValue, [value]);
	        }
	      }

	      valuesByKey.each(function(values, key) {
	        setResult(result, key, apply(values, depth, createResult, setResult));
	      });

	      return result;
	    }

	    function entries(map, depth) {
	      if (++depth > keys.length) return map;
	      var array, sortKey = sortKeys[depth - 1];
	      if (rollup != null && depth >= keys.length) array = map.entries();
	      else array = [], map.each(function(v, k) { array.push({key: k, values: entries(v, depth)}); });
	      return sortKey != null ? array.sort(function(a, b) { return sortKey(a.key, b.key); }) : array;
	    }

	    return nest = {
	      object: function(array) { return apply(array, 0, createObject, setObject); },
	      map: function(array) { return apply(array, 0, createMap, setMap); },
	      entries: function(array) { return entries(apply(array, 0, createMap, setMap), 0); },
	      key: function(d) { keys.push(d); return nest; },
	      sortKeys: function(order) { sortKeys[keys.length - 1] = order; return nest; },
	      sortValues: function(order) { sortValues = order; return nest; },
	      rollup: function(f) { rollup = f; return nest; }
	    };
	  }

	  function createObject() {
	    return {};
	  }

	  function setObject(object, key, value) {
	    object[key] = value;
	  }

	  function createMap() {
	    return map();
	  }

	  function setMap(map, key, value) {
	    map.set(key, value);
	  }

	  function Set() {}

	  var proto = map.prototype;

	  Set.prototype = set.prototype = {
	    constructor: Set,
	    has: proto.has,
	    add: function(value) {
	      value += "";
	      this[prefix + value] = value;
	      return this;
	    },
	    remove: proto.remove,
	    clear: proto.clear,
	    values: proto.keys,
	    size: proto.size,
	    empty: proto.empty,
	    each: proto.each
	  };

	  function set(object, f) {
	    var set = new Set;

	    // Copy constructor.
	    if (object instanceof Set) object.each(function(value) { set.add(value); });

	    // Otherwise, assume itâs an array.
	    else if (object) {
	      var i = -1, n = object.length;
	      if (f == null) while (++i < n) set.add(object[i]);
	      else while (++i < n) set.add(f(object[i], i, object));
	    }

	    return set;
	  }

	  function keys(map) {
	    var keys = [];
	    for (var key in map) keys.push(key);
	    return keys;
	  }

	  function values(map) {
	    var values = [];
	    for (var key in map) values.push(map[key]);
	    return values;
	  }

	  function entries(map) {
	    var entries = [];
	    for (var key in map) entries.push({key: key, value: map[key]});
	    return entries;
	  }

	  exports.nest = nest;
	  exports.set = set;
	  exports.map = map;
	  exports.keys = keys;
	  exports.values = values;
	  exports.entries = entries;

	  Object.defineProperty(exports, '__esModule', { value: true });

	}));

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	// https://d3js.org/d3-interpolate/ Version 1.1.1. Copyright 2016 Mike Bostock.
	(function (global, factory) {
	   true ? factory(exports, __webpack_require__(26)) :
	  typeof define === 'function' && define.amd ? define(['exports', 'd3-color'], factory) :
	  (factory((global.d3 = global.d3 || {}),global.d3));
	}(this, function (exports,d3Color) { 'use strict';

	  function basis(t1, v0, v1, v2, v3) {
	    var t2 = t1 * t1, t3 = t2 * t1;
	    return ((1 - 3 * t1 + 3 * t2 - t3) * v0
	        + (4 - 6 * t2 + 3 * t3) * v1
	        + (1 + 3 * t1 + 3 * t2 - 3 * t3) * v2
	        + t3 * v3) / 6;
	  }

	  function basis$1(values) {
	    var n = values.length - 1;
	    return function(t) {
	      var i = t <= 0 ? (t = 0) : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n),
	          v1 = values[i],
	          v2 = values[i + 1],
	          v0 = i > 0 ? values[i - 1] : 2 * v1 - v2,
	          v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;
	      return basis((t - i / n) * n, v0, v1, v2, v3);
	    };
	  }

	  function basisClosed(values) {
	    var n = values.length;
	    return function(t) {
	      var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n),
	          v0 = values[(i + n - 1) % n],
	          v1 = values[i % n],
	          v2 = values[(i + 1) % n],
	          v3 = values[(i + 2) % n];
	      return basis((t - i / n) * n, v0, v1, v2, v3);
	    };
	  }

	  function constant(x) {
	    return function() {
	      return x;
	    };
	  }

	  function linear(a, d) {
	    return function(t) {
	      return a + t * d;
	    };
	  }

	  function exponential(a, b, y) {
	    return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
	      return Math.pow(a + t * b, y);
	    };
	  }

	  function hue(a, b) {
	    var d = b - a;
	    return d ? linear(a, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : constant(isNaN(a) ? b : a);
	  }

	  function gamma(y) {
	    return (y = +y) === 1 ? nogamma : function(a, b) {
	      return b - a ? exponential(a, b, y) : constant(isNaN(a) ? b : a);
	    };
	  }

	  function nogamma(a, b) {
	    var d = b - a;
	    return d ? linear(a, d) : constant(isNaN(a) ? b : a);
	  }

	  var rgb$1 = (function rgbGamma(y) {
	    var color = gamma(y);

	    function rgb(start, end) {
	      var r = color((start = d3Color.rgb(start)).r, (end = d3Color.rgb(end)).r),
	          g = color(start.g, end.g),
	          b = color(start.b, end.b),
	          opacity = color(start.opacity, end.opacity);
	      return function(t) {
	        start.r = r(t);
	        start.g = g(t);
	        start.b = b(t);
	        start.opacity = opacity(t);
	        return start + "";
	      };
	    }

	    rgb.gamma = rgbGamma;

	    return rgb;
	  })(1);

	  function rgbSpline(spline) {
	    return function(colors) {
	      var n = colors.length,
	          r = new Array(n),
	          g = new Array(n),
	          b = new Array(n),
	          i, color;
	      for (i = 0; i < n; ++i) {
	        color = d3Color.rgb(colors[i]);
	        r[i] = color.r || 0;
	        g[i] = color.g || 0;
	        b[i] = color.b || 0;
	      }
	      r = spline(r);
	      g = spline(g);
	      b = spline(b);
	      color.opacity = 1;
	      return function(t) {
	        color.r = r(t);
	        color.g = g(t);
	        color.b = b(t);
	        return color + "";
	      };
	    };
	  }

	  var rgbBasis = rgbSpline(basis$1);
	  var rgbBasisClosed = rgbSpline(basisClosed);

	  function array(a, b) {
	    var nb = b ? b.length : 0,
	        na = a ? Math.min(nb, a.length) : 0,
	        x = new Array(nb),
	        c = new Array(nb),
	        i;

	    for (i = 0; i < na; ++i) x[i] = value(a[i], b[i]);
	    for (; i < nb; ++i) c[i] = b[i];

	    return function(t) {
	      for (i = 0; i < na; ++i) c[i] = x[i](t);
	      return c;
	    };
	  }

	  function date(a, b) {
	    var d = new Date;
	    return a = +a, b -= a, function(t) {
	      return d.setTime(a + b * t), d;
	    };
	  }

	  function number(a, b) {
	    return a = +a, b -= a, function(t) {
	      return a + b * t;
	    };
	  }

	  function object(a, b) {
	    var i = {},
	        c = {},
	        k;

	    if (a === null || typeof a !== "object") a = {};
	    if (b === null || typeof b !== "object") b = {};

	    for (k in b) {
	      if (k in a) {
	        i[k] = value(a[k], b[k]);
	      } else {
	        c[k] = b[k];
	      }
	    }

	    return function(t) {
	      for (k in i) c[k] = i[k](t);
	      return c;
	    };
	  }

	  var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g;
	  var reB = new RegExp(reA.source, "g");
	  function zero(b) {
	    return function() {
	      return b;
	    };
	  }

	  function one(b) {
	    return function(t) {
	      return b(t) + "";
	    };
	  }

	  function string(a, b) {
	    var bi = reA.lastIndex = reB.lastIndex = 0, // scan index for next number in b
	        am, // current match in a
	        bm, // current match in b
	        bs, // string preceding current number in b, if any
	        i = -1, // index in s
	        s = [], // string constants and placeholders
	        q = []; // number interpolators

	    // Coerce inputs to strings.
	    a = a + "", b = b + "";

	    // Interpolate pairs of numbers in a & b.
	    while ((am = reA.exec(a))
	        && (bm = reB.exec(b))) {
	      if ((bs = bm.index) > bi) { // a string precedes the next number in b
	        bs = b.slice(bi, bs);
	        if (s[i]) s[i] += bs; // coalesce with previous string
	        else s[++i] = bs;
	      }
	      if ((am = am[0]) === (bm = bm[0])) { // numbers in a & b match
	        if (s[i]) s[i] += bm; // coalesce with previous string
	        else s[++i] = bm;
	      } else { // interpolate non-matching numbers
	        s[++i] = null;
	        q.push({i: i, x: number(am, bm)});
	      }
	      bi = reB.lastIndex;
	    }

	    // Add remains of b.
	    if (bi < b.length) {
	      bs = b.slice(bi);
	      if (s[i]) s[i] += bs; // coalesce with previous string
	      else s[++i] = bs;
	    }

	    // Special optimization for only a single match.
	    // Otherwise, interpolate each of the numbers and rejoin the string.
	    return s.length < 2 ? (q[0]
	        ? one(q[0].x)
	        : zero(b))
	        : (b = q.length, function(t) {
	            for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
	            return s.join("");
	          });
	  }

	  function value(a, b) {
	    var t = typeof b, c;
	    return b == null || t === "boolean" ? constant(b)
	        : (t === "number" ? number
	        : t === "string" ? ((c = d3Color.color(b)) ? (b = c, rgb$1) : string)
	        : b instanceof d3Color.color ? rgb$1
	        : b instanceof Date ? date
	        : Array.isArray(b) ? array
	        : isNaN(b) ? object
	        : number)(a, b);
	  }

	  function round(a, b) {
	    return a = +a, b -= a, function(t) {
	      return Math.round(a + b * t);
	    };
	  }

	  var degrees = 180 / Math.PI;

	  var identity = {
	    translateX: 0,
	    translateY: 0,
	    rotate: 0,
	    skewX: 0,
	    scaleX: 1,
	    scaleY: 1
	  };

	  function decompose(a, b, c, d, e, f) {
	    var scaleX, scaleY, skewX;
	    if (scaleX = Math.sqrt(a * a + b * b)) a /= scaleX, b /= scaleX;
	    if (skewX = a * c + b * d) c -= a * skewX, d -= b * skewX;
	    if (scaleY = Math.sqrt(c * c + d * d)) c /= scaleY, d /= scaleY, skewX /= scaleY;
	    if (a * d < b * c) a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
	    return {
	      translateX: e,
	      translateY: f,
	      rotate: Math.atan2(b, a) * degrees,
	      skewX: Math.atan(skewX) * degrees,
	      scaleX: scaleX,
	      scaleY: scaleY
	    };
	  }

	  var cssNode;
	  var cssRoot;
	  var cssView;
	  var svgNode;
	  function parseCss(value) {
	    if (value === "none") return identity;
	    if (!cssNode) cssNode = document.createElement("DIV"), cssRoot = document.documentElement, cssView = document.defaultView;
	    cssNode.style.transform = value;
	    value = cssView.getComputedStyle(cssRoot.appendChild(cssNode), null).getPropertyValue("transform");
	    cssRoot.removeChild(cssNode);
	    value = value.slice(7, -1).split(",");
	    return decompose(+value[0], +value[1], +value[2], +value[3], +value[4], +value[5]);
	  }

	  function parseSvg(value) {
	    if (value == null) return identity;
	    if (!svgNode) svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
	    svgNode.setAttribute("transform", value);
	    if (!(value = svgNode.transform.baseVal.consolidate())) return identity;
	    value = value.matrix;
	    return decompose(value.a, value.b, value.c, value.d, value.e, value.f);
	  }

	  function interpolateTransform(parse, pxComma, pxParen, degParen) {

	    function pop(s) {
	      return s.length ? s.pop() + " " : "";
	    }

	    function translate(xa, ya, xb, yb, s, q) {
	      if (xa !== xb || ya !== yb) {
	        var i = s.push("translate(", null, pxComma, null, pxParen);
	        q.push({i: i - 4, x: number(xa, xb)}, {i: i - 2, x: number(ya, yb)});
	      } else if (xb || yb) {
	        s.push("translate(" + xb + pxComma + yb + pxParen);
	      }
	    }

	    function rotate(a, b, s, q) {
	      if (a !== b) {
	        if (a - b > 180) b += 360; else if (b - a > 180) a += 360; // shortest path
	        q.push({i: s.push(pop(s) + "rotate(", null, degParen) - 2, x: number(a, b)});
	      } else if (b) {
	        s.push(pop(s) + "rotate(" + b + degParen);
	      }
	    }

	    function skewX(a, b, s, q) {
	      if (a !== b) {
	        q.push({i: s.push(pop(s) + "skewX(", null, degParen) - 2, x: number(a, b)});
	      } else if (b) {
	        s.push(pop(s) + "skewX(" + b + degParen);
	      }
	    }

	    function scale(xa, ya, xb, yb, s, q) {
	      if (xa !== xb || ya !== yb) {
	        var i = s.push(pop(s) + "scale(", null, ",", null, ")");
	        q.push({i: i - 4, x: number(xa, xb)}, {i: i - 2, x: number(ya, yb)});
	      } else if (xb !== 1 || yb !== 1) {
	        s.push(pop(s) + "scale(" + xb + "," + yb + ")");
	      }
	    }

	    return function(a, b) {
	      var s = [], // string constants and placeholders
	          q = []; // number interpolators
	      a = parse(a), b = parse(b);
	      translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
	      rotate(a.rotate, b.rotate, s, q);
	      skewX(a.skewX, b.skewX, s, q);
	      scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
	      a = b = null; // gc
	      return function(t) {
	        var i = -1, n = q.length, o;
	        while (++i < n) s[(o = q[i]).i] = o.x(t);
	        return s.join("");
	      };
	    };
	  }

	  var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
	  var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");

	  var rho = Math.SQRT2;
	  var rho2 = 2;
	  var rho4 = 4;
	  var epsilon2 = 1e-12;
	  function cosh(x) {
	    return ((x = Math.exp(x)) + 1 / x) / 2;
	  }

	  function sinh(x) {
	    return ((x = Math.exp(x)) - 1 / x) / 2;
	  }

	  function tanh(x) {
	    return ((x = Math.exp(2 * x)) - 1) / (x + 1);
	  }

	  // p0 = [ux0, uy0, w0]
	  // p1 = [ux1, uy1, w1]
	  function zoom(p0, p1) {
	    var ux0 = p0[0], uy0 = p0[1], w0 = p0[2],
	        ux1 = p1[0], uy1 = p1[1], w1 = p1[2],
	        dx = ux1 - ux0,
	        dy = uy1 - uy0,
	        d2 = dx * dx + dy * dy,
	        i,
	        S;

	    // Special case for u0 â u1.
	    if (d2 < epsilon2) {
	      S = Math.log(w1 / w0) / rho;
	      i = function(t) {
	        return [
	          ux0 + t * dx,
	          uy0 + t * dy,
	          w0 * Math.exp(rho * t * S)
	        ];
	      }
	    }

	    // General case.
	    else {
	      var d1 = Math.sqrt(d2),
	          b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1),
	          b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1),
	          r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0),
	          r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
	      S = (r1 - r0) / rho;
	      i = function(t) {
	        var s = t * S,
	            coshr0 = cosh(r0),
	            u = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s + r0) - sinh(r0));
	        return [
	          ux0 + u * dx,
	          uy0 + u * dy,
	          w0 * coshr0 / cosh(rho * s + r0)
	        ];
	      }
	    }

	    i.duration = S * 1000;

	    return i;
	  }

	  function hsl$1(hue) {
	    return function(start, end) {
	      var h = hue((start = d3Color.hsl(start)).h, (end = d3Color.hsl(end)).h),
	          s = nogamma(start.s, end.s),
	          l = nogamma(start.l, end.l),
	          opacity = nogamma(start.opacity, end.opacity);
	      return function(t) {
	        start.h = h(t);
	        start.s = s(t);
	        start.l = l(t);
	        start.opacity = opacity(t);
	        return start + "";
	      };
	    }
	  }

	  var hsl$2 = hsl$1(hue);
	  var hslLong = hsl$1(nogamma);

	  function lab$1(start, end) {
	    var l = nogamma((start = d3Color.lab(start)).l, (end = d3Color.lab(end)).l),
	        a = nogamma(start.a, end.a),
	        b = nogamma(start.b, end.b),
	        opacity = nogamma(start.opacity, end.opacity);
	    return function(t) {
	      start.l = l(t);
	      start.a = a(t);
	      start.b = b(t);
	      start.opacity = opacity(t);
	      return start + "";
	    };
	  }

	  function hcl$1(hue) {
	    return function(start, end) {
	      var h = hue((start = d3Color.hcl(start)).h, (end = d3Color.hcl(end)).h),
	          c = nogamma(start.c, end.c),
	          l = nogamma(start.l, end.l),
	          opacity = nogamma(start.opacity, end.opacity);
	      return function(t) {
	        start.h = h(t);
	        start.c = c(t);
	        start.l = l(t);
	        start.opacity = opacity(t);
	        return start + "";
	      };
	    }
	  }

	  var hcl$2 = hcl$1(hue);
	  var hclLong = hcl$1(nogamma);

	  function cubehelix$1(hue) {
	    return (function cubehelixGamma(y) {
	      y = +y;

	      function cubehelix(start, end) {
	        var h = hue((start = d3Color.cubehelix(start)).h, (end = d3Color.cubehelix(end)).h),
	            s = nogamma(start.s, end.s),
	            l = nogamma(start.l, end.l),
	            opacity = nogamma(start.opacity, end.opacity);
	        return function(t) {
	          start.h = h(t);
	          start.s = s(t);
	          start.l = l(Math.pow(t, y));
	          start.opacity = opacity(t);
	          return start + "";
	        };
	      }

	      cubehelix.gamma = cubehelixGamma;

	      return cubehelix;
	    })(1);
	  }

	  var cubehelix$2 = cubehelix$1(hue);
	  var cubehelixLong = cubehelix$1(nogamma);

	  function quantize(interpolator, n) {
	    var samples = new Array(n);
	    for (var i = 0; i < n; ++i) samples[i] = interpolator(i / (n - 1));
	    return samples;
	  }

	  exports.interpolate = value;
	  exports.interpolateArray = array;
	  exports.interpolateBasis = basis$1;
	  exports.interpolateBasisClosed = basisClosed;
	  exports.interpolateDate = date;
	  exports.interpolateNumber = number;
	  exports.interpolateObject = object;
	  exports.interpolateRound = round;
	  exports.interpolateString = string;
	  exports.interpolateTransformCss = interpolateTransformCss;
	  exports.interpolateTransformSvg = interpolateTransformSvg;
	  exports.interpolateZoom = zoom;
	  exports.interpolateRgb = rgb$1;
	  exports.interpolateRgbBasis = rgbBasis;
	  exports.interpolateRgbBasisClosed = rgbBasisClosed;
	  exports.interpolateHsl = hsl$2;
	  exports.interpolateHslLong = hslLong;
	  exports.interpolateLab = lab$1;
	  exports.interpolateHcl = hcl$2;
	  exports.interpolateHclLong = hclLong;
	  exports.interpolateCubehelix = cubehelix$2;
	  exports.interpolateCubehelixLong = cubehelixLong;
	  exports.quantize = quantize;

	  Object.defineProperty(exports, '__esModule', { value: true });

	}));

/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	// https://d3js.org/d3-color/ Version 1.0.1. Copyright 2016 Mike Bostock.
	(function (global, factory) {
	   true ? factory(exports) :
	  typeof define === 'function' && define.amd ? define(['exports'], factory) :
	  (factory((global.d3 = global.d3 || {})));
	}(this, function (exports) { 'use strict';

	  function define(constructor, factory, prototype) {
	    constructor.prototype = factory.prototype = prototype;
	    prototype.constructor = constructor;
	  }

	  function extend(parent, definition) {
	    var prototype = Object.create(parent.prototype);
	    for (var key in definition) prototype[key] = definition[key];
	    return prototype;
	  }

	  function Color() {}

	  var darker = 0.7;
	  var brighter = 1 / darker;

	  var reHex3 = /^#([0-9a-f]{3})$/;
	  var reHex6 = /^#([0-9a-f]{6})$/;
	  var reRgbInteger = /^rgb\(\s*([-+]?\d+)\s*,\s*([-+]?\d+)\s*,\s*([-+]?\d+)\s*\)$/;
	  var reRgbPercent = /^rgb\(\s*([-+]?\d+(?:\.\d+)?)%\s*,\s*([-+]?\d+(?:\.\d+)?)%\s*,\s*([-+]?\d+(?:\.\d+)?)%\s*\)$/;
	  var reRgbaInteger = /^rgba\(\s*([-+]?\d+)\s*,\s*([-+]?\d+)\s*,\s*([-+]?\d+)\s*,\s*([-+]?\d+(?:\.\d+)?)\s*\)$/;
	  var reRgbaPercent = /^rgba\(\s*([-+]?\d+(?:\.\d+)?)%\s*,\s*([-+]?\d+(?:\.\d+)?)%\s*,\s*([-+]?\d+(?:\.\d+)?)%\s*,\s*([-+]?\d+(?:\.\d+)?)\s*\)$/;
	  var reHslPercent = /^hsl\(\s*([-+]?\d+(?:\.\d+)?)\s*,\s*([-+]?\d+(?:\.\d+)?)%\s*,\s*([-+]?\d+(?:\.\d+)?)%\s*\)$/;
	  var reHslaPercent = /^hsla\(\s*([-+]?\d+(?:\.\d+)?)\s*,\s*([-+]?\d+(?:\.\d+)?)%\s*,\s*([-+]?\d+(?:\.\d+)?)%\s*,\s*([-+]?\d+(?:\.\d+)?)\s*\)$/;
	  var named = {
	    aliceblue: 0xf0f8ff,
	    antiquewhite: 0xfaebd7,
	    aqua: 0x00ffff,
	    aquamarine: 0x7fffd4,
	    azure: 0xf0ffff,
	    beige: 0xf5f5dc,
	    bisque: 0xffe4c4,
	    black: 0x000000,
	    blanchedalmond: 0xffebcd,
	    blue: 0x0000ff,
	    blueviolet: 0x8a2be2,
	    brown: 0xa52a2a,
	    burlywood: 0xdeb887,
	    cadetblue: 0x5f9ea0,
	    chartreuse: 0x7fff00,
	    chocolate: 0xd2691e,
	    coral: 0xff7f50,
	    cornflowerblue: 0x6495ed,
	    cornsilk: 0xfff8dc,
	    crimson: 0xdc143c,
	    cyan: 0x00ffff,
	    darkblue: 0x00008b,
	    darkcyan: 0x008b8b,
	    darkgoldenrod: 0xb8860b,
	    darkgray: 0xa9a9a9,
	    darkgreen: 0x006400,
	    darkgrey: 0xa9a9a9,
	    darkkhaki: 0xbdb76b,
	    darkmagenta: 0x8b008b,
	    darkolivegreen: 0x556b2f,
	    darkorange: 0xff8c00,
	    darkorchid: 0x9932cc,
	    darkred: 0x8b0000,
	    darksalmon: 0xe9967a,
	    darkseagreen: 0x8fbc8f,
	    darkslateblue: 0x483d8b,
	    darkslategray: 0x2f4f4f,
	    darkslategrey: 0x2f4f4f,
	    darkturquoise: 0x00ced1,
	    darkviolet: 0x9400d3,
	    deeppink: 0xff1493,
	    deepskyblue: 0x00bfff,
	    dimgray: 0x696969,
	    dimgrey: 0x696969,
	    dodgerblue: 0x1e90ff,
	    firebrick: 0xb22222,
	    floralwhite: 0xfffaf0,
	    forestgreen: 0x228b22,
	    fuchsia: 0xff00ff,
	    gainsboro: 0xdcdcdc,
	    ghostwhite: 0xf8f8ff,
	    gold: 0xffd700,
	    goldenrod: 0xdaa520,
	    gray: 0x808080,
	    green: 0x008000,
	    greenyellow: 0xadff2f,
	    grey: 0x808080,
	    honeydew: 0xf0fff0,
	    hotpink: 0xff69b4,
	    indianred: 0xcd5c5c,
	    indigo: 0x4b0082,
	    ivory: 0xfffff0,
	    khaki: 0xf0e68c,
	    lavender: 0xe6e6fa,
	    lavenderblush: 0xfff0f5,
	    lawngreen: 0x7cfc00,
	    lemonchiffon: 0xfffacd,
	    lightblue: 0xadd8e6,
	    lightcoral: 0xf08080,
	    lightcyan: 0xe0ffff,
	    lightgoldenrodyellow: 0xfafad2,
	    lightgray: 0xd3d3d3,
	    lightgreen: 0x90ee90,
	    lightgrey: 0xd3d3d3,
	    lightpink: 0xffb6c1,
	    lightsalmon: 0xffa07a,
	    lightseagreen: 0x20b2aa,
	    lightskyblue: 0x87cefa,
	    lightslategray: 0x778899,
	    lightslategrey: 0x778899,
	    lightsteelblue: 0xb0c4de,
	    lightyellow: 0xffffe0,
	    lime: 0x00ff00,
	    limegreen: 0x32cd32,
	    linen: 0xfaf0e6,
	    magenta: 0xff00ff,
	    maroon: 0x800000,
	    mediumaquamarine: 0x66cdaa,
	    mediumblue: 0x0000cd,
	    mediumorchid: 0xba55d3,
	    mediumpurple: 0x9370db,
	    mediumseagreen: 0x3cb371,
	    mediumslateblue: 0x7b68ee,
	    mediumspringgreen: 0x00fa9a,
	    mediumturquoise: 0x48d1cc,
	    mediumvioletred: 0xc71585,
	    midnightblue: 0x191970,
	    mintcream: 0xf5fffa,
	    mistyrose: 0xffe4e1,
	    moccasin: 0xffe4b5,
	    navajowhite: 0xffdead,
	    navy: 0x000080,
	    oldlace: 0xfdf5e6,
	    olive: 0x808000,
	    olivedrab: 0x6b8e23,
	    orange: 0xffa500,
	    orangered: 0xff4500,
	    orchid: 0xda70d6,
	    palegoldenrod: 0xeee8aa,
	    palegreen: 0x98fb98,
	    paleturquoise: 0xafeeee,
	    palevioletred: 0xdb7093,
	    papayawhip: 0xffefd5,
	    peachpuff: 0xffdab9,
	    peru: 0xcd853f,
	    pink: 0xffc0cb,
	    plum: 0xdda0dd,
	    powderblue: 0xb0e0e6,
	    purple: 0x800080,
	    rebeccapurple: 0x663399,
	    red: 0xff0000,
	    rosybrown: 0xbc8f8f,
	    royalblue: 0x4169e1,
	    saddlebrown: 0x8b4513,
	    salmon: 0xfa8072,
	    sandybrown: 0xf4a460,
	    seagreen: 0x2e8b57,
	    seashell: 0xfff5ee,
	    sienna: 0xa0522d,
	    silver: 0xc0c0c0,
	    skyblue: 0x87ceeb,
	    slateblue: 0x6a5acd,
	    slategray: 0x708090,
	    slategrey: 0x708090,
	    snow: 0xfffafa,
	    springgreen: 0x00ff7f,
	    steelblue: 0x4682b4,
	    tan: 0xd2b48c,
	    teal: 0x008080,
	    thistle: 0xd8bfd8,
	    tomato: 0xff6347,
	    turquoise: 0x40e0d0,
	    violet: 0xee82ee,
	    wheat: 0xf5deb3,
	    white: 0xffffff,
	    whitesmoke: 0xf5f5f5,
	    yellow: 0xffff00,
	    yellowgreen: 0x9acd32
	  };

	  define(Color, color, {
	    displayable: function() {
	      return this.rgb().displayable();
	    },
	    toString: function() {
	      return this.rgb() + "";
	    }
	  });

	  function color(format) {
	    var m;
	    format = (format + "").trim().toLowerCase();
	    return (m = reHex3.exec(format)) ? (m = parseInt(m[1], 16), new Rgb((m >> 8 & 0xf) | (m >> 4 & 0x0f0), (m >> 4 & 0xf) | (m & 0xf0), ((m & 0xf) << 4) | (m & 0xf), 1)) // #f00
	        : (m = reHex6.exec(format)) ? rgbn(parseInt(m[1], 16)) // #ff0000
	        : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) // rgb(255, 0, 0)
	        : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)
	        : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)
	        : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)
	        : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)
	        : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)
	        : named.hasOwnProperty(format) ? rgbn(named[format])
	        : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0)
	        : null;
	  }

	  function rgbn(n) {
	    return new Rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);
	  }

	  function rgba(r, g, b, a) {
	    if (a <= 0) r = g = b = NaN;
	    return new Rgb(r, g, b, a);
	  }

	  function rgbConvert(o) {
	    if (!(o instanceof Color)) o = color(o);
	    if (!o) return new Rgb;
	    o = o.rgb();
	    return new Rgb(o.r, o.g, o.b, o.opacity);
	  }

	  function rgb(r, g, b, opacity) {
	    return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
	  }

	  function Rgb(r, g, b, opacity) {
	    this.r = +r;
	    this.g = +g;
	    this.b = +b;
	    this.opacity = +opacity;
	  }

	  define(Rgb, rgb, extend(Color, {
	    brighter: function(k) {
	      k = k == null ? brighter : Math.pow(brighter, k);
	      return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
	    },
	    darker: function(k) {
	      k = k == null ? darker : Math.pow(darker, k);
	      return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
	    },
	    rgb: function() {
	      return this;
	    },
	    displayable: function() {
	      return (0 <= this.r && this.r <= 255)
	          && (0 <= this.g && this.g <= 255)
	          && (0 <= this.b && this.b <= 255)
	          && (0 <= this.opacity && this.opacity <= 1);
	    },
	    toString: function() {
	      var a = this.opacity; a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
	      return (a === 1 ? "rgb(" : "rgba(")
	          + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", "
	          + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", "
	          + Math.max(0, Math.min(255, Math.round(this.b) || 0))
	          + (a === 1 ? ")" : ", " + a + ")");
	    }
	  }));

	  function hsla(h, s, l, a) {
	    if (a <= 0) h = s = l = NaN;
	    else if (l <= 0 || l >= 1) h = s = NaN;
	    else if (s <= 0) h = NaN;
	    return new Hsl(h, s, l, a);
	  }

	  function hslConvert(o) {
	    if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
	    if (!(o instanceof Color)) o = color(o);
	    if (!o) return new Hsl;
	    if (o instanceof Hsl) return o;
	    o = o.rgb();
	    var r = o.r / 255,
	        g = o.g / 255,
	        b = o.b / 255,
	        min = Math.min(r, g, b),
	        max = Math.max(r, g, b),
	        h = NaN,
	        s = max - min,
	        l = (max + min) / 2;
	    if (s) {
	      if (r === max) h = (g - b) / s + (g < b) * 6;
	      else if (g === max) h = (b - r) / s + 2;
	      else h = (r - g) / s + 4;
	      s /= l < 0.5 ? max + min : 2 - max - min;
	      h *= 60;
	    } else {
	      s = l > 0 && l < 1 ? 0 : h;
	    }
	    return new Hsl(h, s, l, o.opacity);
	  }

	  function hsl(h, s, l, opacity) {
	    return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
	  }

	  function Hsl(h, s, l, opacity) {
	    this.h = +h;
	    this.s = +s;
	    this.l = +l;
	    this.opacity = +opacity;
	  }

	  define(Hsl, hsl, extend(Color, {
	    brighter: function(k) {
	      k = k == null ? brighter : Math.pow(brighter, k);
	      return new Hsl(this.h, this.s, this.l * k, this.opacity);
	    },
	    darker: function(k) {
	      k = k == null ? darker : Math.pow(darker, k);
	      return new Hsl(this.h, this.s, this.l * k, this.opacity);
	    },
	    rgb: function() {
	      var h = this.h % 360 + (this.h < 0) * 360,
	          s = isNaN(h) || isNaN(this.s) ? 0 : this.s,
	          l = this.l,
	          m2 = l + (l < 0.5 ? l : 1 - l) * s,
	          m1 = 2 * l - m2;
	      return new Rgb(
	        hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
	        hsl2rgb(h, m1, m2),
	        hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
	        this.opacity
	      );
	    },
	    displayable: function() {
	      return (0 <= this.s && this.s <= 1 || isNaN(this.s))
	          && (0 <= this.l && this.l <= 1)
	          && (0 <= this.opacity && this.opacity <= 1);
	    }
	  }));

	  /* From FvD 13.37, CSS Color Module Level 3 */
	  function hsl2rgb(h, m1, m2) {
	    return (h < 60 ? m1 + (m2 - m1) * h / 60
	        : h < 180 ? m2
	        : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60
	        : m1) * 255;
	  }

	  var deg2rad = Math.PI / 180;
	  var rad2deg = 180 / Math.PI;

	  var Kn = 18;
	  var Xn = 0.950470;
	  var Yn = 1;
	  var Zn = 1.088830;
	  var t0 = 4 / 29;
	  var t1 = 6 / 29;
	  var t2 = 3 * t1 * t1;
	  var t3 = t1 * t1 * t1;
	  function labConvert(o) {
	    if (o instanceof Lab) return new Lab(o.l, o.a, o.b, o.opacity);
	    if (o instanceof Hcl) {
	      var h = o.h * deg2rad;
	      return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);
	    }
	    if (!(o instanceof Rgb)) o = rgbConvert(o);
	    var b = rgb2xyz(o.r),
	        a = rgb2xyz(o.g),
	        l = rgb2xyz(o.b),
	        x = xyz2lab((0.4124564 * b + 0.3575761 * a + 0.1804375 * l) / Xn),
	        y = xyz2lab((0.2126729 * b + 0.7151522 * a + 0.0721750 * l) / Yn),
	        z = xyz2lab((0.0193339 * b + 0.1191920 * a + 0.9503041 * l) / Zn);
	    return new Lab(116 * y - 16, 500 * (x - y), 200 * (y - z), o.opacity);
	  }

	  function lab(l, a, b, opacity) {
	    return arguments.length === 1 ? labConvert(l) : new Lab(l, a, b, opacity == null ? 1 : opacity);
	  }

	  function Lab(l, a, b, opacity) {
	    this.l = +l;
	    this.a = +a;
	    this.b = +b;
	    this.opacity = +opacity;
	  }

	  define(Lab, lab, extend(Color, {
	    brighter: function(k) {
	      return new Lab(this.l + Kn * (k == null ? 1 : k), this.a, this.b, this.opacity);
	    },
	    darker: function(k) {
	      return new Lab(this.l - Kn * (k == null ? 1 : k), this.a, this.b, this.opacity);
	    },
	    rgb: function() {
	      var y = (this.l + 16) / 116,
	          x = isNaN(this.a) ? y : y + this.a / 500,
	          z = isNaN(this.b) ? y : y - this.b / 200;
	      y = Yn * lab2xyz(y);
	      x = Xn * lab2xyz(x);
	      z = Zn * lab2xyz(z);
	      return new Rgb(
	        xyz2rgb( 3.2404542 * x - 1.5371385 * y - 0.4985314 * z), // D65 -> sRGB
	        xyz2rgb(-0.9692660 * x + 1.8760108 * y + 0.0415560 * z),
	        xyz2rgb( 0.0556434 * x - 0.2040259 * y + 1.0572252 * z),
	        this.opacity
	      );
	    }
	  }));

	  function xyz2lab(t) {
	    return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;
	  }

	  function lab2xyz(t) {
	    return t > t1 ? t * t * t : t2 * (t - t0);
	  }

	  function xyz2rgb(x) {
	    return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);
	  }

	  function rgb2xyz(x) {
	    return (x /= 255) <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
	  }

	  function hclConvert(o) {
	    if (o instanceof Hcl) return new Hcl(o.h, o.c, o.l, o.opacity);
	    if (!(o instanceof Lab)) o = labConvert(o);
	    var h = Math.atan2(o.b, o.a) * rad2deg;
	    return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
	  }

	  function hcl(h, c, l, opacity) {
	    return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
	  }

	  function Hcl(h, c, l, opacity) {
	    this.h = +h;
	    this.c = +c;
	    this.l = +l;
	    this.opacity = +opacity;
	  }

	  define(Hcl, hcl, extend(Color, {
	    brighter: function(k) {
	      return new Hcl(this.h, this.c, this.l + Kn * (k == null ? 1 : k), this.opacity);
	    },
	    darker: function(k) {
	      return new Hcl(this.h, this.c, this.l - Kn * (k == null ? 1 : k), this.opacity);
	    },
	    rgb: function() {
	      return labConvert(this).rgb();
	    }
	  }));

	  var A = -0.14861;
	  var B = +1.78277;
	  var C = -0.29227;
	  var D = -0.90649;
	  var E = +1.97294;
	  var ED = E * D;
	  var EB = E * B;
	  var BC_DA = B * C - D * A;
	  function cubehelixConvert(o) {
	    if (o instanceof Cubehelix) return new Cubehelix(o.h, o.s, o.l, o.opacity);
	    if (!(o instanceof Rgb)) o = rgbConvert(o);
	    var r = o.r / 255,
	        g = o.g / 255,
	        b = o.b / 255,
	        l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB),
	        bl = b - l,
	        k = (E * (g - l) - C * bl) / D,
	        s = Math.sqrt(k * k + bl * bl) / (E * l * (1 - l)), // NaN if l=0 or l=1
	        h = s ? Math.atan2(k, bl) * rad2deg - 120 : NaN;
	    return new Cubehelix(h < 0 ? h + 360 : h, s, l, o.opacity);
	  }

	  function cubehelix(h, s, l, opacity) {
	    return arguments.length === 1 ? cubehelixConvert(h) : new Cubehelix(h, s, l, opacity == null ? 1 : opacity);
	  }

	  function Cubehelix(h, s, l, opacity) {
	    this.h = +h;
	    this.s = +s;
	    this.l = +l;
	    this.opacity = +opacity;
	  }

	  define(Cubehelix, cubehelix, extend(Color, {
	    brighter: function(k) {
	      k = k == null ? brighter : Math.pow(brighter, k);
	      return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
	    },
	    darker: function(k) {
	      k = k == null ? darker : Math.pow(darker, k);
	      return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
	    },
	    rgb: function() {
	      var h = isNaN(this.h) ? 0 : (this.h + 120) * deg2rad,
	          l = +this.l,
	          a = isNaN(this.s) ? 0 : this.s * l * (1 - l),
	          cosh = Math.cos(h),
	          sinh = Math.sin(h);
	      return new Rgb(
	        255 * (l + a * (A * cosh + B * sinh)),
	        255 * (l + a * (C * cosh + D * sinh)),
	        255 * (l + a * (E * cosh)),
	        this.opacity
	      );
	    }
	  }));

	  exports.color = color;
	  exports.rgb = rgb;
	  exports.hsl = hsl;
	  exports.lab = lab;
	  exports.hcl = hcl;
	  exports.cubehelix = cubehelix;

	  Object.defineProperty(exports, '__esModule', { value: true });

	}));

/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	// https://d3js.org/d3-format/ Version 1.0.2. Copyright 2016 Mike Bostock.
	(function (global, factory) {
	   true ? factory(exports) :
	  typeof define === 'function' && define.amd ? define(['exports'], factory) :
	  (factory((global.d3 = global.d3 || {})));
	}(this, function (exports) { 'use strict';

	  // Computes the decimal coefficient and exponent of the specified number x with
	  // significant digits p, where x is positive and p is in [1, 21] or undefined.
	  // For example, formatDecimal(1.23) returns ["123", 0].
	  function formatDecimal(x, p) {
	    if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0) return null; // NaN, Â±Infinity
	    var i, coefficient = x.slice(0, i);

	    // The string returned by toExponential either has the form \d\.\d+e[-+]\d+
	    // (e.g., 1.2e+3) or the form \de[-+]\d+ (e.g., 1e+3).
	    return [
	      coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
	      +x.slice(i + 1)
	    ];
	  }

	  function exponent(x) {
	    return x = formatDecimal(Math.abs(x)), x ? x[1] : NaN;
	  }

	  function formatGroup(grouping, thousands) {
	    return function(value, width) {
	      var i = value.length,
	          t = [],
	          j = 0,
	          g = grouping[0],
	          length = 0;

	      while (i > 0 && g > 0) {
	        if (length + g + 1 > width) g = Math.max(1, width - length);
	        t.push(value.substring(i -= g, i + g));
	        if ((length += g + 1) > width) break;
	        g = grouping[j = (j + 1) % grouping.length];
	      }

	      return t.reverse().join(thousands);
	    };
	  }

	  function formatDefault(x, p) {
	    x = x.toPrecision(p);

	    out: for (var n = x.length, i = 1, i0 = -1, i1; i < n; ++i) {
	      switch (x[i]) {
	        case ".": i0 = i1 = i; break;
	        case "0": if (i0 === 0) i0 = i; i1 = i; break;
	        case "e": break out;
	        default: if (i0 > 0) i0 = 0; break;
	      }
	    }

	    return i0 > 0 ? x.slice(0, i0) + x.slice(i1 + 1) : x;
	  }

	  var prefixExponent;

	  function formatPrefixAuto(x, p) {
	    var d = formatDecimal(x, p);
	    if (!d) return x + "";
	    var coefficient = d[0],
	        exponent = d[1],
	        i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,
	        n = coefficient.length;
	    return i === n ? coefficient
	        : i > n ? coefficient + new Array(i - n + 1).join("0")
	        : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i)
	        : "0." + new Array(1 - i).join("0") + formatDecimal(x, Math.max(0, p + i - 1))[0]; // less than 1y!
	  }

	  function formatRounded(x, p) {
	    var d = formatDecimal(x, p);
	    if (!d) return x + "";
	    var coefficient = d[0],
	        exponent = d[1];
	    return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient
	        : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1)
	        : coefficient + new Array(exponent - coefficient.length + 2).join("0");
	  }

	  var formatTypes = {
	    "": formatDefault,
	    "%": function(x, p) { return (x * 100).toFixed(p); },
	    "b": function(x) { return Math.round(x).toString(2); },
	    "c": function(x) { return x + ""; },
	    "d": function(x) { return Math.round(x).toString(10); },
	    "e": function(x, p) { return x.toExponential(p); },
	    "f": function(x, p) { return x.toFixed(p); },
	    "g": function(x, p) { return x.toPrecision(p); },
	    "o": function(x) { return Math.round(x).toString(8); },
	    "p": function(x, p) { return formatRounded(x * 100, p); },
	    "r": formatRounded,
	    "s": formatPrefixAuto,
	    "X": function(x) { return Math.round(x).toString(16).toUpperCase(); },
	    "x": function(x) { return Math.round(x).toString(16); }
	  };

	  // [[fill]align][sign][symbol][0][width][,][.precision][type]
	  var re = /^(?:(.)?([<>=^]))?([+\-\( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?([a-z%])?$/i;

	  function formatSpecifier(specifier) {
	    return new FormatSpecifier(specifier);
	  }

	  function FormatSpecifier(specifier) {
	    if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);

	    var match,
	        fill = match[1] || " ",
	        align = match[2] || ">",
	        sign = match[3] || "-",
	        symbol = match[4] || "",
	        zero = !!match[5],
	        width = match[6] && +match[6],
	        comma = !!match[7],
	        precision = match[8] && +match[8].slice(1),
	        type = match[9] || "";

	    // The "n" type is an alias for ",g".
	    if (type === "n") comma = true, type = "g";

	    // Map invalid types to the default format.
	    else if (!formatTypes[type]) type = "";

	    // If zero fill is specified, padding goes after sign and before digits.
	    if (zero || (fill === "0" && align === "=")) zero = true, fill = "0", align = "=";

	    this.fill = fill;
	    this.align = align;
	    this.sign = sign;
	    this.symbol = symbol;
	    this.zero = zero;
	    this.width = width;
	    this.comma = comma;
	    this.precision = precision;
	    this.type = type;
	  }

	  FormatSpecifier.prototype.toString = function() {
	    return this.fill
	        + this.align
	        + this.sign
	        + this.symbol
	        + (this.zero ? "0" : "")
	        + (this.width == null ? "" : Math.max(1, this.width | 0))
	        + (this.comma ? "," : "")
	        + (this.precision == null ? "" : "." + Math.max(0, this.precision | 0))
	        + this.type;
	  };

	  var prefixes = ["y","z","a","f","p","n","Âµ","m","","k","M","G","T","P","E","Z","Y"];

	  function identity(x) {
	    return x;
	  }

	  function formatLocale(locale) {
	    var group = locale.grouping && locale.thousands ? formatGroup(locale.grouping, locale.thousands) : identity,
	        currency = locale.currency,
	        decimal = locale.decimal;

	    function newFormat(specifier) {
	      specifier = formatSpecifier(specifier);

	      var fill = specifier.fill,
	          align = specifier.align,
	          sign = specifier.sign,
	          symbol = specifier.symbol,
	          zero = specifier.zero,
	          width = specifier.width,
	          comma = specifier.comma,
	          precision = specifier.precision,
	          type = specifier.type;

	      // Compute the prefix and suffix.
	      // For SI-prefix, the suffix is lazily computed.
	      var prefix = symbol === "$" ? currency[0] : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "",
	          suffix = symbol === "$" ? currency[1] : /[%p]/.test(type) ? "%" : "";

	      // What format function should we use?
	      // Is this an integer type?
	      // Can this type generate exponential notation?
	      var formatType = formatTypes[type],
	          maybeSuffix = !type || /[defgprs%]/.test(type);

	      // Set the default precision if not specified,
	      // or clamp the specified precision to the supported range.
	      // For significant precision, it must be in [1, 21].
	      // For fixed precision, it must be in [0, 20].
	      precision = precision == null ? (type ? 6 : 12)
	          : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision))
	          : Math.max(0, Math.min(20, precision));

	      function format(value) {
	        var valuePrefix = prefix,
	            valueSuffix = suffix,
	            i, n, c;

	        if (type === "c") {
	          valueSuffix = formatType(value) + valueSuffix;
	          value = "";
	        } else {
	          value = +value;

	          // Convert negative to positive, and compute the prefix.
	          // Note that -0 is not less than 0, but 1 / -0 is!
	          var valueNegative = (value < 0 || 1 / value < 0) && (value *= -1, true);

	          // Perform the initial formatting.
	          value = formatType(value, precision);

	          // If the original value was negative, it may be rounded to zero during
	          // formatting; treat this as (positive) zero.
	          if (valueNegative) {
	            i = -1, n = value.length;
	            valueNegative = false;
	            while (++i < n) {
	              if (c = value.charCodeAt(i), (48 < c && c < 58)
	                  || (type === "x" && 96 < c && c < 103)
	                  || (type === "X" && 64 < c && c < 71)) {
	                valueNegative = true;
	                break;
	              }
	            }
	          }

	          // Compute the prefix and suffix.
	          valuePrefix = (valueNegative ? (sign === "(" ? sign : "-") : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
	          valueSuffix = valueSuffix + (type === "s" ? prefixes[8 + prefixExponent / 3] : "") + (valueNegative && sign === "(" ? ")" : "");

	          // Break the formatted value into the integer âvalueâ part that can be
	          // grouped, and fractional or exponential âsuffixâ part that is not.
	          if (maybeSuffix) {
	            i = -1, n = value.length;
	            while (++i < n) {
	              if (c = value.charCodeAt(i), 48 > c || c > 57) {
	                valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
	                value = value.slice(0, i);
	                break;
	              }
	            }
	          }
	        }

	        // If the fill character is not "0", grouping is applied before padding.
	        if (comma && !zero) value = group(value, Infinity);

	        // Compute the padding.
	        var length = valuePrefix.length + value.length + valueSuffix.length,
	            padding = length < width ? new Array(width - length + 1).join(fill) : "";

	        // If the fill character is "0", grouping is applied after padding.
	        if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";

	        // Reconstruct the final output based on the desired alignment.
	        switch (align) {
	          case "<": return valuePrefix + value + valueSuffix + padding;
	          case "=": return valuePrefix + padding + value + valueSuffix;
	          case "^": return padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length);
	        }
	        return padding + valuePrefix + value + valueSuffix;
	      }

	      format.toString = function() {
	        return specifier + "";
	      };

	      return format;
	    }

	    function formatPrefix(specifier, value) {
	      var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)),
	          e = Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3,
	          k = Math.pow(10, -e),
	          prefix = prefixes[8 + e / 3];
	      return function(value) {
	        return f(k * value) + prefix;
	      };
	    }

	    return {
	      format: newFormat,
	      formatPrefix: formatPrefix
	    };
	  }

	  var locale;
	  defaultLocale({
	    decimal: ".",
	    thousands: ",",
	    grouping: [3],
	    currency: ["$", ""]
	  });

	  function defaultLocale(definition) {
	    locale = formatLocale(definition);
	    exports.format = locale.format;
	    exports.formatPrefix = locale.formatPrefix;
	    return locale;
	  }

	  function precisionFixed(step) {
	    return Math.max(0, -exponent(Math.abs(step)));
	  }

	  function precisionPrefix(step, value) {
	    return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3 - exponent(Math.abs(step)));
	  }

	  function precisionRound(step, max) {
	    step = Math.abs(step), max = Math.abs(max) - step;
	    return Math.max(0, exponent(max) - exponent(step)) + 1;
	  }

	  exports.formatDefaultLocale = defaultLocale;
	  exports.formatLocale = formatLocale;
	  exports.formatSpecifier = formatSpecifier;
	  exports.precisionFixed = precisionFixed;
	  exports.precisionPrefix = precisionPrefix;
	  exports.precisionRound = precisionRound;

	  Object.defineProperty(exports, '__esModule', { value: true });

	}));

/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	// https://d3js.org/d3-time/ Version 1.0.2. Copyright 2016 Mike Bostock.
	(function (global, factory) {
	   true ? factory(exports) :
	  typeof define === 'function' && define.amd ? define(['exports'], factory) :
	  (factory((global.d3 = global.d3 || {})));
	}(this, function (exports) { 'use strict';

	  var t0 = new Date;
	  var t1 = new Date;
	  function newInterval(floori, offseti, count, field) {

	    function interval(date) {
	      return floori(date = new Date(+date)), date;
	    }

	    interval.floor = interval;

	    interval.ceil = function(date) {
	      return floori(date = new Date(date - 1)), offseti(date, 1), floori(date), date;
	    };

	    interval.round = function(date) {
	      var d0 = interval(date),
	          d1 = interval.ceil(date);
	      return date - d0 < d1 - date ? d0 : d1;
	    };

	    interval.offset = function(date, step) {
	      return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;
	    };

	    interval.range = function(start, stop, step) {
	      var range = [];
	      start = interval.ceil(start);
	      step = step == null ? 1 : Math.floor(step);
	      if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date
	      do range.push(new Date(+start)); while (offseti(start, step), floori(start), start < stop)
	      return range;
	    };

	    interval.filter = function(test) {
	      return newInterval(function(date) {
	        while (floori(date), !test(date)) date.setTime(date - 1);
	      }, function(date, step) {
	        while (--step >= 0) while (offseti(date, 1), !test(date));
	      });
	    };

	    if (count) {
	      interval.count = function(start, end) {
	        t0.setTime(+start), t1.setTime(+end);
	        floori(t0), floori(t1);
	        return Math.floor(count(t0, t1));
	      };

	      interval.every = function(step) {
	        step = Math.floor(step);
	        return !isFinite(step) || !(step > 0) ? null
	            : !(step > 1) ? interval
	            : interval.filter(field
	                ? function(d) { return field(d) % step === 0; }
	                : function(d) { return interval.count(0, d) % step === 0; });
	      };
	    }

	    return interval;
	  }

	  var millisecond = newInterval(function() {
	    // noop
	  }, function(date, step) {
	    date.setTime(+date + step);
	  }, function(start, end) {
	    return end - start;
	  });

	  // An optimized implementation for this simple case.
	  millisecond.every = function(k) {
	    k = Math.floor(k);
	    if (!isFinite(k) || !(k > 0)) return null;
	    if (!(k > 1)) return millisecond;
	    return newInterval(function(date) {
	      date.setTime(Math.floor(date / k) * k);
	    }, function(date, step) {
	      date.setTime(+date + step * k);
	    }, function(start, end) {
	      return (end - start) / k;
	    });
	  };

	  var milliseconds = millisecond.range;

	  var durationSecond = 1e3;
	  var durationMinute = 6e4;
	  var durationHour = 36e5;
	  var durationDay = 864e5;
	  var durationWeek = 6048e5;

	  var second = newInterval(function(date) {
	    date.setTime(Math.floor(date / durationSecond) * durationSecond);
	  }, function(date, step) {
	    date.setTime(+date + step * durationSecond);
	  }, function(start, end) {
	    return (end - start) / durationSecond;
	  }, function(date) {
	    return date.getUTCSeconds();
	  });

	  var seconds = second.range;

	  var minute = newInterval(function(date) {
	    date.setTime(Math.floor(date / durationMinute) * durationMinute);
	  }, function(date, step) {
	    date.setTime(+date + step * durationMinute);
	  }, function(start, end) {
	    return (end - start) / durationMinute;
	  }, function(date) {
	    return date.getMinutes();
	  });

	  var minutes = minute.range;

	  var hour = newInterval(function(date) {
	    var offset = date.getTimezoneOffset() * durationMinute % durationHour;
	    if (offset < 0) offset += durationHour;
	    date.setTime(Math.floor((+date - offset) / durationHour) * durationHour + offset);
	  }, function(date, step) {
	    date.setTime(+date + step * durationHour);
	  }, function(start, end) {
	    return (end - start) / durationHour;
	  }, function(date) {
	    return date.getHours();
	  });

	  var hours = hour.range;

	  var day = newInterval(function(date) {
	    date.setHours(0, 0, 0, 0);
	  }, function(date, step) {
	    date.setDate(date.getDate() + step);
	  }, function(start, end) {
	    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationDay;
	  }, function(date) {
	    return date.getDate() - 1;
	  });

	  var days = day.range;

	  function weekday(i) {
	    return newInterval(function(date) {
	      date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);
	      date.setHours(0, 0, 0, 0);
	    }, function(date, step) {
	      date.setDate(date.getDate() + step * 7);
	    }, function(start, end) {
	      return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationWeek;
	    });
	  }

	  var sunday = weekday(0);
	  var monday = weekday(1);
	  var tuesday = weekday(2);
	  var wednesday = weekday(3);
	  var thursday = weekday(4);
	  var friday = weekday(5);
	  var saturday = weekday(6);

	  var sundays = sunday.range;
	  var mondays = monday.range;
	  var tuesdays = tuesday.range;
	  var wednesdays = wednesday.range;
	  var thursdays = thursday.range;
	  var fridays = friday.range;
	  var saturdays = saturday.range;

	  var month = newInterval(function(date) {
	    date.setDate(1);
	    date.setHours(0, 0, 0, 0);
	  }, function(date, step) {
	    date.setMonth(date.getMonth() + step);
	  }, function(start, end) {
	    return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;
	  }, function(date) {
	    return date.getMonth();
	  });

	  var months = month.range;

	  var year = newInterval(function(date) {
	    date.setMonth(0, 1);
	    date.setHours(0, 0, 0, 0);
	  }, function(date, step) {
	    date.setFullYear(date.getFullYear() + step);
	  }, function(start, end) {
	    return end.getFullYear() - start.getFullYear();
	  }, function(date) {
	    return date.getFullYear();
	  });

	  // An optimized implementation for this simple case.
	  year.every = function(k) {
	    return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date) {
	      date.setFullYear(Math.floor(date.getFullYear() / k) * k);
	      date.setMonth(0, 1);
	      date.setHours(0, 0, 0, 0);
	    }, function(date, step) {
	      date.setFullYear(date.getFullYear() + step * k);
	    });
	  };

	  var years = year.range;

	  var utcMinute = newInterval(function(date) {
	    date.setUTCSeconds(0, 0);
	  }, function(date, step) {
	    date.setTime(+date + step * durationMinute);
	  }, function(start, end) {
	    return (end - start) / durationMinute;
	  }, function(date) {
	    return date.getUTCMinutes();
	  });

	  var utcMinutes = utcMinute.range;

	  var utcHour = newInterval(function(date) {
	    date.setUTCMinutes(0, 0, 0);
	  }, function(date, step) {
	    date.setTime(+date + step * durationHour);
	  }, function(start, end) {
	    return (end - start) / durationHour;
	  }, function(date) {
	    return date.getUTCHours();
	  });

	  var utcHours = utcHour.range;

	  var utcDay = newInterval(function(date) {
	    date.setUTCHours(0, 0, 0, 0);
	  }, function(date, step) {
	    date.setUTCDate(date.getUTCDate() + step);
	  }, function(start, end) {
	    return (end - start) / durationDay;
	  }, function(date) {
	    return date.getUTCDate() - 1;
	  });

	  var utcDays = utcDay.range;

	  function utcWeekday(i) {
	    return newInterval(function(date) {
	      date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);
	      date.setUTCHours(0, 0, 0, 0);
	    }, function(date, step) {
	      date.setUTCDate(date.getUTCDate() + step * 7);
	    }, function(start, end) {
	      return (end - start) / durationWeek;
	    });
	  }

	  var utcSunday = utcWeekday(0);
	  var utcMonday = utcWeekday(1);
	  var utcTuesday = utcWeekday(2);
	  var utcWednesday = utcWeekday(3);
	  var utcThursday = utcWeekday(4);
	  var utcFriday = utcWeekday(5);
	  var utcSaturday = utcWeekday(6);

	  var utcSundays = utcSunday.range;
	  var utcMondays = utcMonday.range;
	  var utcTuesdays = utcTuesday.range;
	  var utcWednesdays = utcWednesday.range;
	  var utcThursdays = utcThursday.range;
	  var utcFridays = utcFriday.range;
	  var utcSaturdays = utcSaturday.range;

	  var utcMonth = newInterval(function(date) {
	    date.setUTCDate(1);
	    date.setUTCHours(0, 0, 0, 0);
	  }, function(date, step) {
	    date.setUTCMonth(date.getUTCMonth() + step);
	  }, function(start, end) {
	    return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;
	  }, function(date) {
	    return date.getUTCMonth();
	  });

	  var utcMonths = utcMonth.range;

	  var utcYear = newInterval(function(date) {
	    date.setUTCMonth(0, 1);
	    date.setUTCHours(0, 0, 0, 0);
	  }, function(date, step) {
	    date.setUTCFullYear(date.getUTCFullYear() + step);
	  }, function(start, end) {
	    return end.getUTCFullYear() - start.getUTCFullYear();
	  }, function(date) {
	    return date.getUTCFullYear();
	  });

	  // An optimized implementation for this simple case.
	  utcYear.every = function(k) {
	    return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date) {
	      date.setUTCFullYear(Math.floor(date.getUTCFullYear() / k) * k);
	      date.setUTCMonth(0, 1);
	      date.setUTCHours(0, 0, 0, 0);
	    }, function(date, step) {
	      date.setUTCFullYear(date.getUTCFullYear() + step * k);
	    });
	  };

	  var utcYears = utcYear.range;

	  exports.timeInterval = newInterval;
	  exports.timeMillisecond = millisecond;
	  exports.timeMilliseconds = milliseconds;
	  exports.utcMillisecond = millisecond;
	  exports.utcMilliseconds = milliseconds;
	  exports.timeSecond = second;
	  exports.timeSeconds = seconds;
	  exports.utcSecond = second;
	  exports.utcSeconds = seconds;
	  exports.timeMinute = minute;
	  exports.timeMinutes = minutes;
	  exports.timeHour = hour;
	  exports.timeHours = hours;
	  exports.timeDay = day;
	  exports.timeDays = days;
	  exports.timeWeek = sunday;
	  exports.timeWeeks = sundays;
	  exports.timeSunday = sunday;
	  exports.timeSundays = sundays;
	  exports.timeMonday = monday;
	  exports.timeMondays = mondays;
	  exports.timeTuesday = tuesday;
	  exports.timeTuesdays = tuesdays;
	  exports.timeWednesday = wednesday;
	  exports.timeWednesdays = wednesdays;
	  exports.timeThursday = thursday;
	  exports.timeThursdays = thursdays;
	  exports.timeFriday = friday;
	  exports.timeFridays = fridays;
	  exports.timeSaturday = saturday;
	  exports.timeSaturdays = saturdays;
	  exports.timeMonth = month;
	  exports.timeMonths = months;
	  exports.timeYear = year;
	  exports.timeYears = years;
	  exports.utcMinute = utcMinute;
	  exports.utcMinutes = utcMinutes;
	  exports.utcHour = utcHour;
	  exports.utcHours = utcHours;
	  exports.utcDay = utcDay;
	  exports.utcDays = utcDays;
	  exports.utcWeek = utcSunday;
	  exports.utcWeeks = utcSundays;
	  exports.utcSunday = utcSunday;
	  exports.utcSundays = utcSundays;
	  exports.utcMonday = utcMonday;
	  exports.utcMondays = utcMondays;
	  exports.utcTuesday = utcTuesday;
	  exports.utcTuesdays = utcTuesdays;
	  exports.utcWednesday = utcWednesday;
	  exports.utcWednesdays = utcWednesdays;
	  exports.utcThursday = utcThursday;
	  exports.utcThursdays = utcThursdays;
	  exports.utcFriday = utcFriday;
	  exports.utcFridays = utcFridays;
	  exports.utcSaturday = utcSaturday;
	  exports.utcSaturdays = utcSaturdays;
	  exports.utcMonth = utcMonth;
	  exports.utcMonths = utcMonths;
	  exports.utcYear = utcYear;
	  exports.utcYears = utcYears;

	  Object.defineProperty(exports, '__esModule', { value: true });

	}));

/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	// https://d3js.org/d3-time-format/ Version 2.0.2. Copyright 2016 Mike Bostock.
	(function (global, factory) {
	   true ? factory(exports, __webpack_require__(28)) :
	  typeof define === 'function' && define.amd ? define(['exports', 'd3-time'], factory) :
	  (factory((global.d3 = global.d3 || {}),global.d3));
	}(this, function (exports,d3Time) { 'use strict';

	  function localDate(d) {
	    if (0 <= d.y && d.y < 100) {
	      var date = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
	      date.setFullYear(d.y);
	      return date;
	    }
	    return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
	  }

	  function utcDate(d) {
	    if (0 <= d.y && d.y < 100) {
	      var date = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
	      date.setUTCFullYear(d.y);
	      return date;
	    }
	    return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
	  }

	  function newYear(y) {
	    return {y: y, m: 0, d: 1, H: 0, M: 0, S: 0, L: 0};
	  }

	  function formatLocale(locale) {
	    var locale_dateTime = locale.dateTime,
	        locale_date = locale.date,
	        locale_time = locale.time,
	        locale_periods = locale.periods,
	        locale_weekdays = locale.days,
	        locale_shortWeekdays = locale.shortDays,
	        locale_months = locale.months,
	        locale_shortMonths = locale.shortMonths;

	    var periodRe = formatRe(locale_periods),
	        periodLookup = formatLookup(locale_periods),
	        weekdayRe = formatRe(locale_weekdays),
	        weekdayLookup = formatLookup(locale_weekdays),
	        shortWeekdayRe = formatRe(locale_shortWeekdays),
	        shortWeekdayLookup = formatLookup(locale_shortWeekdays),
	        monthRe = formatRe(locale_months),
	        monthLookup = formatLookup(locale_months),
	        shortMonthRe = formatRe(locale_shortMonths),
	        shortMonthLookup = formatLookup(locale_shortMonths);

	    var formats = {
	      "a": formatShortWeekday,
	      "A": formatWeekday,
	      "b": formatShortMonth,
	      "B": formatMonth,
	      "c": null,
	      "d": formatDayOfMonth,
	      "e": formatDayOfMonth,
	      "H": formatHour24,
	      "I": formatHour12,
	      "j": formatDayOfYear,
	      "L": formatMilliseconds,
	      "m": formatMonthNumber,
	      "M": formatMinutes,
	      "p": formatPeriod,
	      "S": formatSeconds,
	      "U": formatWeekNumberSunday,
	      "w": formatWeekdayNumber,
	      "W": formatWeekNumberMonday,
	      "x": null,
	      "X": null,
	      "y": formatYear,
	      "Y": formatFullYear,
	      "Z": formatZone,
	      "%": formatLiteralPercent
	    };

	    var utcFormats = {
	      "a": formatUTCShortWeekday,
	      "A": formatUTCWeekday,
	      "b": formatUTCShortMonth,
	      "B": formatUTCMonth,
	      "c": null,
	      "d": formatUTCDayOfMonth,
	      "e": formatUTCDayOfMonth,
	      "H": formatUTCHour24,
	      "I": formatUTCHour12,
	      "j": formatUTCDayOfYear,
	      "L": formatUTCMilliseconds,
	      "m": formatUTCMonthNumber,
	      "M": formatUTCMinutes,
	      "p": formatUTCPeriod,
	      "S": formatUTCSeconds,
	      "U": formatUTCWeekNumberSunday,
	      "w": formatUTCWeekdayNumber,
	      "W": formatUTCWeekNumberMonday,
	      "x": null,
	      "X": null,
	      "y": formatUTCYear,
	      "Y": formatUTCFullYear,
	      "Z": formatUTCZone,
	      "%": formatLiteralPercent
	    };

	    var parses = {
	      "a": parseShortWeekday,
	      "A": parseWeekday,
	      "b": parseShortMonth,
	      "B": parseMonth,
	      "c": parseLocaleDateTime,
	      "d": parseDayOfMonth,
	      "e": parseDayOfMonth,
	      "H": parseHour24,
	      "I": parseHour24,
	      "j": parseDayOfYear,
	      "L": parseMilliseconds,
	      "m": parseMonthNumber,
	      "M": parseMinutes,
	      "p": parsePeriod,
	      "S": parseSeconds,
	      "U": parseWeekNumberSunday,
	      "w": parseWeekdayNumber,
	      "W": parseWeekNumberMonday,
	      "x": parseLocaleDate,
	      "X": parseLocaleTime,
	      "y": parseYear,
	      "Y": parseFullYear,
	      "Z": parseZone,
	      "%": parseLiteralPercent
	    };

	    // These recursive directive definitions must be deferred.
	    formats.x = newFormat(locale_date, formats);
	    formats.X = newFormat(locale_time, formats);
	    formats.c = newFormat(locale_dateTime, formats);
	    utcFormats.x = newFormat(locale_date, utcFormats);
	    utcFormats.X = newFormat(locale_time, utcFormats);
	    utcFormats.c = newFormat(locale_dateTime, utcFormats);

	    function newFormat(specifier, formats) {
	      return function(date) {
	        var string = [],
	            i = -1,
	            j = 0,
	            n = specifier.length,
	            c,
	            pad,
	            format;

	        if (!(date instanceof Date)) date = new Date(+date);

	        while (++i < n) {
	          if (specifier.charCodeAt(i) === 37) {
	            string.push(specifier.slice(j, i));
	            if ((pad = pads[c = specifier.charAt(++i)]) != null) c = specifier.charAt(++i);
	            else pad = c === "e" ? " " : "0";
	            if (format = formats[c]) c = format(date, pad);
	            string.push(c);
	            j = i + 1;
	          }
	        }

	        string.push(specifier.slice(j, i));
	        return string.join("");
	      };
	    }

	    function newParse(specifier, newDate) {
	      return function(string) {
	        var d = newYear(1900),
	            i = parseSpecifier(d, specifier, string += "", 0);
	        if (i != string.length) return null;

	        // The am-pm flag is 0 for AM, and 1 for PM.
	        if ("p" in d) d.H = d.H % 12 + d.p * 12;

	        // Convert day-of-week and week-of-year to day-of-year.
	        if ("W" in d || "U" in d) {
	          if (!("w" in d)) d.w = "W" in d ? 1 : 0;
	          var day = "Z" in d ? utcDate(newYear(d.y)).getUTCDay() : newDate(newYear(d.y)).getDay();
	          d.m = 0;
	          d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day + 5) % 7 : d.w + d.U * 7 - (day + 6) % 7;
	        }

	        // If a time zone is specified, all fields are interpreted as UTC and then
	        // offset according to the specified time zone.
	        if ("Z" in d) {
	          d.H += d.Z / 100 | 0;
	          d.M += d.Z % 100;
	          return utcDate(d);
	        }

	        // Otherwise, all fields are in local time.
	        return newDate(d);
	      };
	    }

	    function parseSpecifier(d, specifier, string, j) {
	      var i = 0,
	          n = specifier.length,
	          m = string.length,
	          c,
	          parse;

	      while (i < n) {
	        if (j >= m) return -1;
	        c = specifier.charCodeAt(i++);
	        if (c === 37) {
	          c = specifier.charAt(i++);
	          parse = parses[c in pads ? specifier.charAt(i++) : c];
	          if (!parse || ((j = parse(d, string, j)) < 0)) return -1;
	        } else if (c != string.charCodeAt(j++)) {
	          return -1;
	        }
	      }

	      return j;
	    }

	    function parsePeriod(d, string, i) {
	      var n = periodRe.exec(string.slice(i));
	      return n ? (d.p = periodLookup[n[0].toLowerCase()], i + n[0].length) : -1;
	    }

	    function parseShortWeekday(d, string, i) {
	      var n = shortWeekdayRe.exec(string.slice(i));
	      return n ? (d.w = shortWeekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
	    }

	    function parseWeekday(d, string, i) {
	      var n = weekdayRe.exec(string.slice(i));
	      return n ? (d.w = weekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
	    }

	    function parseShortMonth(d, string, i) {
	      var n = shortMonthRe.exec(string.slice(i));
	      return n ? (d.m = shortMonthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
	    }

	    function parseMonth(d, string, i) {
	      var n = monthRe.exec(string.slice(i));
	      return n ? (d.m = monthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
	    }

	    function parseLocaleDateTime(d, string, i) {
	      return parseSpecifier(d, locale_dateTime, string, i);
	    }

	    function parseLocaleDate(d, string, i) {
	      return parseSpecifier(d, locale_date, string, i);
	    }

	    function parseLocaleTime(d, string, i) {
	      return parseSpecifier(d, locale_time, string, i);
	    }

	    function formatShortWeekday(d) {
	      return locale_shortWeekdays[d.getDay()];
	    }

	    function formatWeekday(d) {
	      return locale_weekdays[d.getDay()];
	    }

	    function formatShortMonth(d) {
	      return locale_shortMonths[d.getMonth()];
	    }

	    function formatMonth(d) {
	      return locale_months[d.getMonth()];
	    }

	    function formatPeriod(d) {
	      return locale_periods[+(d.getHours() >= 12)];
	    }

	    function formatUTCShortWeekday(d) {
	      return locale_shortWeekdays[d.getUTCDay()];
	    }

	    function formatUTCWeekday(d) {
	      return locale_weekdays[d.getUTCDay()];
	    }

	    function formatUTCShortMonth(d) {
	      return locale_shortMonths[d.getUTCMonth()];
	    }

	    function formatUTCMonth(d) {
	      return locale_months[d.getUTCMonth()];
	    }

	    function formatUTCPeriod(d) {
	      return locale_periods[+(d.getUTCHours() >= 12)];
	    }

	    return {
	      format: function(specifier) {
	        var f = newFormat(specifier += "", formats);
	        f.toString = function() { return specifier; };
	        return f;
	      },
	      parse: function(specifier) {
	        var p = newParse(specifier += "", localDate);
	        p.toString = function() { return specifier; };
	        return p;
	      },
	      utcFormat: function(specifier) {
	        var f = newFormat(specifier += "", utcFormats);
	        f.toString = function() { return specifier; };
	        return f;
	      },
	      utcParse: function(specifier) {
	        var p = newParse(specifier, utcDate);
	        p.toString = function() { return specifier; };
	        return p;
	      }
	    };
	  }

	  var pads = {"-": "", "_": " ", "0": "0"};
	  var numberRe = /^\s*\d+/;
	  var percentRe = /^%/;
	  var requoteRe = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g;
	  function pad(value, fill, width) {
	    var sign = value < 0 ? "-" : "",
	        string = (sign ? -value : value) + "",
	        length = string.length;
	    return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
	  }

	  function requote(s) {
	    return s.replace(requoteRe, "\\$&");
	  }

	  function formatRe(names) {
	    return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
	  }

	  function formatLookup(names) {
	    var map = {}, i = -1, n = names.length;
	    while (++i < n) map[names[i].toLowerCase()] = i;
	    return map;
	  }

	  function parseWeekdayNumber(d, string, i) {
	    var n = numberRe.exec(string.slice(i, i + 1));
	    return n ? (d.w = +n[0], i + n[0].length) : -1;
	  }

	  function parseWeekNumberSunday(d, string, i) {
	    var n = numberRe.exec(string.slice(i));
	    return n ? (d.U = +n[0], i + n[0].length) : -1;
	  }

	  function parseWeekNumberMonday(d, string, i) {
	    var n = numberRe.exec(string.slice(i));
	    return n ? (d.W = +n[0], i + n[0].length) : -1;
	  }

	  function parseFullYear(d, string, i) {
	    var n = numberRe.exec(string.slice(i, i + 4));
	    return n ? (d.y = +n[0], i + n[0].length) : -1;
	  }

	  function parseYear(d, string, i) {
	    var n = numberRe.exec(string.slice(i, i + 2));
	    return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2000), i + n[0].length) : -1;
	  }

	  function parseZone(d, string, i) {
	    var n = /^(Z)|([+-]\d\d)(?:\:?(\d\d))?/.exec(string.slice(i, i + 6));
	    return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
	  }

	  function parseMonthNumber(d, string, i) {
	    var n = numberRe.exec(string.slice(i, i + 2));
	    return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
	  }

	  function parseDayOfMonth(d, string, i) {
	    var n = numberRe.exec(string.slice(i, i + 2));
	    return n ? (d.d = +n[0], i + n[0].length) : -1;
	  }

	  function parseDayOfYear(d, string, i) {
	    var n = numberRe.exec(string.slice(i, i + 3));
	    return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
	  }

	  function parseHour24(d, string, i) {
	    var n = numberRe.exec(string.slice(i, i + 2));
	    return n ? (d.H = +n[0], i + n[0].length) : -1;
	  }

	  function parseMinutes(d, string, i) {
	    var n = numberRe.exec(string.slice(i, i + 2));
	    return n ? (d.M = +n[0], i + n[0].length) : -1;
	  }

	  function parseSeconds(d, string, i) {
	    var n = numberRe.exec(string.slice(i, i + 2));
	    return n ? (d.S = +n[0], i + n[0].length) : -1;
	  }

	  function parseMilliseconds(d, string, i) {
	    var n = numberRe.exec(string.slice(i, i + 3));
	    return n ? (d.L = +n[0], i + n[0].length) : -1;
	  }

	  function parseLiteralPercent(d, string, i) {
	    var n = percentRe.exec(string.slice(i, i + 1));
	    return n ? i + n[0].length : -1;
	  }

	  function formatDayOfMonth(d, p) {
	    return pad(d.getDate(), p, 2);
	  }

	  function formatHour24(d, p) {
	    return pad(d.getHours(), p, 2);
	  }

	  function formatHour12(d, p) {
	    return pad(d.getHours() % 12 || 12, p, 2);
	  }

	  function formatDayOfYear(d, p) {
	    return pad(1 + d3Time.timeDay.count(d3Time.timeYear(d), d), p, 3);
	  }

	  function formatMilliseconds(d, p) {
	    return pad(d.getMilliseconds(), p, 3);
	  }

	  function formatMonthNumber(d, p) {
	    return pad(d.getMonth() + 1, p, 2);
	  }

	  function formatMinutes(d, p) {
	    return pad(d.getMinutes(), p, 2);
	  }

	  function formatSeconds(d, p) {
	    return pad(d.getSeconds(), p, 2);
	  }

	  function formatWeekNumberSunday(d, p) {
	    return pad(d3Time.timeSunday.count(d3Time.timeYear(d), d), p, 2);
	  }

	  function formatWeekdayNumber(d) {
	    return d.getDay();
	  }

	  function formatWeekNumberMonday(d, p) {
	    return pad(d3Time.timeMonday.count(d3Time.timeYear(d), d), p, 2);
	  }

	  function formatYear(d, p) {
	    return pad(d.getFullYear() % 100, p, 2);
	  }

	  function formatFullYear(d, p) {
	    return pad(d.getFullYear() % 10000, p, 4);
	  }

	  function formatZone(d) {
	    var z = d.getTimezoneOffset();
	    return (z > 0 ? "-" : (z *= -1, "+"))
	        + pad(z / 60 | 0, "0", 2)
	        + pad(z % 60, "0", 2);
	  }

	  function formatUTCDayOfMonth(d, p) {
	    return pad(d.getUTCDate(), p, 2);
	  }

	  function formatUTCHour24(d, p) {
	    return pad(d.getUTCHours(), p, 2);
	  }

	  function formatUTCHour12(d, p) {
	    return pad(d.getUTCHours() % 12 || 12, p, 2);
	  }

	  function formatUTCDayOfYear(d, p) {
	    return pad(1 + d3Time.utcDay.count(d3Time.utcYear(d), d), p, 3);
	  }

	  function formatUTCMilliseconds(d, p) {
	    return pad(d.getUTCMilliseconds(), p, 3);
	  }

	  function formatUTCMonthNumber(d, p) {
	    return pad(d.getUTCMonth() + 1, p, 2);
	  }

	  function formatUTCMinutes(d, p) {
	    return pad(d.getUTCMinutes(), p, 2);
	  }

	  function formatUTCSeconds(d, p) {
	    return pad(d.getUTCSeconds(), p, 2);
	  }

	  function formatUTCWeekNumberSunday(d, p) {
	    return pad(d3Time.utcSunday.count(d3Time.utcYear(d), d), p, 2);
	  }

	  function formatUTCWeekdayNumber(d) {
	    return d.getUTCDay();
	  }

	  function formatUTCWeekNumberMonday(d, p) {
	    return pad(d3Time.utcMonday.count(d3Time.utcYear(d), d), p, 2);
	  }

	  function formatUTCYear(d, p) {
	    return pad(d.getUTCFullYear() % 100, p, 2);
	  }

	  function formatUTCFullYear(d, p) {
	    return pad(d.getUTCFullYear() % 10000, p, 4);
	  }

	  function formatUTCZone() {
	    return "+0000";
	  }

	  function formatLiteralPercent() {
	    return "%";
	  }

	  var locale;
	  defaultLocale({
	    dateTime: "%x, %X",
	    date: "%-m/%-d/%Y",
	    time: "%-I:%M:%S %p",
	    periods: ["AM", "PM"],
	    days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
	    shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
	    months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
	    shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
	  });

	  function defaultLocale(definition) {
	    locale = formatLocale(definition);
	    exports.timeFormat = locale.format;
	    exports.timeParse = locale.parse;
	    exports.utcFormat = locale.utcFormat;
	    exports.utcParse = locale.utcParse;
	    return locale;
	  }

	  var isoSpecifier = "%Y-%m-%dT%H:%M:%S.%LZ";

	  function formatIsoNative(date) {
	    return date.toISOString();
	  }

	  var formatIso = Date.prototype.toISOString
	      ? formatIsoNative
	      : exports.utcFormat(isoSpecifier);

	  function parseIsoNative(string) {
	    var date = new Date(string);
	    return isNaN(date) ? null : date;
	  }

	  var parseIso = +new Date("2000-01-01T00:00:00.000Z")
	      ? parseIsoNative
	      : exports.utcParse(isoSpecifier);

	  exports.timeFormatDefaultLocale = defaultLocale;
	  exports.timeFormatLocale = formatLocale;
	  exports.isoFormat = formatIso;
	  exports.isoParse = parseIso;

	  Object.defineProperty(exports, '__esModule', { value: true });

	}));

/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	// https://d3js.org/d3-geo/ Version 1.2.4. Copyright 2016 Mike Bostock.
	(function (global, factory) {
	   true ? factory(exports, __webpack_require__(23)) :
	  typeof define === 'function' && define.amd ? define(['exports', 'd3-array'], factory) :
	  (factory((global.d3 = global.d3 || {}),global.d3));
	}(this, (function (exports,d3Array) { 'use strict';

	// Adds floating point numbers with twice the normal precision.
	// Reference: J. R. Shewchuk, Adaptive Precision Floating-Point Arithmetic and
	// Fast Robust Geometric Predicates, Discrete & Computational Geometry 18(3)
	// 305â363 (1997).
	// Code adapted from GeographicLib by Charles F. F. Karney,
	// http://geographiclib.sourceforge.net/

	function adder() {
	  return new Adder;
	}

	function Adder() {
	  this.reset();
	}

	Adder.prototype = {
	  constructor: Adder,
	  reset: function() {
	    this.s = // rounded value
	    this.t = 0; // exact error
	  },
	  add: function(y) {
	    add(temp, y, this.t);
	    add(this, temp.s, this.s);
	    if (this.s) this.t += temp.t;
	    else this.s = temp.t;
	  },
	  valueOf: function() {
	    return this.s;
	  }
	};

	var temp = new Adder;

	function add(adder, a, b) {
	  var x = adder.s = a + b,
	      bv = x - a,
	      av = x - bv;
	  adder.t = (a - av) + (b - bv);
	}

	var epsilon = 1e-6;
	var epsilon2 = 1e-12;
	var pi = Math.PI;
	var halfPi = pi / 2;
	var quarterPi = pi / 4;
	var tau = pi * 2;

	var degrees = 180 / pi;
	var radians = pi / 180;

	var abs = Math.abs;
	var atan = Math.atan;
	var atan2 = Math.atan2;
	var cos = Math.cos;
	var ceil = Math.ceil;
	var exp = Math.exp;
	var log = Math.log;
	var pow = Math.pow;
	var sin = Math.sin;
	var sign = Math.sign || function(x) { return x > 0 ? 1 : x < 0 ? -1 : 0; };
	var sqrt = Math.sqrt;
	var tan = Math.tan;

	function acos(x) {
	  return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);
	}

	function asin(x) {
	  return x > 1 ? halfPi : x < -1 ? -halfPi : Math.asin(x);
	}

	function haversin(x) {
	  return (x = sin(x / 2)) * x;
	}

	function noop() {}

	function streamGeometry(geometry, stream) {
	  if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) {
	    streamGeometryType[geometry.type](geometry, stream);
	  }
	}

	var streamObjectType = {
	  Feature: function(feature, stream) {
	    streamGeometry(feature.geometry, stream);
	  },
	  FeatureCollection: function(object, stream) {
	    var features = object.features, i = -1, n = features.length;
	    while (++i < n) streamGeometry(features[i].geometry, stream);
	  }
	};

	var streamGeometryType = {
	  Sphere: function(object, stream) {
	    stream.sphere();
	  },
	  Point: function(object, stream) {
	    object = object.coordinates;
	    stream.point(object[0], object[1], object[2]);
	  },
	  MultiPoint: function(object, stream) {
	    var coordinates = object.coordinates, i = -1, n = coordinates.length;
	    while (++i < n) object = coordinates[i], stream.point(object[0], object[1], object[2]);
	  },
	  LineString: function(object, stream) {
	    streamLine(object.coordinates, stream, 0);
	  },
	  MultiLineString: function(object, stream) {
	    var coordinates = object.coordinates, i = -1, n = coordinates.length;
	    while (++i < n) streamLine(coordinates[i], stream, 0);
	  },
	  Polygon: function(object, stream) {
	    streamPolygon(object.coordinates, stream);
	  },
	  MultiPolygon: function(object, stream) {
	    var coordinates = object.coordinates, i = -1, n = coordinates.length;
	    while (++i < n) streamPolygon(coordinates[i], stream);
	  },
	  GeometryCollection: function(object, stream) {
	    var geometries = object.geometries, i = -1, n = geometries.length;
	    while (++i < n) streamGeometry(geometries[i], stream);
	  }
	};

	function streamLine(coordinates, stream, closed) {
	  var i = -1, n = coordinates.length - closed, coordinate;
	  stream.lineStart();
	  while (++i < n) coordinate = coordinates[i], stream.point(coordinate[0], coordinate[1], coordinate[2]);
	  stream.lineEnd();
	}

	function streamPolygon(coordinates, stream) {
	  var i = -1, n = coordinates.length;
	  stream.polygonStart();
	  while (++i < n) streamLine(coordinates[i], stream, 1);
	  stream.polygonEnd();
	}

	function geoStream(object, stream) {
	  if (object && streamObjectType.hasOwnProperty(object.type)) {
	    streamObjectType[object.type](object, stream);
	  } else {
	    streamGeometry(object, stream);
	  }
	}

	var areaRingSum = adder();

	var areaSum = adder();
	var lambda00;
	var phi00;
	var lambda0;
	var cosPhi0;
	var sinPhi0;
	var areaStream = {
	  point: noop,
	  lineStart: noop,
	  lineEnd: noop,
	  polygonStart: function() {
	    areaRingSum.reset();
	    areaStream.lineStart = areaRingStart;
	    areaStream.lineEnd = areaRingEnd;
	  },
	  polygonEnd: function() {
	    var areaRing = +areaRingSum;
	    areaSum.add(areaRing < 0 ? tau + areaRing : areaRing);
	    this.lineStart = this.lineEnd = this.point = noop;
	  },
	  sphere: function() {
	    areaSum.add(tau);
	  }
	};

	function areaRingStart() {
	  areaStream.point = areaPointFirst;
	}

	function areaRingEnd() {
	  areaPoint(lambda00, phi00);
	}

	function areaPointFirst(lambda, phi) {
	  areaStream.point = areaPoint;
	  lambda00 = lambda, phi00 = phi;
	  lambda *= radians, phi *= radians;
	  lambda0 = lambda, cosPhi0 = cos(phi = phi / 2 + quarterPi), sinPhi0 = sin(phi);
	}

	function areaPoint(lambda, phi) {
	  lambda *= radians, phi *= radians;
	  phi = phi / 2 + quarterPi; // half the angular distance from south pole

	  // Spherical excess E for a spherical triangle with vertices: south pole,
	  // previous point, current point.  Uses a formula derived from Cagnoliâs
	  // theorem.  See Todhunter, Spherical Trig. (1871), Sec. 103, Eq. (2).
	  var dLambda = lambda - lambda0,
	      sdLambda = dLambda >= 0 ? 1 : -1,
	      adLambda = sdLambda * dLambda,
	      cosPhi = cos(phi),
	      sinPhi = sin(phi),
	      k = sinPhi0 * sinPhi,
	      u = cosPhi0 * cosPhi + k * cos(adLambda),
	      v = k * sdLambda * sin(adLambda);
	  areaRingSum.add(atan2(v, u));

	  // Advance the previous points.
	  lambda0 = lambda, cosPhi0 = cosPhi, sinPhi0 = sinPhi;
	}

	function area(object) {
	  areaSum.reset();
	  geoStream(object, areaStream);
	  return areaSum * 2;
	}

	function spherical(cartesian) {
	  return [atan2(cartesian[1], cartesian[0]), asin(cartesian[2])];
	}

	function cartesian(spherical) {
	  var lambda = spherical[0], phi = spherical[1], cosPhi = cos(phi);
	  return [cosPhi * cos(lambda), cosPhi * sin(lambda), sin(phi)];
	}

	function cartesianDot(a, b) {
	  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
	}

	function cartesianCross(a, b) {
	  return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];
	}

	// TODO return a
	function cartesianAddInPlace(a, b) {
	  a[0] += b[0], a[1] += b[1], a[2] += b[2];
	}

	function cartesianScale(vector, k) {
	  return [vector[0] * k, vector[1] * k, vector[2] * k];
	}

	// TODO return d
	function cartesianNormalizeInPlace(d) {
	  var l = sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
	  d[0] /= l, d[1] /= l, d[2] /= l;
	}

	var lambda0$1;
	var phi0;
	var lambda1;
	var phi1;
	var lambda2;
	var lambda00$1;
	var phi00$1;
	var p0;
	var deltaSum = adder();
	var ranges;
	var range$1;
	var boundsStream = {
	  point: boundsPoint,
	  lineStart: boundsLineStart,
	  lineEnd: boundsLineEnd,
	  polygonStart: function() {
	    boundsStream.point = boundsRingPoint;
	    boundsStream.lineStart = boundsRingStart;
	    boundsStream.lineEnd = boundsRingEnd;
	    deltaSum.reset();
	    areaStream.polygonStart();
	  },
	  polygonEnd: function() {
	    areaStream.polygonEnd();
	    boundsStream.point = boundsPoint;
	    boundsStream.lineStart = boundsLineStart;
	    boundsStream.lineEnd = boundsLineEnd;
	    if (areaRingSum < 0) lambda0$1 = -(lambda1 = 180), phi0 = -(phi1 = 90);
	    else if (deltaSum > epsilon) phi1 = 90;
	    else if (deltaSum < -epsilon) phi0 = -90;
	    range$1[0] = lambda0$1, range$1[1] = lambda1;
	  }
	};

	function boundsPoint(lambda, phi) {
	  ranges.push(range$1 = [lambda0$1 = lambda, lambda1 = lambda]);
	  if (phi < phi0) phi0 = phi;
	  if (phi > phi1) phi1 = phi;
	}

	function linePoint(lambda, phi) {
	  var p = cartesian([lambda * radians, phi * radians]);
	  if (p0) {
	    var normal = cartesianCross(p0, p),
	        equatorial = [normal[1], -normal[0], 0],
	        inflection = cartesianCross(equatorial, normal);
	    cartesianNormalizeInPlace(inflection);
	    inflection = spherical(inflection);
	    var delta = lambda - lambda2,
	        sign = delta > 0 ? 1 : -1,
	        lambdai = inflection[0] * degrees * sign,
	        phii,
	        antimeridian = abs(delta) > 180;
	    if (antimeridian ^ (sign * lambda2 < lambdai && lambdai < sign * lambda)) {
	      phii = inflection[1] * degrees;
	      if (phii > phi1) phi1 = phii;
	    } else if (lambdai = (lambdai + 360) % 360 - 180, antimeridian ^ (sign * lambda2 < lambdai && lambdai < sign * lambda)) {
	      phii = -inflection[1] * degrees;
	      if (phii < phi0) phi0 = phii;
	    } else {
	      if (phi < phi0) phi0 = phi;
	      if (phi > phi1) phi1 = phi;
	    }
	    if (antimeridian) {
	      if (lambda < lambda2) {
	        if (angle(lambda0$1, lambda) > angle(lambda0$1, lambda1)) lambda1 = lambda;
	      } else {
	        if (angle(lambda, lambda1) > angle(lambda0$1, lambda1)) lambda0$1 = lambda;
	      }
	    } else {
	      if (lambda1 >= lambda0$1) {
	        if (lambda < lambda0$1) lambda0$1 = lambda;
	        if (lambda > lambda1) lambda1 = lambda;
	      } else {
	        if (lambda > lambda2) {
	          if (angle(lambda0$1, lambda) > angle(lambda0$1, lambda1)) lambda1 = lambda;
	        } else {
	          if (angle(lambda, lambda1) > angle(lambda0$1, lambda1)) lambda0$1 = lambda;
	        }
	      }
	    }
	  } else {
	    boundsPoint(lambda, phi);
	  }
	  p0 = p, lambda2 = lambda;
	}

	function boundsLineStart() {
	  boundsStream.point = linePoint;
	}

	function boundsLineEnd() {
	  range$1[0] = lambda0$1, range$1[1] = lambda1;
	  boundsStream.point = boundsPoint;
	  p0 = null;
	}

	function boundsRingPoint(lambda, phi) {
	  if (p0) {
	    var delta = lambda - lambda2;
	    deltaSum.add(abs(delta) > 180 ? delta + (delta > 0 ? 360 : -360) : delta);
	  } else {
	    lambda00$1 = lambda, phi00$1 = phi;
	  }
	  areaStream.point(lambda, phi);
	  linePoint(lambda, phi);
	}

	function boundsRingStart() {
	  areaStream.lineStart();
	}

	function boundsRingEnd() {
	  boundsRingPoint(lambda00$1, phi00$1);
	  areaStream.lineEnd();
	  if (abs(deltaSum) > epsilon) lambda0$1 = -(lambda1 = 180);
	  range$1[0] = lambda0$1, range$1[1] = lambda1;
	  p0 = null;
	}

	// Finds the left-right distance between two longitudes.
	// This is almost the same as (lambda1 - lambda0 + 360Â°) % 360Â°, except that we want
	// the distance between Â±180Â° to be 360Â°.
	function angle(lambda0, lambda1) {
	  return (lambda1 -= lambda0) < 0 ? lambda1 + 360 : lambda1;
	}

	function rangeCompare(a, b) {
	  return a[0] - b[0];
	}

	function rangeContains(range, x) {
	  return range[0] <= range[1] ? range[0] <= x && x <= range[1] : x < range[0] || range[1] < x;
	}

	function bounds(feature) {
	  var i, n, a, b, merged, deltaMax, delta;

	  phi1 = lambda1 = -(lambda0$1 = phi0 = Infinity);
	  ranges = [];
	  geoStream(feature, boundsStream);

	  // First, sort ranges by their minimum longitudes.
	  if (n = ranges.length) {
	    ranges.sort(rangeCompare);

	    // Then, merge any ranges that overlap.
	    for (i = 1, a = ranges[0], merged = [a]; i < n; ++i) {
	      b = ranges[i];
	      if (rangeContains(a, b[0]) || rangeContains(a, b[1])) {
	        if (angle(a[0], b[1]) > angle(a[0], a[1])) a[1] = b[1];
	        if (angle(b[0], a[1]) > angle(a[0], a[1])) a[0] = b[0];
	      } else {
	        merged.push(a = b);
	      }
	    }

	    // Finally, find the largest gap between the merged ranges.
	    // The final bounding box will be the inverse of this gap.
	    for (deltaMax = -Infinity, n = merged.length - 1, i = 0, a = merged[n]; i <= n; a = b, ++i) {
	      b = merged[i];
	      if ((delta = angle(a[1], b[0])) > deltaMax) deltaMax = delta, lambda0$1 = b[0], lambda1 = a[1];
	    }
	  }

	  ranges = range$1 = null;

	  return lambda0$1 === Infinity || phi0 === Infinity
	      ? [[NaN, NaN], [NaN, NaN]]
	      : [[lambda0$1, phi0], [lambda1, phi1]];
	}

	var W0;
	var W1;
	var X0;
	var Y0;
	var Z0;
	var X1;
	var Y1;
	var Z1;
	var X2;
	var Y2;
	var Z2;
	var lambda00$2;
	var phi00$2;
	var x0;
	var y0;
	var z0;
	// previous point

	var centroidStream = {
	  sphere: noop,
	  point: centroidPoint,
	  lineStart: centroidLineStart,
	  lineEnd: centroidLineEnd,
	  polygonStart: function() {
	    centroidStream.lineStart = centroidRingStart;
	    centroidStream.lineEnd = centroidRingEnd;
	  },
	  polygonEnd: function() {
	    centroidStream.lineStart = centroidLineStart;
	    centroidStream.lineEnd = centroidLineEnd;
	  }
	};

	// Arithmetic mean of Cartesian vectors.
	function centroidPoint(lambda, phi) {
	  lambda *= radians, phi *= radians;
	  var cosPhi = cos(phi);
	  centroidPointCartesian(cosPhi * cos(lambda), cosPhi * sin(lambda), sin(phi));
	}

	function centroidPointCartesian(x, y, z) {
	  ++W0;
	  X0 += (x - X0) / W0;
	  Y0 += (y - Y0) / W0;
	  Z0 += (z - Z0) / W0;
	}

	function centroidLineStart() {
	  centroidStream.point = centroidLinePointFirst;
	}

	function centroidLinePointFirst(lambda, phi) {
	  lambda *= radians, phi *= radians;
	  var cosPhi = cos(phi);
	  x0 = cosPhi * cos(lambda);
	  y0 = cosPhi * sin(lambda);
	  z0 = sin(phi);
	  centroidStream.point = centroidLinePoint;
	  centroidPointCartesian(x0, y0, z0);
	}

	function centroidLinePoint(lambda, phi) {
	  lambda *= radians, phi *= radians;
	  var cosPhi = cos(phi),
	      x = cosPhi * cos(lambda),
	      y = cosPhi * sin(lambda),
	      z = sin(phi),
	      w = atan2(sqrt((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);
	  W1 += w;
	  X1 += w * (x0 + (x0 = x));
	  Y1 += w * (y0 + (y0 = y));
	  Z1 += w * (z0 + (z0 = z));
	  centroidPointCartesian(x0, y0, z0);
	}

	function centroidLineEnd() {
	  centroidStream.point = centroidPoint;
	}

	// See J. E. Brock, The Inertia Tensor for a Spherical Triangle,
	// J. Applied Mechanics 42, 239 (1975).
	function centroidRingStart() {
	  centroidStream.point = centroidRingPointFirst;
	}

	function centroidRingEnd() {
	  centroidRingPoint(lambda00$2, phi00$2);
	  centroidStream.point = centroidPoint;
	}

	function centroidRingPointFirst(lambda, phi) {
	  lambda00$2 = lambda, phi00$2 = phi;
	  lambda *= radians, phi *= radians;
	  centroidStream.point = centroidRingPoint;
	  var cosPhi = cos(phi);
	  x0 = cosPhi * cos(lambda);
	  y0 = cosPhi * sin(lambda);
	  z0 = sin(phi);
	  centroidPointCartesian(x0, y0, z0);
	}

	function centroidRingPoint(lambda, phi) {
	  lambda *= radians, phi *= radians;
	  var cosPhi = cos(phi),
	      x = cosPhi * cos(lambda),
	      y = cosPhi * sin(lambda),
	      z = sin(phi),
	      cx = y0 * z - z0 * y,
	      cy = z0 * x - x0 * z,
	      cz = x0 * y - y0 * x,
	      m = sqrt(cx * cx + cy * cy + cz * cz),
	      u = x0 * x + y0 * y + z0 * z,
	      v = m && -acos(u) / m, // area weight
	      w = atan2(m, u); // line weight
	  X2 += v * cx;
	  Y2 += v * cy;
	  Z2 += v * cz;
	  W1 += w;
	  X1 += w * (x0 + (x0 = x));
	  Y1 += w * (y0 + (y0 = y));
	  Z1 += w * (z0 + (z0 = z));
	  centroidPointCartesian(x0, y0, z0);
	}

	function centroid(object) {
	  W0 = W1 =
	  X0 = Y0 = Z0 =
	  X1 = Y1 = Z1 =
	  X2 = Y2 = Z2 = 0;
	  geoStream(object, centroidStream);

	  var x = X2,
	      y = Y2,
	      z = Z2,
	      m = x * x + y * y + z * z;

	  // If the area-weighted ccentroid is undefined, fall back to length-weighted ccentroid.
	  if (m < epsilon2) {
	    x = X1, y = Y1, z = Z1;
	    // If the feature has zero length, fall back to arithmetic mean of point vectors.
	    if (W1 < epsilon) x = X0, y = Y0, z = Z0;
	    m = x * x + y * y + z * z;
	    // If the feature still has an undefined ccentroid, then return.
	    if (m < epsilon2) return [NaN, NaN];
	  }

	  return [atan2(y, x) * degrees, asin(z / sqrt(m)) * degrees];
	}

	function constant(x) {
	  return function() {
	    return x;
	  };
	}

	function compose(a, b) {

	  function compose(x, y) {
	    return x = a(x, y), b(x[0], x[1]);
	  }

	  if (a.invert && b.invert) compose.invert = function(x, y) {
	    return x = b.invert(x, y), x && a.invert(x[0], x[1]);
	  };

	  return compose;
	}

	function rotationIdentity(lambda, phi) {
	  return [lambda > pi ? lambda - tau : lambda < -pi ? lambda + tau : lambda, phi];
	}

	rotationIdentity.invert = rotationIdentity;

	function rotateRadians(deltaLambda, deltaPhi, deltaGamma) {
	  return (deltaLambda %= tau) ? (deltaPhi || deltaGamma ? compose(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma))
	    : rotationLambda(deltaLambda))
	    : (deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma)
	    : rotationIdentity);
	}

	function forwardRotationLambda(deltaLambda) {
	  return function(lambda, phi) {
	    return lambda += deltaLambda, [lambda > pi ? lambda - tau : lambda < -pi ? lambda + tau : lambda, phi];
	  };
	}

	function rotationLambda(deltaLambda) {
	  var rotation = forwardRotationLambda(deltaLambda);
	  rotation.invert = forwardRotationLambda(-deltaLambda);
	  return rotation;
	}

	function rotationPhiGamma(deltaPhi, deltaGamma) {
	  var cosDeltaPhi = cos(deltaPhi),
	      sinDeltaPhi = sin(deltaPhi),
	      cosDeltaGamma = cos(deltaGamma),
	      sinDeltaGamma = sin(deltaGamma);

	  function rotation(lambda, phi) {
	    var cosPhi = cos(phi),
	        x = cos(lambda) * cosPhi,
	        y = sin(lambda) * cosPhi,
	        z = sin(phi),
	        k = z * cosDeltaPhi + x * sinDeltaPhi;
	    return [
	      atan2(y * cosDeltaGamma - k * sinDeltaGamma, x * cosDeltaPhi - z * sinDeltaPhi),
	      asin(k * cosDeltaGamma + y * sinDeltaGamma)
	    ];
	  }

	  rotation.invert = function(lambda, phi) {
	    var cosPhi = cos(phi),
	        x = cos(lambda) * cosPhi,
	        y = sin(lambda) * cosPhi,
	        z = sin(phi),
	        k = z * cosDeltaGamma - y * sinDeltaGamma;
	    return [
	      atan2(y * cosDeltaGamma + z * sinDeltaGamma, x * cosDeltaPhi + k * sinDeltaPhi),
	      asin(k * cosDeltaPhi - x * sinDeltaPhi)
	    ];
	  };

	  return rotation;
	}

	function rotation(rotate) {
	  rotate = rotateRadians(rotate[0] * radians, rotate[1] * radians, rotate.length > 2 ? rotate[2] * radians : 0);

	  function forward(coordinates) {
	    coordinates = rotate(coordinates[0] * radians, coordinates[1] * radians);
	    return coordinates[0] *= degrees, coordinates[1] *= degrees, coordinates;
	  }

	  forward.invert = function(coordinates) {
	    coordinates = rotate.invert(coordinates[0] * radians, coordinates[1] * radians);
	    return coordinates[0] *= degrees, coordinates[1] *= degrees, coordinates;
	  };

	  return forward;
	}

	// Generates a circle centered at [0Â°, 0Â°], with a given radius and precision.
	function circleStream(stream, radius, delta, direction, t0, t1) {
	  if (!delta) return;
	  var cosRadius = cos(radius),
	      sinRadius = sin(radius),
	      step = direction * delta;
	  if (t0 == null) {
	    t0 = radius + direction * tau;
	    t1 = radius - step / 2;
	  } else {
	    t0 = circleRadius(cosRadius, t0);
	    t1 = circleRadius(cosRadius, t1);
	    if (direction > 0 ? t0 < t1 : t0 > t1) t0 += direction * tau;
	  }
	  for (var point, t = t0; direction > 0 ? t > t1 : t < t1; t -= step) {
	    point = spherical([cosRadius, -sinRadius * cos(t), -sinRadius * sin(t)]);
	    stream.point(point[0], point[1]);
	  }
	}

	// Returns the signed angle of a cartesian point relative to [cosRadius, 0, 0].
	function circleRadius(cosRadius, point) {
	  point = cartesian(point), point[0] -= cosRadius;
	  cartesianNormalizeInPlace(point);
	  var radius = acos(-point[1]);
	  return ((-point[2] < 0 ? -radius : radius) + tau - epsilon) % tau;
	}

	function circle() {
	  var center = constant([0, 0]),
	      radius = constant(90),
	      precision = constant(6),
	      ring,
	      rotate,
	      stream = {point: point};

	  function point(x, y) {
	    ring.push(x = rotate(x, y));
	    x[0] *= degrees, x[1] *= degrees;
	  }

	  function circle() {
	    var c = center.apply(this, arguments),
	        r = radius.apply(this, arguments) * radians,
	        p = precision.apply(this, arguments) * radians;
	    ring = [];
	    rotate = rotateRadians(-c[0] * radians, -c[1] * radians, 0).invert;
	    circleStream(stream, r, p, 1);
	    c = {type: "Polygon", coordinates: [ring]};
	    ring = rotate = null;
	    return c;
	  }

	  circle.center = function(_) {
	    return arguments.length ? (center = typeof _ === "function" ? _ : constant([+_[0], +_[1]]), circle) : center;
	  };

	  circle.radius = function(_) {
	    return arguments.length ? (radius = typeof _ === "function" ? _ : constant(+_), circle) : radius;
	  };

	  circle.precision = function(_) {
	    return arguments.length ? (precision = typeof _ === "function" ? _ : constant(+_), circle) : precision;
	  };

	  return circle;
	}

	function clipBuffer() {
	  var lines = [],
	      line;
	  return {
	    point: function(x, y) {
	      line.push([x, y]);
	    },
	    lineStart: function() {
	      lines.push(line = []);
	    },
	    lineEnd: noop,
	    rejoin: function() {
	      if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));
	    },
	    result: function() {
	      var result = lines;
	      lines = [];
	      line = null;
	      return result;
	    }
	  };
	}

	function clipLine(a, b, x0, y0, x1, y1) {
	  var ax = a[0],
	      ay = a[1],
	      bx = b[0],
	      by = b[1],
	      t0 = 0,
	      t1 = 1,
	      dx = bx - ax,
	      dy = by - ay,
	      r;

	  r = x0 - ax;
	  if (!dx && r > 0) return;
	  r /= dx;
	  if (dx < 0) {
	    if (r < t0) return;
	    if (r < t1) t1 = r;
	  } else if (dx > 0) {
	    if (r > t1) return;
	    if (r > t0) t0 = r;
	  }

	  r = x1 - ax;
	  if (!dx && r < 0) return;
	  r /= dx;
	  if (dx < 0) {
	    if (r > t1) return;
	    if (r > t0) t0 = r;
	  } else if (dx > 0) {
	    if (r < t0) return;
	    if (r < t1) t1 = r;
	  }

	  r = y0 - ay;
	  if (!dy && r > 0) return;
	  r /= dy;
	  if (dy < 0) {
	    if (r < t0) return;
	    if (r < t1) t1 = r;
	  } else if (dy > 0) {
	    if (r > t1) return;
	    if (r > t0) t0 = r;
	  }

	  r = y1 - ay;
	  if (!dy && r < 0) return;
	  r /= dy;
	  if (dy < 0) {
	    if (r > t1) return;
	    if (r > t0) t0 = r;
	  } else if (dy > 0) {
	    if (r < t0) return;
	    if (r < t1) t1 = r;
	  }

	  if (t0 > 0) a[0] = ax + t0 * dx, a[1] = ay + t0 * dy;
	  if (t1 < 1) b[0] = ax + t1 * dx, b[1] = ay + t1 * dy;
	  return true;
	}

	function pointEqual(a, b) {
	  return abs(a[0] - b[0]) < epsilon && abs(a[1] - b[1]) < epsilon;
	}

	function Intersection(point, points, other, entry) {
	  this.x = point;
	  this.z = points;
	  this.o = other; // another intersection
	  this.e = entry; // is an entry?
	  this.v = false; // visited
	  this.n = this.p = null; // next & previous
	}

	// A generalized polygon clipping algorithm: given a polygon that has been cut
	// into its visible line segments, and rejoins the segments by interpolating
	// along the clip edge.
	function clipPolygon(segments, compareIntersection, startInside, interpolate, stream) {
	  var subject = [],
	      clip = [],
	      i,
	      n;

	  segments.forEach(function(segment) {
	    if ((n = segment.length - 1) <= 0) return;
	    var n, p0 = segment[0], p1 = segment[n], x;

	    // If the first and last points of a segment are coincident, then treat as a
	    // closed ring. TODO if all rings are closed, then the winding order of the
	    // exterior ring should be checked.
	    if (pointEqual(p0, p1)) {
	      stream.lineStart();
	      for (i = 0; i < n; ++i) stream.point((p0 = segment[i])[0], p0[1]);
	      stream.lineEnd();
	      return;
	    }

	    subject.push(x = new Intersection(p0, segment, null, true));
	    clip.push(x.o = new Intersection(p0, null, x, false));
	    subject.push(x = new Intersection(p1, segment, null, false));
	    clip.push(x.o = new Intersection(p1, null, x, true));
	  });

	  if (!subject.length) return;

	  clip.sort(compareIntersection);
	  link(subject);
	  link(clip);

	  for (i = 0, n = clip.length; i < n; ++i) {
	    clip[i].e = startInside = !startInside;
	  }

	  var start = subject[0],
	      points,
	      point;

	  while (1) {
	    // Find first unvisited intersection.
	    var current = start,
	        isSubject = true;
	    while (current.v) if ((current = current.n) === start) return;
	    points = current.z;
	    stream.lineStart();
	    do {
	      current.v = current.o.v = true;
	      if (current.e) {
	        if (isSubject) {
	          for (i = 0, n = points.length; i < n; ++i) stream.point((point = points[i])[0], point[1]);
	        } else {
	          interpolate(current.x, current.n.x, 1, stream);
	        }
	        current = current.n;
	      } else {
	        if (isSubject) {
	          points = current.p.z;
	          for (i = points.length - 1; i >= 0; --i) stream.point((point = points[i])[0], point[1]);
	        } else {
	          interpolate(current.x, current.p.x, -1, stream);
	        }
	        current = current.p;
	      }
	      current = current.o;
	      points = current.z;
	      isSubject = !isSubject;
	    } while (!current.v);
	    stream.lineEnd();
	  }
	}

	function link(array) {
	  if (!(n = array.length)) return;
	  var n,
	      i = 0,
	      a = array[0],
	      b;
	  while (++i < n) {
	    a.n = b = array[i];
	    b.p = a;
	    a = b;
	  }
	  a.n = b = array[0];
	  b.p = a;
	}

	var clipMax = 1e9;
	var clipMin = -clipMax;
	// TODO Use d3-polygonâs polygonContains here for the ring check?
	// TODO Eliminate duplicate buffering in clipBuffer and polygon.push?

	function clipExtent(x0, y0, x1, y1) {

	  function visible(x, y) {
	    return x0 <= x && x <= x1 && y0 <= y && y <= y1;
	  }

	  function interpolate(from, to, direction, stream) {
	    var a = 0, a1 = 0;
	    if (from == null
	        || (a = corner(from, direction)) !== (a1 = corner(to, direction))
	        || comparePoint(from, to) < 0 ^ direction > 0) {
	      do stream.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);
	      while ((a = (a + direction + 4) % 4) !== a1);
	    } else {
	      stream.point(to[0], to[1]);
	    }
	  }

	  function corner(p, direction) {
	    return abs(p[0] - x0) < epsilon ? direction > 0 ? 0 : 3
	        : abs(p[0] - x1) < epsilon ? direction > 0 ? 2 : 1
	        : abs(p[1] - y0) < epsilon ? direction > 0 ? 1 : 0
	        : direction > 0 ? 3 : 2; // abs(p[1] - y1) < epsilon
	  }

	  function compareIntersection(a, b) {
	    return comparePoint(a.x, b.x);
	  }

	  function comparePoint(a, b) {
	    var ca = corner(a, 1),
	        cb = corner(b, 1);
	    return ca !== cb ? ca - cb
	        : ca === 0 ? b[1] - a[1]
	        : ca === 1 ? a[0] - b[0]
	        : ca === 2 ? a[1] - b[1]
	        : b[0] - a[0];
	  }

	  return function(stream) {
	    var activeStream = stream,
	        bufferStream = clipBuffer(),
	        segments,
	        polygon,
	        ring,
	        x__, y__, v__, // first point
	        x_, y_, v_, // previous point
	        first,
	        clean;

	    var clipStream = {
	      point: point,
	      lineStart: lineStart,
	      lineEnd: lineEnd,
	      polygonStart: polygonStart,
	      polygonEnd: polygonEnd
	    };

	    function point(x, y) {
	      if (visible(x, y)) activeStream.point(x, y);
	    }

	    function polygonInside() {
	      var winding = 0;

	      for (var i = 0, n = polygon.length; i < n; ++i) {
	        for (var ring = polygon[i], j = 1, m = ring.length, point = ring[0], a0, a1, b0 = point[0], b1 = point[1]; j < m; ++j) {
	          a0 = b0, a1 = b1, point = ring[j], b0 = point[0], b1 = point[1];
	          if (a1 <= y1) { if (b1 > y1 && (b0 - a0) * (y1 - a1) > (b1 - a1) * (x0 - a0)) ++winding; }
	          else { if (b1 <= y1 && (b0 - a0) * (y1 - a1) < (b1 - a1) * (x0 - a0)) --winding; }
	        }
	      }

	      return winding;
	    }

	    // Buffer geometry within a polygon and then clip it en masse.
	    function polygonStart() {
	      activeStream = bufferStream, segments = [], polygon = [], clean = true;
	    }

	    function polygonEnd() {
	      var startInside = polygonInside(),
	          cleanInside = clean && startInside,
	          visible = (segments = d3Array.merge(segments)).length;
	      if (cleanInside || visible) {
	        stream.polygonStart();
	        if (cleanInside) {
	          stream.lineStart();
	          interpolate(null, null, 1, stream);
	          stream.lineEnd();
	        }
	        if (visible) {
	          clipPolygon(segments, compareIntersection, startInside, interpolate, stream);
	        }
	        stream.polygonEnd();
	      }
	      activeStream = stream, segments = polygon = ring = null;
	    }

	    function lineStart() {
	      clipStream.point = linePoint;
	      if (polygon) polygon.push(ring = []);
	      first = true;
	      v_ = false;
	      x_ = y_ = NaN;
	    }

	    // TODO rather than special-case polygons, simply handle them separately.
	    // Ideally, coincident intersection points should be jittered to avoid
	    // clipping issues.
	    function lineEnd() {
	      if (segments) {
	        linePoint(x__, y__);
	        if (v__ && v_) bufferStream.rejoin();
	        segments.push(bufferStream.result());
	      }
	      clipStream.point = point;
	      if (v_) activeStream.lineEnd();
	    }

	    function linePoint(x, y) {
	      var v = visible(x, y);
	      if (polygon) ring.push([x, y]);
	      if (first) {
	        x__ = x, y__ = y, v__ = v;
	        first = false;
	        if (v) {
	          activeStream.lineStart();
	          activeStream.point(x, y);
	        }
	      } else {
	        if (v && v_) activeStream.point(x, y);
	        else {
	          var a = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))],
	              b = [x = Math.max(clipMin, Math.min(clipMax, x)), y = Math.max(clipMin, Math.min(clipMax, y))];
	          if (clipLine(a, b, x0, y0, x1, y1)) {
	            if (!v_) {
	              activeStream.lineStart();
	              activeStream.point(a[0], a[1]);
	            }
	            activeStream.point(b[0], b[1]);
	            if (!v) activeStream.lineEnd();
	            clean = false;
	          } else if (v) {
	            activeStream.lineStart();
	            activeStream.point(x, y);
	            clean = false;
	          }
	        }
	      }
	      x_ = x, y_ = y, v_ = v;
	    }

	    return clipStream;
	  };
	}

	function extent() {
	  var x0 = 0,
	      y0 = 0,
	      x1 = 960,
	      y1 = 500,
	      cache,
	      cacheStream,
	      clip;

	  return clip = {
	    stream: function(stream) {
	      return cache && cacheStream === stream ? cache : cache = clipExtent(x0, y0, x1, y1)(cacheStream = stream);
	    },
	    extent: function(_) {
	      return arguments.length ? (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1], cache = cacheStream = null, clip) : [[x0, y0], [x1, y1]];
	    }
	  };
	}

	var lengthSum = adder();
	var lambda0$2;
	var sinPhi0$1;
	var cosPhi0$1;
	var lengthStream = {
	  sphere: noop,
	  point: noop,
	  lineStart: lengthLineStart,
	  lineEnd: noop,
	  polygonStart: noop,
	  polygonEnd: noop
	};

	function lengthLineStart() {
	  lengthStream.point = lengthPointFirst;
	  lengthStream.lineEnd = lengthLineEnd;
	}

	function lengthLineEnd() {
	  lengthStream.point = lengthStream.lineEnd = noop;
	}

	function lengthPointFirst(lambda, phi) {
	  lambda *= radians, phi *= radians;
	  lambda0$2 = lambda, sinPhi0$1 = sin(phi), cosPhi0$1 = cos(phi);
	  lengthStream.point = lengthPoint;
	}

	function lengthPoint(lambda, phi) {
	  lambda *= radians, phi *= radians;
	  var sinPhi = sin(phi),
	      cosPhi = cos(phi),
	      delta = abs(lambda - lambda0$2),
	      cosDelta = cos(delta),
	      sinDelta = sin(delta),
	      x = cosPhi * sinDelta,
	      y = cosPhi0$1 * sinPhi - sinPhi0$1 * cosPhi * cosDelta,
	      z = sinPhi0$1 * sinPhi + cosPhi0$1 * cosPhi * cosDelta;
	  lengthSum.add(atan2(sqrt(x * x + y * y), z));
	  lambda0$2 = lambda, sinPhi0$1 = sinPhi, cosPhi0$1 = cosPhi;
	}

	function length(object) {
	  lengthSum.reset();
	  geoStream(object, lengthStream);
	  return +lengthSum;
	}

	var coordinates = [null, null];
	var object = {type: "LineString", coordinates: coordinates};
	function distance(a, b) {
	  coordinates[0] = a;
	  coordinates[1] = b;
	  return length(object);
	}

	function graticuleX(y0, y1, dy) {
	  var y = d3Array.range(y0, y1 - epsilon, dy).concat(y1);
	  return function(x) { return y.map(function(y) { return [x, y]; }); };
	}

	function graticuleY(x0, x1, dx) {
	  var x = d3Array.range(x0, x1 - epsilon, dx).concat(x1);
	  return function(y) { return x.map(function(x) { return [x, y]; }); };
	}

	function graticule() {
	  var x1, x0, X1, X0,
	      y1, y0, Y1, Y0,
	      dx = 10, dy = dx, DX = 90, DY = 360,
	      x, y, X, Y,
	      precision = 2.5;

	  function graticule() {
	    return {type: "MultiLineString", coordinates: lines()};
	  }

	  function lines() {
	    return d3Array.range(ceil(X0 / DX) * DX, X1, DX).map(X)
	        .concat(d3Array.range(ceil(Y0 / DY) * DY, Y1, DY).map(Y))
	        .concat(d3Array.range(ceil(x0 / dx) * dx, x1, dx).filter(function(x) { return abs(x % DX) > epsilon; }).map(x))
	        .concat(d3Array.range(ceil(y0 / dy) * dy, y1, dy).filter(function(y) { return abs(y % DY) > epsilon; }).map(y));
	  }

	  graticule.lines = function() {
	    return lines().map(function(coordinates) { return {type: "LineString", coordinates: coordinates}; });
	  };

	  graticule.outline = function() {
	    return {
	      type: "Polygon",
	      coordinates: [
	        X(X0).concat(
	        Y(Y1).slice(1),
	        X(X1).reverse().slice(1),
	        Y(Y0).reverse().slice(1))
	      ]
	    };
	  };

	  graticule.extent = function(_) {
	    if (!arguments.length) return graticule.extentMinor();
	    return graticule.extentMajor(_).extentMinor(_);
	  };

	  graticule.extentMajor = function(_) {
	    if (!arguments.length) return [[X0, Y0], [X1, Y1]];
	    X0 = +_[0][0], X1 = +_[1][0];
	    Y0 = +_[0][1], Y1 = +_[1][1];
	    if (X0 > X1) _ = X0, X0 = X1, X1 = _;
	    if (Y0 > Y1) _ = Y0, Y0 = Y1, Y1 = _;
	    return graticule.precision(precision);
	  };

	  graticule.extentMinor = function(_) {
	    if (!arguments.length) return [[x0, y0], [x1, y1]];
	    x0 = +_[0][0], x1 = +_[1][0];
	    y0 = +_[0][1], y1 = +_[1][1];
	    if (x0 > x1) _ = x0, x0 = x1, x1 = _;
	    if (y0 > y1) _ = y0, y0 = y1, y1 = _;
	    return graticule.precision(precision);
	  };

	  graticule.step = function(_) {
	    if (!arguments.length) return graticule.stepMinor();
	    return graticule.stepMajor(_).stepMinor(_);
	  };

	  graticule.stepMajor = function(_) {
	    if (!arguments.length) return [DX, DY];
	    DX = +_[0], DY = +_[1];
	    return graticule;
	  };

	  graticule.stepMinor = function(_) {
	    if (!arguments.length) return [dx, dy];
	    dx = +_[0], dy = +_[1];
	    return graticule;
	  };

	  graticule.precision = function(_) {
	    if (!arguments.length) return precision;
	    precision = +_;
	    x = graticuleX(y0, y1, 90);
	    y = graticuleY(x0, x1, precision);
	    X = graticuleX(Y0, Y1, 90);
	    Y = graticuleY(X0, X1, precision);
	    return graticule;
	  };

	  return graticule
	      .extentMajor([[-180, -90 + epsilon], [180, 90 - epsilon]])
	      .extentMinor([[-180, -80 - epsilon], [180, 80 + epsilon]]);
	}

	function interpolate(a, b) {
	  var x0 = a[0] * radians,
	      y0 = a[1] * radians,
	      x1 = b[0] * radians,
	      y1 = b[1] * radians,
	      cy0 = cos(y0),
	      sy0 = sin(y0),
	      cy1 = cos(y1),
	      sy1 = sin(y1),
	      kx0 = cy0 * cos(x0),
	      ky0 = cy0 * sin(x0),
	      kx1 = cy1 * cos(x1),
	      ky1 = cy1 * sin(x1),
	      d = 2 * asin(sqrt(haversin(y1 - y0) + cy0 * cy1 * haversin(x1 - x0))),
	      k = sin(d);

	  var interpolate = d ? function(t) {
	    var B = sin(t *= d) / k,
	        A = sin(d - t) / k,
	        x = A * kx0 + B * kx1,
	        y = A * ky0 + B * ky1,
	        z = A * sy0 + B * sy1;
	    return [
	      atan2(y, x) * degrees,
	      atan2(z, sqrt(x * x + y * y)) * degrees
	    ];
	  } : function() {
	    return [x0 * degrees, y0 * degrees];
	  };

	  interpolate.distance = d;

	  return interpolate;
	}

	function identity(x) {
	  return x;
	}

	var areaSum$1 = adder();
	var areaRingSum$1 = adder();
	var x00;
	var y00;
	var x0$1;
	var y0$1;
	var areaStream$1 = {
	  point: noop,
	  lineStart: noop,
	  lineEnd: noop,
	  polygonStart: function() {
	    areaStream$1.lineStart = areaRingStart$1;
	    areaStream$1.lineEnd = areaRingEnd$1;
	  },
	  polygonEnd: function() {
	    areaStream$1.lineStart = areaStream$1.lineEnd = areaStream$1.point = noop;
	    areaSum$1.add(abs(areaRingSum$1));
	    areaRingSum$1.reset();
	  },
	  result: function() {
	    var area = areaSum$1 / 2;
	    areaSum$1.reset();
	    return area;
	  }
	};

	function areaRingStart$1() {
	  areaStream$1.point = areaPointFirst$1;
	}

	function areaPointFirst$1(x, y) {
	  areaStream$1.point = areaPoint$1;
	  x00 = x0$1 = x, y00 = y0$1 = y;
	}

	function areaPoint$1(x, y) {
	  areaRingSum$1.add(y0$1 * x - x0$1 * y);
	  x0$1 = x, y0$1 = y;
	}

	function areaRingEnd$1() {
	  areaPoint$1(x00, y00);
	}

	var x0$2 = Infinity;
	var y0$2 = x0$2;
	var x1 = -x0$2;
	var y1 = x1;
	var boundsStream$1 = {
	  point: boundsPoint$1,
	  lineStart: noop,
	  lineEnd: noop,
	  polygonStart: noop,
	  polygonEnd: noop,
	  result: function() {
	    var bounds = [[x0$2, y0$2], [x1, y1]];
	    x1 = y1 = -(y0$2 = x0$2 = Infinity);
	    return bounds;
	  }
	};

	function boundsPoint$1(x, y) {
	  if (x < x0$2) x0$2 = x;
	  if (x > x1) x1 = x;
	  if (y < y0$2) y0$2 = y;
	  if (y > y1) y1 = y;
	}

	var X0$1 = 0;
	var Y0$1 = 0;
	var Z0$1 = 0;
	var X1$1 = 0;
	var Y1$1 = 0;
	var Z1$1 = 0;
	var X2$1 = 0;
	var Y2$1 = 0;
	var Z2$1 = 0;
	var x00$1;
	var y00$1;
	var x0$3;
	var y0$3;
	var centroidStream$1 = {
	  point: centroidPoint$1,
	  lineStart: centroidLineStart$1,
	  lineEnd: centroidLineEnd$1,
	  polygonStart: function() {
	    centroidStream$1.lineStart = centroidRingStart$1;
	    centroidStream$1.lineEnd = centroidRingEnd$1;
	  },
	  polygonEnd: function() {
	    centroidStream$1.point = centroidPoint$1;
	    centroidStream$1.lineStart = centroidLineStart$1;
	    centroidStream$1.lineEnd = centroidLineEnd$1;
	  },
	  result: function() {
	    var centroid = Z2$1 ? [X2$1 / Z2$1, Y2$1 / Z2$1]
	        : Z1$1 ? [X1$1 / Z1$1, Y1$1 / Z1$1]
	        : Z0$1 ? [X0$1 / Z0$1, Y0$1 / Z0$1]
	        : [NaN, NaN];
	    X0$1 = Y0$1 = Z0$1 =
	    X1$1 = Y1$1 = Z1$1 =
	    X2$1 = Y2$1 = Z2$1 = 0;
	    return centroid;
	  }
	};

	function centroidPoint$1(x, y) {
	  X0$1 += x;
	  Y0$1 += y;
	  ++Z0$1;
	}

	function centroidLineStart$1() {
	  centroidStream$1.point = centroidPointFirstLine;
	}

	function centroidPointFirstLine(x, y) {
	  centroidStream$1.point = centroidPointLine;
	  centroidPoint$1(x0$3 = x, y0$3 = y);
	}

	function centroidPointLine(x, y) {
	  var dx = x - x0$3, dy = y - y0$3, z = sqrt(dx * dx + dy * dy);
	  X1$1 += z * (x0$3 + x) / 2;
	  Y1$1 += z * (y0$3 + y) / 2;
	  Z1$1 += z;
	  centroidPoint$1(x0$3 = x, y0$3 = y);
	}

	function centroidLineEnd$1() {
	  centroidStream$1.point = centroidPoint$1;
	}

	function centroidRingStart$1() {
	  centroidStream$1.point = centroidPointFirstRing;
	}

	function centroidRingEnd$1() {
	  centroidPointRing(x00$1, y00$1);
	}

	function centroidPointFirstRing(x, y) {
	  centroidStream$1.point = centroidPointRing;
	  centroidPoint$1(x00$1 = x0$3 = x, y00$1 = y0$3 = y);
	}

	function centroidPointRing(x, y) {
	  var dx = x - x0$3,
	      dy = y - y0$3,
	      z = sqrt(dx * dx + dy * dy);

	  X1$1 += z * (x0$3 + x) / 2;
	  Y1$1 += z * (y0$3 + y) / 2;
	  Z1$1 += z;

	  z = y0$3 * x - x0$3 * y;
	  X2$1 += z * (x0$3 + x);
	  Y2$1 += z * (y0$3 + y);
	  Z2$1 += z * 3;
	  centroidPoint$1(x0$3 = x, y0$3 = y);
	}

	function PathContext(context) {
	  this._context = context;
	}

	PathContext.prototype = {
	  _radius: 4.5,
	  pointRadius: function(_) {
	    return this._radius = _, this;
	  },
	  polygonStart: function() {
	    this._line = 0;
	  },
	  polygonEnd: function() {
	    this._line = NaN;
	  },
	  lineStart: function() {
	    this._point = 0;
	  },
	  lineEnd: function() {
	    if (this._line === 0) this._context.closePath();
	    this._point = NaN;
	  },
	  point: function(x, y) {
	    switch (this._point) {
	      case 0: {
	        this._context.moveTo(x, y);
	        this._point = 1;
	        break;
	      }
	      case 1: {
	        this._context.lineTo(x, y);
	        break;
	      }
	      default: {
	        this._context.moveTo(x + this._radius, y);
	        this._context.arc(x, y, this._radius, 0, tau);
	        break;
	      }
	    }
	  },
	  result: noop
	};

	function PathString() {
	  this._string = [];
	}

	PathString.prototype = {
	  _circle: circle$1(4.5),
	  pointRadius: function(_) {
	    return this._circle = circle$1(_), this;
	  },
	  polygonStart: function() {
	    this._line = 0;
	  },
	  polygonEnd: function() {
	    this._line = NaN;
	  },
	  lineStart: function() {
	    this._point = 0;
	  },
	  lineEnd: function() {
	    if (this._line === 0) this._string.push("Z");
	    this._point = NaN;
	  },
	  point: function(x, y) {
	    switch (this._point) {
	      case 0: {
	        this._string.push("M", x, ",", y);
	        this._point = 1;
	        break;
	      }
	      case 1: {
	        this._string.push("L", x, ",", y);
	        break;
	      }
	      default: {
	        this._string.push("M", x, ",", y, this._circle);
	        break;
	      }
	    }
	  },
	  result: function() {
	    if (this._string.length) {
	      var result = this._string.join("");
	      this._string = [];
	      return result;
	    }
	  }
	};

	function circle$1(radius) {
	  return "m0," + radius
	      + "a" + radius + "," + radius + " 0 1,1 0," + -2 * radius
	      + "a" + radius + "," + radius + " 0 1,1 0," + 2 * radius
	      + "z";
	}

	function index() {
	  var pointRadius = 4.5,
	      projection,
	      projectionStream,
	      context,
	      contextStream;

	  function path(object) {
	    if (object) {
	      if (typeof pointRadius === "function") contextStream.pointRadius(+pointRadius.apply(this, arguments));
	      geoStream(object, projectionStream(contextStream));
	    }
	    return contextStream.result();
	  }

	  path.area = function(object) {
	    geoStream(object, projectionStream(areaStream$1));
	    return areaStream$1.result();
	  };

	  path.bounds = function(object) {
	    geoStream(object, projectionStream(boundsStream$1));
	    return boundsStream$1.result();
	  };

	  path.centroid = function(object) {
	    geoStream(object, projectionStream(centroidStream$1));
	    return centroidStream$1.result();
	  };

	  path.projection = function(_) {
	    return arguments.length ? (projectionStream = (projection = _) == null ? identity : _.stream, path) : projection;
	  };

	  path.context = function(_) {
	    if (!arguments.length) return context;
	    contextStream = (context = _) == null ? new PathString : new PathContext(_);
	    if (typeof pointRadius !== "function") contextStream.pointRadius(pointRadius);
	    return path;
	  };

	  path.pointRadius = function(_) {
	    if (!arguments.length) return pointRadius;
	    pointRadius = typeof _ === "function" ? _ : (contextStream.pointRadius(+_), +_);
	    return path;
	  };

	  return path.projection(null).context(null);
	}

	var sum = adder();

	function polygonContains(polygon, point) {
	  var lambda = point[0],
	      phi = point[1],
	      normal = [sin(lambda), -cos(lambda), 0],
	      angle = 0,
	      winding = 0;

	  sum.reset();

	  for (var i = 0, n = polygon.length; i < n; ++i) {
	    if (!(m = (ring = polygon[i]).length)) continue;
	    var ring,
	        m,
	        point0 = ring[m - 1],
	        lambda0 = point0[0],
	        phi0 = point0[1] / 2 + quarterPi,
	        sinPhi0 = sin(phi0),
	        cosPhi0 = cos(phi0);

	    for (var j = 0; j < m; ++j, lambda0 = lambda1, sinPhi0 = sinPhi1, cosPhi0 = cosPhi1, point0 = point1) {
	      var point1 = ring[j],
	          lambda1 = point1[0],
	          phi1 = point1[1] / 2 + quarterPi,
	          sinPhi1 = sin(phi1),
	          cosPhi1 = cos(phi1),
	          delta = lambda1 - lambda0,
	          sign = delta >= 0 ? 1 : -1,
	          absDelta = sign * delta,
	          antimeridian = absDelta > pi,
	          k = sinPhi0 * sinPhi1;

	      sum.add(atan2(k * sign * sin(absDelta), cosPhi0 * cosPhi1 + k * cos(absDelta)));
	      angle += antimeridian ? delta + sign * tau : delta;

	      // Are the longitudes either side of the pointâs meridian (lambda),
	      // and are the latitudes smaller than the parallel (phi)?
	      if (antimeridian ^ lambda0 >= lambda ^ lambda1 >= lambda) {
	        var arc = cartesianCross(cartesian(point0), cartesian(point1));
	        cartesianNormalizeInPlace(arc);
	        var intersection = cartesianCross(normal, arc);
	        cartesianNormalizeInPlace(intersection);
	        var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * asin(intersection[2]);
	        if (phi > phiArc || phi === phiArc && (arc[0] || arc[1])) {
	          winding += antimeridian ^ delta >= 0 ? 1 : -1;
	        }
	      }
	    }
	  }

	  // First, determine whether the South pole is inside or outside:
	  //
	  // It is inside if:
	  // * the polygon winds around it in a clockwise direction.
	  // * the polygon does not (cumulatively) wind around it, but has a negative
	  //   (counter-clockwise) area.
	  //
	  // Second, count the (signed) number of times a segment crosses a lambda
	  // from the point to the South pole.  If it is zero, then the point is the
	  // same side as the South pole.

	  return (angle < -epsilon || angle < epsilon && sum < -epsilon) ^ (winding & 1);
	}

	function clip(pointVisible, clipLine, interpolate, start) {
	  return function(rotate, sink) {
	    var line = clipLine(sink),
	        rotatedStart = rotate.invert(start[0], start[1]),
	        ringBuffer = clipBuffer(),
	        ringSink = clipLine(ringBuffer),
	        polygonStarted = false,
	        polygon,
	        segments,
	        ring;

	    var clip = {
	      point: point,
	      lineStart: lineStart,
	      lineEnd: lineEnd,
	      polygonStart: function() {
	        clip.point = pointRing;
	        clip.lineStart = ringStart;
	        clip.lineEnd = ringEnd;
	        segments = [];
	        polygon = [];
	      },
	      polygonEnd: function() {
	        clip.point = point;
	        clip.lineStart = lineStart;
	        clip.lineEnd = lineEnd;
	        segments = d3Array.merge(segments);
	        var startInside = polygonContains(polygon, rotatedStart);
	        if (segments.length) {
	          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
	          clipPolygon(segments, compareIntersection, startInside, interpolate, sink);
	        } else if (startInside) {
	          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
	          sink.lineStart();
	          interpolate(null, null, 1, sink);
	          sink.lineEnd();
	        }
	        if (polygonStarted) sink.polygonEnd(), polygonStarted = false;
	        segments = polygon = null;
	      },
	      sphere: function() {
	        sink.polygonStart();
	        sink.lineStart();
	        interpolate(null, null, 1, sink);
	        sink.lineEnd();
	        sink.polygonEnd();
	      }
	    };

	    function point(lambda, phi) {
	      var point = rotate(lambda, phi);
	      if (pointVisible(lambda = point[0], phi = point[1])) sink.point(lambda, phi);
	    }

	    function pointLine(lambda, phi) {
	      var point = rotate(lambda, phi);
	      line.point(point[0], point[1]);
	    }

	    function lineStart() {
	      clip.point = pointLine;
	      line.lineStart();
	    }

	    function lineEnd() {
	      clip.point = point;
	      line.lineEnd();
	    }

	    function pointRing(lambda, phi) {
	      ring.push([lambda, phi]);
	      var point = rotate(lambda, phi);
	      ringSink.point(point[0], point[1]);
	    }

	    function ringStart() {
	      ringSink.lineStart();
	      ring = [];
	    }

	    function ringEnd() {
	      pointRing(ring[0][0], ring[0][1]);
	      ringSink.lineEnd();

	      var clean = ringSink.clean(),
	          ringSegments = ringBuffer.result(),
	          i, n = ringSegments.length, m,
	          segment,
	          point;

	      ring.pop();
	      polygon.push(ring);
	      ring = null;

	      if (!n) return;

	      // No intersections.
	      if (clean & 1) {
	        segment = ringSegments[0];
	        if ((m = segment.length - 1) > 0) {
	          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
	          sink.lineStart();
	          for (i = 0; i < m; ++i) sink.point((point = segment[i])[0], point[1]);
	          sink.lineEnd();
	        }
	        return;
	      }

	      // Rejoin connected segments.
	      // TODO reuse ringBuffer.rejoin()?
	      if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));

	      segments.push(ringSegments.filter(validSegment));
	    }

	    return clip;
	  };
	}

	function validSegment(segment) {
	  return segment.length > 1;
	}

	// Intersections are sorted along the clip edge. For both antimeridian cutting
	// and circle clipping, the same comparison is used.
	function compareIntersection(a, b) {
	  return ((a = a.x)[0] < 0 ? a[1] - halfPi - epsilon : halfPi - a[1])
	       - ((b = b.x)[0] < 0 ? b[1] - halfPi - epsilon : halfPi - b[1]);
	}

	var clipAntimeridian = clip(
	  function() { return true; },
	  clipAntimeridianLine,
	  clipAntimeridianInterpolate,
	  [-pi, -halfPi]
	);

	// Takes a line and cuts into visible segments. Return values: 0 - there were
	// intersections or the line was empty; 1 - no intersections; 2 - there were
	// intersections, and the first and last segments should be rejoined.
	function clipAntimeridianLine(stream) {
	  var lambda0 = NaN,
	      phi0 = NaN,
	      sign0 = NaN,
	      clean; // no intersections

	  return {
	    lineStart: function() {
	      stream.lineStart();
	      clean = 1;
	    },
	    point: function(lambda1, phi1) {
	      var sign1 = lambda1 > 0 ? pi : -pi,
	          delta = abs(lambda1 - lambda0);
	      if (abs(delta - pi) < epsilon) { // line crosses a pole
	        stream.point(lambda0, phi0 = (phi0 + phi1) / 2 > 0 ? halfPi : -halfPi);
	        stream.point(sign0, phi0);
	        stream.lineEnd();
	        stream.lineStart();
	        stream.point(sign1, phi0);
	        stream.point(lambda1, phi0);
	        clean = 0;
	      } else if (sign0 !== sign1 && delta >= pi) { // line crosses antimeridian
	        if (abs(lambda0 - sign0) < epsilon) lambda0 -= sign0 * epsilon; // handle degeneracies
	        if (abs(lambda1 - sign1) < epsilon) lambda1 -= sign1 * epsilon;
	        phi0 = clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1);
	        stream.point(sign0, phi0);
	        stream.lineEnd();
	        stream.lineStart();
	        stream.point(sign1, phi0);
	        clean = 0;
	      }
	      stream.point(lambda0 = lambda1, phi0 = phi1);
	      sign0 = sign1;
	    },
	    lineEnd: function() {
	      stream.lineEnd();
	      lambda0 = phi0 = NaN;
	    },
	    clean: function() {
	      return 2 - clean; // if intersections, rejoin first and last segments
	    }
	  };
	}

	function clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1) {
	  var cosPhi0,
	      cosPhi1,
	      sinLambda0Lambda1 = sin(lambda0 - lambda1);
	  return abs(sinLambda0Lambda1) > epsilon
	      ? atan((sin(phi0) * (cosPhi1 = cos(phi1)) * sin(lambda1)
	          - sin(phi1) * (cosPhi0 = cos(phi0)) * sin(lambda0))
	          / (cosPhi0 * cosPhi1 * sinLambda0Lambda1))
	      : (phi0 + phi1) / 2;
	}

	function clipAntimeridianInterpolate(from, to, direction, stream) {
	  var phi;
	  if (from == null) {
	    phi = direction * halfPi;
	    stream.point(-pi, phi);
	    stream.point(0, phi);
	    stream.point(pi, phi);
	    stream.point(pi, 0);
	    stream.point(pi, -phi);
	    stream.point(0, -phi);
	    stream.point(-pi, -phi);
	    stream.point(-pi, 0);
	    stream.point(-pi, phi);
	  } else if (abs(from[0] - to[0]) > epsilon) {
	    var lambda = from[0] < to[0] ? pi : -pi;
	    phi = direction * lambda / 2;
	    stream.point(-lambda, phi);
	    stream.point(0, phi);
	    stream.point(lambda, phi);
	  } else {
	    stream.point(to[0], to[1]);
	  }
	}

	function clipCircle(radius, delta) {
	  var cr = cos(radius),
	      smallRadius = cr > 0,
	      notHemisphere = abs(cr) > epsilon; // TODO optimise for this common case

	  function interpolate(from, to, direction, stream) {
	    circleStream(stream, radius, delta, direction, from, to);
	  }

	  function visible(lambda, phi) {
	    return cos(lambda) * cos(phi) > cr;
	  }

	  // Takes a line and cuts into visible segments. Return values used for polygon
	  // clipping: 0 - there were intersections or the line was empty; 1 - no
	  // intersections 2 - there were intersections, and the first and last segments
	  // should be rejoined.
	  function clipLine(stream) {
	    var point0, // previous point
	        c0, // code for previous point
	        v0, // visibility of previous point
	        v00, // visibility of first point
	        clean; // no intersections
	    return {
	      lineStart: function() {
	        v00 = v0 = false;
	        clean = 1;
	      },
	      point: function(lambda, phi) {
	        var point1 = [lambda, phi],
	            point2,
	            v = visible(lambda, phi),
	            c = smallRadius
	              ? v ? 0 : code(lambda, phi)
	              : v ? code(lambda + (lambda < 0 ? pi : -pi), phi) : 0;
	        if (!point0 && (v00 = v0 = v)) stream.lineStart();
	        // Handle degeneracies.
	        // TODO ignore if not clipping polygons.
	        if (v !== v0) {
	          point2 = intersect(point0, point1);
	          if (pointEqual(point0, point2) || pointEqual(point1, point2)) {
	            point1[0] += epsilon;
	            point1[1] += epsilon;
	            v = visible(point1[0], point1[1]);
	          }
	        }
	        if (v !== v0) {
	          clean = 0;
	          if (v) {
	            // outside going in
	            stream.lineStart();
	            point2 = intersect(point1, point0);
	            stream.point(point2[0], point2[1]);
	          } else {
	            // inside going out
	            point2 = intersect(point0, point1);
	            stream.point(point2[0], point2[1]);
	            stream.lineEnd();
	          }
	          point0 = point2;
	        } else if (notHemisphere && point0 && smallRadius ^ v) {
	          var t;
	          // If the codes for two points are different, or are both zero,
	          // and there this segment intersects with the small circle.
	          if (!(c & c0) && (t = intersect(point1, point0, true))) {
	            clean = 0;
	            if (smallRadius) {
	              stream.lineStart();
	              stream.point(t[0][0], t[0][1]);
	              stream.point(t[1][0], t[1][1]);
	              stream.lineEnd();
	            } else {
	              stream.point(t[1][0], t[1][1]);
	              stream.lineEnd();
	              stream.lineStart();
	              stream.point(t[0][0], t[0][1]);
	            }
	          }
	        }
	        if (v && (!point0 || !pointEqual(point0, point1))) {
	          stream.point(point1[0], point1[1]);
	        }
	        point0 = point1, v0 = v, c0 = c;
	      },
	      lineEnd: function() {
	        if (v0) stream.lineEnd();
	        point0 = null;
	      },
	      // Rejoin first and last segments if there were intersections and the first
	      // and last points were visible.
	      clean: function() {
	        return clean | ((v00 && v0) << 1);
	      }
	    };
	  }

	  // Intersects the great circle between a and b with the clip circle.
	  function intersect(a, b, two) {
	    var pa = cartesian(a),
	        pb = cartesian(b);

	    // We have two planes, n1.p = d1 and n2.p = d2.
	    // Find intersection line p(t) = c1 n1 + c2 n2 + t (n1 â¨¯ n2).
	    var n1 = [1, 0, 0], // normal
	        n2 = cartesianCross(pa, pb),
	        n2n2 = cartesianDot(n2, n2),
	        n1n2 = n2[0], // cartesianDot(n1, n2),
	        determinant = n2n2 - n1n2 * n1n2;

	    // Two polar points.
	    if (!determinant) return !two && a;

	    var c1 =  cr * n2n2 / determinant,
	        c2 = -cr * n1n2 / determinant,
	        n1xn2 = cartesianCross(n1, n2),
	        A = cartesianScale(n1, c1),
	        B = cartesianScale(n2, c2);
	    cartesianAddInPlace(A, B);

	    // Solve |p(t)|^2 = 1.
	    var u = n1xn2,
	        w = cartesianDot(A, u),
	        uu = cartesianDot(u, u),
	        t2 = w * w - uu * (cartesianDot(A, A) - 1);

	    if (t2 < 0) return;

	    var t = sqrt(t2),
	        q = cartesianScale(u, (-w - t) / uu);
	    cartesianAddInPlace(q, A);
	    q = spherical(q);

	    if (!two) return q;

	    // Two intersection points.
	    var lambda0 = a[0],
	        lambda1 = b[0],
	        phi0 = a[1],
	        phi1 = b[1],
	        z;

	    if (lambda1 < lambda0) z = lambda0, lambda0 = lambda1, lambda1 = z;

	    var delta = lambda1 - lambda0,
	        polar = abs(delta - pi) < epsilon,
	        meridian = polar || delta < epsilon;

	    if (!polar && phi1 < phi0) z = phi0, phi0 = phi1, phi1 = z;

	    // Check that the first point is between a and b.
	    if (meridian
	        ? polar
	          ? phi0 + phi1 > 0 ^ q[1] < (abs(q[0] - lambda0) < epsilon ? phi0 : phi1)
	          : phi0 <= q[1] && q[1] <= phi1
	        : delta > pi ^ (lambda0 <= q[0] && q[0] <= lambda1)) {
	      var q1 = cartesianScale(u, (-w + t) / uu);
	      cartesianAddInPlace(q1, A);
	      return [q, spherical(q1)];
	    }
	  }

	  // Generates a 4-bit vector representing the location of a point relative to
	  // the small circle's bounding box.
	  function code(lambda, phi) {
	    var r = smallRadius ? radius : pi - radius,
	        code = 0;
	    if (lambda < -r) code |= 1; // left
	    else if (lambda > r) code |= 2; // right
	    if (phi < -r) code |= 4; // below
	    else if (phi > r) code |= 8; // above
	    return code;
	  }

	  return clip(visible, clipLine, interpolate, smallRadius ? [0, -radius] : [-pi, radius - pi]);
	}

	function transform(prototype) {
	  return {
	    stream: transform$1(prototype)
	  };
	}

	function transform$1(prototype) {
	  function T() {}
	  var p = T.prototype = Object.create(Transform.prototype);
	  for (var k in prototype) p[k] = prototype[k];
	  return function(stream) {
	    var t = new T;
	    t.stream = stream;
	    return t;
	  };
	}

	function Transform() {}

	Transform.prototype = {
	  point: function(x, y) { this.stream.point(x, y); },
	  sphere: function() { this.stream.sphere(); },
	  lineStart: function() { this.stream.lineStart(); },
	  lineEnd: function() { this.stream.lineEnd(); },
	  polygonStart: function() { this.stream.polygonStart(); },
	  polygonEnd: function() { this.stream.polygonEnd(); }
	};

	function fit(project, extent, object) {
	  var w = extent[1][0] - extent[0][0],
	      h = extent[1][1] - extent[0][1],
	      clip = project.clipExtent && project.clipExtent();

	  project
	      .scale(150)
	      .translate([0, 0]);

	  if (clip != null) project.clipExtent(null);

	  geoStream(object, project.stream(boundsStream$1));

	  var b = boundsStream$1.result(),
	      k = Math.min(w / (b[1][0] - b[0][0]), h / (b[1][1] - b[0][1])),
	      x = +extent[0][0] + (w - k * (b[1][0] + b[0][0])) / 2,
	      y = +extent[0][1] + (h - k * (b[1][1] + b[0][1])) / 2;

	  if (clip != null) project.clipExtent(clip);

	  return project
	      .scale(k * 150)
	      .translate([x, y]);
	}

	function fitSize(project) {
	  return function(size, object) {
	    return fit(project, [[0, 0], size], object);
	  };
	}

	function fitExtent(project) {
	  return function(extent, object) {
	    return fit(project, extent, object);
	  };
	}

	var maxDepth = 16;
	var cosMinDistance = cos(30 * radians);
	// cos(minimum angular distance)

	function resample(project, delta2) {
	  return +delta2 ? resample$1(project, delta2) : resampleNone(project);
	}

	function resampleNone(project) {
	  return transform$1({
	    point: function(x, y) {
	      x = project(x, y);
	      this.stream.point(x[0], x[1]);
	    }
	  });
	}

	function resample$1(project, delta2) {

	  function resampleLineTo(x0, y0, lambda0, a0, b0, c0, x1, y1, lambda1, a1, b1, c1, depth, stream) {
	    var dx = x1 - x0,
	        dy = y1 - y0,
	        d2 = dx * dx + dy * dy;
	    if (d2 > 4 * delta2 && depth--) {
	      var a = a0 + a1,
	          b = b0 + b1,
	          c = c0 + c1,
	          m = sqrt(a * a + b * b + c * c),
	          phi2 = asin(c /= m),
	          lambda2 = abs(abs(c) - 1) < epsilon || abs(lambda0 - lambda1) < epsilon ? (lambda0 + lambda1) / 2 : atan2(b, a),
	          p = project(lambda2, phi2),
	          x2 = p[0],
	          y2 = p[1],
	          dx2 = x2 - x0,
	          dy2 = y2 - y0,
	          dz = dy * dx2 - dx * dy2;
	      if (dz * dz / d2 > delta2 // perpendicular projected distance
	          || abs((dx * dx2 + dy * dy2) / d2 - 0.5) > 0.3 // midpoint close to an end
	          || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) { // angular distance
	        resampleLineTo(x0, y0, lambda0, a0, b0, c0, x2, y2, lambda2, a /= m, b /= m, c, depth, stream);
	        stream.point(x2, y2);
	        resampleLineTo(x2, y2, lambda2, a, b, c, x1, y1, lambda1, a1, b1, c1, depth, stream);
	      }
	    }
	  }
	  return function(stream) {
	    var lambda00, x00, y00, a00, b00, c00, // first point
	        lambda0, x0, y0, a0, b0, c0; // previous point

	    var resampleStream = {
	      point: point,
	      lineStart: lineStart,
	      lineEnd: lineEnd,
	      polygonStart: function() { stream.polygonStart(); resampleStream.lineStart = ringStart; },
	      polygonEnd: function() { stream.polygonEnd(); resampleStream.lineStart = lineStart; }
	    };

	    function point(x, y) {
	      x = project(x, y);
	      stream.point(x[0], x[1]);
	    }

	    function lineStart() {
	      x0 = NaN;
	      resampleStream.point = linePoint;
	      stream.lineStart();
	    }

	    function linePoint(lambda, phi) {
	      var c = cartesian([lambda, phi]), p = project(lambda, phi);
	      resampleLineTo(x0, y0, lambda0, a0, b0, c0, x0 = p[0], y0 = p[1], lambda0 = lambda, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);
	      stream.point(x0, y0);
	    }

	    function lineEnd() {
	      resampleStream.point = point;
	      stream.lineEnd();
	    }

	    function ringStart() {
	      lineStart();
	      resampleStream.point = ringPoint;
	      resampleStream.lineEnd = ringEnd;
	    }

	    function ringPoint(lambda, phi) {
	      linePoint(lambda00 = lambda, phi), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;
	      resampleStream.point = linePoint;
	    }

	    function ringEnd() {
	      resampleLineTo(x0, y0, lambda0, a0, b0, c0, x00, y00, lambda00, a00, b00, c00, maxDepth, stream);
	      resampleStream.lineEnd = lineEnd;
	      lineEnd();
	    }

	    return resampleStream;
	  };
	}

	var transformRadians = transform$1({
	  point: function(x, y) {
	    this.stream.point(x * radians, y * radians);
	  }
	});

	function projection(project) {
	  return projectionMutator(function() { return project; })();
	}

	function projectionMutator(projectAt) {
	  var project,
	      k = 150, // scale
	      x = 480, y = 250, // translate
	      dx, dy, lambda = 0, phi = 0, // center
	      deltaLambda = 0, deltaPhi = 0, deltaGamma = 0, rotate, projectRotate, // rotate
	      theta = null, preclip = clipAntimeridian, // clip angle
	      x0 = null, y0, x1, y1, postclip = identity, // clip extent
	      delta2 = 0.5, projectResample = resample(projectTransform, delta2), // precision
	      cache,
	      cacheStream;

	  function projection(point) {
	    point = projectRotate(point[0] * radians, point[1] * radians);
	    return [point[0] * k + dx, dy - point[1] * k];
	  }

	  function invert(point) {
	    point = projectRotate.invert((point[0] - dx) / k, (dy - point[1]) / k);
	    return point && [point[0] * degrees, point[1] * degrees];
	  }

	  function projectTransform(x, y) {
	    return x = project(x, y), [x[0] * k + dx, dy - x[1] * k];
	  }

	  projection.stream = function(stream) {
	    return cache && cacheStream === stream ? cache : cache = transformRadians(preclip(rotate, projectResample(postclip(cacheStream = stream))));
	  };

	  projection.clipAngle = function(_) {
	    return arguments.length ? (preclip = +_ ? clipCircle(theta = _ * radians, 6 * radians) : (theta = null, clipAntimeridian), reset()) : theta * degrees;
	  };

	  projection.clipExtent = function(_) {
	    return arguments.length ? (postclip = _ == null ? (x0 = y0 = x1 = y1 = null, identity) : clipExtent(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];
	  };

	  projection.scale = function(_) {
	    return arguments.length ? (k = +_, recenter()) : k;
	  };

	  projection.translate = function(_) {
	    return arguments.length ? (x = +_[0], y = +_[1], recenter()) : [x, y];
	  };

	  projection.center = function(_) {
	    return arguments.length ? (lambda = _[0] % 360 * radians, phi = _[1] % 360 * radians, recenter()) : [lambda * degrees, phi * degrees];
	  };

	  projection.rotate = function(_) {
	    return arguments.length ? (deltaLambda = _[0] % 360 * radians, deltaPhi = _[1] % 360 * radians, deltaGamma = _.length > 2 ? _[2] % 360 * radians : 0, recenter()) : [deltaLambda * degrees, deltaPhi * degrees, deltaGamma * degrees];
	  };

	  projection.precision = function(_) {
	    return arguments.length ? (projectResample = resample(projectTransform, delta2 = _ * _), reset()) : sqrt(delta2);
	  };

	  projection.fitExtent = fitExtent(projection);

	  projection.fitSize = fitSize(projection);

	  function recenter() {
	    projectRotate = compose(rotate = rotateRadians(deltaLambda, deltaPhi, deltaGamma), project);
	    var center = project(lambda, phi);
	    dx = x - center[0] * k;
	    dy = y + center[1] * k;
	    return reset();
	  }

	  function reset() {
	    cache = cacheStream = null;
	    return projection;
	  }

	  return function() {
	    project = projectAt.apply(this, arguments);
	    projection.invert = project.invert && invert;
	    return recenter();
	  };
	}

	function conicProjection(projectAt) {
	  var phi0 = 0,
	      phi1 = pi / 3,
	      m = projectionMutator(projectAt),
	      p = m(phi0, phi1);

	  p.parallels = function(_) {
	    return arguments.length ? m(phi0 = _[0] * radians, phi1 = _[1] * radians) : [phi0 * degrees, phi1 * degrees];
	  };

	  return p;
	}

	function conicEqualAreaRaw(y0, y1) {
	  var sy0 = sin(y0),
	      n = (sy0 + sin(y1)) / 2,
	      c = 1 + sy0 * (2 * n - sy0),
	      r0 = sqrt(c) / n;

	  function project(x, y) {
	    var r = sqrt(c - 2 * n * sin(y)) / n;
	    return [r * sin(x *= n), r0 - r * cos(x)];
	  }

	  project.invert = function(x, y) {
	    var r0y = r0 - y;
	    return [atan2(x, r0y) / n, asin((c - (x * x + r0y * r0y) * n * n) / (2 * n))];
	  };

	  return project;
	}

	function conicEqualArea() {
	  return conicProjection(conicEqualAreaRaw)
	      .scale(155.424)
	      .center([0, 33.6442]);
	}

	function albers() {
	  return conicEqualArea()
	      .parallels([29.5, 45.5])
	      .scale(1070)
	      .translate([480, 250])
	      .rotate([96, 0])
	      .center([-0.6, 38.7]);
	}

	// The projections must have mutually exclusive clip regions on the sphere,
	// as this will avoid emitting interleaving lines and polygons.
	function multiplex(streams) {
	  var n = streams.length;
	  return {
	    point: function(x, y) { var i = -1; while (++i < n) streams[i].point(x, y); },
	    sphere: function() { var i = -1; while (++i < n) streams[i].sphere(); },
	    lineStart: function() { var i = -1; while (++i < n) streams[i].lineStart(); },
	    lineEnd: function() { var i = -1; while (++i < n) streams[i].lineEnd(); },
	    polygonStart: function() { var i = -1; while (++i < n) streams[i].polygonStart(); },
	    polygonEnd: function() { var i = -1; while (++i < n) streams[i].polygonEnd(); }
	  };
	}

	// A composite projection for the United States, configured by default for
	// 960Ã500. The projection also works quite well at 960Ã600 if you change the
	// scale to 1285 and adjust the translate accordingly. The set of standard
	// parallels for each region comes from USGS, which is published here:
	// http://egsc.usgs.gov/isb/pubs/MapProjections/projections.html#albers
	function albersUsa() {
	  var cache,
	      cacheStream,
	      lower48 = albers(), lower48Point,
	      alaska = conicEqualArea().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]), alaskaPoint, // EPSG:3338
	      hawaii = conicEqualArea().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]), hawaiiPoint, // ESRI:102007
	      point, pointStream = {point: function(x, y) { point = [x, y]; }};

	  function albersUsa(coordinates) {
	    var x = coordinates[0], y = coordinates[1];
	    return point = null,
	        (lower48Point.point(x, y), point)
	        || (alaskaPoint.point(x, y), point)
	        || (hawaiiPoint.point(x, y), point);
	  }

	  albersUsa.invert = function(coordinates) {
	    var k = lower48.scale(),
	        t = lower48.translate(),
	        x = (coordinates[0] - t[0]) / k,
	        y = (coordinates[1] - t[1]) / k;
	    return (y >= 0.120 && y < 0.234 && x >= -0.425 && x < -0.214 ? alaska
	        : y >= 0.166 && y < 0.234 && x >= -0.214 && x < -0.115 ? hawaii
	        : lower48).invert(coordinates);
	  };

	  albersUsa.stream = function(stream) {
	    return cache && cacheStream === stream ? cache : cache = multiplex([lower48.stream(cacheStream = stream), alaska.stream(stream), hawaii.stream(stream)]);
	  };

	  albersUsa.precision = function(_) {
	    if (!arguments.length) return lower48.precision();
	    lower48.precision(_), alaska.precision(_), hawaii.precision(_);
	    return albersUsa;
	  };

	  albersUsa.scale = function(_) {
	    if (!arguments.length) return lower48.scale();
	    lower48.scale(_), alaska.scale(_ * 0.35), hawaii.scale(_);
	    return albersUsa.translate(lower48.translate());
	  };

	  albersUsa.translate = function(_) {
	    if (!arguments.length) return lower48.translate();
	    var k = lower48.scale(), x = +_[0], y = +_[1];

	    lower48Point = lower48
	        .translate(_)
	        .clipExtent([[x - 0.455 * k, y - 0.238 * k], [x + 0.455 * k, y + 0.238 * k]])
	        .stream(pointStream);

	    alaskaPoint = alaska
	        .translate([x - 0.307 * k, y + 0.201 * k])
	        .clipExtent([[x - 0.425 * k + epsilon, y + 0.120 * k + epsilon], [x - 0.214 * k - epsilon, y + 0.234 * k - epsilon]])
	        .stream(pointStream);

	    hawaiiPoint = hawaii
	        .translate([x - 0.205 * k, y + 0.212 * k])
	        .clipExtent([[x - 0.214 * k + epsilon, y + 0.166 * k + epsilon], [x - 0.115 * k - epsilon, y + 0.234 * k - epsilon]])
	        .stream(pointStream);

	    return albersUsa;
	  };

	  albersUsa.fitExtent = fitExtent(albersUsa);

	  albersUsa.fitSize = fitSize(albersUsa);

	  return albersUsa.scale(1070);
	}

	function azimuthalRaw(scale) {
	  return function(x, y) {
	    var cx = cos(x),
	        cy = cos(y),
	        k = scale(cx * cy);
	    return [
	      k * cy * sin(x),
	      k * sin(y)
	    ];
	  }
	}

	function azimuthalInvert(angle) {
	  return function(x, y) {
	    var z = sqrt(x * x + y * y),
	        c = angle(z),
	        sc = sin(c),
	        cc = cos(c);
	    return [
	      atan2(x * sc, z * cc),
	      asin(z && y * sc / z)
	    ];
	  }
	}

	var azimuthalEqualAreaRaw = azimuthalRaw(function(cxcy) {
	  return sqrt(2 / (1 + cxcy));
	});

	azimuthalEqualAreaRaw.invert = azimuthalInvert(function(z) {
	  return 2 * asin(z / 2);
	});

	function azimuthalEqualArea() {
	  return projection(azimuthalEqualAreaRaw)
	      .scale(124.75)
	      .clipAngle(180 - 1e-3);
	}

	var azimuthalEquidistantRaw = azimuthalRaw(function(c) {
	  return (c = acos(c)) && c / sin(c);
	});

	azimuthalEquidistantRaw.invert = azimuthalInvert(function(z) {
	  return z;
	});

	function azimuthalEquidistant() {
	  return projection(azimuthalEquidistantRaw)
	      .scale(79.4188)
	      .clipAngle(180 - 1e-3);
	}

	function mercatorRaw(lambda, phi) {
	  return [lambda, log(tan((halfPi + phi) / 2))];
	}

	mercatorRaw.invert = function(x, y) {
	  return [x, 2 * atan(exp(y)) - halfPi];
	};

	function mercator() {
	  return mercatorProjection(mercatorRaw)
	      .scale(961 / tau);
	}

	function mercatorProjection(project) {
	  var m = projection(project),
	      scale = m.scale,
	      translate = m.translate,
	      clipExtent = m.clipExtent,
	      clipAuto;

	  m.scale = function(_) {
	    return arguments.length ? (scale(_), clipAuto && m.clipExtent(null), m) : scale();
	  };

	  m.translate = function(_) {
	    return arguments.length ? (translate(_), clipAuto && m.clipExtent(null), m) : translate();
	  };

	  m.clipExtent = function(_) {
	    if (!arguments.length) return clipAuto ? null : clipExtent();
	    if (clipAuto = _ == null) {
	      var k = pi * scale(),
	          t = translate();
	      _ = [[t[0] - k, t[1] - k], [t[0] + k, t[1] + k]];
	    }
	    clipExtent(_);
	    return m;
	  };

	  return m.clipExtent(null);
	}

	function tany(y) {
	  return tan((halfPi + y) / 2);
	}

	function conicConformalRaw(y0, y1) {
	  var cy0 = cos(y0),
	      n = y0 === y1 ? sin(y0) : log(cy0 / cos(y1)) / log(tany(y1) / tany(y0)),
	      f = cy0 * pow(tany(y0), n) / n;

	  if (!n) return mercatorRaw;

	  function project(x, y) {
	    if (f > 0) { if (y < -halfPi + epsilon) y = -halfPi + epsilon; }
	    else { if (y > halfPi - epsilon) y = halfPi - epsilon; }
	    var r = f / pow(tany(y), n);
	    return [r * sin(n * x), f - r * cos(n * x)];
	  }

	  project.invert = function(x, y) {
	    var fy = f - y, r = sign(n) * sqrt(x * x + fy * fy);
	    return [atan2(x, fy) / n, 2 * atan(pow(f / r, 1 / n)) - halfPi];
	  };

	  return project;
	}

	function conicConformal() {
	  return conicProjection(conicConformalRaw)
	      .scale(109.5)
	      .parallels([30, 30]);
	}

	function equirectangularRaw(lambda, phi) {
	  return [lambda, phi];
	}

	equirectangularRaw.invert = equirectangularRaw;

	function equirectangular() {
	  return projection(equirectangularRaw)
	      .scale(152.63);
	}

	function conicEquidistantRaw(y0, y1) {
	  var cy0 = cos(y0),
	      n = y0 === y1 ? sin(y0) : (cy0 - cos(y1)) / (y1 - y0),
	      g = cy0 / n + y0;

	  if (abs(n) < epsilon) return equirectangularRaw;

	  function project(x, y) {
	    var gy = g - y, nx = n * x;
	    return [gy * sin(nx), g - gy * cos(nx)];
	  }

	  project.invert = function(x, y) {
	    var gy = g - y;
	    return [atan2(x, gy) / n, g - sign(n) * sqrt(x * x + gy * gy)];
	  };

	  return project;
	}

	function conicEquidistant() {
	  return conicProjection(conicEquidistantRaw)
	      .scale(131.154)
	      .center([0, 13.9389]);
	}

	function gnomonicRaw(x, y) {
	  var cy = cos(y), k = cos(x) * cy;
	  return [cy * sin(x) / k, sin(y) / k];
	}

	gnomonicRaw.invert = azimuthalInvert(atan);

	function gnomonic() {
	  return projection(gnomonicRaw)
	      .scale(144.049)
	      .clipAngle(60);
	}

	function orthographicRaw(x, y) {
	  return [cos(y) * sin(x), sin(y)];
	}

	orthographicRaw.invert = azimuthalInvert(asin);

	function orthographic() {
	  return projection(orthographicRaw)
	      .scale(249.5)
	      .clipAngle(90 + epsilon);
	}

	function stereographicRaw(x, y) {
	  var cy = cos(y), k = 1 + cos(x) * cy;
	  return [cy * sin(x) / k, sin(y) / k];
	}

	stereographicRaw.invert = azimuthalInvert(function(z) {
	  return 2 * atan(z);
	});

	function stereographic() {
	  return projection(stereographicRaw)
	      .scale(250)
	      .clipAngle(142);
	}

	function transverseMercatorRaw(lambda, phi) {
	  return [log(tan((halfPi + phi) / 2)), -lambda];
	}

	transverseMercatorRaw.invert = function(x, y) {
	  return [-y, 2 * atan(exp(x)) - halfPi];
	};

	function transverseMercator() {
	  var m = mercatorProjection(transverseMercatorRaw),
	      center = m.center,
	      rotate = m.rotate;

	  m.center = function(_) {
	    return arguments.length ? center([-_[1], _[0]]) : (_ = center(), [_[1], -_[0]]);
	  };

	  m.rotate = function(_) {
	    return arguments.length ? rotate([_[0], _[1], _.length > 2 ? _[2] + 90 : 90]) : (_ = rotate(), [_[0], _[1], _[2] - 90]);
	  };

	  return rotate([0, 0, 90])
	      .scale(159.155);
	}

	exports.geoArea = area;
	exports.geoBounds = bounds;
	exports.geoCentroid = centroid;
	exports.geoCircle = circle;
	exports.geoClipExtent = extent;
	exports.geoDistance = distance;
	exports.geoGraticule = graticule;
	exports.geoInterpolate = interpolate;
	exports.geoLength = length;
	exports.geoPath = index;
	exports.geoAlbers = albers;
	exports.geoAlbersUsa = albersUsa;
	exports.geoAzimuthalEqualArea = azimuthalEqualArea;
	exports.geoAzimuthalEqualAreaRaw = azimuthalEqualAreaRaw;
	exports.geoAzimuthalEquidistant = azimuthalEquidistant;
	exports.geoAzimuthalEquidistantRaw = azimuthalEquidistantRaw;
	exports.geoConicConformal = conicConformal;
	exports.geoConicConformalRaw = conicConformalRaw;
	exports.geoConicEqualArea = conicEqualArea;
	exports.geoConicEqualAreaRaw = conicEqualAreaRaw;
	exports.geoConicEquidistant = conicEquidistant;
	exports.geoConicEquidistantRaw = conicEquidistantRaw;
	exports.geoEquirectangular = equirectangular;
	exports.geoEquirectangularRaw = equirectangularRaw;
	exports.geoGnomonic = gnomonic;
	exports.geoGnomonicRaw = gnomonicRaw;
	exports.geoProjection = projection;
	exports.geoProjectionMutator = projectionMutator;
	exports.geoMercator = mercator;
	exports.geoMercatorRaw = mercatorRaw;
	exports.geoOrthographic = orthographic;
	exports.geoOrthographicRaw = orthographicRaw;
	exports.geoStereographic = stereographic;
	exports.geoStereographicRaw = stereographicRaw;
	exports.geoTransverseMercator = transverseMercator;
	exports.geoTransverseMercatorRaw = transverseMercatorRaw;
	exports.geoRotation = rotation;
	exports.geoStream = geoStream;
	exports.geoTransform = transform;

	Object.defineProperty(exports, '__esModule', { value: true });

	})));

/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	// https://d3js.org/d3-selection/ Version 1.0.2. Copyright 2016 Mike Bostock.
	(function (global, factory) {
	   true ? factory(exports) :
	  typeof define === 'function' && define.amd ? define(['exports'], factory) :
	  (factory((global.d3 = global.d3 || {})));
	}(this, function (exports) { 'use strict';

	  var xhtml = "http://www.w3.org/1999/xhtml";

	  var namespaces = {
	    svg: "http://www.w3.org/2000/svg",
	    xhtml: xhtml,
	    xlink: "http://www.w3.org/1999/xlink",
	    xml: "http://www.w3.org/XML/1998/namespace",
	    xmlns: "http://www.w3.org/2000/xmlns/"
	  };

	  function namespace(name) {
	    var prefix = name += "", i = prefix.indexOf(":");
	    if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
	    return namespaces.hasOwnProperty(prefix) ? {space: namespaces[prefix], local: name} : name;
	  }

	  function creatorInherit(name) {
	    return function() {
	      var document = this.ownerDocument,
	          uri = this.namespaceURI;
	      return uri === xhtml && document.documentElement.namespaceURI === xhtml
	          ? document.createElement(name)
	          : document.createElementNS(uri, name);
	    };
	  }

	  function creatorFixed(fullname) {
	    return function() {
	      return this.ownerDocument.createElementNS(fullname.space, fullname.local);
	    };
	  }

	  function creator(name) {
	    var fullname = namespace(name);
	    return (fullname.local
	        ? creatorFixed
	        : creatorInherit)(fullname);
	  }

	  var nextId = 0;

	  function local() {
	    return new Local;
	  }

	  function Local() {
	    this._ = "@" + (++nextId).toString(36);
	  }

	  Local.prototype = local.prototype = {
	    constructor: Local,
	    get: function(node) {
	      var id = this._;
	      while (!(id in node)) if (!(node = node.parentNode)) return;
	      return node[id];
	    },
	    set: function(node, value) {
	      return node[this._] = value;
	    },
	    remove: function(node) {
	      return this._ in node && delete node[this._];
	    },
	    toString: function() {
	      return this._;
	    }
	  };

	  var matcher = function(selector) {
	    return function() {
	      return this.matches(selector);
	    };
	  };

	  if (typeof document !== "undefined") {
	    var element = document.documentElement;
	    if (!element.matches) {
	      var vendorMatches = element.webkitMatchesSelector
	          || element.msMatchesSelector
	          || element.mozMatchesSelector
	          || element.oMatchesSelector;
	      matcher = function(selector) {
	        return function() {
	          return vendorMatches.call(this, selector);
	        };
	      };
	    }
	  }

	  var matcher$1 = matcher;

	  var filterEvents = {};

	  exports.event = null;

	  if (typeof document !== "undefined") {
	    var element$1 = document.documentElement;
	    if (!("onmouseenter" in element$1)) {
	      filterEvents = {mouseenter: "mouseover", mouseleave: "mouseout"};
	    }
	  }

	  function filterContextListener(listener, index, group) {
	    listener = contextListener(listener, index, group);
	    return function(event) {
	      var related = event.relatedTarget;
	      if (!related || (related !== this && !(related.compareDocumentPosition(this) & 8))) {
	        listener.call(this, event);
	      }
	    };
	  }

	  function contextListener(listener, index, group) {
	    return function(event1) {
	      var event0 = exports.event; // Events can be reentrant (e.g., focus).
	      exports.event = event1;
	      try {
	        listener.call(this, this.__data__, index, group);
	      } finally {
	        exports.event = event0;
	      }
	    };
	  }

	  function parseTypenames(typenames) {
	    return typenames.trim().split(/^|\s+/).map(function(t) {
	      var name = "", i = t.indexOf(".");
	      if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
	      return {type: t, name: name};
	    });
	  }

	  function onRemove(typename) {
	    return function() {
	      var on = this.__on;
	      if (!on) return;
	      for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
	        if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
	          this.removeEventListener(o.type, o.listener, o.capture);
	        } else {
	          on[++i] = o;
	        }
	      }
	      if (++i) on.length = i;
	      else delete this.__on;
	    };
	  }

	  function onAdd(typename, value, capture) {
	    var wrap = filterEvents.hasOwnProperty(typename.type) ? filterContextListener : contextListener;
	    return function(d, i, group) {
	      var on = this.__on, o, listener = wrap(value, i, group);
	      if (on) for (var j = 0, m = on.length; j < m; ++j) {
	        if ((o = on[j]).type === typename.type && o.name === typename.name) {
	          this.removeEventListener(o.type, o.listener, o.capture);
	          this.addEventListener(o.type, o.listener = listener, o.capture = capture);
	          o.value = value;
	          return;
	        }
	      }
	      this.addEventListener(typename.type, listener, capture);
	      o = {type: typename.type, name: typename.name, value: value, listener: listener, capture: capture};
	      if (!on) this.__on = [o];
	      else on.push(o);
	    };
	  }

	  function selection_on(typename, value, capture) {
	    var typenames = parseTypenames(typename + ""), i, n = typenames.length, t;

	    if (arguments.length < 2) {
	      var on = this.node().__on;
	      if (on) for (var j = 0, m = on.length, o; j < m; ++j) {
	        for (i = 0, o = on[j]; i < n; ++i) {
	          if ((t = typenames[i]).type === o.type && t.name === o.name) {
	            return o.value;
	          }
	        }
	      }
	      return;
	    }

	    on = value ? onAdd : onRemove;
	    if (capture == null) capture = false;
	    for (i = 0; i < n; ++i) this.each(on(typenames[i], value, capture));
	    return this;
	  }

	  function customEvent(event1, listener, that, args) {
	    var event0 = exports.event;
	    event1.sourceEvent = exports.event;
	    exports.event = event1;
	    try {
	      return listener.apply(that, args);
	    } finally {
	      exports.event = event0;
	    }
	  }

	  function sourceEvent() {
	    var current = exports.event, source;
	    while (source = current.sourceEvent) current = source;
	    return current;
	  }

	  function point(node, event) {
	    var svg = node.ownerSVGElement || node;

	    if (svg.createSVGPoint) {
	      var point = svg.createSVGPoint();
	      point.x = event.clientX, point.y = event.clientY;
	      point = point.matrixTransform(node.getScreenCTM().inverse());
	      return [point.x, point.y];
	    }

	    var rect = node.getBoundingClientRect();
	    return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];
	  }

	  function mouse(node) {
	    var event = sourceEvent();
	    if (event.changedTouches) event = event.changedTouches[0];
	    return point(node, event);
	  }

	  function none() {}

	  function selector(selector) {
	    return selector == null ? none : function() {
	      return this.querySelector(selector);
	    };
	  }

	  function selection_select(select) {
	    if (typeof select !== "function") select = selector(select);

	    for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
	      for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
	        if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
	          if ("__data__" in node) subnode.__data__ = node.__data__;
	          subgroup[i] = subnode;
	        }
	      }
	    }

	    return new Selection(subgroups, this._parents);
	  }

	  function empty() {
	    return [];
	  }

	  function selectorAll(selector) {
	    return selector == null ? empty : function() {
	      return this.querySelectorAll(selector);
	    };
	  }

	  function selection_selectAll(select) {
	    if (typeof select !== "function") select = selectorAll(select);

	    for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
	      for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
	        if (node = group[i]) {
	          subgroups.push(select.call(node, node.__data__, i, group));
	          parents.push(node);
	        }
	      }
	    }

	    return new Selection(subgroups, parents);
	  }

	  function selection_filter(match) {
	    if (typeof match !== "function") match = matcher$1(match);

	    for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
	      for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
	        if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
	          subgroup.push(node);
	        }
	      }
	    }

	    return new Selection(subgroups, this._parents);
	  }

	  function sparse(update) {
	    return new Array(update.length);
	  }

	  function selection_enter() {
	    return new Selection(this._enter || this._groups.map(sparse), this._parents);
	  }

	  function EnterNode(parent, datum) {
	    this.ownerDocument = parent.ownerDocument;
	    this.namespaceURI = parent.namespaceURI;
	    this._next = null;
	    this._parent = parent;
	    this.__data__ = datum;
	  }

	  EnterNode.prototype = {
	    constructor: EnterNode,
	    appendChild: function(child) { return this._parent.insertBefore(child, this._next); },
	    insertBefore: function(child, next) { return this._parent.insertBefore(child, next); },
	    querySelector: function(selector) { return this._parent.querySelector(selector); },
	    querySelectorAll: function(selector) { return this._parent.querySelectorAll(selector); }
	  };

	  function constant(x) {
	    return function() {
	      return x;
	    };
	  }

	  var keyPrefix = "$"; // Protect against keys like â__proto__â.

	  function bindIndex(parent, group, enter, update, exit, data) {
	    var i = 0,
	        node,
	        groupLength = group.length,
	        dataLength = data.length;

	    // Put any non-null nodes that fit into update.
	    // Put any null nodes into enter.
	    // Put any remaining data into enter.
	    for (; i < dataLength; ++i) {
	      if (node = group[i]) {
	        node.__data__ = data[i];
	        update[i] = node;
	      } else {
	        enter[i] = new EnterNode(parent, data[i]);
	      }
	    }

	    // Put any non-null nodes that donât fit into exit.
	    for (; i < groupLength; ++i) {
	      if (node = group[i]) {
	        exit[i] = node;
	      }
	    }
	  }

	  function bindKey(parent, group, enter, update, exit, data, key) {
	    var i,
	        node,
	        nodeByKeyValue = {},
	        groupLength = group.length,
	        dataLength = data.length,
	        keyValues = new Array(groupLength),
	        keyValue;

	    // Compute the key for each node.
	    // If multiple nodes have the same key, the duplicates are added to exit.
	    for (i = 0; i < groupLength; ++i) {
	      if (node = group[i]) {
	        keyValues[i] = keyValue = keyPrefix + key.call(node, node.__data__, i, group);
	        if (keyValue in nodeByKeyValue) {
	          exit[i] = node;
	        } else {
	          nodeByKeyValue[keyValue] = node;
	        }
	      }
	    }

	    // Compute the key for each datum.
	    // If there a node associated with this key, join and add it to update.
	    // If there is not (or the key is a duplicate), add it to enter.
	    for (i = 0; i < dataLength; ++i) {
	      keyValue = keyPrefix + key.call(parent, data[i], i, data);
	      if (node = nodeByKeyValue[keyValue]) {
	        update[i] = node;
	        node.__data__ = data[i];
	        nodeByKeyValue[keyValue] = null;
	      } else {
	        enter[i] = new EnterNode(parent, data[i]);
	      }
	    }

	    // Add any remaining nodes that were not bound to data to exit.
	    for (i = 0; i < groupLength; ++i) {
	      if ((node = group[i]) && (nodeByKeyValue[keyValues[i]] === node)) {
	        exit[i] = node;
	      }
	    }
	  }

	  function selection_data(value, key) {
	    if (!value) {
	      data = new Array(this.size()), j = -1;
	      this.each(function(d) { data[++j] = d; });
	      return data;
	    }

	    var bind = key ? bindKey : bindIndex,
	        parents = this._parents,
	        groups = this._groups;

	    if (typeof value !== "function") value = constant(value);

	    for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
	      var parent = parents[j],
	          group = groups[j],
	          groupLength = group.length,
	          data = value.call(parent, parent && parent.__data__, j, parents),
	          dataLength = data.length,
	          enterGroup = enter[j] = new Array(dataLength),
	          updateGroup = update[j] = new Array(dataLength),
	          exitGroup = exit[j] = new Array(groupLength);

	      bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);

	      // Now connect the enter nodes to their following update node, such that
	      // appendChild can insert the materialized enter node before this node,
	      // rather than at the end of the parent node.
	      for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
	        if (previous = enterGroup[i0]) {
	          if (i0 >= i1) i1 = i0 + 1;
	          while (!(next = updateGroup[i1]) && ++i1 < dataLength);
	          previous._next = next || null;
	        }
	      }
	    }

	    update = new Selection(update, parents);
	    update._enter = enter;
	    update._exit = exit;
	    return update;
	  }

	  function selection_exit() {
	    return new Selection(this._exit || this._groups.map(sparse), this._parents);
	  }

	  function selection_merge(selection) {

	    for (var groups0 = this._groups, groups1 = selection._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
	      for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
	        if (node = group0[i] || group1[i]) {
	          merge[i] = node;
	        }
	      }
	    }

	    for (; j < m0; ++j) {
	      merges[j] = groups0[j];
	    }

	    return new Selection(merges, this._parents);
	  }

	  function selection_order() {

	    for (var groups = this._groups, j = -1, m = groups.length; ++j < m;) {
	      for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0;) {
	        if (node = group[i]) {
	          if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);
	          next = node;
	        }
	      }
	    }

	    return this;
	  }

	  function selection_sort(compare) {
	    if (!compare) compare = ascending;

	    function compareNode(a, b) {
	      return a && b ? compare(a.__data__, b.__data__) : !a - !b;
	    }

	    for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
	      for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
	        if (node = group[i]) {
	          sortgroup[i] = node;
	        }
	      }
	      sortgroup.sort(compareNode);
	    }

	    return new Selection(sortgroups, this._parents).order();
	  }

	  function ascending(a, b) {
	    return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
	  }

	  function selection_call() {
	    var callback = arguments[0];
	    arguments[0] = this;
	    callback.apply(null, arguments);
	    return this;
	  }

	  function selection_nodes() {
	    var nodes = new Array(this.size()), i = -1;
	    this.each(function() { nodes[++i] = this; });
	    return nodes;
	  }

	  function selection_node() {

	    for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
	      for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
	        var node = group[i];
	        if (node) return node;
	      }
	    }

	    return null;
	  }

	  function selection_size() {
	    var size = 0;
	    this.each(function() { ++size; });
	    return size;
	  }

	  function selection_empty() {
	    return !this.node();
	  }

	  function selection_each(callback) {

	    for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
	      for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
	        if (node = group[i]) callback.call(node, node.__data__, i, group);
	      }
	    }

	    return this;
	  }

	  function attrRemove(name) {
	    return function() {
	      this.removeAttribute(name);
	    };
	  }

	  function attrRemoveNS(fullname) {
	    return function() {
	      this.removeAttributeNS(fullname.space, fullname.local);
	    };
	  }

	  function attrConstant(name, value) {
	    return function() {
	      this.setAttribute(name, value);
	    };
	  }

	  function attrConstantNS(fullname, value) {
	    return function() {
	      this.setAttributeNS(fullname.space, fullname.local, value);
	    };
	  }

	  function attrFunction(name, value) {
	    return function() {
	      var v = value.apply(this, arguments);
	      if (v == null) this.removeAttribute(name);
	      else this.setAttribute(name, v);
	    };
	  }

	  function attrFunctionNS(fullname, value) {
	    return function() {
	      var v = value.apply(this, arguments);
	      if (v == null) this.removeAttributeNS(fullname.space, fullname.local);
	      else this.setAttributeNS(fullname.space, fullname.local, v);
	    };
	  }

	  function selection_attr(name, value) {
	    var fullname = namespace(name);

	    if (arguments.length < 2) {
	      var node = this.node();
	      return fullname.local
	          ? node.getAttributeNS(fullname.space, fullname.local)
	          : node.getAttribute(fullname);
	    }

	    return this.each((value == null
	        ? (fullname.local ? attrRemoveNS : attrRemove) : (typeof value === "function"
	        ? (fullname.local ? attrFunctionNS : attrFunction)
	        : (fullname.local ? attrConstantNS : attrConstant)))(fullname, value));
	  }

	  function defaultView(node) {
	    return (node.ownerDocument && node.ownerDocument.defaultView) // node is a Node
	        || (node.document && node) // node is a Window
	        || node.defaultView; // node is a Document
	  }

	  function styleRemove(name) {
	    return function() {
	      this.style.removeProperty(name);
	    };
	  }

	  function styleConstant(name, value, priority) {
	    return function() {
	      this.style.setProperty(name, value, priority);
	    };
	  }

	  function styleFunction(name, value, priority) {
	    return function() {
	      var v = value.apply(this, arguments);
	      if (v == null) this.style.removeProperty(name);
	      else this.style.setProperty(name, v, priority);
	    };
	  }

	  function selection_style(name, value, priority) {
	    var node;
	    return arguments.length > 1
	        ? this.each((value == null
	              ? styleRemove : typeof value === "function"
	              ? styleFunction
	              : styleConstant)(name, value, priority == null ? "" : priority))
	        : defaultView(node = this.node())
	            .getComputedStyle(node, null)
	            .getPropertyValue(name);
	  }

	  function propertyRemove(name) {
	    return function() {
	      delete this[name];
	    };
	  }

	  function propertyConstant(name, value) {
	    return function() {
	      this[name] = value;
	    };
	  }

	  function propertyFunction(name, value) {
	    return function() {
	      var v = value.apply(this, arguments);
	      if (v == null) delete this[name];
	      else this[name] = v;
	    };
	  }

	  function selection_property(name, value) {
	    return arguments.length > 1
	        ? this.each((value == null
	            ? propertyRemove : typeof value === "function"
	            ? propertyFunction
	            : propertyConstant)(name, value))
	        : this.node()[name];
	  }

	  function classArray(string) {
	    return string.trim().split(/^|\s+/);
	  }

	  function classList(node) {
	    return node.classList || new ClassList(node);
	  }

	  function ClassList(node) {
	    this._node = node;
	    this._names = classArray(node.getAttribute("class") || "");
	  }

	  ClassList.prototype = {
	    add: function(name) {
	      var i = this._names.indexOf(name);
	      if (i < 0) {
	        this._names.push(name);
	        this._node.setAttribute("class", this._names.join(" "));
	      }
	    },
	    remove: function(name) {
	      var i = this._names.indexOf(name);
	      if (i >= 0) {
	        this._names.splice(i, 1);
	        this._node.setAttribute("class", this._names.join(" "));
	      }
	    },
	    contains: function(name) {
	      return this._names.indexOf(name) >= 0;
	    }
	  };

	  function classedAdd(node, names) {
	    var list = classList(node), i = -1, n = names.length;
	    while (++i < n) list.add(names[i]);
	  }

	  function classedRemove(node, names) {
	    var list = classList(node), i = -1, n = names.length;
	    while (++i < n) list.remove(names[i]);
	  }

	  function classedTrue(names) {
	    return function() {
	      classedAdd(this, names);
	    };
	  }

	  function classedFalse(names) {
	    return function() {
	      classedRemove(this, names);
	    };
	  }

	  function classedFunction(names, value) {
	    return function() {
	      (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
	    };
	  }

	  function selection_classed(name, value) {
	    var names = classArray(name + "");

	    if (arguments.length < 2) {
	      var list = classList(this.node()), i = -1, n = names.length;
	      while (++i < n) if (!list.contains(names[i])) return false;
	      return true;
	    }

	    return this.each((typeof value === "function"
	        ? classedFunction : value
	        ? classedTrue
	        : classedFalse)(names, value));
	  }

	  function textRemove() {
	    this.textContent = "";
	  }

	  function textConstant(value) {
	    return function() {
	      this.textContent = value;
	    };
	  }

	  function textFunction(value) {
	    return function() {
	      var v = value.apply(this, arguments);
	      this.textContent = v == null ? "" : v;
	    };
	  }

	  function selection_text(value) {
	    return arguments.length
	        ? this.each(value == null
	            ? textRemove : (typeof value === "function"
	            ? textFunction
	            : textConstant)(value))
	        : this.node().textContent;
	  }

	  function htmlRemove() {
	    this.innerHTML = "";
	  }

	  function htmlConstant(value) {
	    return function() {
	      this.innerHTML = value;
	    };
	  }

	  function htmlFunction(value) {
	    return function() {
	      var v = value.apply(this, arguments);
	      this.innerHTML = v == null ? "" : v;
	    };
	  }

	  function selection_html(value) {
	    return arguments.length
	        ? this.each(value == null
	            ? htmlRemove : (typeof value === "function"
	            ? htmlFunction
	            : htmlConstant)(value))
	        : this.node().innerHTML;
	  }

	  function raise() {
	    if (this.nextSibling) this.parentNode.appendChild(this);
	  }

	  function selection_raise() {
	    return this.each(raise);
	  }

	  function lower() {
	    if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);
	  }

	  function selection_lower() {
	    return this.each(lower);
	  }

	  function selection_append(name) {
	    var create = typeof name === "function" ? name : creator(name);
	    return this.select(function() {
	      return this.appendChild(create.apply(this, arguments));
	    });
	  }

	  function constantNull() {
	    return null;
	  }

	  function selection_insert(name, before) {
	    var create = typeof name === "function" ? name : creator(name),
	        select = before == null ? constantNull : typeof before === "function" ? before : selector(before);
	    return this.select(function() {
	      return this.insertBefore(create.apply(this, arguments), select.apply(this, arguments) || null);
	    });
	  }

	  function remove() {
	    var parent = this.parentNode;
	    if (parent) parent.removeChild(this);
	  }

	  function selection_remove() {
	    return this.each(remove);
	  }

	  function selection_datum(value) {
	    return arguments.length
	        ? this.property("__data__", value)
	        : this.node().__data__;
	  }

	  function dispatchEvent(node, type, params) {
	    var window = defaultView(node),
	        event = window.CustomEvent;

	    if (event) {
	      event = new event(type, params);
	    } else {
	      event = window.document.createEvent("Event");
	      if (params) event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;
	      else event.initEvent(type, false, false);
	    }

	    node.dispatchEvent(event);
	  }

	  function dispatchConstant(type, params) {
	    return function() {
	      return dispatchEvent(this, type, params);
	    };
	  }

	  function dispatchFunction(type, params) {
	    return function() {
	      return dispatchEvent(this, type, params.apply(this, arguments));
	    };
	  }

	  function selection_dispatch(type, params) {
	    return this.each((typeof params === "function"
	        ? dispatchFunction
	        : dispatchConstant)(type, params));
	  }

	  var root = [null];

	  function Selection(groups, parents) {
	    this._groups = groups;
	    this._parents = parents;
	  }

	  function selection() {
	    return new Selection([[document.documentElement]], root);
	  }

	  Selection.prototype = selection.prototype = {
	    constructor: Selection,
	    select: selection_select,
	    selectAll: selection_selectAll,
	    filter: selection_filter,
	    data: selection_data,
	    enter: selection_enter,
	    exit: selection_exit,
	    merge: selection_merge,
	    order: selection_order,
	    sort: selection_sort,
	    call: selection_call,
	    nodes: selection_nodes,
	    node: selection_node,
	    size: selection_size,
	    empty: selection_empty,
	    each: selection_each,
	    attr: selection_attr,
	    style: selection_style,
	    property: selection_property,
	    classed: selection_classed,
	    text: selection_text,
	    html: selection_html,
	    raise: selection_raise,
	    lower: selection_lower,
	    append: selection_append,
	    insert: selection_insert,
	    remove: selection_remove,
	    datum: selection_datum,
	    on: selection_on,
	    dispatch: selection_dispatch
	  };

	  function select(selector) {
	    return typeof selector === "string"
	        ? new Selection([[document.querySelector(selector)]], [document.documentElement])
	        : new Selection([[selector]], root);
	  }

	  function selectAll(selector) {
	    return typeof selector === "string"
	        ? new Selection([document.querySelectorAll(selector)], [document.documentElement])
	        : new Selection([selector == null ? [] : selector], root);
	  }

	  function touch(node, touches, identifier) {
	    if (arguments.length < 3) identifier = touches, touches = sourceEvent().changedTouches;

	    for (var i = 0, n = touches ? touches.length : 0, touch; i < n; ++i) {
	      if ((touch = touches[i]).identifier === identifier) {
	        return point(node, touch);
	      }
	    }

	    return null;
	  }

	  function touches(node, touches) {
	    if (touches == null) touches = sourceEvent().touches;

	    for (var i = 0, n = touches ? touches.length : 0, points = new Array(n); i < n; ++i) {
	      points[i] = point(node, touches[i]);
	    }

	    return points;
	  }

	  exports.creator = creator;
	  exports.local = local;
	  exports.matcher = matcher$1;
	  exports.mouse = mouse;
	  exports.namespace = namespace;
	  exports.namespaces = namespaces;
	  exports.select = select;
	  exports.selectAll = selectAll;
	  exports.selection = selection;
	  exports.selector = selector;
	  exports.selectorAll = selectorAll;
	  exports.touch = touch;
	  exports.touches = touches;
	  exports.window = defaultView;
	  exports.customEvent = customEvent;

	  Object.defineProperty(exports, '__esModule', { value: true });

	}));

/***/ },
/* 32 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.getParameterByName = getParameterByName;
	exports.setQueryString = setQueryString;
	exports.addQueryStringValue = addQueryStringValue;
	exports.removeQueryStringValue = removeQueryStringValue;
	exports.updateQueryString = updateQueryString;
	/***********************************
	 * QUERY STRING FUNCTIONS *
	 ***********************************/

	var trim = exports.trim = function () {
	    "use strict";

	    function escapeRegex(string) {
	        return string.replace(/[\[\](){}?*+\^$\\.|\-]/g, "\\$&");
	    }

	    return function trim(str, characters, flags) {
	        flags = flags || "g";
	        if (typeof str !== "string" || typeof characters !== "string" || typeof flags !== "string") {
	            throw new TypeError("argument must be string");
	        }

	        if (!/^[gi]*$/.test(flags)) {
	            throw new TypeError("Invalid flags supplied '" + flags.match(new RegExp("[^gi]*")) + "'");
	        }

	        characters = escapeRegex(characters);

	        return str.replace(new RegExp("^[" + characters + "]+|[" + characters + "]+$", flags), '');
	    };
	}();

	function getParameterByName(name) {
	    name = name.replace(/[\[]/, "\\[").replace(/[\]]/, "\\]");
	    var regex = new RegExp("[\\?&]" + name + "=([^&#]*)"),
	        results = regex.exec(location.search);
	    return results == null ? "" : decodeURIComponent(results[1].replace(/\+/g, " "));
	}

	function setQueryString(key, value) {
	    history.pushState(null, "", updateQueryString(key, value));
	}

	function addQueryStringValue(key, value) {
	    console.log('addQueryStringValue', key, value);
	    var qs = getParameterByName(key);
	    qs = trim(trim(qs, ' ;') + ';' + value, ' ;');
	    history.pushState(null, "", updateQueryString(key, qs));
	}

	function removeQueryStringValue(key, value) {
	    console.log('removeQueryStringValue', key, value);
	    var qs = getParameterByName(key);
	    qs = trim(trim(qs, ' ;').replace(value, '').replace(/;;/g, ''), ' ;');
	    history.pushState(null, "", updateQueryString(key, qs != '' ? qs : null));
	}

	function updateQueryString(key, value, url) {
	    if (!url) url = window.location.href;
	    var re = new RegExp("([?&])" + key + "=.*?(&|#|$)(.*)", "gi"),
	        hash;

	    if (re.test(url)) {
	        if (typeof value !== 'undefined' && value !== null) return url.replace(re, '$1' + key + "=" + value + '$2$3');else {
	            hash = url.split('#');
	            url = hash[0].replace(re, '$1$3').replace(/(&|\?)$/, '');
	            if (typeof hash[1] !== 'undefined' && hash[1] !== null) url += '#' + hash[1];
	            return url;
	        }
	    } else {
	        if (typeof value !== 'undefined' && value !== null) {
	            var separator = url.indexOf('?') !== -1 ? '&' : '?';
	            hash = url.split('#');
	            url = hash[0] + separator + key + '=' + value;
	            if (typeof hash[1] !== 'undefined' && hash[1] !== null) url += '#' + hash[1];
	            return url;
	        } else {
	            return url;
	        }
	    }
	}

	/*** EXPORTS FROM exports-loader ***/

/***/ },
/* 33 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.getTileRadius = getTileRadius;
	exports.lerp = lerp;
	exports.reverseLerp = reverseLerp;
	exports.latLonToWorld = latLonToWorld;
	exports.worldToLatLon = worldToLatLon;
	exports.getScaledRadius = getScaledRadius;
	exports.calculateDistance = calculateDistance;
	/***********************************
	 * COORDINATE CONVERSION FUNCTIONS *
	 ***********************************/

	function getTileRadius(r) {
	    return parseInt(Math.floor(r / 64));
	}

	function lerp(minVal, maxVal, pos_r) {
	    return pos_r * (maxVal - minVal) + minVal;
	}

	function reverseLerp(minVal, maxVal, pos) {
	    return (pos - minVal) / (maxVal - minVal);
	}

	function latLonToWorld(map_x_boundaries, map_y_boundaries, map_w, map_h, x, y) {
	    var x_r = lerp(map_x_boundaries[0], map_x_boundaries[1], x / map_w),
	        y_r = lerp(map_y_boundaries[0], map_y_boundaries[1], (map_h - y) / map_h);

	    return {
	        x: x_r,
	        y: y_r
	    };
	}

	function worldToLatLon(map_x_boundaries, map_y_boundaries, map_w, map_h, x_r, y_r) {
	    var x = reverseLerp(map_x_boundaries[0], map_x_boundaries[1], x_r) * map_w,
	        y = map_h - reverseLerp(map_y_boundaries[0], map_y_boundaries[1], y_r) * map_h;

	    return {
	        x: x,
	        y: y
	    };
	}

	function getScaledRadius(map_x_boundaries, map_w, r) {
	    return r / (map_x_boundaries[1] - map_x_boundaries[0]) * map_w;
	}

	function calculateDistance(scale, order, units, measure) {
	    if (order == 1) {
	        if (units == "km") {
	            return measure * scale * 1000;
	        } else {
	            return measure * scale;
	        }
	    } else {
	        return measure * scale;
	    }
	}

	/*** EXPORTS FROM exports-loader ***/

/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _OpenLayers = __webpack_require__(20);

	var _OpenLayers2 = _interopRequireDefault(_OpenLayers);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = _OpenLayers2.default.Class(_OpenLayers2.default.Control.LayerSwitcher, {

	    initialize: function initialize(options) {
	        _OpenLayers2.default.Control.LayerSwitcher.prototype.initialize.apply(this, arguments);
	        this.layerStates = [];
	    },

	    onButtonClick: function onButtonClick(evt) {
	        return _OpenLayers2.default.Control.LayerSwitcher.prototype.onButtonClick.apply(this, arguments);
	    },

	    maximizeControl: function maximizeControl(e) {
	        _OpenLayers2.default.Element.removeClass(this.div, "minimized");

	        this.showControls(false);

	        if (e != null) {
	            _OpenLayers2.default.Event.stop(e);
	        }
	    },

	    minimizeControl: function minimizeControl(e) {
	        _OpenLayers2.default.Element.addClass(this.div, "minimized");

	        this.showControls(true);

	        if (e != null) {
	            _OpenLayers2.default.Event.stop(e);
	        }
	    },

	    loadContents: function loadContents() {

	        // layers list div
	        this.layersDiv = document.createElement("div");
	        this.layersDiv.id = this.id + "_layersDiv";
	        _OpenLayers2.default.Element.addClass(this.layersDiv, "layersDiv");

	        this.baseLbl = document.createElement("div");
	        this.baseLbl.innerHTML = _OpenLayers2.default.i18n("Base Layer");
	        _OpenLayers2.default.Element.addClass(this.baseLbl, "baseLbl");

	        this.baseLayersDiv = document.createElement("div");
	        _OpenLayers2.default.Element.addClass(this.baseLayersDiv, "baseLayersDiv");

	        this.dataLbl = document.createElement("div");
	        this.dataLbl.innerHTML = _OpenLayers2.default.i18n("Overlays");
	        _OpenLayers2.default.Element.addClass(this.dataLbl, "dataLbl");

	        this.dataLayersDiv = document.createElement("div");
	        _OpenLayers2.default.Element.addClass(this.dataLayersDiv, "dataLayersDiv");

	        if (this.ascending) {
	            this.layersDiv.appendChild(this.baseLbl);
	            this.layersDiv.appendChild(this.baseLayersDiv);
	            this.layersDiv.appendChild(this.dataLbl);
	            this.layersDiv.appendChild(this.dataLayersDiv);
	        } else {
	            this.layersDiv.appendChild(this.dataLbl);
	            this.layersDiv.appendChild(this.dataLayersDiv);
	            this.layersDiv.appendChild(this.baseLbl);
	            this.layersDiv.appendChild(this.baseLayersDiv);
	        }

	        this.div.appendChild(this.layersDiv);

	        // maximize button div
	        this.maximizeDiv = document.createElement("div");
	        _OpenLayers2.default.Element.addClass(this.maximizeDiv, "OpenLayers_Control_MaximizeDiv maximizeDiv olButton");
	        this.maximizeDiv.style.display = "none";

	        this.div.appendChild(this.maximizeDiv);

	        // minimize button div
	        this.minimizeDiv = document.createElement("div");
	        _OpenLayers2.default.Element.addClass(this.minimizeDiv, "OpenLayers_Control_MinimizeDiv minimizeDiv olButton");
	        this.minimizeDiv.style.display = "none";

	        this.minimizeDiv.innerHTML = '&times;';

	        var bars = document.createElement("i");
	        _OpenLayers2.default.Element.addClass(bars, "fa fa-bars");
	        this.maximizeDiv.appendChild(bars);

	        this.div.appendChild(this.minimizeDiv);
	    },

	    CLASS_NAME: "OpenLayers.Control.LayerSwitcher"
	});

	/*** EXPORTS FROM exports-loader ***/

/***/ }
/******/ ]);